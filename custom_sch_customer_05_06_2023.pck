CREATE OR REPLACE PACKAGE custom_sch_customer AS

	cpackagedescr  CONSTANT VARCHAR2(100) := 'Revolving Credit Cards Module';
	cheaderversion CONSTANT VARCHAR2(50) := '82.0.9';
	cheaderdate    CONSTANT DATE := to_date('31-05-2022', 'DD-MM-YYYY');
	cheadertwcms   CONSTANT VARCHAR2(50) := '4.15.82';

	ctrxntype_debit     CONSTANT PLS_INTEGER := 1;
	ctrxntype_creditrev CONSTANT PLS_INTEGER := 2;
	ctrxntype_repayment CONSTANT PLS_INTEGER := 3;
	ctrxntype_debitrev  CONSTANT PLS_INTEGER := 4;

	cnotdefined CONSTANT PLS_INTEGER := 1;
	caggregate  CONSTANT PLS_INTEGER := 2;
	cseparate   CONSTANT PLS_INTEGER := 3;
	cnotused    CONSTANT PLS_INTEGER := 4;

	cinstadjusting CONSTANT PLS_INTEGER := 1;
	cinstclosing   CONSTANT PLS_INTEGER := 2;

	cinstrep2mep CONSTANT PLS_INTEGER := 2;
	cinstacc2mep CONSTANT PLS_INTEGER := 3;
	cinstint2mep CONSTANT PLS_INTEGER := 4;

	cnofee      CONSTANT PLS_INTEGER := 1;
	crcmfee     CONSTANT PLS_INTEGER := 2;
	cinstfee    CONSTANT PLS_INTEGER := 3;
	crcminstfee CONSTANT PLS_INTEGER := 4;

	cunpaidonly CONSTANT PLS_INTEGER := 0;
	cfullamount CONSTANT PLS_INTEGER := 1;

	SUBTYPE typepackagename IS tcontractschemas.packagename%TYPE;
	SUBTYPE typecontractrecord IS tcontract%ROWTYPE;
	SUBTYPE typecontractno IS tcontract.no%TYPE;
	SUBTYPE typecontracttype IS tcontract.type%TYPE;
	SUBTYPE typeaccountno IS taccount.accountno%TYPE;
	SUBTYPE typecurrency IS treferencecurrency.currency%TYPE;
	SUBTYPE typeentryident IS treferenceentry.ident%TYPE;
	SUBTYPE typeentrycode IS treferenceentry.code%TYPE;
	SUBTYPE typebillingcycle IS tcontractstcycle%ROWTYPE;

	SUBTYPE typedocno IS tdocument.docno%TYPE;
	SUBTYPE typeentryno IS tentry.no%TYPE;

	SUBTYPE typepackno IS tcontracttrxnlist.packno%TYPE;
	SUBTYPE typerecno IS tcontracttrxnlist.recno%TYPE;
	SUBTYPE typegroupid IS tcontractentrygroup.groupid%TYPE;

	SUBTYPE typepan IS tcard.pan%TYPE;
	SUBTYPE typembr IS tcard.mbr%TYPE;

	TYPE typetrxnrec IS RECORD(
		
		 branch       NUMBER
		,contractno   typecontractno
		,accountno    typeaccountno
		,packno       NUMBER
		,recno        NUMBER
		,groupid      NUMBER
		,trantype     NUMBER
		,trandate     DATE
		,postdate     DATE
		,amount       NUMBER
		,paidamount   NUMBER := 0
		,paidfull     NUMBER := 0
		,rate         NUMBER
		,intstartdate DATE
		,intenddate   DATE
		,paidfulldate DATE
		,docno        typedocno
		,entryno      typeentryno
		,pan          typepan
		,mbr          typembr
		,debitentcode NUMBER
		,offbalance   NUMBER
		,
		
		grouptype      NUMBER
		,trancode       textract.trancode%TYPE
		,enttype        textract.enttype%TYPE
		,parentdocno    typedocno
		,parententryno  typeentryno
		,childdocno     typedocno
		,revgroup       NUMBER
		,nextsd         DATE
		,priority       NUMBER
		,instcheck      NUMBER
		,instcontractno typecontractno
		,instaccountno  typeaccountno
		,loanno         NUMBER
		,insttotalsum   NUMBER);

	TYPE typetrxnarray IS TABLE OF typetrxnrec INDEX BY PLS_INTEGER;

	TYPE typedelstatusrecord IS RECORD(
		 overduecalctype         PLS_INTEGER
		,period                  NUMBER
		,fairperiod              NUMBER
		,deldate                 DATE
		,overduecalcspecmodeused BOOLEAN
		,overdueamount_threshold NUMBER
		,overlimitcalctype       PLS_INTEGER
		,overlimit               NUMBER
		,stateid                 NUMBER
		,state                   contractstatereference.typestaterow
		,profileiddom            NUMBER
		,profileidint            NUMBER
		,mpprofileiddom          NUMBER
		,mpprofileidint          NUMBER
		,aggregatedoverdueamount NUMBER
		,lastreggroupindex       NUMBER
		,currentgroupindex       NUMBER
		,lastregisteredstatecode contractstatereference.typestatecode
		,lastregisteredstickmode tcontractstatehistory.stickmode%TYPE
		,statechangeallowed      BOOLEAN);

	TYPE typeprcchargerecord IS RECORD(
		 groupid NUMBER
		,amount  NUMBER);

	TYPE typeprcchargearray IS TABLE OF typeprcchargerecord INDEX BY PLS_INTEGER;

	SUBTYPE typeovdfeeprofilesettings IS toverduefeecalclogmain%ROWTYPE;
	SUBTYPE typeovdfeecalcdata IS tregpromologcalcsetings%ROWTYPE;
	TYPE typeovdfeeasintcalcdetails IS TABLE OF toverduefeeinterestcalcdetails%ROWTYPE INDEX BY PLS_INTEGER;

	TYPE typeovdfeecalclog IS RECORD(
		 hasinfo         BOOLEAN := FALSE
		,profilesettings typeovdfeeprofilesettings
		,regularcalcdata typeovdfeecalcdata
		,promocalcdata   typeovdfeecalcdata
		,intcalcdetails  typeovdfeeasintcalcdetails
		,lastfeecharge   DATE);

	TYPE typecloseinfo IS RECORD(
		 account           contracttools.taccountrecord
		,prcchargearray    typeprcchargearray
		,overduefee        NUMBER := 0
		,overduefeegst     NUMBER := 0
		,ovdfeecalclog     typeovdfeecalclog
		,overlimitfee      NUMBER := 0
		,overlimitfeegst   NUMBER := 0
		,installmentamount NUMBER := 0
		,totalbalance      NUMBER);

	TYPE typecloseinfoarray IS TABLE OF typecloseinfo INDEX BY PLS_INTEGER;

	TYPE typenumber IS TABLE OF NUMBER INDEX BY PLS_INTEGER;

	TYPE typecontractcyclerecord IS RECORD(
		 contractno        typecontractno
		,statementdate     DATE
		,duedate           DATE
		,duedatepass       BOOLEAN
		,nextstatementdate DATE
		,accountno         typeaccountno
		,sdbalance         NUMBER
		,dafdate           DATE);

	TYPE typestcyclerecord IS RECORD(
		 statementdate     DATE
		,duedate           DATE
		,nextstatementdate DATE);
	TYPE typestcyclearray IS TABLE OF typestcyclerecord INDEX BY PLS_INTEGER;

	TYPE typestcyclefullrecord IS RECORD(
		 statementdate     DATE
		,duedate           DATE
		,duedatepass       BOOLEAN
		,nextstatementdate DATE
		,minpaymentdom     NUMBER
		,minpaymentint     NUMBER);
	TYPE typestcyclefullinfoarray IS TABLE OF typestcyclefullrecord INDEX BY PLS_INTEGER;

	TYPE typedafsetrecord IS RECORD(
		 generate   BOOLEAN
		,basedon    NUMBER
		,method     NUMBER
		,amount     NUMBER
		,prc        NUMBER
		,usepayment BOOLEAN
		,restrictmp BOOLEAN);

	TYPE typeminpayhistrecord IS RECORD(
		 statementdate DATE
		,amountdom     NUMBER
		,amountint     NUMBER);
	TYPE typeminpayhistarray IS TABLE OF typeminpayhistrecord INDEX BY PLS_INTEGER;

	TYPE typepaidhistcurrarray IS TABLE OF typepaidhistarray INDEX BY PLS_INTEGER;

	TYPE typecontractintsetuprecord IS RECORD(
		 groupid   tcontractinterestsetuplog.groupid%TYPE
		,groupname tcontractentrygroup.groupname%TYPE
		,calcinfo  tcontractinterestsetuplog.calcinfo%TYPE);
	TYPE typecontractintsetuplogarray IS TABLE OF typecontractintsetuprecord INDEX BY PLS_INTEGER;

	TYPE typechargeoverduefeerecord IS RECORD(
		 chargeovdfee BOOLEAN
		,profileiddom NUMBER
		,profileidint NUMBER
		,ovdfee       NUMBER
		,info         VARCHAR(250));

	TYPE typeallowedoverduerecord IS RECORD(
		 statementdate DATE
		,duedate       DATE
		,nextsd        DATE
		,allowedod_dom NUMBER
		,allowedod_int NUMBER);
	TYPE typeallowedoverduearray IS TABLE OF typeallowedoverduerecord INDEX BY PLS_INTEGER;

	TYPE typempprofilerecord IS RECORD(
		 profileid    NUMBER
		,minpaybase   NUMBER
		,minpaytype   NUMBER
		,minpayamount NUMBER
		,minpayprc    NUMBER
		,minpayprccl  BOOLEAN
		,incunpaidmp  BOOLEAN
		,incoverlimit BOOLEAN
		,addunpaidmp  BOOLEAN
		,addoverlimit BOOLEAN
		,incmax       BOOLEAN);
	TYPE typempprofilearray IS TABLE OF typempprofilerecord INDEX BY PLS_INTEGER;

	TYPE typeminpaymentstdata IS TABLE OF vcontractstcyclempdata%ROWTYPE INDEX BY PLS_INTEGER;

	TYPE typeparam_descr_val IS RECORD(
		 parameter   VARCHAR2(30)
		,description VARCHAR2(200)
		,val         VARCHAR2(200));

	TYPE typekeydatesrec IS RECORD(
		 dafdate           DATE
		,printedduedate    DATE
		,duedate           DATE
		,nextstatementdate DATE);

	TYPE typelimitvaluerecord IS RECORD(
		 credlimit NUMBER
		,cashlimit NUMBER);

	coverdueuom_days   CONSTANT NUMBER := 1;
	coverdueuom_cycles CONSTANT NUMBER := 2;

	ccontrinform_remaindom         CONSTANT contracttypeschema.typefschparamid := 'DOM_ACCOUNT_REMAIN';
	ccontrinform_remainint         CONSTANT contracttypeschema.typefschparamid := 'INT_ACCOUNT_REMAIN';
	ccontrinform_stdate            CONSTANT contracttypeschema.typefschparamid := 'STATEMENT_DATE';
	ccontrinform_dafdate           CONSTANT contracttypeschema.typefschparamid := 'DAF_DATE';
	ccontrinform_prnduedate        CONSTANT contracttypeschema.typefschparamid := 'PRN_DUE_DATE';
	ccontrinform_duedate           CONSTANT contracttypeschema.typefschparamid := 'DUE_DATE';
	ccontrinform_creditlimitdom    CONSTANT contracttypeschema.typefschparamid := 'DOM_CREDIT_LIMIT';
	ccontrinform_creditlimitint    CONSTANT contracttypeschema.typefschparamid := 'INT_CREDIT_LIMIT';
	ccontrinform_contrstatecode    CONSTANT contracttypeschema.typefschparamid := 'CONTR_STATE_CODE';
	ccontrinform_contrstatename    CONSTANT contracttypeschema.typefschparamid := 'CONTR_STATE_NAME';
	ccontrinform_intr_ovl_ovd_dom  CONSTANT contracttypeschema.typefschparamid := 'DOM_INTEREST_OVL_OVD';
	ccontrinform_intr_ovl_ovd_int  CONSTANT contracttypeschema.typefschparamid := 'INT_INTEREST_OVL_OVD';
	ccontrinform_overdueamntdom    CONSTANT contracttypeschema.typefschparamid := 'DOM_OVERDUE_AMOUNT';
	ccontrinform_overdueamntint    CONSTANT contracttypeschema.typefschparamid := 'INT_OVERDUE_AMOUNT';
	ccontrinform_totaldebitamntdom CONSTANT contracttypeschema.typefschparamid := 'DOM_TOTAL_DEBIT_AMOUNT';
	ccontrinform_totaldebitamntint CONSTANT contracttypeschema.typefschparamid := 'INT_TOTAL_DEBIT_AMOUNT';
	ccontrinform_overduedays       CONSTANT contracttypeschema.typefschparamid := 'OVERDUE_DAYS';
	ccontrinform_ovdbeforefullpaym CONSTANT contracttypeschema.typefschparamid := 'OVD_COUNT_BEFORE_PAYMENT';
	ccontrinform_totaloverduecount CONSTANT contracttypeschema.typefschparamid := 'TOTAL_OVERDUE_COUNT';
	ccontrinform_overlimitcountdom CONSTANT contracttypeschema.typefschparamid := 'DOM_OVERLIMIT_COUNT';
	ccontrinform_overlimitcountint CONSTANT contracttypeschema.typefschparamid := 'INT_OVERLIMIT_COUNT';
	ccontrinform_lastpaidamntdom   CONSTANT contracttypeschema.typefschparamid := 'DOM_LAST_PAYMENT_AMOUNT';
	ccontrinform_lastpaidamntint   CONSTANT contracttypeschema.typefschparamid := 'INT_LAST_PAYMENT_AMOUNT';
	ccontrinform_dueamountdom      CONSTANT contracttypeschema.typefschparamid := 'DOM_DUE_AMOUNT';
	ccontrinform_dueamountint      CONSTANT contracttypeschema.typefschparamid := 'INT_DUE_AMOUNT';
	ccontrinform_sdamountdom       CONSTANT contracttypeschema.typefschparamid := 'DOM_SD_AMOUNT';
	ccontrinform_sdamountint       CONSTANT contracttypeschema.typefschparamid := 'INT_SD_AMOUNT';
	ccontrinform_ovdperiodregged   CONSTANT contracttypeschema.typefschparamid := 'OVD_PERIOD_REGGED';
	ccontrinform_ovdperiodcalc     CONSTANT contracttypeschema.typefschparamid := 'OVD_PERIOD_CALC';

	cgroup_1 CONSTANT VARCHAR2(100) := 'CycleKeyDates_MPs';
	cgroup_2 CONSTANT VARCHAR2(100) := 'Limits';
	cgroup_3 CONSTANT VARCHAR2(100) := 'LastPaymentDate';

	coperinstallment CONSTANT VARCHAR2(100) := upper('Instalment');

	cright_instschedule   CONSTANT VARCHAR2(20) := 'INST_SCHEDULE';
	cright_instprecheck   CONSTANT VARCHAR2(20) := 'INST_PRE_CHK';
	cright_insttransfer   CONSTANT VARCHAR2(20) := 'INST_TRANSFER';
	cright_instaccelerate CONSTANT VARCHAR2(20) := 'INST_ACCELERATE';
	cright_instdelete     CONSTANT VARCHAR2(20) := 'INST_DELETE';

	cright_scheddelete    CONSTANT VARCHAR2(20) := 'SCHED_DELETE';
	cright_schedrepayment CONSTANT VARCHAR2(20) := 'SCHED_REPAYMENT';

	cerror_credlimitscorecheck CONSTANT PLS_INTEGER := -20801;

	scontracttype NUMBER;

	cim_voice  CONSTANT NUMBER := 1;
	cim_manual CONSTANT NUMBER := 2;
	cim_auto   CONSTANT NUMBER := 3;

	FUNCTION initaggregate(pcontracttype IN typecontracttype) RETURN NUMBER;
	FUNCTION execaggregate RETURN NUMBER;
	PROCEDURE downaggregate(pcontracttype IN typecontracttype);

	FUNCTION initadjusting(pcontracttype IN typecontracttype) RETURN NUMBER;
	FUNCTION execadjusting RETURN NUMBER;
	PROCEDURE downadjusting(pcontracttype IN typecontracttype);

	FUNCTION initundoadjusting(pcontracttype IN typecontracttype) RETURN NUMBER;
	FUNCTION undoadjusting RETURN NUMBER;

	PROCEDURE undolabel
	(
		pcontractno IN typecontractno
	   ,plabel      IN contractrb.tlabel
	);
	FUNCTION getlabeldescription
	(
		pcontractno IN typecontractno
	   ,plabel      IN contractrb.tlabel
	) RETURN VARCHAR2;
	FUNCTION getlabeldescription
	(
		pcontractno IN typecontractno
	   ,plabel      IN VARCHAR2
	) RETURN VARCHAR2;

	FUNCTION getdataforreport
	(
		pstartdate  IN DATE
	   ,penddate    IN DATE
	   ,pmaxcount   IN NUMBER
	   ,parchive    IN BOOLEAN := FALSE
	   ,pneedremain IN BOOLEAN := TRUE
	) RETURN NUMBER;
	FUNCTION getcontractinfo(pcontractno IN typecontractno) RETURN NUMBER;
	FUNCTION getcontractoperations
	(
		pcontractno IN typecontractno
	   ,pstartdate  IN DATE
	   ,penddate    IN DATE
	   ,parchive    IN NUMBER := 0
	) RETURN contracttypeschema.tentryarray;
	FUNCTION getstatementgenerationsign(pcontractno IN typecontractno) RETURN BOOLEAN;

	FUNCTION initoper
	(
		pcontracttype IN typecontracttype
	   ,popcode       IN NUMBER
	) RETURN NUMBER;
	FUNCTION execoper RETURN NUMBER;

	FUNCTION oppreexec RETURN NUMBER;
	FUNCTION oppostexec RETURN NUMBER;

	PROCEDURE sop_preexec
	(
		pcontractno IN typecontractno
	   ,pdocno      IN OUT NUMBER
	   ,pno         IN OUT NUMBER
	   ,pparams     IN OUT NOCOPY contracttypeschema.tsop_params
	);
	PROCEDURE sop_postexec
	(
		pcontractno IN typecontractno
	   ,pdocno      IN OUT NUMBER
	   ,pno         IN OUT NUMBER
	   ,pparams     IN contracttypeschema.tsop_params
	);

	PROCEDURE entryundoinit(poentryproperties IN OUT NOCOPY contracttypeschema.typeentryproperties);

	PROCEDURE entryundopre(poentryproperties IN OUT NOCOPY contracttypeschema.typeentryproperties);

	PROCEDURE entryundodone(poentryproperties IN OUT NOCOPY contracttypeschema.typeentryproperties);

	PROCEDURE ext_chargeinterest
	(
		pcontractno IN typecontractno
	   ,podocno     IN OUT NUMBER
	   ,poentryno   IN OUT NUMBER
	);

	PROCEDURE ext_movedebttodom
	(
		pcontractno   IN typecontractno
	   ,podocno       IN OUT NUMBER
	   ,poentryno     IN OUT NUMBER
	   ,psum          IN NUMBER
	   ,pentryident   IN typeentryident
	   ,pexchangerate IN NUMBER := NULL
	);

	PROCEDURE ext_movefundstodom
	(
		pcontractno   IN typecontractno
	   ,podocno       IN OUT NUMBER
	   ,poentryno     IN OUT NUMBER
	   ,psum          IN NUMBER
	   ,pentryident   IN typeentryident
	   ,pexchangerate IN NUMBER := NULL
	);

	PROCEDURE ext_moveusedlimitstodom
	(
		pcontractno   IN typecontractno
	   ,ppan          IN typepan
	   ,pmbr          IN typembr
	   ,pexchangerate IN NUMBER := NULL
	);

	PROCEDURE ext_completemigration
	(
		pcontractno IN typecontractno
	   ,pdocno      IN NUMBER
	   ,pentryno    IN NUMBER
	);

	FUNCTION ext_markforinstallmenttransfer
	(
		prcmaccountno   IN typeaccountno
	   ,pdocno          IN typedocno
	   ,pentryno        IN typeentryno
	   ,pinstcontractno IN typecontractno
	   ,pmode           IN PLS_INTEGER
	   ,pcycles         IN NUMBER := NULL
	   ,pregrepayment   IN NUMBER := NULL
	) RETURN NUMBER;

	FUNCTION gettrxn
	(
		paccountno IN typeaccountno
	   ,pdocno     IN typedocno
	   ,pentryno   IN typeentryno
	) RETURN typetrxnrec;

	PROCEDURE getstatelist4dc
	(
		pcontracttype IN typecontracttype
	   ,ostatelist    OUT NOCOPY apitypesfordc.typecontractstatelist
	);
	PROCEDURE initgetdata4dc(pcontracttype IN typecontracttype);
	PROCEDURE execgetdata4dc
	(
		pcontractno   IN typecontractno
	   ,pocontractsh  IN OUT NOCOPY apitypesfordc.typecontractsnapshotrecord
	   ,pitemsshlist  IN apitypesfordc.typecontractitemshapshotlist
	   ,ocontractrec  OUT NOCOPY apitypesfordc.typecontractrecord
	   ,oitemslist    OUT NOCOPY apitypesfordc.typecontractitemlist
	   ,otranslist    OUT NOCOPY apitypesfordc.typedctranslist
	   ,orollbackdata OUT NOCOPY VARCHAR2
	   ,ooverduelist  OUT NOCOPY apitypesfordc.typecontractoverduelist
	);
	PROCEDURE downgetdata4dc(pcontracttype IN typecontracttype);
	PROCEDURE undogetdata4dc
	(
		pcontractno   IN typecontractno
	   ,prollbackdata IN VARCHAR2
	);
	PROCEDURE complyrequest
	(
		pactions      IN apitypesfordc.typeactionrecord
	   ,orollbackdata OUT NOCOPY VARCHAR2
	);
	PROCEDURE undocomplyrequest
	(
		pactions      IN apitypesfordc.typeactionrecord
	   ,prollbackdata IN VARCHAR2
	);

	FUNCTION getsetupdialog(pcontracttype IN NUMBER) RETURN NUMBER;
	PROCEDURE dlg_typeparams_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR
	   ,pcmd      IN NUMBER := 0
	);
	FUNCTION importcontracttype
	(
		pctypefrom IN typecontracttype
	   ,pctypeto   IN typecontracttype
	) RETURN NUMBER;

	FUNCTION canlinkcontracttype
	(
		pcontracttype IN NUMBER
	   ,plinkname     IN VARCHAR
	   ,plinkcode     IN VARCHAR
	) RETURN NUMBER;
	FUNCTION canlinkaccttocust
	(
		pcontractno IN VARCHAR
	   ,paccountno  IN VARCHAR
	) RETURN NUMBER;

	FUNCTION getoperationlist
	(
		pcontracttype    IN typecontracttype
	   ,pcontractno      IN typecontractno
	   ,oaoperationslist OUT NOCOPY contract.typeschemaoperationsarray
	) RETURN NUMBER;

	FUNCTION execoperation(pcode IN VARCHAR2) RETURN NUMBER;
	FUNCTION executeoperation
	(
		pcontractno    IN typecontractno
	   ,poperationcode IN VARCHAR2
	) RETURN contracttypeschema.typeoperationresult;

	PROCEDURE drawinfopanel
	(
		pcontractno   IN typecontractno
	   ,pcontracttype IN typecontracttype
	   ,pdialog       IN NUMBER
	   ,ppanel        IN NUMBER
	);
	PROCEDURE fillinfopanel
	(
		pcontractno   IN typecontractno
	   ,pcontracttype IN typecontracttype
	   ,pdialog       IN NUMBER
	   ,ppanel        IN NUMBER
	);

	FUNCTION fillitemaccountarray RETURN NUMBER;

	PROCEDURE fillsecurityarray(popercode IN VARCHAR2);

	PROCEDURE changecontractparams
	(
		pcontractno    IN typecontractno
	   ,pcontracttype  IN typecontracttype
	   ,pfschparamlist IN contracttypeschema.typefschparamlist
	);

	FUNCTION changecontractparams RETURN NUMBER;

	FUNCTION closecontract
	(
		pcontractno IN typecontractno
	   ,pparams     IN contracttypeschema.tclosecontractparamrec
	) RETURN contractrb.trollbackdata;
	PROCEDURE undoclosecontract
	(
		pcontractno   IN typecontractno
	   ,prollbackdata IN contractrb.trollbackdata
	);

	FUNCTION changecreditlimit
	(
		pcontractno    IN typecontractno
	   ,pvalue         IN NUMBER
	   ,paccounthandle IN NUMBER
	) RETURN NUMBER;
	FUNCTION undochangecreditlimit
	(
		pcontractno   IN typecontractno
	   ,prollbackdata IN VARCHAR2
	) RETURN NUMBER;

	PROCEDURE changecontracttype
	(
		pcontractno IN typecontractno
	   ,poldtype    IN typecontracttype
	   ,pnewtype    IN typecontracttype
	);
	PROCEDURE changecontracttype_post
	(
		pcontractno IN typecontractno
	   ,poldtype    IN typecontracttype
	   ,pnewtype    IN typecontracttype
	);

	FUNCTION getmainaccount
	(
		pcontractno IN typecontractno
	   ,pcurrency   IN typecurrency
	) RETURN typeaccountno;
	FUNCTION getmainitemcode RETURN NUMBER;
	FUNCTION getduedate
	(
		pcontractno    IN typecontractno
	   ,pstatementdate IN DATE
	) RETURN DATE;
	FUNCTION getminpayment
	(
		pcontractno    IN VARCHAR
	   ,paccountno     IN VARCHAR
	   ,pstatementdate IN DATE
	) RETURN NUMBER;

	FUNCTION getunpaidminpayment
	(
		pcontractno    IN typecontractno
	   ,paccountno     IN typeaccountno
	   ,pstatementdate IN DATE
	) RETURN NUMBER;
	FUNCTION getpaymentamount
	(
		paccountno IN VARCHAR
	   ,pstartdate IN DATE
	   ,penddate   IN DATE
	) RETURN NUMBER;

	FUNCTION getnextstatementdate
	(
		pcontractno    IN typecontractno
	   ,pstatementdate IN DATE
	   ,pdoexception   IN BOOLEAN := TRUE
	) RETURN DATE;
	FUNCTION getoverlimitperiod
	(
		pcontractno IN VARCHAR
	   ,paccountno  IN VARCHAR
	   ,pdate       IN DATE := NULL
	) RETURN NUMBER;
	FUNCTION getoverdueperiod
	(
		pcontractno IN typecontractno
	   ,paccountno  IN typeaccountno
	   ,pdate       IN DATE := NULL
	) RETURN NUMBER;
	FUNCTION getoverduehistory
	(
		pcontractno IN typecontractno
	   ,pcurno      IN NUMBER
	) RETURN typepaidhistarray;
	PROCEDURE getoverduedate
	(
		paccountno     IN VARCHAR2
	   ,pcurnumber     IN NUMBER
	   ,pdate          IN DATE
	   ,ooverduedate   OUT DATE
	   ,ooverdueamount OUT NUMBER
	);

	PROCEDURE getdueamount
	(
		paccountno     IN VARCHAR
	   ,pdate          IN DATE
	   ,odueamount     OUT NUMBER
	   ,ooverdueamount OUT NUMBER
	);

	PROCEDURE getcardlimitvalue
	(
		pcontractno    IN typecontractno
	   ,paccountno     IN typeaccountno
	   ,ppan           IN typepan
	   ,pmbr           IN typembr
	   ,ocredlimit     OUT NUMBER
	   ,ocashlimit     OUT NUMBER
	   ,ousedcredlimit OUT NUMBER
	   ,ousedcashlimit OUT NUMBER
	   ,pconsiderpb    IN BOOLEAN := FALSE
	);
	PROCEDURE getavailablelimit
	(
		pcontractno IN VARCHAR
	   ,olimitdom   OUT NUMBER
	   ,olimitint   OUT NUMBER
	);
	PROCEDURE getcreditlastpayment
	(
		pcontractno IN VARCHAR
	   ,pcurrencyno IN NUMBER
	   ,odate       OUT DATE
	   ,oamount     OUT NUMBER
	);

	FUNCTION getcontractdelinquencystate
	(
		pcontractno IN typecontractno
	   ,pdate       IN DATE := NULL
	) RETURN typedelstatusrecord;

	FUNCTION getdafvalue
	(
		pcontractno IN typecontractno
	   ,paccountno  IN typeaccountno
	   ,pdate       IN DATE
	) RETURN NUMBER;
	FUNCTION getdafvalue
	(
		pcontractno          IN typecontractno
	   ,paccountno           IN typeaccountno
	   ,pdate                IN DATE
	   ,osdbalance           OUT NUMBER
	   ,osd                  OUT DATE
	   ,pifneededroundresult BOOLEAN := TRUE
	) RETURN NUMBER;

	FUNCTION getdafsettings
	(
		pcontractno IN typecontractno
	   ,paccountno  IN typeaccountno
	) RETURN typedafsetrecord;

	FUNCTION getlpfeeamount
	(
		pcontractno IN typecontractno
	   ,paccountno  IN typeaccountno
	   ,pdate       IN DATE
	) RETURN NUMBER;
	FUNCTION getolfeeamount
	(
		pcontractno IN typecontractno
	   ,paccountno  IN typeaccountno
	   ,pdate       IN DATE
	) RETURN NUMBER;
	FUNCTION getinterestamount
	(
		pcontractno IN typecontractno
	   ,paccountno  IN typeaccountno
	   ,pgroup      IN NUMBER
	   ,pdate       IN DATE
	) RETURN NUMBER;

	FUNCTION getolamount
	(
		pcontractno IN typecontractno
	   ,paccountno  IN typeaccountno
	   ,pdate       IN DATE
	) RETURN NUMBER;
	FUNCTION getminpaymenthistory(pcontractno IN typecontractno) RETURN typeminpayhistarray;

	PROCEDURE getinterestamount
	(
		pcontractno           IN VARCHAR
	   ,oaprcarraydom         OUT NOCOPY typeprcchargearray
	   ,oaprcarrayint         OUT NOCOPY typeprcchargearray
	   ,oaovdfeeamount        OUT NOCOPY typenumber
	   ,oaovlfeeamount        OUT NOCOPY typenumber
	   ,osavedinterestcalclog OUT NOCOPY typeparsedinterestlog_tab
	   ,puserdefinedoperdate  IN DATE := NULL
	);

	TYPE typecontrattributesrec IS RECORD(
		 account_no VARCHAR2(50)
		,pan_mbr    VARCHAR2(50)
		,
		
		st_date_on_spec_date      DATE
		,due_date_on_spec_date     DATE
		,mp_on_spec_date           NUMBER
		,prn_due_date_on_spec_date DATE
		,daf_date_on_spec_date     DATE
		,next_st_date_on_spec_date DATE
		,sd_amount_on_spec_date    NUMBER
		,
		
		last_payment_date DATE
		,last_paid_amount  NUMBER
		,
		
		estab_credit_limit      NUMBER
		,cash_limit              NUMBER
		,used_cred_limit         NUMBER
		,used_cash_limit         NUMBER
		,used_installment        NUMBER
		,avail_limit             NUMBER
		,avail_cash_limit        NUMBER
		,aggr_estab_credit_limit NUMBER
		,aggr_cash_limit         NUMBER
		,aggr_used_cred_limit    NUMBER
		,aggr_used_cash_limit    NUMBER
		,aggr_avail_limit        NUMBER
		,aggr_avail_cash_limit   NUMBER);
	TYPE typecontrattributesarr IS TABLE OF typecontrattributesrec INDEX BY PLS_INTEGER;
	TYPE typecontrcacheattr IS TABLE OF typecontrattributesarr INDEX BY VARCHAR2(150);

	TYPE typecontrgroupattrcalcflag IS TABLE OF NUMBER INDEX BY VARCHAR2(100);
	TYPE typecontrgrattrcalcflagbycache IS TABLE OF typecontrgroupattrcalcflag INDEX BY VARCHAR2(150);

	FUNCTION getcreditlimit
	(
		pcontractno IN VARCHAR
	   ,pcurrencyno IN NUMBER := NULL
	) RETURN NUMBER;
	FUNCTION getstdatelist
	(
		pcontractno IN typecontractno
	   ,pstartdate  IN DATE
	   ,pposition   IN PLS_INTEGER
	   ,pcount      IN PLS_INTEGER
	) RETURN types.arrdate;
	FUNCTION getcontractstate(pcontractno IN typecontractno) RETURN contractstatereference.typestateid;
	FUNCTION getstcyclelist
	(
		pcontractno IN typecontractno
	   ,pstartdate  DATE := NULL
	   ,penddate    DATE := NULL
	) RETURN typestcyclearray;
	FUNCTION getstcyclefulllist
	(
		pcontractno IN VARCHAR
	   ,pstartdate  DATE := NULL
	   ,penddate    DATE := NULL
	) RETURN typestcyclefullinfoarray;

	FUNCTION getprevstdate(pcontractno IN typecontractno) RETURN DATE;
	FUNCTION getcurrentstdate(pcontractno IN typecontractno) RETURN DATE;
	FUNCTION getnextstdate(pcontractno IN typecontractno) RETURN DATE;
	FUNCTION getprintedduedate
	(
		pcontractno    IN typecontractno
	   ,pstatementdate IN DATE
	) RETURN DATE;
	FUNCTION getdafgendate(pcontractno IN typecontractno) RETURN DATE;
	FUNCTION getcontractstinfo RETURN typecontractcyclerecord;

	FUNCTION getcontractinterestsetuplog
	(
		pcontractno    IN typecontractno
	   ,pcurno         IN NUMBER
	   ,pstatementdate IN DATE
	) RETURN typecontractintsetuplogarray;
	FUNCTION getallowedoverdue(pcontractno IN typecontractno) RETURN typeallowedoverduearray;

	PROCEDURE plsql_setdiscountshield(pdiscountvalue IN NUMBER);
	FUNCTION plsql_ispromoperiod RETURN BOOLEAN;
	FUNCTION plsql_getshieldvalue RETURN NUMBER;
	FUNCTION plsql_getdiscountshieldvalue RETURN NUMBER;
	FUNCTION plsql_getbalance RETURN NUMBER;
	FUNCTION plsql_getoverlimit RETURN NUMBER;
	FUNCTION plsql_getunpaidmp RETURN NUMBER;
	FUNCTION plsql_getoverduemp RETURN NUMBER;
	FUNCTION plsql_getsdbalanceod RETURN NUMBER;
	FUNCTION plsql_getsdbalancedd RETURN NUMBER;
	FUNCTION plsql_getdelinqstateid RETURN contractstatereference.typestateid;

	PROCEDURE setcardlimit
	(
		pcontractno IN typecontractno
	   ,ppan        IN typepan
	   ,pmbr        IN typembr
	   ,pcurno      IN NUMBER
	   ,pcltype     IN NUMBER := 0
	   ,pclamount   IN NUMBER := 0
	   ,pclprc      IN NUMBER := 0
	   ,pcashtype   IN NUMBER := 0
	   ,pcashamount IN NUMBER := 0
	   ,pcashprc    IN NUMBER := 0
	);

	PROCEDURE setstateproc
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR
	   ,pcmd      IN NUMBER
	);
	PROCEDURE scoresetupdialogproc
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR
	   ,pcmd      IN NUMBER
	);
	PROCEDURE rangesetupdialogproc
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR
	   ,pcmd      IN NUMBER
	);
	PROCEDURE chargeaccumintproc
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR
	   ,pcmd      IN NUMBER
	);

	FUNCTION adjmodeonget_atomarray RETURN adjustingmode.tatomarray;

	FUNCTION getpackno RETURN NUMBER;

	FUNCTION getschemaparametersdialog(pcanmodify IN BOOLEAN) RETURN NUMBER;

	PROCEDURE initgetdata4vcf(pcontracttype IN typecontracttype);

	FUNCTION execgetbalance4vcf
	(
		pcontractno IN typecontractno
	   ,penddate    IN DATE
	) RETURN apitypesforvcf.typebalancelist;

	PROCEDURE downgetdata4vcf(pcontracttype IN typecontracttype);

	PROCEDURE getprofilescalculatedondate
	(
		pcontractno       typecontractno
	   ,pcurno            NUMBER
	   ,pdate             DATE
	   ,ointcalcprofileid OUT NUMBER
	   ,ompcalcprofileid  OUT NUMBER
	);

	FUNCTION getinterestcalclog
	(
		pcontractno    VARCHAR2
	   ,pstatementdate DATE
	) RETURN typeparsedinterestlog_tab;

	FUNCTION interestcalcinfoparser(plogcalcinfo tcontractinterestsetuplog.calcinfo%TYPE)
		RETURN type_param_descr_val_varr;

	PROCEDURE getoverdueperiod
	(
		pcontractno    typecontractno
	   ,pdate          DATE
	   ,puom           NUMBER := NULL
	   ,olastovddate   OUT DATE
	   ,ooverdueperiod OUT NUMBER
	   ,ouom           OUT NOCOPY VARCHAR2
	);

	PROCEDURE getcontractinformation
	(
		pcontractno      IN typecontractno
	   ,poafschparamlist IN OUT NOCOPY contracttypeschema.typefschparamlist
	);

	FUNCTION getcontractinformation
	(
		pcontractno IN typecontractno
	   ,pparamid    IN contracttypeschema.typefschparamid
	   ,pstartdate  DATE := NULL
	   ,penddate    DATE := NULL
	) RETURN VARCHAR2;

	FUNCTION getcyclekeydates
	(
		pcontractno    IN typecontractno
	   ,pstatementdate IN DATE
	) RETURN typekeydatesrec;

	FUNCTION getcyclebydate
	(
		pcontractno  IN typecontractno
	   ,pdate        IN DATE
	   ,pdoexception IN BOOLEAN := TRUE
	) RETURN typebillingcycle;

	FUNCTION getcalclimitsvalue
	(
		pcurno      IN NUMBER
	   ,pcontractno IN typecontractno := NULL
	   ,ppan        IN typepan := NULL
	   ,pmbr        IN typembr := NULL
	   ,pconsiderpb IN BOOLEAN := TRUE
	) RETURN typelimitvaluerecord;

	FUNCTION getbillingcyclecalendar(pcontractno typecontractno := NULL)
		RETURN tcontractcalendar.calendarid%TYPE;

	TYPE typeoverduedatarecord IS RECORD(
		 minpayment             NUMBER
		,dueamountonpdate       NUMBER
		,overdueamountonduedate NUMBER
		,overdueamountonpdate   NUMBER
		,overdueflag            BOOLEAN
		,accountremainonpdate   NUMBER);
	TYPE typeoverduedataarray IS TABLE OF typeoverduedatarecord INDEX BY PLS_INTEGER;

	FUNCTION getoverduedata
	(
		pcontractno typecontractno
	   ,pdate       DATE
	) RETURN typeoverduedataarray;

	TYPE typealllimitrec IS RECORD(
		 estabcreditlimit     NUMBER
		,estabcashlimit       NUMBER
		,usedcredlimit        NUMBER
		,usedcashlimit        NUMBER
		,usedinstallment      NUMBER
		,availcreditlimit     NUMBER
		,availcashlimit       NUMBER
		,estabcreditlimitaggr NUMBER
		,estabcashlimitaggr   NUMBER
		,usedcredlimitaggr    NUMBER
		,usedcashlimitaggr    NUMBER
		,availcreditlimitaggr NUMBER
		,availcashlimitaggr   NUMBER);
	TYPE typealllimitbypanarr IS TABLE OF typealllimitrec INDEX BY VARCHAR2(100);
	TYPE typealllimitarray IS TABLE OF typealllimitbypanarr INDEX BY PLS_INTEGER;

	FUNCTION getalllimitsvalue(pcontractno IN typecontractno) RETURN typealllimitarray;

	FUNCTION getalllimitsvalue_fromhistory
	(
		pcontractno IN typecontractno
	   ,pdate       IN DATE := NULL
	) RETURN typealllimitarray;

	TYPE typecontrstminpaymdatarec IS RECORD(
		 contractno        typecontractno
		,currencynumber    NUMBER
		,accountno         typeaccountno
		,dafdate           DATE
		,printedduedate    DATE
		,duedate           DATE
		,statementdate     DATE
		,nextstatementdate DATE
		,sdamount          NUMBER
		,minpayment        NUMBER);
	TYPE typecontrstminpaymdataarr IS TABLE OF typecontrstminpaymdatarec INDEX BY PLS_INTEGER;

	FUNCTION getcontrattr_cyclekeydates
	(
		pcontractno IN typecontractno
	   ,pdate       IN DATE
	) RETURN typecontrstminpaymdatarec;

	FUNCTION getcontrattr_minpayment
	(
		pcontractno IN typecontractno
	   ,pdate       IN DATE
	   ,pcurno      IN NUMBER
	) RETURN NUMBER;

	FUNCTION getcontrattr_sdamount
	(
		pcontractno     typecontractno
	   ,pdate           DATE
	   ,pcurrencynumber tcontractstminpaymentdata.currencynumber%TYPE
	) RETURN vcontractstcyclempdata.sdamount%TYPE;

	FUNCTION getcontrattr_alllimits
	(
		pcontractno IN typecontractno
	   ,pcurno      IN NUMBER
	   ,ppan        IN typepan
	   ,pmbr        IN typembr
	) RETURN typealllimitrec;

	FUNCTION getcontrattr_lastpaymdate
	(
		pcontractno     IN typecontractno
	   ,pdate           IN DATE
	   ,pcurrencynumber IN NUMBER := NULL
	) RETURN DATE;

	FUNCTION getcontrattr_lastpaidamount
	(
		pcontractno     IN typecontractno
	   ,pdate           IN DATE
	   ,pcurrencynumber IN NUMBER := NULL
	) RETURN NUMBER;

	FUNCTION deletecontract
	(
		pcontractno IN typecontractno
	   ,pmode       IN NUMBER := NULL
	) RETURN NUMBER;

	FUNCTION getcurrencynumberbyaccount(paccountno IN typeaccountno) RETURN NUMBER;

	FUNCTION getaccountbycurrencynumber
	(
		pcontractno     IN typecontractno
	   ,pcurrencynumber IN NUMBER
	) RETURN typeaccountno;

	FUNCTION getcardaccountbycurrency
	(
		pcontractno  IN typecontractno
	   ,pcurrency    IN NUMBER
	   ,pdoexception IN BOOLEAN := TRUE
	) RETURN contracttools.taccountrecord;

	FUNCTION needstatementgenerate
	(
		pcontractno IN typecontractno
	   ,pprevdate   IN OUT DATE
	   ,pcurdate    IN DATE
	   ,pperiodtype IN NUMBER
	) RETURN NUMBER;

	FUNCTION getusedmpprofilesettings
	(
		pcontractno     IN typecontractno
	   ,pcurrencynumber IN NUMBER
	   ,pdate           DATE
	) RETURN types.arrstr1000;

	FUNCTION getlastregisteredprofiles
	(
		pcontractno IN typecontractno
	   ,pcurno      IN NUMBER
	   ,pdate       IN DATE := NULL
	) RETURN tinterestandmp_profhistory%ROWTYPE;

	TYPE typecalculatedprofiles_record IS RECORD(
		 interestprofileid        tcontractprofile.profileid%TYPE
		,interestprofilename      tcontractprofile.profilename%TYPE
		,interestprofwastakenfrom tinterestandmp_profhistory.interestprofwastakenfrom%TYPE
		,mpprofileid              tcontractmpprofile.profileid%TYPE
		,mpprofilename            tcontractmpprofile.profilename%TYPE
		,mpprofwastakenfrom       tinterestandmp_profhistory.mpprofwastakenfrom%TYPE);

	FUNCTION getcalculatedprofiles
	(
		pcontractno IN typecontractno
	   ,pcurno      IN NUMBER
	) RETURN typecalculatedprofiles_record;

	FUNCTION getcalculatedcyclecalendar(pcontractno typecontractno)
		RETURN tcontractcalendarreference%ROWTYPE;

	FUNCTION getcloseinfo(pcontractno IN typecontractno) RETURN typecloseinfoarray;

	FUNCTION getlimittypedescr(plimittype IN PLS_INTEGER) RETURN VARCHAR2;

	FUNCTION getlimittype(pcontractno IN typecontractno) RETURN PLS_INTEGER;

	FUNCTION getlimittypedescr(pcontractno IN typecontractno) RETURN VARCHAR2;

	PROCEDURE dlg_managecard_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER
	);

	PROCEDURE dlg_managecards_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER
	);

	PROCEDURE dlg_creditrepayment_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER
	);

	PROCEDURE dlg_moveduedate_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER := 0
	);

	PROCEDURE dlg_debtrestructuring_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER := 0
	);

	PROCEDURE dlg_viewtransactions_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER := 0
	);

	PROCEDURE dlg_closecontract_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER
	);

	PROCEDURE dlg_schemaparams_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER
	);

	PROCEDURE dlg_contractparams_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER := 0
	);

	PROCEDURE dlg_managelimits_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER
	);

	PROCEDURE dlg_setobjectlimits_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER
	);

	FUNCTION collectionrulesetupdialog
	(
		pcontracttype IN typecontracttype
	   ,pregister     IN contractcollection.typeregister
	   ,pruleid       IN contractcollection.typeruleid
	   ,oinuse        OUT NUMBER
	) RETURN NUMBER;

	FUNCTION collectiongetcontractamount
	(
		pcontractno IN typecontractno
	   ,pregister   IN contractcollection.typeregister
	   ,pregisterid IN contractcollection.typeregisterid
	   ,pamountcode IN NUMBER
	   ,oamount     OUT NOCOPY contracttypeschema.typecollectionamount
	) RETURN NUMBER;

	FUNCTION collectioncheckrule
	(
		pcontractno IN typecontractno
	   ,pregister   IN contractcollection.typeregister
	   ,pruleid     IN contractcollection.typeruleid
	) RETURN NUMBER;

	FUNCTION collectionperformaction
	(
		pcontractno IN typecontractno
	   ,paction     IN contracttypeschema.typecollectionperformedaction
	   ,oresult     OUT NOCOPY contracttypeschema.typecollectionactionresult
	) RETURN NUMBER;

	FUNCTION collectiongetschemerules RETURN contractcollection.typestandardspecificrulearray;

	FUNCTION getrepaymentamount
	(
		pcontractno IN typecontractno
	   ,pstartdate  IN DATE
	   ,penddate    IN DATE
	) RETURN contracttypeschema.typecollectionamount;

	FUNCTION getruleblock(pruleid IN contractcollection.typeruleid) RETURN VARCHAR2;

	FUNCTION getcyclecalendar
	(
		pcontractno IN typecontractno
	   ,pstartdate  IN DATE
	   ,pcount      IN NUMBER
	) RETURN contracttypeschema.typecollectiondatelist;

	FUNCTION getcontractstructure(pcontractno IN typecontractno)
		RETURN contracttypeschema.typecontractcollectionstruct;

	PROCEDURE startnewinstallment
	(
		pcurno          IN NUMBER
	   ,pinstcontractno IN typecontractno
	   ,pmode           IN PLS_INTEGER
	   ,ploanno         IN NUMBER
	   ,pamount         IN NUMBER
	   ,pdocno          IN typedocno
	   ,pentryno        IN typeentryno
	   ,precno          IN NUMBER
	);

	PROCEDURE installmententrypost
	(
		pcurno      IN NUMBER
	   ,paccountno  IN typeaccountno
	   ,pamount     IN NUMBER
	   ,pentryident IN typeentryident
	   ,pdocno      IN typedocno
	   ,pentryno    IN typeentryno
	);

	FUNCTION getpreviouscycle RETURN typebillingcycle;

	FUNCTION getbodyversion RETURN VARCHAR2;

	FUNCTION getbodydate RETURN DATE;

	FUNCTION getbodytwcms RETURN VARCHAR2;

	FUNCTION getversion RETURN VARCHAR2;

	FUNCTION getschemaabout RETURN types.arrstr100;

END custom_sch_customer;
/
CREATE OR REPLACE PACKAGE BODY custom_sch_customer AS

	cpackagename CONSTANT typepackagename := 'custom_SCH_Customer';
	cbodyversion CONSTANT VARCHAR2(50) := '84.1.1';
	cbodydate    CONSTANT DATE := to_date('23-11-2022', 'DD-MM-YYYY');
	cbodytwcms   CONSTANT VARCHAR2(50) := '4.15.88';

	TYPE typearrboolbystr IS TABLE OF BOOLEAN INDEX BY VARCHAR2(20);
	SUBTYPE typemethodname IS VARCHAR2(200);
	SUBTYPE typeopername IS VARCHAR2(10);
	SUBTYPE typeitemname IS VARCHAR2(50);
	SUBTYPE typeaccountstatus IS treferenceacct_stat.acct_stat%TYPE;
	SUBTYPE typecardstatus IS treferencecrd_stat.crd_stat%TYPE;
	SUBTYPE typecardstate IS treferencecardsign.cardsign%TYPE;
	SUBTYPE typeparamvalue IS tcontractparameters.value%TYPE;
	SUBTYPE typedepositinfo IS tcontractdepositinfo%ROWTYPE;
	SUBTYPE typereissuesign IS tcard.remakedisable%TYPE;
	SUBTYPE typetrxnrow IS tcontracttrxnlist%ROWTYPE;
	SUBTYPE typehistkey IS tcontracthistory.key%TYPE;
	SUBTYPE typehistaddkey IS tcontracthistory.addkey%TYPE;
	SUBTYPE typeclientid IS tcontract.idclient%TYPE;
	SUBTYPE typeshortremark IS tentry.shortremark%TYPE;
	SUBTYPE typefullremark IS tentry.fullremark%TYPE;

	TYPE typecontractcalculatedlimits IS TABLE OF tcontractcalculatedlimits%ROWTYPE INDEX BY PLS_INTEGER;

	SUBTYPE typelimitsetuprow IS tcontractlimitparams%ROWTYPE;

	TYPE typelimitsettings IS RECORD(
		 calcmethod NUMBER
		,amount     NUMBER
		,percent    NUMBER
		,validfrom  DATE
		,validto    DATE
		,active     BOOLEAN);

	TYPE typeobjectlimitsettings IS RECORD(
		 curno         NUMBER
		,pan           typepan
		,mbr           typembr
		,credlimit     typelimitsettings
		,cashlimit     typelimitsettings
		,tempcredlimit typelimitsettings
		,tempcashlimit typelimitsettings
		,usedcredlimit typelimitsettings
		,usedcashlimit typelimitsettings);

	TYPE typearrusedlimitsrollback IS TABLE OF tcontractlimitrollback%ROWTYPE INDEX BY PLS_INTEGER;

	TYPE typecontractobject IS RECORD(
		 branch        NUMBER
		,contactno     typecontractno
		,accountno     typeaccountno
		,curno         NUMBER
		,pan           typepan
		,mbr           typembr
		,usedcredlimit NUMBER
		,usedcashlimit NUMBER);

	TYPE typecontractobjects IS TABLE OF typecontractobject INDEX BY PLS_INTEGER;

	excmethodnotfound EXCEPTION;
	PRAGMA EXCEPTION_INIT(excmethodnotfound, -06550);

	exccancelledbyuser EXCEPTION;

	excothererror EXCEPTION;

	ccorppackagename CONSTANT VARCHAR2(30) := 'SCH_Corporate';
	cinstpackagename CONSTANT VARCHAR2(30) := 'SCH_Installment';

	cinstlinkname CONSTANT VARCHAR2(30) := 'INSTALLMENT';

	c_writelog CONSTANT BOOLEAN := TRUE;

	c_norollback CONSTANT BOOLEAN := FALSE;
	c_dorollback CONSTANT BOOLEAN := TRUE;

	c_noexception CONSTANT BOOLEAN := FALSE;
	c_doexception CONSTANT BOOLEAN := TRUE;

	cright_viewparams      CONSTANT VARCHAR2(20) := 'VIEW_PARAMS';
	cright_modifyparams    CONSTANT VARCHAR2(20) := 'MODIFY_PARAMS';
	cright_viewreference   CONSTANT VARCHAR2(20) := 'VIEW_REFERENCE';
	cright_modifyreference CONSTANT VARCHAR2(20) := 'MODIFY_REFERENCE';

	c_cannothing CONSTANT PLS_INTEGER := 0;
	c_canview    CONSTANT PLS_INTEGER := 1;
	c_canmodify  CONSTANT PLS_INTEGER := 2;

	cadjusting         CONSTANT PLS_INTEGER := cinstadjusting;
	cclosing           CONSTANT PLS_INTEGER := cinstclosing;
	csetcontrstate     CONSTANT PLS_INTEGER := 03;
	csetcardstatus     CONSTANT PLS_INTEGER := 04;
	csetcredlimit      CONSTANT PLS_INTEGER := 05;
	ccontrtypechanging CONSTANT PLS_INTEGER := 06;
	ccontractcreation  CONSTANT PLS_INTEGER := 07;
	cbatchparamchange  CONSTANT PLS_INTEGER := 08;
	cexternalapicall   CONSTANT PLS_INTEGER := 09;
	csetcontractparams CONSTANT PLS_INTEGER := 10;
	coperationundo     CONSTANT PLS_INTEGER := 11;
	cdebtrefinance     CONSTANT PLS_INTEGER := 12;

	caoperationlabel CONSTANT tblchar100 := tblchar100('Contract adjustment'
													  ,'Contract closure'
													  ,'Set contract state'
													  ,'Set card status'
													  ,'Set credit limit'
													  ,'Contract type change'
													  ,'Contract creation'
													  ,'Batch parameters change'
													  ,'External API method call'
													  ,'Set contract parameters'
													  ,'Operation rollback');

	copersetdefault        CONSTANT typeopername := upper('Set_Def');
	coperundodefault       CONSTANT typeopername := upper('Undo_Def');
	copersetcreditlimit    CONSTANT typeopername := upper('Set_Lmt');
	copersetcontractparams CONSTANT typeopername := upper('Set_Param');
	copersetdcparams       CONSTANT typeopername := upper('Set_DC');
	copersetcontractstate  CONSTANT typeopername := upper('Set_State');
	copermanagecards       CONSTANT typeopername := upper('Card_Sts');
	copersetcorporatelink  CONSTANT typeopername := upper('Set_Link');
	copercreditrepayment   CONSTANT typeopername := upper('Repayment');
	coperchargeinterest    CONSTANT typeopername := upper('ChargeInt');

	copersetdccase         CONSTANT typeopername := upper('ChangeCase');
	copermoveduedate       CONSTANT typeopername := upper('MoveDD');
	coperrestructuring     CONSTANT typeopername := upper('Restruct');
	coperundorestructuring CONSTANT typeopername := upper('Undo_Restr');
	coperclosecontract     CONSTANT typeopername := upper('Close_Con');
	coperundoclose         CONSTANT typeopername := upper('Undo_Close');
	copertranchesinfo      CONSTANT typeopername := upper('Trxns_Info');

	crl_corp           CONSTANT contractrb.tlabel := contractrb.crs_schema + 01;
	crl_limit          CONSTANT contractrb.tlabel := contractrb.crs_schema + 02;
	crl_cstate         CONSTANT contractrb.tlabel := contractrb.crs_schema + 03;
	crl_createcontract CONSTANT contractrb.tlabel := contractrb.crs_schema + 04;
	crl_linkcontract   CONSTANT contractrb.tlabel := contractrb.crs_schema + 05;
	crl_cardstatus     CONSTANT contractrb.tlabel := contractrb.crs_schema + 06;
	crl_instmark       CONSTANT contractrb.tlabel := contractrb.crs_schema + 07;
	crl_limitdeleted   CONSTANT contractrb.tlabel := contractrb.crs_schema + 08;
	crl_billcycleclndr CONSTANT contractrb.tlabel := contractrb.crs_schema + 09;

	crl_daf_profile CONSTANT contractrb.tlabel := contractrb.crs_schema + 13;

	crl_packnosaved        CONSTANT contractrb.tlabel := contractrb.crs_schema + 15;
	crl_contractstate      CONSTANT contractrb.tlabel := contractrb.crs_schema + 16;
	crl_ovdfeelogsaved     CONSTANT contractrb.tlabel := contractrb.crs_schema + 17;
	crl_calculatedsd       CONSTANT contractrb.tlabel := contractrb.crs_schema + 18;
	crl_calculateddd       CONSTANT contractrb.tlabel := contractrb.crs_schema + 19;
	crl_contractadjusted   CONSTANT contractrb.tlabel := contractrb.crs_schema + 20;
	crl_histpacknosaved    CONSTANT contractrb.tlabel := contractrb.crs_schema + 21;
	crl_limitpacknosaved   CONSTANT contractrb.tlabel := contractrb.crs_schema + 22;
	crl_depositinfoupdated CONSTANT contractrb.tlabel := contractrb.crs_schema + 23;
	crl_objectlimit        CONSTANT contractrb.tlabel := contractrb.crs_schema + 24;
	crl_nextsd             CONSTANT contractrb.tlabel := contractrb.crs_schema + 25;
	crl_contractmigrated   CONSTANT contractrb.tlabel := contractrb.crs_schema + 26;

	calabeldesc CONSTANT tblchar100 := tblchar100('Corporate contract changed'
												 ,'Credit limit changed'
												 ,'Contract state changed'
												 ,'Contract created'
												 ,'Contract linked'
												 ,'Card status changed'
												 ,'Tranche is marked for transfer'
												 ,'Object limit settings deleted'
												 ,'Billing cycle calendar changed'
												 ,''
												 ,''
												 ,''
												 ,'DAF calculation profile changed'
												 ,''
												 ,'PackNo saved'
												 ,'Delinquency group changed'
												 ,'Overdue fee charge log saved'
												 ,'Calculated next SD'
												 ,'Calculated next DD'
												 ,'Contract adjusted'
												 ,'Parameters history saved'
												 ,'Limits updated'
												 ,'Deposit info updated'
												 ,'Object limit changed'
												 ,'Cycle next SD changed'
												 ,'Contract migrated');

	cso_closecontract CONSTANT VARCHAR2(80) := 'CONTRACT_CLOSURE';
	cso_cardoper      CONSTANT VARCHAR2(80) := 'CARD_OPER';
	cso_restructuring CONSTANT VARCHAR2(80) := 'RESTRUCTURE';

	clk_creditlimit CONSTANT PLS_INTEGER := 0;
	clk_cashlimit   CONSTANT PLS_INTEGER := 1;
	clk_addlimit    CONSTANT PLS_INTEGER := 2;

	ccredlimit     CONSTANT PLS_INTEGER := 0;
	ccashlimit     CONSTANT PLS_INTEGER := 1;
	ctempcredlimit CONSTANT PLS_INTEGER := 2;
	ctempcashlimit CONSTANT PLS_INTEGER := 3;

	cco_primary       CONSTANT PLS_INTEGER := 0;
	cco_supplementary CONSTANT PLS_INTEGER := 1;

	crecoveryperiods CONSTANT tblnumber := tblnumber(contracttypelimits.periodtype_at_sd
													,referencelimit.periodtype_none
													,referencelimit.periodtype_week
													,referencelimit.periodtype_month
													,referencelimit.periodtype_year
													,referencelimit.periodtype_reset_in_refresh);

	calimitcalcmethods CONSTANT tblchar100 := tblchar100('Not defined (100% of initial value)'
														,'As total of'
														,'As maximum between'
														,'As minimum between'
														,NULL
														,'Not used'
														,'Use contract type setup'
														,'Defined');

	calimittypelabel CONSTANT tblchar100 := tblchar100('Not defined'
													  ,'Aggregate'
													  ,'Separate'
													  ,'Single currency');

	clmtnotdefined CONSTANT PLS_INTEGER := 0;
	clmttotal      CONSTANT PLS_INTEGER := 1;
	clmtmax        CONSTANT PLS_INTEGER := 2;
	clmtmin        CONSTANT PLS_INTEGER := 3;
	clmtnotused    CONSTANT PLS_INTEGER := 5;
	clmtastype     CONSTANT PLS_INTEGER := 6;
	clmtdefined    CONSTANT PLS_INTEGER := 7;

	cpb_donotuse     CONSTANT PLS_INTEGER := 1;
	cpb_increasebase CONSTANT PLS_INTEGER := 2;
	cpb_addtolimit   CONSTANT PLS_INTEGER := 3;

	ctrxngrp_cash     CONSTANT PLS_INTEGER := 1;
	ctrxngrp_payments CONSTANT PLS_INTEGER := 2;
	ctrxngrp_other    CONSTANT PLS_INTEGER := 3;

	catrxntypeprefixes CONSTANT tblchar20 := tblchar20('Debit'
													  ,'Credit reverse'
													  ,'Repayment'
													  ,'Debit reverse');

	crate_regular      CONSTANT PLS_INTEGER := 1;
	crate_reduced      CONSTANT PLS_INTEGER := 2;
	crate_promotional  CONSTANT PLS_INTEGER := 3;
	crate_preferential CONSTANT PLS_INTEGER := 4;

	caratesprefixes CONSTANT tblchar20 := tblchar20('REG', 'RED', 'PROMO', 'PREF');

	caratesdescr CONSTANT tblchar20 := tblchar20('Regular rate'
												,'Reduced rate'
												,'Promotional rate'
												,'Preferential rate');

	citem_currency       CONSTANT typeitemname := upper('Item_Currency');
	citem_cardattributes CONSTANT typeitemname := upper('Item_CardAttributes');
	citem_useautomode    CONSTANT typeitemname := upper('Item_UseAutoMode');
	citem_changeonline   CONSTANT typeitemname := upper('Item_ChangeOnline');
	citem_pan            CONSTANT typeitemname := upper('Item_PAN');
	citem_mbr            CONSTANT typeitemname := upper('Item_MBR');
	citem_card           CONSTANT typeitemname := upper('Item_Card');
	citem_state          CONSTANT typeitemname := upper('Item_State');
	citem_status         CONSTANT typeitemname := upper('Item_Status');
	citem_cardmode       CONSTANT typeitemname := upper('Item_CardMode');
	citem_stuck          CONSTANT typeitemname := upper('Item_Stuck');
	citem_automode       CONSTANT typeitemname := upper('Item_AutoMode');

	citem_repaymententry CONSTANT typeitemname := upper('Item_RepaymentEntry');
	citem_payoutentry    CONSTANT typeitemname := upper('Item_PayOutEntry');

	citem_overdraft  CONSTANT typeitemname := upper('Item_Overdraft');
	citem_debithold  CONSTANT typeitemname := upper('Item_DebitHold');
	citem_credithold CONSTANT typeitemname := upper('Item_CreditHold');
	citem_balance    CONSTANT typeitemname := upper('Item_Balance');
	citem_paymethod  CONSTANT typeitemname := upper('Item_PayMethod');
	citem_accountno  CONSTANT typeitemname := upper('Item_AccountNo');
	citem_cardscount CONSTANT typeitemname := upper('Item_CardsCount');

	citem_cardstoclose CONSTANT typeitemname := upper('CloseCardsMode');

	citem_amount CONSTANT typeitemname := upper('Item_Amount');

	clist_debtinfo      CONSTANT typeitemname := upper('List_DebtInfo');
	clist_cards         CONSTANT typeitemname := upper('List_Cards');
	clist_trxncommon    CONSTANT typeitemname := upper('List_TrxnCommon');
	clist_trxndetail    CONSTANT typeitemname := upper('List_TrxnDetail');
	clist_cyclekeydates CONSTANT typeitemname := upper('List_CycleKeyDates');
	clist_cycleparams   CONSTANT typeitemname := upper('List_CycleParams');

	cfld_id   CONSTANT typeitemname := upper('ItemID');
	cfld_name CONSTANT typeitemname := upper('ItemName');

	cbtn_ok       CONSTANT typeitemname := upper('Btn_OK');
	cbtn_cancel   CONSTANT typeitemname := upper('Btn_Cancel');
	cbtn_setlimit CONSTANT typeitemname := upper('Btn_SetLimit');

	ccmd_findaccount CONSTANT PLS_INTEGER := 101;

	cdaf_default  CONSTANT PLS_INTEGER := 0;
	cdaf_generate CONSTANT PLS_INTEGER := 1;
	cdaf_skip     CONSTANT PLS_INTEGER := 2;

	ccrdstatset_default CONSTANT PLS_INTEGER := 0;
	ccrdstatset_never   CONSTANT PLS_INTEGER := 1;
	ccrdstatset_open    CONSTANT PLS_INTEGER := 2;
	ccrdstatset_auto    CONSTANT PLS_INTEGER := 3;

	ccs_donotcharge   CONSTANT PLS_INTEGER := 0;
	ccs_alwayscharge  CONSTANT PLS_INTEGER := 1;
	ccs_charge4credit CONSTANT PLS_INTEGER := 2;

	ccs_default  CONSTANT PLS_INTEGER := 0;
	ccs_charge   CONSTANT PLS_INTEGER := 1;
	ccs_nocharge CONSTANT PLS_INTEGER := 2;

	cmode_cashaccount   CONSTANT PLS_INTEGER := 0;
	cmode_clientaccount CONSTANT PLS_INTEGER := 1;
	cmode_bankaccount   CONSTANT PLS_INTEGER := 2;
	cmode_corpaccount   CONSTANT PLS_INTEGER := 3;

	cprefrate_donotuse    CONSTANT PLS_INTEGER := 0;
	cprefrate_forcontract CONSTANT PLS_INTEGER := 1;
	cprefrate_fortrxn     CONSTANT PLS_INTEGER := 2;

	cautopay_mponod   CONSTANT PLS_INTEGER := 1;
	cautopay_debtonsd CONSTANT PLS_INTEGER := 2;
	cautopay_debtonod CONSTANT PLS_INTEGER := 3;

	covdcalc_normal     CONSTANT PLS_INTEGER := 1;
	covdcalc_frzwithrep CONSTANT PLS_INTEGER := 2;
	covdcalc_frzworep   CONSTANT PLS_INTEGER := 3;

	cshieldtotal CONSTANT PLS_INTEGER := 2;
	cshieldmax   CONSTANT PLS_INTEGER := 3;
	cshieldmin   CONSTANT PLS_INTEGER := 4;

	cshieldstatic     CONSTANT PLS_INTEGER := 1;
	cshielddynamic    CONSTANT PLS_INTEGER := 2;
	cshieldstaticpost CONSTANT PLS_INTEGER := 3;

	ccalctype_notcalc CONSTANT NUMBER := 0;
	ccalctype_total   CONSTANT NUMBER := 1;
	ccalctype_min     CONSTANT NUMBER := 2;
	ccalctype_max     CONSTANT NUMBER := 3;

	cshieldnotused  CONSTANT NUMBER := 1;
	cmonthlyeom     CONSTANT NUMBER := 2;
	cmonthlyeoc     CONSTANT NUMBER := 3;
	cqreom          CONSTANT NUMBER := 4;
	cqreoc          CONSTANT NUMBER := 5;
	cmonthlyonday   CONSTANT NUMBER := 6;
	cqronday        CONSTANT NUMBER := 7;
	cfirstsdafterqr CONSTANT NUMBER := 8;

	ccurrentbalance        CONSTANT NUMBER := 1;
	cpreveombalance        CONSTANT NUMBER := 2;
	cpreveocbalance        CONSTANT NUMBER := 3;
	cprevbusinessday       CONSTANT NUMBER := 4;
	chighestbalwithinqr    CONSTANT NUMBER := 5;
	chighestbalwithinmonth CONSTANT NUMBER := 6;

	cbasedonfixedvalues    CONSTANT NUMBER := 1;
	cbasedoncredlimitrange CONSTANT NUMBER := 2;

	cshiedlsupplamnt_zero        CONSTANT NUMBER := 1;
	cshiedlsupplamnt_installment CONSTANT NUMBER := 2;

	cmp0_count     CONSTANT NUMBER := 1;
	cmp0_dontcount CONSTANT NUMBER := 2;
	cmp0_restart   CONSTANT NUMBER := 3;

	cinstnotdepend            CONSTANT NUMBER := 1;
	cinstregpayment           CONSTANT NUMBER := 2;
	cinstusedlimit            CONSTANT NUMBER := 3;
	cinstusedlimitandinterest CONSTANT NUMBER := 4;

	cp_lastodfee    CONSTANT PLS_INTEGER := 01;
	cp_lastdocno    CONSTANT PLS_INTEGER := 02;
	cp_limit        CONSTANT PLS_INTEGER := 03;
	cp_pbaccount    CONSTANT PLS_INTEGER := 04;
	cp_payaccount   CONSTANT PLS_INTEGER := 05;
	cp_payamount    CONSTANT PLS_INTEGER := 06;
	cp_profile      CONSTANT PLS_INTEGER := 07;
	cp_mpprofile    CONSTANT PLS_INTEGER := 08;
	cp_fixprofile   CONSTANT PLS_INTEGER := 09;
	cp_fixmpprofile CONSTANT PLS_INTEGER := 10;
	cp_accoltype    CONSTANT PLS_INTEGER := 11;
	cp_accolamount  CONSTANT PLS_INTEGER := 12;
	cp_accolprc     CONSTANT PLS_INTEGER := 13;
	cp_accstatus    CONSTANT PLS_INTEGER := 14;
	cp_paydate      CONSTANT PLS_INTEGER := 15;
	cp_inttoinston  CONSTANT PLS_INTEGER := 16;

	cacontrpdom_ident CONSTANT tblschitem := tblschitem(recschitem(cp_lastodfee
																  ,'Last_Overdue_Fee_1'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_lastdocno
																  ,'LastDocNo_1'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,0
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_limit
																  ,'Limit1'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_pbaccount
																  ,'AccountDOM'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_payaccount
																  ,'PayAccountDOM'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_payamount
																  ,'PayAmountDOM'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,1
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_profile
																  ,'ProfileDOM'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_mpprofile
																  ,'MPProfileDOM'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_fixprofile
																  ,'FixProfileDOM'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,0
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_fixmpprofile
																  ,'FixMPProfileDOM'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,0
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_accoltype
																  ,'AccOverLimitTypeDOM'
																  ,''
																  ,''
																  ,contracttools.cboth
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,-1)
													   ,recschitem(cp_accolamount
																  ,'AccOverLimitAmountDOM'
																  ,''
																  ,''
																  ,contracttools.cboth
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_accolprc
																  ,'AccOverLimitPrcDOM'
																  ,''
																  ,''
																  ,contracttools.cboth
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_accstatus
																  ,'Acc_Status_1'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_paydate
																  ,'PayDate_1'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_inttoinston
																  ,'IntToInstOnDOM'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,0
																  ,NULL
																  ,NULL));
	cacontrpint_ident CONSTANT tblschitem := tblschitem(recschitem(cp_lastodfee
																  ,'Last_Overdue_Fee_2'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_lastdocno
																  ,'LastDocNo_2'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,0
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_limit
																  ,'Limit2'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_pbaccount
																  ,'AccountINT'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_payaccount
																  ,'PayAccountINT'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_payamount
																  ,'PayAmountINT'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,1
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_profile
																  ,'ProfileINT'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_mpprofile
																  ,'MPProfileINT'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_fixprofile
																  ,'FixProfileINT'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,0
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_fixmpprofile
																  ,'FixMPProfileINT'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,0
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_accoltype
																  ,'AccOverLimitTypeINT'
																  ,''
																  ,''
																  ,contracttools.cboth
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,-1)
													   ,recschitem(cp_accolamount
																  ,'AccOverLimitAmountINT'
																  ,''
																  ,''
																  ,contracttools.cboth
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_accolprc
																  ,'AccOverLimitPrcINT'
																  ,''
																  ,''
																  ,contracttools.cboth
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_accstatus
																  ,'Acc_Status_2'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_paydate
																  ,'PayDate_2'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,NULL
																  ,NULL
																  ,NULL)
													   ,recschitem(cp_inttoinston
																  ,'IntToInstOnINT'
																  ,''
																  ,''
																  ,contracttools.ccont
																  ,contracttools.coptional
																  ,0
																  ,NULL
																  ,NULL));

	cp_cardlock          CONSTANT PLS_INTEGER := 01;
	cp_chaccstatus       CONSTANT PLS_INTEGER := 02;
	cp_zerompcycles      CONSTANT PLS_INTEGER := 03;
	cp_useshield         CONSTANT PLS_INTEGER := 04;
	cp_nextstmtdate      CONSTANT PLS_INTEGER := 05;
	cp_closedocno        CONSTANT PLS_INTEGER := 06;
	cp_closepackno       CONSTANT PLS_INTEGER := 07;
	cp_gendaf            CONSTANT PLS_INTEGER := 08;
	cp_lastadpackno      CONSTANT PLS_INTEGER := 09;
	cp_delcycle4dc       CONSTANT PLS_INTEGER := 10;
	cp_dclasttime        CONSTANT PLS_INTEGER := 11;
	cp_billcyclecalendar CONSTANT PLS_INTEGER := 12;
	cp_ovdperiodcalcmode CONSTANT PLS_INTEGER := 13;
	cp_ovdperioddatefrom CONSTANT PLS_INTEGER := 14;
	cp_ovdperioddateto   CONSTANT PLS_INTEGER := 15;

	cacp_ident CONSTANT tblschitem := tblschitem(recschitem(cp_cardlock
														   ,'CardLock'
														   ,''
														   ,''
														   ,contracttools.cboth
														   ,contracttools.coptional
														   ,NULL
														   ,3
														   ,0)
												,recschitem(cp_chaccstatus
														   ,'ChangeAccStatus'
														   ,''
														   ,''
														   ,contracttools.cboth
														   ,contracttools.coptional
														   ,NULL
														   ,2
														   ,0)
												,recschitem(cp_zerompcycles
														   ,'ZeroMPCycles'
														   ,''
														   ,''
														   ,contracttools.cboth
														   ,contracttools.coptional
														   ,NULL
														   ,cmp0_count
														   ,0)
												,recschitem(cp_useshield
														   ,'UseShield'
														   ,''
														   ,''
														   ,contracttools.ccont
														   ,contracttools.coptional
														   ,0
														   ,NULL
														   ,NULL)
												,recschitem(cp_nextstmtdate
														   ,'NextStmtDate'
														   ,''
														   ,''
														   ,contracttools.ccont
														   ,contracttools.coptional
														   ,NULL
														   ,NULL
														   ,NULL)
												,recschitem(cp_closedocno
														   ,'CloseDocNo'
														   ,''
														   ,''
														   ,contracttools.ccont
														   ,contracttools.coptional
														   ,NULL
														   ,NULL
														   ,NULL)
												,recschitem(cp_closepackno
														   ,'ClosePackNo'
														   ,''
														   ,''
														   ,contracttools.ccont
														   ,contracttools.coptional
														   ,NULL
														   ,NULL
														   ,NULL)
												,recschitem(cp_gendaf
														   ,'GenDAF'
														   ,''
														   ,''
														   ,contracttools.ccont
														   ,contracttools.coptional
														   ,0
														   ,NULL
														   ,NULL)
												,recschitem(cp_lastadpackno
														   ,'LastAdPackNo'
														   ,''
														   ,''
														   ,contracttools.ccont
														   ,contracttools.coptional
														   ,0
														   ,NULL
														   ,NULL)
												,recschitem(cp_delcycle4dc
														   ,'DelCycle4DC'
														   ,''
														   ,''
														   ,contracttools.ccont
														   ,contracttools.coptional
														   ,0
														   ,NULL
														   ,NULL)
												,recschitem(cp_dclasttime
														   ,'DCLastTimeSendData'
														   ,''
														   ,''
														   ,contracttools.ccont
														   ,contracttools.coptional
														   ,0
														   ,NULL
														   ,NULL)
												,recschitem(cp_billcyclecalendar
														   ,'BillCycleCalendar'
														   ,''
														   ,''
														   ,contracttools.ccont
														   ,contracttools.coptional
														   ,-1
														   ,NULL
														   ,NULL)
												,recschitem(cp_ovdperiodcalcmode
														   ,'OvdPeriodCalcMode'
														   ,''
														   ,''
														   ,contracttools.cboth
														   ,contracttools.cmandatory
														   ,NULL
														   ,NULL
														   ,NULL)
												,recschitem(cp_ovdperioddatefrom
														   ,'OvdPeriodDateFrom'
														   ,''
														   ,''
														   ,contracttools.cboth
														   ,contracttools.coptional
														   ,NULL
														   ,NULL
														   ,NULL)
												,recschitem(cp_ovdperioddateto
														   ,'OvdPeriodDateTo'
														   ,''
														   ,''
														   ,contracttools.cboth
														   ,contracttools.coptional
														   ,NULL
														   ,NULL
														   ,NULL)
												 
												 );

	cctp_exchangerate      CONSTANT PLS_INTEGER := 01;
	cctp_intlog            CONSTANT PLS_INTEGER := 02;
	cctp_correction        CONSTANT PLS_INTEGER := 03;
	cctp_stmttype          CONSTANT PLS_INTEGER := 04;
	cctp_stmtfolder        CONSTANT PLS_INTEGER := 05;
	cctp_stmtmode          CONSTANT PLS_INTEGER := 06;
	cctp_promtext          CONSTANT PLS_INTEGER := 07;
	cctp_stmttrns          CONSTANT PLS_INTEGER := 08;
	cctp_corpmode          CONSTANT PLS_INTEGER := 09;
	cctp_calendarid        CONSTANT PLS_INTEGER := 10;
	cctp_usedaf            CONSTANT PLS_INTEGER := 11;
	cctp_dafreport         CONSTANT PLS_INTEGER := 12;
	cctp_outpath           CONSTANT PLS_INTEGER := 13;
	cctp_useinst           CONSTANT PLS_INTEGER := 14;
	cctp_instaddpay        CONSTANT PLS_INTEGER := 15;
	cctp_instaddacc        CONSTANT PLS_INTEGER := 16;
	cctp_instaddint        CONSTANT PLS_INTEGER := 17;
	cctp_instdooneentry    CONSTANT PLS_INTEGER := 18;
	cctp_shieldchargemode  CONSTANT PLS_INTEGER := 19;
	cctp_shieldcalendar    CONSTANT PLS_INTEGER := 20;
	cctp_defstate          CONSTANT PLS_INTEGER := 21;
	cctp_periodtype        CONSTANT PLS_INTEGER := 22;
	cctp_overlimittype     CONSTANT PLS_INTEGER := 23;
	cctp_instdepend        CONSTANT PLS_INTEGER := 24;
	cctp_dafgen4ctype      CONSTANT PLS_INTEGER := 25;
	cctp_stmntpl_sql       CONSTANT PLS_INTEGER := 26;
	cctp_overdueamountcurr CONSTANT PLS_INTEGER := 27;
	cctp_ovdperiodcalcmode CONSTANT PLS_INTEGER := 28;
	cctp_ovdperioddatefrom CONSTANT PLS_INTEGER := 29;
	cctp_ovdperioddateto   CONSTANT PLS_INTEGER := 30;

	cactp_ident CONSTANT tblschitem := tblschitem(recschitem(cctp_exchangerate
															,'ExchangeRate'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,NULL
															,NULL)
												 ,recschitem(cctp_intlog
															,'IntLog'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,0
															,NULL)
												 ,recschitem(cctp_correction
															,'Correction'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,0
															,NULL)
												 ,recschitem(cctp_stmttype
															,'StmtType'
															,'Statement type'
															,''
															,contracttools.ctype
															,contracttools.cmandatory
															,NULL
															,NULL
															,NULL)
												 ,recschitem(cctp_stmtfolder
															,'StmtFolder'
															,'Statement unload directory'
															,''
															,contracttools.ctype
															,contracttools.cmandatory
															,NULL
															,NULL
															,NULL)
												 ,recschitem(cctp_stmtmode
															,'StmtMode'
															,'Generation condition'
															,''
															,contracttools.ctype
															,contracttools.cmandatory
															,NULL
															,NULL
															,NULL)
												 ,recschitem(cctp_promtext
															,'PromText'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,NULL
															,NULL)
												 ,recschitem(cctp_stmttrns
															,'StmtTrns'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,NULL
															,NULL)
												 ,recschitem(cctp_corpmode
															,'CorpMode'
															,'Use corporate operation mode'
															,''
															,contracttools.ctype
															,contracttools.cmandatory
															,NULL
															,NULL
															,NULL)
												 ,recschitem(cctp_calendarid
															,'CalendarId'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,NULL
															,NULL)
												 ,recschitem(cctp_usedaf
															,'UseDAF'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,NULL
															,NULL)
												 ,recschitem(cctp_dafreport
															,'DAFReport'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,NULL
															,NULL)
												 ,recschitem(cctp_outpath
															,'OutPath'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,NULL
															,NULL)
												 ,recschitem(cctp_useinst
															,'UseInst'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,0
															,NULL)
												 ,recschitem(cctp_instaddpay
															,'InstAddPay'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,0
															,NULL)
												 ,recschitem(cctp_instaddacc
															,'InstAddAcc'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,0
															,NULL)
												 ,recschitem(cctp_instaddint
															,'InstAddInt'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,0
															,NULL)
												 ,recschitem(cctp_instdooneentry
															,'InstDoOneEntry'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,0
															,NULL)
												 ,recschitem(cctp_shieldchargemode
															,'ShieldChargeMode'
															,''
															,''
															,contracttools.ctype
															,contracttools.cmandatory
															,NULL
															,ccs_donotcharge
															,NULL)
												 ,recschitem(cctp_shieldcalendar
															,'ShieldCalendar'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,0
															,NULL)
												 ,recschitem(cctp_defstate
															,'DefState'
															,'Normal contract state'
															,''
															,contracttools.ctype
															,contracttools.cmandatory
															,NULL
															,NULL
															,NULL)
												 ,recschitem(cctp_periodtype
															,'PeriodType'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,1
															,NULL)
												 ,recschitem(cctp_overlimittype
															,'OverlimitType'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,1
															,NULL)
												 ,recschitem(cctp_instdepend
															,'InstDepend'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,3
															,NULL)
												 ,recschitem(cctp_dafgen4ctype
															,'DAFGen4CType'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,3
															,NULL)
												 ,recschitem(cctp_stmntpl_sql
															,'StmntPL_SQL'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,NULL
															,NULL)
												 ,recschitem(cctp_overdueamountcurr
															,'OverdueAmountCurr'
															,''
															,''
															,contracttools.ctype
															,contracttools.cmandatory
															,NULL
															,NULL
															,NULL)
												 ,recschitem(cctp_ovdperiodcalcmode
															,'OvdPeriodCalcMode'
															,''
															,''
															,contracttools.ctype
															,contracttools.cmandatory
															,NULL
															,covdcalc_normal
															,NULL)
												 ,recschitem(cctp_ovdperioddatefrom
															,'OvdPeriodDateFrom'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,NULL
															,NULL)
												 ,recschitem(cctp_ovdperioddateto
															,'OvdPeriodDateTo'
															,''
															,''
															,contracttools.ctype
															,contracttools.coptional
															,NULL
															,NULL
															,NULL));

	cctp_usecur                      CONSTANT PLS_INTEGER := 01;
	cctp_profile                     CONSTANT PLS_INTEGER := 02;
	cctp_mpprofile                   CONSTANT PLS_INTEGER := 03;
	cctp_pblimit                     CONSTANT PLS_INTEGER := 04;
	cctp_acccredlimitmin             CONSTANT PLS_INTEGER := 05;
	cctp_acccredlimitmax             CONSTANT PLS_INTEGER := 06;
	cctp_acccashlimitpbtype          CONSTANT PLS_INTEGER := 07;
	cctp_pricardlimitmax             CONSTANT PLS_INTEGER := 08;
	cctp_prilimitbpuse               CONSTANT PLS_INTEGER := 09;
	cctp_pricashlimitpbtype          CONSTANT PLS_INTEGER := 10;
	cctp_supcardlimitmax             CONSTANT PLS_INTEGER := 11;
	cctp_suplimitbpuse               CONSTANT PLS_INTEGER := 12;
	cctp_supcashlimitpbtype          CONSTANT PLS_INTEGER := 13;
	cctp_shieldtype                  CONSTANT PLS_INTEGER := 14;
	cctp_shieldamount                CONSTANT PLS_INTEGER := 15;
	cctp_shieldprc                   CONSTANT PLS_INTEGER := 16;
	cctp_proshieldtype               CONSTANT PLS_INTEGER := 17;
	cctp_proshieldamount             CONSTANT PLS_INTEGER := 18;
	cctp_proshieldprc                CONSTANT PLS_INTEGER := 19;
	cctp_proshieldclnd               CONSTANT PLS_INTEGER := 20;
	cctp_proshieldcycles             CONSTANT PLS_INTEGER := 21;
	cctp_proshielddoboth             CONSTANT PLS_INTEGER := 22;
	cctp_shieldcalctype              CONSTANT PLS_INTEGER := 23;
	cctp_shieldplsql                 CONSTANT PLS_INTEGER := 24;
	cctp_shieldacc                   CONSTANT PLS_INTEGER := 25;
	cctp_stmtfeeamount               CONSTANT PLS_INTEGER := 26;
	cctp_stmtfeeacc                  CONSTANT PLS_INTEGER := 27;
	cctp_accoltype                   CONSTANT PLS_INTEGER := 28;
	cctp_accolamount                 CONSTANT PLS_INTEGER := 29;
	cctp_accolprc                    CONSTANT PLS_INTEGER := 30;
	cctp_shieldwhentocharge          CONSTANT PLS_INTEGER := 31;
	cctp_shieldcertainday            CONSTANT PLS_INTEGER := 32;
	cctp_shieldbaseamount            CONSTANT PLS_INTEGER := 33;
	cctp_shieldcalcmethod            CONSTANT PLS_INTEGER := 34;
	cctp_rangeshieldprc              CONSTANT PLS_INTEGER := 35;
	cctp_rangeshieldamount           CONSTANT PLS_INTEGER := 36;
	cctp_installmentonfee            CONSTANT PLS_INTEGER := 37;
	cctp_instonfeecalc               CONSTANT PLS_INTEGER := 38;
	cctp_instonfeeacc                CONSTANT PLS_INTEGER := 39;
	cctp_inttoinston                 CONSTANT PLS_INTEGER := 40;
	cctp_inttoinstfrom               CONSTANT PLS_INTEGER := 41;
	cctp_inttoinstto                 CONSTANT PLS_INTEGER := 42;
	cctp_inttoinstct                 CONSTANT PLS_INTEGER := 43;
	cctp_debttoinston                CONSTANT PLS_INTEGER := 44;
	cctp_debttoinstct                CONSTANT PLS_INTEGER := 45;
	cctp_stmntfeecalctype            CONSTANT PLS_INTEGER := 46;
	cctp_stmntfeeprcnt               CONSTANT PLS_INTEGER := 47;
	cctp_supamnttoshieldbaseamount   CONSTANT PLS_INTEGER := 48;
	cctp_monthlyfeeprof              CONSTANT PLS_INTEGER := 49;
	cctp_priincrscrdlimbyallwovl     CONSTANT PLS_INTEGER := 50;
	cctp_supincrscrdlimbyallwovl     CONSTANT PLS_INTEGER := 51;
	cctp_priincrscashlimbyallwovl    CONSTANT PLS_INTEGER := 52;
	cctp_supincrscashlimbyallwovl    CONSTANT PLS_INTEGER := 53;
	cctp_accincrscashlimbyallwovl    CONSTANT PLS_INTEGER := 54;
	cctp_gst_profileid               CONSTANT PLS_INTEGER := 55;
	cctp_lcf_acccredlmtprofileid     CONSTANT PLS_INTEGER := 56;
	cctp_lcf_acccredtemplmtprofileid CONSTANT PLS_INTEGER := 57;

	cactp_dom_ident CONSTANT tblschitem := tblschitem(recschitem(cctp_usecur
																,'UseCurDOM'
																,'Use Domestic Currency Account'
																,''
																,contracttools.ctype
																,contracttools.cmandatory
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_profile
																,'ProfileDOM'
																,'Interest Profile DOM'
																,''
																,contracttools.ctype
																,contracttools.cmandatory
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_mpprofile
																,'MPProfileDOM'
																,'Minimum Payment Profile DOM'
																,''
																,contracttools.ctype
																,contracttools.cmandatory
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_pblimit
																,'PBLimitDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_acccredlimitmin
																,'AccCredLimitMinDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_acccredlimitmax
																,'AccCredLimitMaxDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_acccashlimitpbtype
																,'AccCashLimitPBTypeDOM'
																,'PB amount usage in Account W/d Limit DOM'
																,''
																,contracttools.ctype
																,contracttools.cmandatory
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_pricardlimitmax
																,'PriCardCalcLimitMaxDOM'
																,'Card Calculated Limit maximum value (prim.) DOM'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_prilimitbpuse
																,'PriLimitBPUseDOM'
																,'Increase Available Limit by PB (prim.) DOM'
																,''
																,contracttools.ctype
																,contracttools.cmandatory
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_pricashlimitpbtype
																,'PriCashLimitPBTypeDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_supcardlimitmax
																,'SupCardCalcLimitMaxDOM'
																,'Card Calculated Limit maximum value (suppl.) DOM'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_suplimitbpuse
																,'SupLimitBPUseDOM'
																,'Increase Available Limit by PB (suppl.) DOM'
																,''
																,contracttools.ctype
																,contracttools.cmandatory
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_supcashlimitpbtype
																,'SupCashLimitPBTypeDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_shieldtype
																,'ShieldTypeDOM'
																,'Credit Shield Premium charge type DOM'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_shieldamount
																,'ShieldAmountDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_shieldprc
																,'ShieldPrcDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_proshieldtype
																,'ProShieldTypeDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_proshieldamount
																,'ProShieldAmountDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_proshieldprc
																,'ProShieldPrcDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_proshieldclnd
																,'ProShieldClndDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_proshieldcycles
																,'ProShieldCyclesDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_proshielddoboth
																,'ProShieldDoBothEntriesDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_shieldcalctype
																,'ShieldCalcTypeDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,cshieldstatic
																,NULL)
													 ,recschitem(cctp_shieldplsql
																,'ShieldPLSQLDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_shieldacc
																,'ShieldAccDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_stmtfeeamount
																,'StmtFeeAmountDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_stmtfeeacc
																,'StmtFeeAccDOM'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_accoltype
																,'AccOverLimitTypeDOM'
																,''
																,''
																,contracttools.ccont
																,contracttools.coptional
																,NULL
																,clmtnotdefined
																,NULL)
													 ,recschitem(cctp_accolamount
																,'AccOverLimitAmountDOM'
																,''
																,''
																,contracttools.ccont
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_accolprc
																,'AccOverLimitPrcDOM'
																,''
																,''
																,contracttools.ccont
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_shieldwhentocharge
																,'ShieldWhenToChargeDOM'
																,'When credit shield should be charged'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,cmonthlyeoc
																,NULL)
													 ,recschitem(cctp_shieldcertainday
																,'ShieldCertainDayDOM'
																,'Certain day when credit shield should be charged'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_shieldbaseamount
																,'ShieldChargeBaseDOM'
																,'Base Amount on which credit shield should be charged'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,ccurrentbalance
																,NULL)
													 ,recschitem(cctp_shieldcalcmethod
																,'ShieldCalcMethodDOM'
																,'Method by which credit shield should be calculated'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,cbasedonfixedvalues
																,NULL)
													 ,recschitem(cctp_rangeshieldprc
																,'RangeShieldPrcDOM'
																,'Prc. value for CS calculation depending on Credit Limit Range'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_rangeshieldamount
																,'RangeShieldAmountDOM'
																,'Flat amount for CS calculated depending on Credit Limit Range'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_installmentonfee
																,'InstallmentOnFeeDOM'
																,'Tariff for InstallmentOn fee calcualtion'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_instonfeecalc
																,'InstOnFeeCalcDOM'
																,'Calculate InstallmentOn Fee'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_instonfeeacc
																,'InstOnFeeAccDOM'
																,'InstallmentOn fee income account'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_inttoinston
																,'IntToInstOnDOM'
																,'Transfer interest to installment'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_inttoinstfrom
																,'IntToInstFromDOM'
																,'Interest transfer to installment period start'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_inttoinstto
																,'IntToInstToDOM'
																,'Interest transfer to installment period end'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_inttoinstct
																,'IntToInstCTDOM'
																,'Interest transfer to installment contract type'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_debttoinston
																,'AllowRestructureDOM'
																,'Allow debt restructuring'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_debttoinstct
																,'DebtToInstCTDOM'
																,'Installment contract type to be used'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_stmntfeecalctype
																,'StmntFeeCalcTypeDOM'
																,'Statement fee calculation type'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,ccalctype_notcalc
																,NULL)
													 ,recschitem(cctp_stmntfeeprcnt
																,'StmntFeePrcntDOM'
																,'Percentage from outstanding amount'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_supamnttoshieldbaseamount
																,'AddToShieldBaseAmountDOM'
																,'Supplementary amount should be added to credit shield base'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,cshiedlsupplamnt_zero
																,NULL)
													 ,recschitem(cctp_monthlyfeeprof
																,'MonthlyFeeProfDOM'
																,'Monthly fee profile identifier'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_priincrscrdlimbyallwovl
																,'PriIncrsCrdLimByAllwOvlDOM'
																,'Increase primary card credit limit by allowable account overlimit'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_supincrscrdlimbyallwovl
																,'SupIncrsCrdLimByAllwOvlDOM'
																,'Increase supplementary card credit limit by allowable account overlimit'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_priincrscashlimbyallwovl
																,'PriIncrsCashLimByAllwOvlDOM'
																,'Increase primary card cash limit by allowable account overlimit'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_supincrscashlimbyallwovl
																,'SupIncrsCashLimByAllwOvlDOM'
																,'Increase supplementary card cash limit by allowable account overlimit'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_accincrscashlimbyallwovl
																,'AccIncrsCashLimByAllwOvlDOM'
																,'Increase account cash limit by allowable account overlimit'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_gst_profileid
																,'GSTProfileDOM'
																,'Profile ID for GST accrual DOM'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_lcf_acccredlmtprofileid
																,'LCF_AccCredLmtProfileDOM'
																,'Account credit limit change fee profile'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_lcf_acccredtemplmtprofileid
																,'LCF_AccCredTempLmtProfileDOM'
																,'Account temporary credit limit change fee profile'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL));

	cactp_int_ident CONSTANT tblschitem := tblschitem(recschitem(cctp_usecur
																,'UseCurINT'
																,'Use Domestic Currency Account'
																,''
																,contracttools.ctype
																,contracttools.cmandatory
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_profile
																,'ProfileINT'
																,'Interest Profile INT'
																,''
																,contracttools.ctype
																,contracttools.cmandatory
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_mpprofile
																,'MPProfileINT'
																,'Minimum Payment Profile INT'
																,''
																,contracttools.ctype
																,contracttools.cmandatory
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_pblimit
																,'PBLimitINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_acccredlimitmin
																,'AccCredLimitMinINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_acccredlimitmax
																,'AccCredLimitMaxINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_acccashlimitpbtype
																,'AccCashLimitPBTypeINT'
																,'PB amount usage in Account W/d Limit INT'
																,''
																,contracttools.ctype
																,contracttools.cmandatory
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_pricardlimitmax
																,'PriCardCalcLimitMaxINT'
																,'Card Calculated Limit maximum value (prim.) INT'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_prilimitbpuse
																,'PriLimitBPUseINT'
																,'Increase Available Limit by PB (prim.) INT'
																,''
																,contracttools.ctype
																,contracttools.cmandatory
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_pricashlimitpbtype
																,'PriCashLimitPBTypeINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_supcardlimitmax
																,'SupCardCalcLimitMaxINT'
																,'Card Calculated Limit maximum value (suppl.) INT'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_suplimitbpuse
																,'SupLimitBPUseINT'
																,'Increase Available Limit by PB (suppl.) INT'
																,''
																,contracttools.ctype
																,contracttools.cmandatory
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_supcashlimitpbtype
																,'SupCashLimitPBTypeINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_shieldtype
																,'ShieldTypeINT'
																,'Credit Shield Premium charge type INT'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_shieldamount
																,'ShieldAmountINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_shieldprc
																,'ShieldPrcINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_proshieldtype
																,'ProShieldTypeINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_proshieldamount
																,'ProShieldAmountINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_proshieldprc
																,'ProShieldPrcINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_proshieldclnd
																,'ProShieldClndINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_proshieldcycles
																,'ProShieldCyclesINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_proshielddoboth
																,'ProShieldDoBothEntriesINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_shieldcalctype
																,'ShieldCalcTypeINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,cshieldstatic
																,NULL)
													 ,recschitem(cctp_shieldplsql
																,'ShieldPLSQLINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_shieldacc
																,'ShieldAccINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_stmtfeeamount
																,'StmtFeeAmountINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_stmtfeeacc
																,'StmtFeeAccINT'
																,''
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_accoltype
																,'AccOverLimitTypeINT'
																,''
																,''
																,contracttools.ccont
																,contracttools.coptional
																,NULL
																,clmtnotdefined
																,NULL)
													 ,recschitem(cctp_accolamount
																,'AccOverLimitAmountINT'
																,''
																,''
																,contracttools.ccont
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_accolprc
																,'AccOverLimitPrcINT'
																,''
																,''
																,contracttools.ccont
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_shieldwhentocharge
																,'ShieldWhenToChargeINT'
																,'When credit shield should be charged'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,cmonthlyeoc
																,NULL)
													 ,recschitem(cctp_shieldcertainday
																,'ShieldCertainDayINT'
																,'Certain day when credit shield should be charged'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_shieldbaseamount
																,'ShieldChargeBaseINT'
																,'Base Amount on which credit shield should be charged'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,ccurrentbalance
																,NULL)
													 ,recschitem(cctp_shieldcalcmethod
																,'ShieldCalcMethodINT'
																,'Method by which credit shield should be calculated'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,cbasedonfixedvalues
																,NULL)
													 ,recschitem(cctp_rangeshieldprc
																,'RangeShieldPrcINT'
																,'Prc. value for CS calculation depending on Credit Limit Range'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_rangeshieldamount
																,'RangeShieldAmountINT'
																,'Flat amount for CS calculated depending on Credit Limit Range'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_installmentonfee
																,'InstallmentOnFeeINT'
																,'Tariff for InstallmentOn fee calcualtion'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_instonfeecalc
																,'InstOnFeeCalcINT'
																,'Calculate InstallmentOn Fee'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_instonfeeacc
																,'InstOnFeeAccINT'
																,'InstallmentOn fee income account'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_inttoinston
																,'IntToInstOnINT'
																,'Transfer interest to installment'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_inttoinstfrom
																,'IntToInstFromINT'
																,'Interest transfer to installment period start'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_inttoinstto
																,'IntToInstToINT'
																,'Interest transfer to installment period end'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_inttoinstct
																,'IntToInstCTINT'
																,'Interest transfer to installment contract type'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_debttoinston
																,'AllowRestructureINT'
																,'Allow debt restructuring'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_debttoinstct
																,'DebtToInstCTINT'
																,'Installment contract type to be used'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_stmntfeecalctype
																,'StmntFeeCalcTypeINT'
																,'Statement fee calculation type'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,ccalctype_notcalc
																,NULL)
													 ,recschitem(cctp_stmntfeeprcnt
																,'StmntFeePrcntINT'
																,'Percentage from outstanding amount'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_supamnttoshieldbaseamount
																,'AddToShieldBaseAmountINT'
																,'Supplementary amount should be added to credit shield base'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,cshiedlsupplamnt_zero
																,NULL)
													 ,recschitem(cctp_monthlyfeeprof
																,'MonthlyFeeProfINT'
																,'Monthly fee profile identifier'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_priincrscrdlimbyallwovl
																,'PriIncrsCrdLimByAllwOvlINT'
																,'Increase primary card credit limit by allowable account overlimit'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_supincrscrdlimbyallwovl
																,'SupIncrsCrdLimByAllwOvlINT'
																,'Increase supplementary card credit limit by allowable account overlimit'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_priincrscashlimbyallwovl
																,'PriIncrsCashLimByAllwOvlINT'
																,'Increase primary card cash limit by allowable account overlimit'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_supincrscashlimbyallwovl
																,'SupIncrsCashLimByAllwOvlINT'
																,'Increase supplementary card cash limit by allowable account overlimit'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_accincrscashlimbyallwovl
																,'AccIncrsCashLimByAllwOvlINT'
																,'Increase account cash limit by allowable account overlimit'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,0
																,NULL)
													 ,recschitem(cctp_gst_profileid
																,'GSTProfileINT'
																,'Profile ID for GST accrual INT'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_lcf_acccredlmtprofileid
																,'LCF_AccCredLmtProfileINT'
																,'Account credit limit change fee profile'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL)
													 ,recschitem(cctp_lcf_acccredtemplmtprofileid
																,'LCF_AccCredTempLmtProfileINT'
																,'Account temporary credit limit change fee profile'
																,''
																,contracttools.ctype
																,contracttools.coptional
																,NULL
																,NULL
																,NULL));

	cb_incacc               CONSTANT PLS_INTEGER := 01;
	cb_incaccolf            CONSTANT PLS_INTEGER := 02;
	cb_incaccodf            CONSTANT PLS_INTEGER := 03;
	cb_techacc              CONSTANT PLS_INTEGER := 04;
	cb_shieldacc            CONSTANT PLS_INTEGER := 05;
	cb_stmtfeeacc           CONSTANT PLS_INTEGER := 06;
	cb_accumintacc          CONSTANT PLS_INTEGER := 07;
	cb_instonfeeacc         CONSTANT PLS_INTEGER := 08;
	cb_monthlyfeeacc        CONSTANT PLS_INTEGER := 09;
	cb_incaccoffbal         CONSTANT PLS_INTEGER := 10;
	cb_incaccodfoffbal      CONSTANT PLS_INTEGER := 11;
	cb_incacclimitchangefee CONSTANT PLS_INTEGER := 12;

	cab_identdom CONSTANT tblschitem := tblschitem(recschitem(cb_incacc
															 ,'IncomeAccDOM'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_incaccolf
															 ,'IncomeAccOLFDOM'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_incaccodf
															 ,'IncomeAccODFDOM'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_techacc
															 ,'TechnicalAccDOM'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_shieldacc
															 ,'ShieldAccDOM'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_stmtfeeacc
															 ,'StmtFeeAccDOM'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_accumintacc
															 ,'BankAccumIntAccDOM'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_instonfeeacc
															 ,'InstOnFeeAccDOM'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_monthlyfeeacc
															 ,'MonthlyFeeAccDOM'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_incaccoffbal
															 ,'IncomeAcc_OffBalDOM'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_incaccodfoffbal
															 ,'IncomeAccODF_OffBalDOM'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_incacclimitchangefee
															 ,'IncAccLimitChangeFeeDOM'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL));

	cab_identint CONSTANT tblschitem := tblschitem(recschitem(cb_incacc
															 ,'IncomeAccINT'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_incaccolf
															 ,'IncomeAccOLFINT'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_incaccodf
															 ,'IncomeAccODFINT'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_techacc
															 ,'TechnicalAccINT'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_shieldacc
															 ,'ShieldAccINT'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_stmtfeeacc
															 ,'StmtFeeAccINT'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_accumintacc
															 ,'BankAccumIntAccINT'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_instonfeeacc
															 ,'InstOnFeeAccINT'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_monthlyfeeacc
															 ,'MonthlyFeeAccINT'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_incaccoffbal
															 ,'IncomeAcc_OffBalINT'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_incaccodfoffbal
															 ,'IncomeAccODF_OffBalINT'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL)
												  ,recschitem(cb_incacclimitchangefee
															 ,'IncAccLimitChangeFeeINT'
															 ,''
															 ,''
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL
															 ,NULL));

	cshieldblockexample CONSTANT VARCHAR2(2000) := 'declare' || chr(10) ||
												   '  vIsPromoPeriod boolean:= Sch_Customer.PLSQL_IsPromoPeriod;' ||
												   chr(10) ||
												   '  vOverLimit     number:= Sch_Customer.PLSQL_GetOverlimit;' ||
												   chr(10) ||
												   '  vDiscount      number:= Sch_Customer.PLSQL_GetDiscountShieldValue;' ||
												   chr(10) ||
												   '  vBalance       number:= Sch_Customer.PLSQL_GetBalance;' ||
												   chr(10) ||
												   '  vShield        number:= Sch_Customer.PLSQL_GetShieldValue;' ||
												   chr(10) || 'begin' || chr(10) ||
												   '  if vIsPromoPeriod and (vOverLimit = 0) and (vDiscount < vShield) then' ||
												   chr(10) ||
												   '    Sch_Customer.PLSQL_SetDiscountShield(vShield);' ||
												   chr(10) || '    :Ret:= vShield;' || chr(10) ||
												   '  elsif vBalance > -100 then' || chr(10) ||
												   '    :Ret:= 0;' || chr(10) || '  else' ||
												   chr(10) || '    :Ret:= vShield;' || chr(10) ||
												   '  end if;' || chr(10) || 'end;';

	TYPE typestrarrarr IS TABLE OF types.arrstr1000 INDEX BY PLS_INTEGER;
	TYPE typeaccarrarr IS TABLE OF contracttools.typeaccarray INDEX BY PLS_INTEGER;

	sacparamccy   typestrarrarr;
	sacctparamccy typestrarrarr;
	sacparam      types.arrstr1000;
	sact_cparam   types.arrstr1000;
	sactparamccy  typestrarrarr;
	sactparam     types.arrstr1000;
	sabaccounts   typeaccarrarr;

	TYPE typescoreuserecord IS RECORD(
		 id           NUMBER
		,NAME         VARCHAR(50)
		,intervalname VARCHAR(50));

	TYPE typescoreusearray IS TABLE OF typescoreuserecord INDEX BY PLS_INTEGER;

	TYPE typeitemrecord IS RECORD(
		 dep NUMBER
		,ovd NUMBER
		,INT NUMBER);
	TYPE typeitemarray IS TABLE OF typeitemrecord INDEX BY PLS_INTEGER;

	TYPE typedelstatusarray IS TABLE OF typedelstatusrecord INDEX BY PLS_INTEGER;

	TYPE typelimitrecord IS RECORD(
		 cur1overlimit        NUMBER
		,cur2overlimit        NUMBER
		,cur1aggroverlimit    NUMBER
		,cur1allowedoverlimit NUMBER);
	TYPE typelimitarray IS TABLE OF typelimitrecord INDEX BY PLS_INTEGER;

	TYPE typedcstaterecord IS RECORD(
		 overlimit BOOLEAN
		,overdue   BOOLEAN);
	TYPE typedcstatearray IS TABLE OF typedcstaterecord INDEX BY PLS_INTEGER;

	TYPE typedelparamrecord IS RECORD(
		 overdueint NUMBER
		,limitint   NUMBER);

	TYPE typeamnthistoryrecord IS RECORD(
		 operdate DATE
		,amount   NUMBER
		,balance  NUMBER);
	TYPE typeamnthistoryarray IS TABLE OF typeamnthistoryrecord INDEX BY PLS_INTEGER;

	TYPE typecardlimitvaluearray IS TABLE OF typelimitvaluerecord INDEX BY VARCHAR2(25);

	sautounstick       BOOLEAN;
	scrdstsautounstick BOOLEAN;
	spaidtoinst        BOOLEAN;
	sdontcheckdata     BOOLEAN;
	susereversalent    BOOLEAN;
	supdatesd          BOOLEAN;

	saccumintaccmode NUMBER;

	scloserepaymententry typeentryident;
	sclosepayoutentry    typeentryident;
	sclosecardsmode      NUMBER;

	ssubstacconextract BOOLEAN;

	sfillalwdovlattr BOOLEAN;
	salwdovlattrname VARCHAR2(64);

	sposbalanceblacklist NUMBER;

	cintaccmode_donotaccumulate CONSTANT PLS_INTEGER := 0;
	cintaccmode_bankincomeacc   CONSTANT PLS_INTEGER := 1;
	cintaccmode_intaccbalance   CONSTANT PLS_INTEGER := 2;

	cintaccmode_intacctechnical CONSTANT PLS_INTEGER := 3;

	scontractddrecord typecontractcyclerecord;
	scontractno       typecontractno;
	scontractstat     VARCHAR2(10);
	sscoreprocid      NUMBER;
	scurrencynumber   NUMBER;
	sscoreid          NUMBER;
	sscoremin         NUMBER;
	sscoremax         NUMBER;
	sscorerange       NUMBER;
	sprecision        types.arrnum;
	sentriescount     types.arrnum;

	slinkschemas      contractlink.typevarchar40;
	slinkschemasinst  contractlink.typevarchar40;
	slabel            types.arrstr20;
	sfulllabel        types.arrstr40;
	sscoreproc        typescoreusearray;
	sopercode         NUMBER;
	sentryno          NUMBER;
	sdocno            NUMBER;
	snowstatementdate BOOLEAN;
	snowduedate       BOOLEAN;

	scycleinfoloaded BOOLEAN := FALSE;
	scurrentcycle    typebillingcycle;
	spreviouscycle   typebillingcycle;
	scurrentmp       types.arrnum;
	snextduedate     DATE;

	sminpaymentod           types.arrnum;
	sminpaymentdd           types.arrnum;
	ssdbalancedd            types.arrnum;
	ssdbalanceod            types.arrnum;
	sstatementpackno        NUMBER;
	sstatstartdate          DATE;
	spacket                 statementmanualrt.tmanuallogrec;
	spackno                 NUMBER;
	shistpackno             NUMBER;
	slimitpackno            NUMBER;
	schangedtrxns           typearrboolbystr;
	snotusedlimit           types.arrnum;
	sacctocloseontypechange typeaccountno;

	scardlist1  apitypes.typeaccount2cardlist;
	scardlist2  apitypes.typeaccount2cardlist;
	scardcount1 NUMBER;
	scardcount2 NUMBER;

	sprcchargedom      typeprcchargearray;
	sprcchargeint      typeprcchargearray;
	sdcstate           typedcstatearray;
	sdcoverduedate     DATE;
	sdcoverlimitdate   DATE;
	sdcoverlimitdates  types.arrdate;
	sdcoverdueamount   types.arrnum;
	sdcoverlimitamount types.arrnum;
	slimittype         NUMBER;
	sprofile           custom_contractprofiles.typeprofilparamarray;
	sprofileid         types.arrnum;
	smainprofile       types.arrnum;
	sprofilerates      custom_contractprofiles.typegrouprates;
	smpprofile         custom_contractprofiles.typeprofilparamarray;
	smpprofileid       types.arrnum;
	smpaltprofile      types.arrnum;
	smpmainprofile     types.arrnum;
	smpgroupsettings   custom_contractprofiles.typempgroupparamarrarr;
	sdelparam          typedelparamrecord;
	sordergroup        custom_contractprofiles.typenumbernumber;
	sopergroup         custom_contractprofiles.typeprofilgroupparamarray;
	sopergroupredrates custom_contractprofiles.typereducedratesprofarr;
	sdelstatus         typedelstatusarray;
	sodparams          contractdcsetup.typeparamarray;
	solparams          contractdcsetup.typeparamarray;
	schargefromparam   contractdcsetup.typechargefromparamarray;
	schargeparam       contractdcsetup.typechargeparamrecord;
	sdcparam           contractdcsetup.typectsettingsrecord;
	sodparamsdom       contractdcsetup.typeparamarray;
	solparamsdom       contractdcsetup.typeparamarray;
	sdcparamdom        contractdcsetup.typectsettingsrecord;
	sodparamsint       contractdcsetup.typeparamarray;
	solparamsint       contractdcsetup.typeparamarray;
	sdcparamint        contractdcsetup.typectsettingsrecord;
	spaidhistarray     typepaidhistcurrarray;

	sdeldate    types.arrdate;
	slastdocno  types.arrnum;
	sblockparam typedelstatusrecord;

	sitem       typeitemarray;
	sdepaccount contracttools.typeaccarray;
	sovdaccount contracttools.typeaccarray;
	sintaccount contracttools.typeaccarray;

	saccountforentry contracttools.taccountrecord;

	sdelfeeonentcode  NUMBER;
	sovdfeeonentcode  NUMBER;
	ssrvfeeonentcode  NUMBER;
	scrdshieldentcode NUMBER;

	sprconentcode tblnumber := tblnumber();

	saggrdep1 types.arrnum;
	saggrdep2 types.arrnum;

	scurright_contype   PLS_INTEGER;
	scurright_reference PLS_INTEGER;

	splsql_shieldvalue         NUMBER;
	splsql_discountshieldvalue NUMBER;
	splsql_depaccountbalance   NUMBER;
	splsql_overlimit           NUMBER;
	splsql_minpaymentod        NUMBER;
	splsql_minpaymentdd        NUMBER;
	splsql_sdbalanceod         NUMBER;
	splsql_sdbalancedd         NUMBER;
	splsql_ispromoperiod       BOOLEAN;
	splsql_delinqstateid       contractstatereference.typestateid;

	scorpcontractnumber typecontractno;
	scorpnumberloaded   BOOLEAN;
	smulticurrency      BOOLEAN;
	smulticurrencyrate  types.arrnum;
	sinttoinston        types.arrbool;

	scollectionavailable    BOOLEAN;
	sdebtcollectoravailable BOOLEAN;

	sacloseinfo typecloseinfoarray;

	TYPE typeentryaggregatesrecord IS RECORD(
		 incomebalance  NUMBER
		,outcomebalance NUMBER
		,debitturnover  NUMBER
		,creditturnover NUMBER);

	ssavedinterestcalclog typeparsedinterestlog_tab;

	TYPE typeoverdueparametersarray IS TABLE OF custom_overdueparameterscalculation.typeoverdueparamsrecord INDEX BY PLS_INTEGER;
	soverdueparametersarray typeoverdueparametersarray;

	scontrattrcache    typecontrcacheattr;
	scontrattrcalcflag typecontrgrattrcalcflagbycache;

	vdummypha typepaidhistarray;
	sdummynum NUMBER;

	TYPE typedelinqprofilearray IS TABLE OF tcontractdelinqprofiles%ROWTYPE INDEX BY PLS_INTEGER;
	TYPE typedelinqprofilearrbycurr IS TABLE OF typedelinqprofilearray INDEX BY PLS_INTEGER;

	TYPE typecontrtypeparams_cache_rec IS RECORD(
		 usedcurrency           types.arrbool
		,delinqprofiles         typedelinqprofilearrbycurr
		,defaultriskgroup       NUMBER
		,readsetupscheme_called BOOLEAN := FALSE);
	TYPE typecontrtypeparams_cache_arr IS TABLE OF typecontrtypeparams_cache_rec INDEX BY PLS_INTEGER;
	scontrtype_cache typecontrtypeparams_cache_arr;

	TYPE typecardinfo IS RECORD(
		 pan           typepan
		,mbr           typembr
		,infosaved     BOOLEAN
		,currstate     typecardstate
		,currstatus    typecardstatus
		,lockstate     typecardstate
		,lockstatus    typecardstatus
		,cardchanged   BOOLEAN
		,setmode       CHAR
		,sticktype     CHAR
		,autounstick   CHAR
		,stateofsticky contractstatereference.typestateid);

	FUNCTION gettypelimitperiod
	(
		plimitkind IN NUMBER
	   ,pcurno     IN NUMBER
	   ,ppan       IN typepan := NULL
	   ,pmbr       IN typembr := NULL
	) RETURN NUMBER;

	FUNCTION getlimittype_int(pcontractno IN typecontractno) RETURN PLS_INTEGER;

	FUNCTION getcurrency
	(
		pcontracttype IN NUMBER
	   ,pitemname     IN VARCHAR
	) RETURN NUMBER;

	PROCEDURE getoverdueinfo
	(
		paccountno     IN VARCHAR2
	   ,pcurnumber     IN NUMBER
	   ,pdate          IN DATE
	   ,ooverduedate   OUT DATE
	   ,ooverdueamount OUT NUMBER
	);

	PROCEDURE getdelparameters(pdate IN DATE := NULL);

	PROCEDURE rollbacktrxnlist(ppackno IN NUMBER);

	FUNCTION getamnthistory
	(
		pcurno   IN NUMBER
	   ,penddate DATE := NULL
	) RETURN typeamnthistoryarray;

	PROCEDURE processinstallmenttrxns
	(
		pcurno             IN NUMBER
	   ,pinstcontractno    IN typecontractno
	   ,ploanno            IN NUMBER
	   ,poinstaccount      IN OUT NOCOPY contracttools.taccountrecord
	   ,pamount            IN NUMBER
	   ,poatrxnstotransfer IN OUT typetrxnarray
	   ,pchargecommisson   IN BOOLEAN
	   ,pskiploancheck     IN BOOLEAN
	);

	FUNCTION getinstallmentaccount(pcontractno IN typecontractno) RETURN typeaccountno;

	FUNCTION cardchangeallowed
	(
		pcardrecord IN apitypes.typecardrecord
	   ,poperation  IN PLS_INTEGER
	) RETURN BOOLEAN;

	FUNCTION reissuesignchangeallowed
	(
		pcardrecord     IN apitypes.typecardrecord
	   ,pnewreissuesign IN typereissuesign
	) RETURN BOOLEAN;

	PROCEDURE updatecardsattributes
	(
		pcardrecord     IN apitypes.typecardrecord
	   ,pnewstate       IN typecardstate
	   ,pnewstatus      IN typecardstatus
	   ,pnewreissuesign IN typereissuesign
	   ,pcomment        IN VARCHAR2
	);

	PROCEDURE savecardinfo
	(
		pcardinfo   IN typecardinfo
	   ,pdorollback IN BOOLEAN
	);

	FUNCTION calccontractforclose(psaveinterestcalclog BOOLEAN := FALSE) RETURN typecloseinfoarray;

	FUNCTION getobjectlimitssetup
	(
		pcontractno IN typecontractno
	   ,pcurno      IN NUMBER
	   ,ppan        IN typepan := NULL
	   ,pmbr        IN typembr := NULL
	) RETURN typeobjectlimitsettings;

	PROCEDURE dotransactionsrepayment
	(
		pcurno         IN NUMBER
	   ,pmigrationmode IN BOOLEAN := FALSE
	);

	PROCEDURE setoperationrollbackdata
	(
		pcyclerecno IN NUMBER := NULL
	   ,padddocno   IN BOOLEAN := TRUE
	);

	PROCEDURE chooseprofiles(pcurno IN NUMBER);

	PROCEDURE makecheckbox
	(
		pdialog      IN NUMBER
	   ,pitemname    IN typeitemname
	   ,px           IN NUMBER
	   ,py           IN NUMBER
	   ,pcaption     IN VARCHAR2
	   ,phint        IN VARCHAR2
	   ,phandlername IN typemethodname := NULL
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.MakeCheckBox';
	BEGIN
		dialog.inputcheck(pdialog, pitemname, px, py, length(pcaption) + 2, phint, pcaption);
		contractparams.loaddialogbool(pdialog
									 ,pitemname
									 ,contractparams.ccontracttype
									 ,scontracttype);
		IF phandlername IS NOT NULL
		THEN
			dialog.setitempre(pdialog, pitemname, phandlername);
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END makecheckbox;

	PROCEDURE nullifyparams
	(
		paparamslist   IN tblchar100
	   ,pobjecttype    IN NUMBER
	   ,pobjectno      IN VARCHAR
	   ,ppostfix       IN VARCHAR2
	   ,pwritelog      IN BOOLEAN := FALSE
	   ,psaveinhistory IN BOOLEAN := FALSE
	   ,pmaskmode      IN NUMBER := NULL
	   ,powner         IN a4mlog.typeclientid := NULL
	   ,pstartdate     IN DATE := NULL
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.NullifyParams';
	BEGIN
		FOR i IN 1 .. paparamslist.count
		LOOP
			contractparams.savechar(pobjecttype
								   ,pobjectno
								   ,paparamslist(i) || ppostfix
								   ,NULL
								   ,pwritelog
								   ,psaveinhistory => psaveinhistory
								   ,pmaskmode => pmaskmode
								   ,powner => powner
								   ,pstartdate => pstartdate);
		END LOOP;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END nullifyparams;

	FUNCTION gettrxntypedescription(ptrantype IN NUMBER) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetTrxnTypeDescription';
		vresult VARCHAR2(100);
	BEGIN
		t.enter(cmethodname, ptrantype);
	
		IF catrxntypeprefixes.exists(ptrantype)
		THEN
			vresult := catrxntypeprefixes(ptrantype);
		ELSE
			vresult := 'Unknown transaction type <' || ptrantype || '>';
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END gettrxntypedescription;

	PROCEDURE startnewdocument IS
	BEGIN
		sdocno   := NULL;
		sentryno := 0;
	END startnewdocument;

	PROCEDURE setdocument
	(
		pdocno   IN typedocno
	   ,pentryno IN typeentryno := NULL
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SetDocument';
	BEGIN
		t.enter(cmethodname, pdocno);
	
		contracttools.raiseif((pdocno IS NULL) AND (nvl(pentryno, 0) <> 0)
							 ,'Incorrect document and entry number combination: ' || pdocno || '/' ||
							  pentryno);
	
		sdocno   := pdocno;
		sentryno := coalesce(pentryno, findocument.getlastentryno(pdocno));
	
		t.leave(cmethodname, sentryno);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END setdocument;

	PROCEDURE getdocument
	(
		odocno   OUT typedocno
	   ,oentryno OUT typeentryno
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetDocument';
	BEGIN
		odocno   := sdocno;
		oentryno := sentryno;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getdocument;

	PROCEDURE clearcontrtypecache IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ClearContrTypeCache';
	BEGIN
		scontrtype_cache.delete;
		s.say(cmethodname || '     -info: Contract type cache (sContrType_Cache) has been purged');
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END clearcontrtypecache;

	FUNCTION ifcurrencyisusedintype
	(
		pcurno        IN NUMBER
	   ,pcontracttype IN typecontracttype := NULL
	   ,pcontractno   IN typecontractno := NULL
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.IfCurrencyIsUsedInType';
		vcontracttype typecontracttype;
		vresult       BOOLEAN;
	BEGIN
		t.enter(cmethodname
			   ,'pCurNo = ' || pcurno || ', pContractType = ' || pcontracttype ||
				', pContractNo = ' || pcontractno);
	
		IF pcontracttype IS NOT NULL
		THEN
			vcontracttype := pcontracttype;
		ELSIF pcontractno IS NOT NULL
		THEN
			vcontracttype := contract.gettype(pcontractno);
		ELSE
			error.raiseerror('Internal error: pContractType and pContractNo can not be NULL simultaneously');
		END IF;
	
		t.var('Selected ContractType', vcontracttype);
	
		IF scontrtype_cache.exists(vcontracttype)
		   AND scontrtype_cache(vcontracttype).usedcurrency.exists(1)
		THEN
			s.say(cmethodname || '     - info: data are going to be taken from CACHE');
		ELSE
			s.say(cmethodname ||
				  '     - info: data in cache has not existed. Data are going to be read from DISC');
			scontrtype_cache(vcontracttype).usedcurrency(1) := nvl(contractparams.loadbool(contractparams.ccontracttype
																						  ,vcontracttype
																						  ,'UseCurDOM'
																						  ,FALSE)
																  ,FALSE);
			scontrtype_cache(vcontracttype).usedcurrency(2) := nvl(contractparams.loadbool(contractparams.ccontracttype
																						  ,vcontracttype
																						  ,'UseCurINT'
																						  ,FALSE)
																  ,FALSE);
		END IF;
	
		vresult := scontrtype_cache(vcontracttype).usedcurrency(pcurno);
	
		t.leave(cmethodname, htools.b2s(vresult));
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END ifcurrencyisusedintype;

	PROCEDURE getcontractobjects(ocontractobjects OUT NOCOPY typecontractobjects) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetContractObjects';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	BEGIN
		t.enter(cmethodname);
	
		SELECT sq.branch
			  ,sq.contractno
			  ,sq.accountno
			  ,sq.currencynumber
			  ,clp.pan
			  ,clp.mbr
			  ,nvl(clp.usedcredlimit, 0) usedcredlimit
			  ,nvl(clp.usedcashlimit, 0) usedcashlimit BULK COLLECT
		INTO   ocontractobjects
		FROM   (SELECT ci.branch
					  ,ci.no contractno
					  ,ci.key accountno
					  ,CASE ctin.itemname
						   WHEN 'ITEMDEPOSITDOM' THEN
							1
						   ELSE
							2
					   END currencynumber
				FROM   tcontractitem         ci
					  ,tcontracttypeitemname ctin
					  ,taccount              a
				WHERE  ci.branch = cbranch
				AND    ci.no = scontractno
				AND    ctin.branch = ci.branch
				AND    ctin.itemcode = ci.itemcode
				AND    ctin.itemname IN ('ITEMDEPOSITDOM', 'ITEMDEPOSITINT')
				AND    a.branch = ctin.branch
				AND    a.accountno = ci.key
				AND    a.closedate IS NULL) sq
			  ,tcontractlimitparams clp
		WHERE  clp.branch(+) = sq.branch
		AND    clp.contractno(+) = sq.contractno
		AND    clp.currencynumber(+) = sq.currencynumber
		AND    clp.pan(+) IS NULL
		AND    clp.mbr(+) IS NULL
		
		UNION ALL
		
		SELECT sq.branch
			  ,sq.contractno
			  ,sq.accountno
			  ,sq.currencynumber
			  ,sq.pan
			  ,sq.mbr
			  ,nvl(clp.usedcredlimit, 0) usedcredlimit
			  ,nvl(clp.usedcashlimit, 0) usedcashlimit
		FROM   (SELECT ci.branch
					  ,ci.no contractno
					  ,ci.key accountno
					  ,CASE ctin.itemname
						   WHEN 'ITEMDEPOSITDOM' THEN
							1
						   ELSE
							2
					   END currencynumber
					  ,cicard.pan
					  ,cicard.mbr
				FROM   tcontractitem         ci
					  ,tcontracttypeitemname ctin
					  ,tcontractcarditem     cicard
				WHERE  ci.branch = cbranch
				AND    ci.no = scontractno
				AND    ctin.branch = ci.branch
				AND    ctin.itemcode = ci.itemcode
				AND    ctin.itemname IN ('ITEMDEPOSITDOM', 'ITEMDEPOSITINT')
				AND    cicard.branch = ci.branch
				AND    cicard.no = ci.no) sq
			  ,tcontractlimitparams clp
		WHERE  clp.branch(+) = sq.branch
		AND    clp.contractno(+) = sq.contractno
		AND    clp.currencynumber(+) = sq.currencynumber
		AND    clp.pan(+) = sq.pan
		AND    clp.mbr(+) = sq.mbr
		
		ORDER  BY currencynumber
				 ,pan
				 ,mbr;
	
		t.leave(cmethodname, ocontractobjects.count);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getcontractobjects;

	FUNCTION getrate
	(
		pcurrency1 IN NUMBER
	   ,pcurrency2 IN NUMBER
	   ,pdate      IN DATE
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetRate';
		vexchangerate NUMBER;
		vresult       NUMBER;
	BEGIN
		t.enter(cmethodname, pdate);
	
		vexchangerate := coalesce(sactparam(cctp_exchangerate), exchangerate.getdefaultexchange);
	
		vresult := exchangerate.getrate(vexchangerate, pcurrency1, pcurrency2, pdate);
	
		IF vresult IS NULL
		THEN
			error.raiseerror('Exchange rate ' || pcurrency1 || ' <-> ' || pcurrency2 ||
							 ' is not defined in rate with exchange ID = ' || vexchangerate ||
							 ' on date ' || htools.d2s(pdate) || '!');
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getrate;

	FUNCTION debtcollectoravailable RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.DebtCollectorAvailable';
	BEGIN
		t.enter(cmethodname);
	
		IF sdebtcollectoravailable IS NULL
		THEN
		
			sdebtcollectoravailable := exchange.getmoduletypebysysname('ANAL') IS NOT NULL;
		
			IF NOT sdebtcollectoravailable
			THEN
				err.seterror(0, cmethodname);
			END IF;
		
		END IF;
	
		t.leave(cmethodname, htools.b2s(sdebtcollectoravailable));
		RETURN sdebtcollectoravailable;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END debtcollectoravailable;

	FUNCTION loadparam
	(
		pctype       typecontracttype
	   ,paitem       tblschitem
	   ,pdoexception BOOLEAN := TRUE
	) RETURN types.arrstr1000 IS
		cmethod_name CONSTANT VARCHAR2(80) := cpackagename || '.LoadParam[ctype]';
		cbranch      CONSTANT NUMBER := seance.getbranch;
		verrmsg VARCHAR2(4000) := NULL;
		varet   types.arrstr1000;
	BEGIN
		s.say(cmethod_name || ': BEGIN for type ' || pctype);
		SELECT /*+ ORDERED USE_NL (p) INDEX (p pk_CTypeParameters)*/
		 nvl(p.value, d.attr4) BULK COLLECT
		INTO   varet
		FROM   TABLE(paitem) d
		LEFT   OUTER JOIN tcontracttypeparameters p
		ON     p.branch = cbranch
		AND    p.contracttype = pctype
		AND    p.key = upper(d.name)
		ORDER  BY d.idx;
	
		s.say(cmethod_name || '     LOADED TYPE PARAMETERS:');
		FOR nn IN 1 .. paitem.count
		LOOP
			s.say(cmethod_name || '       name ( paItem(' || nn || ').name ) = ' || paitem(nn).name ||
				  ', value ( vaRet(' || nn || ') )= ' || varet(nn));
		END LOOP;
		s.say(cmethod_name || ': END for type ' || pctype);
	
		IF pdoexception
		THEN
			FOR i IN 1 .. paitem.count
			LOOP
			
				IF (paitem(i).attr1 IN (contracttools.ctype, contracttools.cboth))
				   AND (paitem(i).attr2 = contracttools.cmandatory)
				   AND (varet(i) IS NULL)
				THEN
					verrmsg := verrmsg || ', ' || paitem(i).spec || ', paItem (' || i || ') = ' || paitem(i).name;
				END IF;
			END LOOP;
		
			IF verrmsg IS NOT NULL
			THEN
				error.raiseerror('Contract type <' || pctype ||
								 '>:  following parameters are not defined:' || substr(verrmsg, 2));
			END IF;
		END IF;
	
		RETURN varet;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethod_name);
			RAISE;
	END loadparam;

	PROCEDURE loadparam
	(
		pcno         typecontractno
	   ,paitem       tblschitem
	   ,pactparam    types.arrstr1000
	   ,oacparam     IN OUT NOCOPY types.arrstr1000
	   ,pdoexception BOOLEAN := TRUE
	) IS
		cmethod_name CONSTANT VARCHAR2(80) := cpackagename || '.LoadParam[contract]';
		cbranch      CONSTANT NUMBER := seance.getbranch;
		verrmsg VARCHAR2(4000) := NULL;
	BEGIN
		s.say(cmethod_name || ': BEGIN for contract ' || pcno);
	
		SELECT /*+ ORDERED USE_NL (p) INDEX (p pk_CNoParameters) */
		 nvl(p.value, d.attr3) BULK COLLECT
		INTO   oacparam
		FROM   TABLE(paitem) d
		LEFT   OUTER JOIN tcontractparameters p
		ON     p.branch = cbranch
		AND    p.contractno = pcno
		AND    p.key = upper(d.name)
		ORDER  BY d.idx;
	
		FOR i IN 1 .. oacparam.count
		LOOP
			IF (oacparam(i) IS NULL OR
			   (paitem(i).attr5 IS NOT NULL AND oacparam(i) = paitem(i).attr5))
			   AND pactparam.exists(i)
			THEN
				oacparam(i) := pactparam(i);
			END IF;
		END LOOP;
	
		s.say(cmethod_name || '     LOADED CONTRACT PARAMETERS:');
		FOR nn IN 1 .. paitem.count
		LOOP
			s.say(cmethod_name || '       name ( paItem(' || nn || ').name ) = ' || paitem(nn).name ||
				  ', value ( oaCParam(' || nn || ') )= ' || oacparam(nn));
		END LOOP;
	
		IF pdoexception
		THEN
			FOR i IN 1 .. paitem.count
			LOOP
			
				IF (paitem(i).attr1 IN (contracttools.ccont))
				   AND (paitem(i).attr2 = contracttools.cmandatory)
				   AND (oacparam(i) IS NULL)
				THEN
					verrmsg := verrmsg || ', ' || paitem(i).spec;
				END IF;
			END LOOP;
			IF verrmsg IS NOT NULL
			THEN
				error.raiseerror('Contract <' || pcno ||
								 '>: following parameters are not defined:' || substr(verrmsg, 2));
			END IF;
		END IF;
		s.say(cmethod_name || ': END for contract ' || pcno);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethod_name);
			RAISE;
	END loadparam;

	PROCEDURE fillmpprofilesettings(pmpprofileid IN tcontractmpprofile.profileid%TYPE) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.FillMPProfileSettings';
	BEGIN
		IF NOT smpprofile.exists(pmpprofileid)
		THEN
			smpprofile(pmpprofileid)(custom_contractprofiles.cp_mpp_base) := 2;
			custom_contractprofiles.getmpprofile(pmpprofileid, smpprofile(pmpprofileid));
			IF smpprofile(pmpprofileid)
			 (custom_contractprofiles.cp_mpp_base) = custom_contractprofiles.cmpbasegroup
			THEN
				smpgroupsettings(pmpprofileid)(0).prcvalue := 0;
				custom_contractprofiles.getmpgroupsettings(pmpprofileid
														  ,smpgroupsettings(pmpprofileid));
			END IF;
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END fillmpprofilesettings;

	PROCEDURE fillinterestprofsettings(pintprofileid IN tcontractprofile.profileid%TYPE) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.FillInterestProfSettings';
	BEGIN
		t.enter(cmethodname, pintprofileid);
	
		IF NOT sprofile.exists(pintprofileid)
		THEN
			sprofile(pintprofileid)(custom_contractprofiles.cp_profileid) := pintprofileid;
			sopergroup(pintprofileid)(0)(custom_contractprofiles.cpg_chargeint) := 0;
			sprofilerates(pintprofileid)(0)(custom_contractprofiles.cr_ovrprchist) := NULL;
			sopergroupredrates(pintprofileid)(0)(1).rateid := NULL;
		
			custom_contractprofiles.getprofile(pintprofileid
											  ,sprofile(pintprofileid)
											  ,sopergroup(pintprofileid)
											  ,sprofilerates(pintprofileid)
											  ,sopergroupredrates(pintprofileid));
		END IF;
	
		IF NOT sordergroup.exists(pintprofileid)
		THEN
			sordergroup(pintprofileid)(0) := NULL;
			custom_contractprofiles.fillgrouparray(pintprofileid, sordergroup(pintprofileid));
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END fillinterestprofsettings;

	PROCEDURE filldcarrays IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.FillDCArrays';
	BEGIN
		s.say(cmethodname || ' -> Start');
		sodparams.delete;
		solparams.delete;
		schargefromparam.delete;
	
		sodparams(1).paramcode := 'OVERDUE_AMOUNT';
		sodparams(1).paramname := 'Overdue amount';
		sodparams(1).paramtype := 2;
		sodparams(1).parammin := 0;
		sodparams(1).parammax := NULL;
	
		sodparams(2).paramcode := 'OVERDUE_PERIOD';
		sodparams(2).paramname := 'Overdue period (days)';
		sodparams(2).paramtype := 1;
		sodparams(2).parammin := 0;
		sodparams(2).parammax := NULL;
	
		solparams(1).paramcode := 'OVERLIMIT_AMOUNT';
		solparams(1).paramname := 'Over-limit amount';
		solparams(1).paramtype := 2;
		solparams(1).parammin := 0;
		solparams(1).parammax := NULL;
	
		solparams(2).paramcode := 'OVERLIMIT_RATE';
		solparams(2).paramname := 'Over-limit rate (%)';
		solparams(2).paramtype := 2;
		solparams(2).parammin := 0;
		solparams(2).parammax := NULL;
	
		solparams(3).paramcode := 'OVERLIMIT_PERIOD';
		solparams(3).paramname := 'Over-limit period (days)';
		solparams(3).paramtype := 1;
		solparams(3).parammin := 0;
		solparams(3).parammax := NULL;
	
		schargefromparam(1).itemid := 1;
		schargefromparam(1).itemname := 'Card Account in Domestic Currency';
		schargefromparam(2).itemid := 2;
		schargefromparam(2).itemname := 'Card Account in International Currency';
		schargefromparam(3).itemid := 3;
		schargefromparam(3).itemname := 'Card Account in Fee Currency';
		s.say(cmethodname || ' -> End');
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	PROCEDURE readsetupscheme(ploadprofiles IN BOOLEAN := TRUE) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.ReadSetupScheme';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vprfcount  NUMBER := 0;
		vtypearray contractlink.typenumber;
		vindex     NUMBER := 0;
	
		CURSOR curdelinqset IS
			SELECT v.*
				  ,rownum rnum
			FROM   vtypedelinqsettings_bytype v
			WHERE  branch = cbranch
			AND    contracttype = scontracttype
			ORDER  BY period    DESC
					 ,overlimit DESC;
	
	BEGIN
		t.enter(cmethodname);
	
		s.say(cmethodname || ' -> OperDate=' || seance.getoperdate);
		filldcarrays;
		FOR i IN 1 .. 2
		LOOP
			sprecision(i) := NULL;
			sitem(i).dep := contracttypeitems.getitemcode(scontracttype, 'ItemDeposit' || slabel(i));
			sitem(i).ovd := contracttypeitems.getitemcode(scontracttype
														 ,'ItemOverdraft' || slabel(i));
			IF saccumintaccmode <> cintaccmode_donotaccumulate
			THEN
				sitem(i).int := contracttypeitems.getitemcode(scontracttype
															 ,'ItemInterest' || slabel(i));
			END IF;
		END LOOP;
	
		sactparam   := loadparam(scontracttype, cactp_ident);
		sact_cparam := loadparam(scontracttype, cacp_ident, FALSE);
		IF sactparam(cctp_stmtmode) IN (2, 3, 4)
		   AND sactparam(cctp_stmttrns) = 0
		THEN
			RAISE excothererror;
		END IF;
		IF sactparam(cctp_corpmode) = '1'
		THEN
			IF contractlink.getlinktypes(scontracttype, contractlink.clink, vtypearray) <> 1
			THEN
				RAISE contractparams.accountnotexists;
			END IF;
			sactparam(cctp_calendarid) := contractparams.loadnumber(contractparams.ccontracttype
																   ,vtypearray(1)
																   ,'CalendarId');
		END IF;
	
		FOR i IN 1 .. 2
		LOOP
			smainprofile(i) := NULL;
			IF ifcurrencyisusedintype(i, scontracttype)
			THEN
				vprfcount := vprfcount + 1;
				smainprofile(i) := contractparams.loadnumber(contractparams.ccontracttype
															,scontracttype
															,'Profile' || slabel(i));
				fillinterestprofsettings(smainprofile(i));
			
				IF debtcollectoravailable
				THEN
					contractdcsetup.loadchargectvalues('DC_Charge', scontracttype, schargeparam);
					contractdcsetup.loadctvalues('DC_' || slabel(i)
												,scontracttype
												,sdcparam
												,sodparams
												,solparams);
					IF i = 1
					THEN
						sodparamsdom := sodparams;
						solparamsdom := solparams;
						sdcparamdom  := sdcparam;
					ELSE
						sodparamsint := sodparams;
						solparamsint := solparams;
						sdcparamint  := sdcparam;
					END IF;
				END IF;
			
				IF NOT sordergroup.exists(smainprofile(i))
				THEN
					sordergroup(smainprofile(i))(0) := NULL;
					custom_contractprofiles.fillgrouparray(smainprofile(i)
														  ,sordergroup(smainprofile(i)));
				END IF;
				IF sordergroup(smainprofile(i)).count = 0
				THEN
					RAISE contractparams.incorrectvalue;
				END IF;
			END IF;
		END LOOP;
	
		FOR i IN 1 .. 2
		LOOP
			smpaltprofile(i) := 0;
			smpmainprofile(i) := NULL;
			IF (nvl(ploadprofiles, FALSE) OR contractcalendar.issdinsomecalendar)
			   AND ifcurrencyisusedintype(i, scontracttype)
			THEN
				s.say(cmethodname || ': call custom_contractprofiles.GetMPProfile');
				smpmainprofile(i) := contractparams.loadnumber(contractparams.ccontracttype
															  ,scontracttype
															  ,'MPProfile' || slabel(i));
				fillmpprofilesettings(smpmainprofile(i));
			END IF;
		END LOOP;
	
		FOR i IN 1 .. 2
		LOOP
			IF ifcurrencyisusedintype(i, scontracttype)
			THEN
				IF i = 1
				THEN
					sactparamccy(i) := loadparam(scontracttype, cactp_dom_ident);
					sacctparamccy(i) := loadparam(scontracttype, cacontrpdom_ident, FALSE);
					sabaccounts(i) := contracttools.loadbaccounts(scontracttype
																 ,cab_identdom
																 ,FALSE);
				ELSE
					sactparamccy(i) := loadparam(scontracttype, cactp_int_ident);
					sacctparamccy(i) := loadparam(scontracttype, cacontrpint_ident, FALSE);
					sabaccounts(i) := contracttools.loadbaccounts(scontracttype
																 ,cab_identint
																 ,FALSE);
				END IF;
			END IF;
		END LOOP;
	
		IF (vprfcount = 0)
		   AND (nvl(ploadprofiles, FALSE) OR contractcalendar.isddinsomecalendar OR
		   contractcalendar.issdinsomecalendar)
		THEN
			RAISE contractparams.incorrectvalue;
		END IF;
		sdelstatus.delete;
		sdelparam.overdueint := sactparam(cctp_periodtype);
		sdelparam.limitint   := sactparam(cctp_overlimittype);
	
		s.say(cmethodname || '             - info: DELINQUENCY GROUP CACHE IS GOING TO BE FILLED ');
		FOR cc IN curdelinqset
		LOOP
			vindex := cc.rnum;
			s.say(cmethodname || '               Delinquency group index (vIndex) = ' || vindex ||
				  ', Ovd. period = ' || cc.period || ', Overlimit = ' || cc.overlimit ||
				  ', OverdueAmount_Threshold = ' || cc.overdueamount_threshold);
			sdelstatus(vindex).period := cc.period;
			sdelstatus(vindex).overdueamount_threshold := cc.overdueamount_threshold;
			sdelstatus(vindex).overlimit := cc.overlimit;
			sdelstatus(vindex).stateid := cc.stateid;
			sdelstatus(vindex).state := contractstatereference.getstate(cc.stateid);
			sdelstatus(vindex).profileiddom := cc.profileid_dom;
			sdelstatus(vindex).mpprofileiddom := cc.mp_profileid_dom;
			sdelstatus(vindex).profileidint := cc.profileid_int;
			sdelstatus(vindex).mpprofileidint := cc.mp_profileid_int;
		
			IF nvl(cc.period, -0.75) = -0.75
			   AND nvl(cc.overlimit, -0.75) = -0.75
			THEN
				scontrtype_cache(scontracttype).defaultriskgroup := vindex;
			END IF;
		
		END LOOP;
		s.say(cmethodname ||
			  '             Default group index (sContrType_Cache(sContractType).DefaultRiskGroup) = ' || scontrtype_cache(scontracttype)
			  .defaultriskgroup);
	
		contracttools.readentcode(sdelfeeonentcode, 'OVERDUE_FEE_ON');
		contracttools.readentcode(sovdfeeonentcode, 'OVERLIMIT_FEE_ON');
		contracttools.readentcode(ssrvfeeonentcode, 'MONTHLY_FEE_ON');
		contracttools.readentcode(scrdshieldentcode, 'CREDIT_SHIELD_PREMIUM');
	
		SELECT code BULK COLLECT
		INTO   sprconentcode
		FROM   treferenceentry
		WHERE  branch = cbranch
		AND    ident LIKE 'CHARGE_INTEREST_GROUP_%';
	
		smulticurrency := ifcurrencyisusedintype(1, scontracttype, scontractno) AND
						  ifcurrencyisusedintype(2, scontracttype, scontractno);
	
		IF smulticurrency
		THEN
			smulticurrencyrate(1) := getrate(contractaccount.getaccounttypecurrency(scontracttype
																				   ,'ItemDeposit' ||
																					slabel(1))
											,contractaccount.getaccounttypecurrency(scontracttype
																				   ,'ItemDeposit' ||
																					slabel(2))
											,seance.getoperdate);
			smulticurrencyrate(2) := getrate(contractaccount.getaccounttypecurrency(scontracttype
																				   ,'ItemDeposit' ||
																					slabel(2))
											,contractaccount.getaccounttypecurrency(scontracttype
																				   ,'ItemDeposit' ||
																					slabel(1))
											,seance.getoperdate);
		
		ELSE
			FOR i IN 1 .. 2
			LOOP
				IF ifcurrencyisusedintype(i, scontracttype, scontractno)
				THEN
					smulticurrencyrate(i) := 1;
				END IF;
			END LOOP;
		END IF;
	
		scontrtype_cache(scontracttype).readsetupscheme_called := TRUE;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN excothererror THEN
			RAISE;
		WHEN contractparams.accountnotexists THEN
			error.saveraise(cmethodname, error.errorconst, 'Account does not exist');
		WHEN contractparams.valuenotexists THEN
			error.saveraise(cmethodname
						   ,error.errorconst
						   ,'Can''t find some value at contract type settings (contract type ' ||
							scontracttype || ')');
		WHEN contractparams.incorrectvalue THEN
			error.saveraise(cmethodname
						   ,error.errorconst
						   ,'Incorrect value at contract type settings (contract type ' ||
							scontracttype || ')');
		WHEN contracttools.usererror THEN
			error.save(cmethodname);
			RAISE excothererror;
		WHEN OTHERS THEN
			err.seterror(SQLCODE, cmethodname);
			error.save(cmethodname);
			RAISE excothererror;
	END readsetupscheme;

	PROCEDURE readaltsetupscheme(ploadprofiles IN BOOLEAN := TRUE) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.ReadAltSetupScheme';
		vprofileid types.arrnum;
	BEGIN
		vprofileid(1) := sblockparam.profileiddom;
		vprofileid(2) := sblockparam.profileidint;
	
		FOR i IN 1 .. 2
		LOOP
			IF (vprofileid(i) > 0)
			THEN
				fillinterestprofsettings(vprofileid(i));
			END IF;
		END LOOP;
	
		smpaltprofile(1) := sblockparam.mpprofileiddom;
		smpaltprofile(2) := sblockparam.mpprofileidint;
	
		FOR i IN 1 .. 2
		LOOP
			IF (smpaltprofile(i) > 0)
			   AND (nvl(ploadprofiles, FALSE) OR contractcalendar.issdinsomecalendar)
			THEN
				fillmpprofilesettings(smpaltprofile(i));
			END IF;
		END LOOP;
	
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END readaltsetupscheme;

	PROCEDURE resetcorpcontractnumber IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ResetCorpContractNumber';
	BEGIN
		scorpcontractnumber := NULL;
		scorpnumberloaded   := FALSE;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END resetcorpcontractnumber;

	FUNCTION getcorpcontractnumber RETURN typecontractno IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCorpContractNumber';
		vnoarray contractlink.typecontractarray;
	BEGIN
		t.enter(cmethodname);
	
		IF NOT scorpnumberloaded
		THEN
			IF contractlink.getlinkno(scontractno, contractlink.clink, vnoarray) > 0
			THEN
				scorpcontractnumber := vnoarray(1).cno;
			END IF;
			scorpnumberloaded := TRUE;
		END IF;
	
		t.leave(cmethodname, scorpcontractnumber);
		RETURN scorpcontractnumber;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcorpcontractnumber;

	FUNCTION hascorporatecontract RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.HasCorporateContract';
	BEGIN
		RETURN getcorpcontractnumber IS NOT NULL;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END hascorporatecontract;

	PROCEDURE int_getcycle
	(
		precno IN NUMBER
	   ,ocycle OUT typebillingcycle
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Int_GetCycle';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	BEGIN
		t.enter(cmethodname, precno);
	
		SELECT *
		INTO   ocycle
		FROM   tcontractstcycle
		WHERE  branch = cbranch
		AND    recno = precno;
	
		t.outpar('Cycle RecNo', ocycle.recno);
		t.outpar('StatementDate', htools.d2s(ocycle.statementdate));
		t.outpar('PrintedDueDate', htools.d2s(ocycle.printedduedate));
		t.outpar('DueDate', htools.d2s(ocycle.duedate));
		t.outpar('LastDueDate', htools.d2s(ocycle.lastduedate));
		t.outpar('NextStatementDate', htools.d2s(ocycle.nextstatementdate));
		t.outpar('DAFDate', htools.d2s(ocycle.dafdate));
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN no_data_found THEN
			error.raiseerror('Internal error: cycle with record no <' || precno || '> not found!');
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END int_getcycle;

	PROCEDURE int_getmp
	(
		precno IN NUMBER
	   ,oamp   OUT NOCOPY types.arrnum
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Int_GetMP';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	BEGIN
		t.enter(cmethodname, precno);
	
		oamp(1) := 0;
		oamp(2) := 0;
	
		FOR i IN (SELECT currencynumber
						,minpayment
				  FROM   tcontractstminpaymentdata
				  WHERE  branch = cbranch
				  AND    screcno = precno)
		LOOP
			oamp(i.currencynumber) := i.minpayment;
		END LOOP;
	
		t.leave(cmethodname, 'MP DOM = ' || oamp(1) || ', MP INT = ' || oamp(2));
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END int_getmp;

	FUNCTION int_getcyclebydate
	(
		pdate       IN DATE
	   ,ocycle      OUT NOCOPY typebillingcycle
	   ,pcontractno IN typecontractno := NULL
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Int_GetCycleByDate';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vresult BOOLEAN;
	BEGIN
		t.enter(cmethodname);
	
		SELECT nvl(MIN(recno), 0)
		INTO   ocycle.recno
		FROM   tcontractstcycle
		WHERE  branch = cbranch
		AND    contractno = nvl(pcontractno, scontractno)
		AND    nextstatementdate >= pdate;
	
		vresult := ocycle.recno > 0;
	
		IF vresult
		THEN
			int_getcycle(ocycle.recno, ocycle);
		END IF;
	
		t.leave(cmethodname, htools.b2s(vresult));
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END int_getcyclebydate;

	FUNCTION getcyclebydate
	(
		pcontractno  IN typecontractno
	   ,pdate        IN DATE
	   ,pdoexception IN BOOLEAN := TRUE
	) RETURN typebillingcycle IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCycleByDate';
		vresult typebillingcycle;
	BEGIN
		t.enter(cmethodname, 'ContractNo = ' || pcontractno || ', Date = ' || htools.d2s(pdate));
	
		IF (NOT int_getcyclebydate(pdate, vresult, pcontractno))
		   AND pdoexception
		THEN
			error.raiseerror('Cycle on <' || htools.d2s(pdate) || '> for contract <' ||
							 pcontractno || '> not found!');
		END IF;
	
		t.leave(cmethodname, vresult.recno);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcyclebydate;

	PROCEDURE loadcurrentcycle IS
		cmethodname CONSTANT typemethodname := cpackagename || '.LoadCurrentCycle';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	BEGIN
		t.enter(cmethodname);
	
		SELECT MAX(recno)
		INTO   scurrentcycle.recno
		FROM   tcontractstcycle
		WHERE  branch = cbranch
		AND    contractno = scontractno;
	
		int_getcycle(scurrentcycle.recno, scurrentcycle);
	
		int_getmp(scurrentcycle.recno, scurrentmp);
	
		IF scurrentcycle.statementdate IS NOT NULL
		THEN
		
			SELECT *
			INTO   spreviouscycle
			FROM   tcontractstcycle
			WHERE  branch = cbranch
			AND    contractno = scontractno
			AND    nextstatementdate = scurrentcycle.statementdate;
		
		END IF;
	
		snextduedate := contractcalendar.getpaymentduedate(getbillingcyclecalendar(scontractno)
														  ,scurrentcycle.nextstatementdate);
	
		scycleinfoloaded := TRUE;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END loadcurrentcycle;

	PROCEDURE resetcurrentcycle IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ResetCurrentCycle';
	BEGIN
		scurrentcycle  := NULL;
		spreviouscycle := NULL;
		scurrentmp.delete;
		snextduedate     := NULL;
		scycleinfoloaded := FALSE;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END resetcurrentcycle;

	FUNCTION getcurrentcycle RETURN typebillingcycle IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCurrentCycle';
	BEGIN
		IF NOT scycleinfoloaded
		THEN
			loadcurrentcycle;
		END IF;
		RETURN scurrentcycle;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcurrentcycle;

	FUNCTION getpreviouscycle RETURN typebillingcycle IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetPreviousCycle';
	BEGIN
		IF NOT scycleinfoloaded
		THEN
			loadcurrentcycle;
		END IF;
		RETURN spreviouscycle;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getpreviouscycle;

	FUNCTION getcurrentmp(pcurno IN NUMBER) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCurrentMP';
	BEGIN
		IF NOT scycleinfoloaded
		THEN
			loadcurrentcycle;
		END IF;
		RETURN scurrentmp(pcurno);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcurrentmp;

	FUNCTION getnextduedate RETURN DATE IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetNextDueDate';
	BEGIN
		IF NOT scycleinfoloaded
		THEN
			loadcurrentcycle;
		END IF;
		RETURN snextduedate;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getnextduedate;

	PROCEDURE assumetodayissd IS
		cmethodname CONSTANT typemethodname := cpackagename || '.AssumeTodayIsSD';
	BEGIN
		IF NOT scycleinfoloaded
		THEN
			loadcurrentcycle;
		END IF;
		scurrentcycle.nextstatementdate := seance.getoperdate;
		snowstatementdate               := TRUE;
		snowduedate                     := FALSE;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END assumetodayissd;

	FUNCTION cycleisclosed RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CycleIsClosed';
		vresult BOOLEAN;
	BEGIN
		t.enter(cmethodname);
	
		vresult := (getcurrentcycle().statementdate IS NOT NULL) AND
				   (seance.getoperdate <= getcurrentcycle().statementdate);
	
		t.leave(cmethodname, htools.b2s(vresult));
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END cycleisclosed;

	PROCEDURE getcontractdata
	(
		pcreatenew     IN BOOLEAN := FALSE
	   ,penddate       IN DATE := NULL
	   ,pfromadjusting IN BOOLEAN := FALSE
	   ,pcalcdelparams IN BOOLEAN := TRUE
	) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetContractData';
		coperdate   CONSTANT DATE := seance.getoperdate;
		cbranch     CONSTANT NUMBER := seance.getbranch;
		venddate DATE := coalesce(penddate, seance.getoperdate);
	BEGIN
		s.say(cmethodname || '  --<< BEGIN');
		s.say(cmethodname || '  -- INPUT PARAMETERS:');
		s.say(cmethodname || '     Whether New Contract is created (pCreateNew) = ' ||
			  service.iif(pcreatenew, 'YES', 'NO'));
		s.say(cmethodname || '     What Date are Data obtained on (vEndDate) = ' ||
			  htools.d2s(venddate));
		s.say(cmethodname ||
			  '     Whether the method was run from ExecAdjustment (pFromAdjusting) = ' ||
			  service.iif(pfromadjusting, 'YES', 'NO'));
		s.say(cmethodname ||
			  '     implicit: Contract Number (ContractTypeSchema.sContractRow.No) = ' ||
			  contracttypeschema.scontractrow.no);
		s.say(cmethodname || ' ');
	
		s.say(cmethodname || ' - Accumulate Interest Mode {Interest coming back} = ' ||
			  saccumintaccmode);
		IF NOT pfromadjusting
		THEN
			SELECT *
			INTO   contracttypeschema.scontractrow
			FROM   tcontract
			WHERE  branch = cbranch
			AND    no = contracttypeschema.scontractrow.no;
		END IF;
		scontractno := contracttypeschema.scontractrow.no;
	
		FOR i IN 1 .. 2
		LOOP
			contracttools.loadcontractaccount(sitem(i).dep, sdepaccount(i));
			contracttools.loadcontractaccount(sitem(i).ovd, sovdaccount(i));
			IF saccumintaccmode <> cintaccmode_donotaccumulate
			THEN
				s.say(cmethodname || '--> sItem(' || i || ').Int = ' || sitem(i).int);
				contracttools.loadcontractaccount(sitem(i).int, sintaccount(i));
				s.say(cmethodname || '--> sIntAccount(' || i || ').accountNo = ' || sintaccount(i)
					  .accountno);
			END IF;
		
			IF ifcurrencyisusedintype(i, contracttypeschema.scontractrow.type, scontractno)
			THEN
				IF sprecision(i) IS NULL
				THEN
					sprecision(i) := referencecurrency.getprecision(sdepaccount(i).currencyno);
				END IF;
			
				sacparamccy(i)(0) := NULL;
				IF i = 1
				THEN
					loadparam(scontractno
							 ,cacontrpdom_ident
							 ,sacctparamccy(i)
							 ,sacparamccy(i)
							 ,FALSE);
				ELSE
					loadparam(scontractno
							 ,cacontrpint_ident
							 ,sacctparamccy(i)
							 ,sacparamccy(i)
							 ,FALSE);
				END IF;
				fillmpprofilesettings(sacparamccy(i) (cp_mpprofile));
				fillinterestprofsettings(sacparamccy(i) (cp_profile));
			
				sinttoinston(i) := (sactparamccy(i) (cctp_inttoinston) = 1) AND
								   (sacparamccy(i) (cp_inttoinston) = 1) AND
								   (coperdate BETWEEN
								   nvl(to_date(sactparamccy(i) (cctp_inttoinstfrom)
											   ,contractparams.cparam_date_format)
									   ,coperdate) AND
								   nvl(to_date(sactparamccy(i) (cctp_inttoinstto)
											   ,contractparams.cparam_date_format)
									   ,coperdate));
			
			ELSE
				sacparamccy(i)(cp_lastdocno) := 0;
			END IF;
		
		END LOOP;
	
		resetcurrentcycle;
		resetcorpcontractnumber;
	
		loadparam(scontractno, cacp_ident, sact_cparam, sacparam, FALSE);
	
		IF NOT pcreatenew
		THEN
		
			FOR i IN 1 .. 2
			LOOP
				slastdocno(i) := sacparamccy(i) (cp_lastdocno);
			END LOOP;
		
			IF pcalcdelparams
			THEN
				getdelparameters(venddate);
			END IF;
		
		END IF;
		s.say(cmethodname || '  -->> END');
	EXCEPTION
		WHEN contracttools.valuenotexists
			 OR contracttools.usererror THEN
			error.save(cmethodname);
			RAISE excothererror;
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcontractdata;

	FUNCTION getclientid RETURN typeclientid IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetClientID';
	BEGIN
		IF contracttypeschema.scontractrow.idclient IS NULL
		THEN
			error.raiseerror('Client ID for contract <' || scontractno || '> not defined!');
		END IF;
		RETURN contracttypeschema.scontractrow.idclient;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getclientid;

	PROCEDURE initcontract(pcontractno IN typecontractno) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.InitContract';
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		contract.checkcontractno(pcontractno);
	
		contracttypeschema.scontractrow.no   := pcontractno;
		scontractno                          := pcontractno;
		scontracttype                        := contract.gettype(pcontractno, c_doexception);
		contracttypeschema.scontractrow.type := scontracttype;
	
		readsetupscheme;
	
		getcontractdata;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END initcontract;

	PROCEDURE savetrxntorollback
	(
		precno        IN NUMBER
	   ,pamount       IN NUMBER
	   ,ppaidamount   IN NUMBER
	   ,ppaidfull     IN NUMBER
	   ,pintenddate   IN DATE
	   ,ppaidfulldate IN DATE
	   ,poffbalance   IN NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SaveTrxnToRollback';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vneedsave BOOLEAN;
	BEGIN
		t.enter(cmethodname, precno);
	
		vneedsave := NOT schangedtrxns.exists(precno);
	
		IF vneedsave
		THEN
			INSERT INTO tcontracttrxnrollback
			VALUES
				(cbranch
				,getpackno
				,precno
				,pamount
				,ppaidamount
				,ppaidfull
				,pintenddate
				,ppaidfulldate
				,poffbalance);
			schangedtrxns(precno) := TRUE;
		END IF;
	
		t.leave(cmethodname, 'Was saved: ' || htools.b2s(vneedsave));
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END savetrxntorollback;

	PROCEDURE savetrxntorollback(ptrxnrec IN typetrxnrec) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SaveTrxnToRollback [record]';
	BEGIN
		savetrxntorollback(ptrxnrec.recno
						  ,ptrxnrec.amount
						  ,ptrxnrec.paidamount
						  ,ptrxnrec.paidfull
						  ,ptrxnrec.intenddate
						  ,ptrxnrec.paidfulldate
						  ,ptrxnrec.offbalance);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END savetrxntorollback;

	PROCEDURE savetrxntorollback(ptrxnrow IN typetrxnrow) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SaveTrxnToRollback [row]';
	BEGIN
		savetrxntorollback(ptrxnrow.recno
						  ,ptrxnrow.amount
						  ,ptrxnrow.paidamount
						  ,ptrxnrow.paidfull
						  ,ptrxnrow.intenddate
						  ,ptrxnrow.paidfulldate
						  ,ptrxnrow.offbalance);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END savetrxntorollback;

	FUNCTION getvaluebycurno
	(
		pcurno    IN NUMBER
	   ,pvaluedom IN NUMBER
	   ,pvalueint IN NUMBER
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetValueByCurNo';
	BEGIN
		CASE pcurno
			WHEN 1 THEN
				RETURN pvaluedom;
			WHEN 2 THEN
				RETURN pvalueint;
			ELSE
				error.raiseerror('Internal error: unsupported currency number <' || pcurno || '>!');
		END CASE;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getvaluebycurno;

	FUNCTION getvaluebycurno
	(
		pcurno    IN NUMBER
	   ,pvaluedom IN VARCHAR2
	   ,pvalueint IN VARCHAR2
	) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetValueByCurNo';
	BEGIN
		CASE pcurno
			WHEN 1 THEN
				RETURN pvaluedom;
			WHEN 2 THEN
				RETURN pvalueint;
			ELSE
				error.raiseerror('Internal error: unsupported currency number <' || pcurno || '>!');
		END CASE;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getvaluebycurno;

	FUNCTION getcurnobyvalue
	(
		pvalue    IN NUMBER
	   ,pvaluedom IN NUMBER
	   ,pvalueint IN NUMBER
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCurNoByValue';
	BEGIN
		CASE pvalue
			WHEN pvaluedom THEN
				RETURN 1;
			WHEN pvalueint THEN
				RETURN 2;
			ELSE
				error.raiseerror('Internal error: currency number for value <' || pvalue ||
								 '> not found!');
		END CASE;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcurnobyvalue;

	FUNCTION getcurnobyvalue
	(
		pvalue    IN VARCHAR2
	   ,pvaluedom IN VARCHAR2
	   ,pvalueint IN VARCHAR2
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCurNoByValue';
	BEGIN
		CASE pvalue
			WHEN pvaluedom THEN
				RETURN 1;
			WHEN pvalueint THEN
				RETURN 2;
			ELSE
				error.raiseerror('Internal error: currency number for value <' || pvalue ||
								 '> not found!');
		END CASE;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcurnobyvalue;

	FUNCTION getcurnobycurrency(pcurrency IN NUMBER) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCurNoByCurrency';
	BEGIN
		FOR i IN 1 .. 2
		LOOP
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			   AND (sdepaccount(i).currencyno = pcurrency)
			THEN
				RETURN i;
			END IF;
		END LOOP;
		error.raiseerror('Internal error: account with currency <' || pcurrency ||
						 '> does not exist in contract!');
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcurnobycurrency;

	FUNCTION getcurnobyaccountno(paccountno IN typeaccountno) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCurNoByAccountNo';
	BEGIN
		FOR i IN 1 .. 2
		LOOP
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			   AND (sdepaccount(i).accountno = paccountno)
			THEN
				RETURN i;
			END IF;
		END LOOP;
		error.raiseerror('Internal error: account with number <' || paccountno ||
						 '> does not exist in contract!');
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcurnobyaccountno;

	FUNCTION getcurnotopostentry(pcurrency IN typecurrency) RETURN PLS_INTEGER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCurNoToPostEntry';
		vresult PLS_INTEGER;
	BEGIN
		t.enter(cmethodname, pcurrency);
	
		IF (getlimittype_int(scontractno) = caggregate)
		   AND (nvl(contractparams.loadbool(contractparams.ccontracttype
										   ,scontracttype
										   ,'SwitchFromDualToOneCur'
										   ,FALSE)
				   ,FALSE))
		THEN
			s.say(cmethodname ||
				  '     - info: Contract Type has aggregated limit and also all transactions should be posted on card account only');
			s.say(cmethodname || '     sCardCount1 = ' || scardcount1 || ', sCardCount2 = ' ||
				  scardcount2);
		
			IF scardcount1 > 0
			THEN
				vresult := 1;
			ELSIF scardcount2 > 0
			THEN
				vresult := 2;
			END IF;
		
		ELSE
		
			IF NOT ifcurrencyisusedintype(2, scontracttype, scontractno)
			THEN
				vresult := 1;
			ELSIF NOT ifcurrencyisusedintype(1, scontracttype, scontractno)
			THEN
				vresult := 2;
			
			ELSIF sdepaccount(1).currencyno = pcurrency
			THEN
				vresult := 1;
			
			ELSE
				vresult := 2;
			END IF;
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcurnotopostentry;

	FUNCTION masktodialog
	(
		ppan IN typepan
	   ,pmbr IN typembr
	) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.MaskToDialog';
	BEGIN
		IF ppan IS NULL
		THEN
			RETURN NULL;
		ELSE
			RETURN card.getmaskedpan(ppan) || '-' || pmbr;
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END masktodialog;

	FUNCTION masktodialog(pcardrecord IN apitypes.typecardrecord) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.MaskToDialog';
	BEGIN
		RETURN masktodialog(pcardrecord.pan, pcardrecord.mbr);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END masktodialog;

	FUNCTION masktodebug
	(
		ppan IN typepan
	   ,pmbr IN typembr
	) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.MaskToDebug';
	BEGIN
		IF ppan IS NULL
		THEN
			RETURN NULL;
		ELSE
			RETURN s.maskdata(ppan, s.cmask_pan) || '-' || pmbr;
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END masktodebug;

	FUNCTION masktodebug(pcardrecord IN apitypes.typecardrecord) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.MaskToDebug';
	BEGIN
		RETURN masktodebug(pcardrecord.pan, pcardrecord.mbr);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END masktodebug;

	FUNCTION masktodebug(ppanmbr IN VARCHAR2) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.MaskToDebug';
		vpan typepan;
		vmbr typembr;
	BEGIN
		IF nvl(ppanmbr, '-') = '-'
		THEN
			RETURN ppanmbr;
		ELSE
			contracttools.parsecardstring(ppanmbr, vpan, vmbr, '-');
			RETURN masktodebug(vpan, vmbr);
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END masktodebug;

	FUNCTION masktolog
	(
		ppan IN typepan
	   ,pmbr IN typembr
	) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.MaskToLog';
	BEGIN
		IF ppan IS NULL
		THEN
			RETURN NULL;
		ELSE
			RETURN card.getmaskedpan(ppan, FALSE) || '-' || pmbr;
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END masktolog;

	FUNCTION masktolog(pcardrecord IN apitypes.typecardrecord) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.MaskToLog';
	BEGIN
		RETURN masktolog(pcardrecord.pan, pcardrecord.mbr);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END masktolog;

	FUNCTION formatmoneywithabbr
	(
		psum   IN NUMBER
	   ,pcurno IN NUMBER
	) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.FormatMoneyWithAbbr';
		ccurrency   CONSTANT NUMBER := sdepaccount(pcurno).currencyno;
	BEGIN
		RETURN ltools.formatamount(psum, ccurrency) || ' ' || referencecurrency.getabbreviation(ccurrency);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END formatmoneywithabbr;

	FUNCTION getfullremark
	(
		pcurno      IN PLS_INTEGER
	   ,pparamname  IN VARCHAR2
	   ,pentryident IN VARCHAR2 := NULL
	) RETURN typefullremark IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetFullRemark';
		vparamlist contractsql.typeinparameterlist;
		vresult    typefullremark := NULL;
		vblockid   NUMBER;
	BEGIN
		t.enter(cmethodname, 'pCurNo = ' || pcurno || ', pParamName = ' || pparamname);
	
		vblockid := contractparams.loadnumber(custom_contractprofiles.getobjecttype
											 ,contractparams.loadchar(contractparams.ccontracttype
																	 ,scontracttype
																	 ,getvaluebycurno(pcurno
																					 ,'PROFILEDOM'
																					 ,'PROFILEINT')
																	 ,FALSE)
											 ,pparamname
											 ,FALSE);
	
		IF vblockid IS NOT NULL
		THEN
		
			vparamlist(1).ident := ':CardAccountNo';
			vparamlist(1).typeparam := contractsql.ctype_funcchar;
			vparamlist(1).charvalue := sdepaccount(pcurno).accountno;
		
			vparamlist(2).ident := ':EntryIdent';
			vparamlist(2).typeparam := contractsql.ctype_funcchar;
			vparamlist(2).charvalue := pentryident;
		
			vresult := contractsql.runbatchchar(vblockid, vparamlist);
		END IF;
	
		t.leave(cmethodname);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getfullremark;

	FUNCTION getoperationdescr(poperationtype IN PLS_INTEGER) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetOperationDescr';
		vresult VARCHAR2(100);
	BEGIN
		t.enter(cmethodname, poperationtype);
	
		IF caoperationlabel.exists(poperationtype)
		THEN
			vresult := caoperationlabel(poperationtype);
		ELSE
			vresult := 'Unknown operation';
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getoperationdescr;

	FUNCTION getminpaymentamount(pcurno IN NUMBER) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetMinPaymentAmount';
		voverdueparameters custom_overdueparameterscalculation.typeoverdueparamsrecord;
	BEGIN
		t.enter(cmethodname, pcurno);
		vdummypha := custom_overdueparameterscalculation.getoverdueparameters(sdepaccount(pcurno)
																			  .accountno
																			 ,pcurno
																			 ,NULL
																			 ,sdelparam.overdueint
																			 ,voverdueparameters);
		t.leave(cmethodname, voverdueparameters.dueamount);
		RETURN voverdueparameters.dueamount;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getminpaymentamount;

	FUNCTION getoverdueminpaymentamount
	(
		pcurnumber         IN NUMBER
	   ,osdbalanceamount   OUT NUMBER
	   ,osdbalanceodamount OUT NUMBER
	) RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetOverdueMinPaymentAmount';
		voverdueparameters custom_overdueparameterscalculation.typeoverdueparamsrecord;
		voverduemp         NUMBER;
	BEGIN
		t.enter(cmethodname);
	
		vdummypha := custom_overdueparameterscalculation.getoverdueparameters(paccountno           => sdepaccount(pcurnumber)
																									  .accountno
																			 ,pcurrencynumber      => pcurnumber
																			 ,pdate                => NULL
																			 ,pconsideroverduefrom => sdelparam.overdueint
																			 ,ooverdueparameters   => voverdueparameters);
	
		voverduemp := voverdueparameters.overdueamount_onduedate;
	
		osdbalanceamount   := voverdueparameters.unpaidsdamountonddate;
		osdbalanceodamount := voverdueparameters.unpaidsdamountonpdate;
	
		t.outpar('Unpaid amount on DD', osdbalanceamount);
		t.outpar('Current unpaid amount', osdbalanceodamount);
	
		t.leave(cmethodname, voverduemp);
		RETURN voverduemp;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getoverdueminpaymentamount;

	PROCEDURE getunpaidamounts
	(
		pcurno         IN NUMBER
	   ,ompamount      OUT NUMBER
	   ,ooverduemp     OUT NUMBER
	   ,osdbalamount   OUT NUMBER
	   ,osdbalodamount OUT NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetUnpaidAmounts';
		voverdueparameters custom_overdueparameterscalculation.typeoverdueparamsrecord;
	BEGIN
		t.enter(cmethodname);
	
		vdummypha := custom_overdueparameterscalculation.getoverdueparameters(sdepaccount(pcurno)
																			  .accountno
																			 ,pcurno
																			 ,NULL
																			 ,sdelparam.overdueint
																			 ,voverdueparameters);
	
		ompamount      := voverdueparameters.dueamount;
		ooverduemp     := voverdueparameters.overdueamount_onduedate;
		osdbalamount   := voverdueparameters.unpaidsdamountonddate;
		osdbalodamount := voverdueparameters.unpaidsdamountonpdate;
	
		t.outpar('Unpaid MP', ompamount);
		t.outpar('Overdue MP', ooverduemp);
		t.outpar('Unpaid amount on DD', osdbalamount);
		t.outpar('Current unpaid amount', osdbalodamount);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getunpaidamounts;

	PROCEDURE updateusedlimits
	(
		pcurno      IN NUMBER
	   ,ppan        IN typepan
	   ,pmbr        IN typembr
	   ,pdeltacred  IN NUMBER
	   ,pdeltacash  IN NUMBER
	   ,pdorollback IN BOOLEAN := c_dorollback
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UpdateUsedLimits';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	BEGIN
		t.enter(cmethodname
			   ,'CurNo = ' || pcurno || ', Card = ' || masktodebug(ppan, pmbr) ||
				', pDeltaCred = ' || pdeltacred || ', pDeltaCash = ' || pdeltacash);
	
		IF (pdeltacred <> 0)
		   OR (pdeltacash <> 0)
		THEN
		
			IF pdorollback
			THEN
			
				IF slimitpackno IS NULL
				THEN
					slimitpackno := seqlimitchangepackno.nextval;
				END IF;
			
				INSERT INTO tcontractlimitrollback
				VALUES
					(cbranch
					,slimitpackno
					,scontractno
					,ppan
					,pmbr
					,pcurno
					,pdeltacred
					,pdeltacash);
			
			END IF;
		
			IF ppan IS NOT NULL
			THEN
			
				UPDATE tcontractlimitparams
				SET    usedcredlimit = usedcredlimit + pdeltacred
					  ,usedcashlimit = usedcashlimit + pdeltacash
				WHERE  branch = cbranch
				AND    contractno = scontractno
				AND    pan = ppan
				AND    mbr = pmbr
				AND    currencynumber = pcurno;
			
			ELSE
			
				UPDATE tcontractlimitparams
				SET    usedcashlimit = usedcashlimit + pdeltacash
				WHERE  branch = cbranch
				AND    contractno = scontractno
				AND    pan IS NULL
				AND    mbr IS NULL
				AND    currencynumber = pcurno;
			
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END updateusedlimits;

	PROCEDURE correctusedlimits
	(
		pcurno     IN NUMBER
	   ,pfullreset IN BOOLEAN
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CorrectUsedLimits';
	
		vobjectlimitsetup typeobjectlimitsettings;
		vcardlist         apitypes.typecardlist;
		vdeltacred        NUMBER;
		vdeltacash        NUMBER;
	
		FUNCTION getlimitdelta
		(
			pcurno      IN NUMBER
		   ,pperiodtype IN NUMBER
		   ,pusedlimit  IN NUMBER
		   ,pfullreset  IN BOOLEAN
		) RETURN NUMBER IS
			cmethodname CONSTANT typemethodname := correctusedlimits.cmethodname ||
												   '.GetLimitDelta';
			vaccbalance NUMBER;
			vresult     NUMBER := 0;
		BEGIN
			t.enter(cmethodname, pusedlimit);
		
			IF pperiodtype = contracttypelimits.periodtype_at_sd
			THEN
			
				IF pfullreset
				THEN
				
					vresult := -pusedlimit;
				END IF;
			
			ELSIF NOT pfullreset
			THEN
			
				vaccbalance := -least(sdepaccount(pcurno).remain, 0);
			
				vresult := -greatest(pusedlimit - vaccbalance, 0);
			END IF;
		
			t.leave(cmethodname, vresult);
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END getlimitdelta;
	
	BEGIN
		t.enter(cmethodname, pcurno);
	
		vcardlist := contract.getcardlist(scontractno);
	
		FOR i IN 1 .. vcardlist.count
		LOOP
		
			vobjectlimitsetup := getobjectlimitssetup(scontractno
													 ,pcurno
													 ,vcardlist  (i).pan
													 ,vcardlist  (i).mbr);
		
			vdeltacred := getlimitdelta(pcurno
									   ,gettypelimitperiod(clk_creditlimit
														  ,pcurno
														  ,vcardlist      (i).pan
														  ,vcardlist      (i).mbr)
									   ,vobjectlimitsetup.usedcredlimit.amount
									   ,pfullreset);
			vdeltacash := getlimitdelta(pcurno
									   ,gettypelimitperiod(clk_cashlimit
														  ,pcurno
														  ,vcardlist    (i).pan
														  ,vcardlist    (i).mbr)
									   ,vobjectlimitsetup.usedcashlimit.amount
									   ,pfullreset);
		
			updateusedlimits(pcurno, vcardlist(i).pan, vcardlist(i).mbr, vdeltacred, vdeltacash);
		
		END LOOP;
	
		vobjectlimitsetup := getobjectlimitssetup(scontractno, pcurno);
	
		vdeltacash := getlimitdelta(pcurno
								   ,gettypelimitperiod(clk_cashlimit, pcurno)
								   ,vobjectlimitsetup.usedcashlimit.amount
								   ,pfullreset);
	
		updateusedlimits(pcurno, NULL, NULL, 0, vdeltacash);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END correctusedlimits;

	PROCEDURE changeusedlimits
	(
		pcurno           IN NUMBER
	   ,pvalue           IN NUMBER
	   ,ppan             IN typepan
	   ,pmbr             IN typembr
	   ,pupdateallcards  IN BOOLEAN
	   ,pupdatecashlimit IN BOOLEAN
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ChangeUsedLimits';
	
		vcardlist apitypes.typecardlist;
	
		PROCEDURE updateobjectusedlimits
		(
			pvalue IN NUMBER
		   ,ppan   IN typepan := NULL
		   ,pmbr   IN typembr := NULL
		) IS
			cmethodname CONSTANT typemethodname := changeusedlimits.cmethodname ||
												   '.UpdateObjectUsedLimits';
			vobjectlimitsetup typeobjectlimitsettings;
			vdeltacred        NUMBER := 0;
			vdeltacash        NUMBER := 0;
		
			FUNCTION calclimitdelta
			(
				pcurvalue   IN NUMBER
			   ,pvalue      IN NUMBER
			   ,pperiodtype IN NUMBER
			) RETURN NUMBER IS
				cmethodname CONSTANT typemethodname := updateobjectusedlimits.cmethodname ||
													   '.CalcLimitDelta';
				vresult NUMBER := 0;
			BEGIN
				t.enter(cmethodname, pcurvalue);
			
				IF pvalue < 0
				THEN
					vresult := -pvalue;
				
				ELSIF pperiodtype <> contracttypelimits.periodtype_at_sd
				THEN
					vresult := -least(pcurvalue, pvalue);
				END IF;
			
				t.leave(cmethodname, vresult);
				RETURN vresult;
			EXCEPTION
				WHEN OTHERS THEN
					t.exc(cmethodname);
					error.save(cmethodname);
					RAISE;
			END calclimitdelta;
		
		BEGIN
			t.enter(cmethodname);
		
			vobjectlimitsetup := getobjectlimitssetup(scontractno, pcurno, ppan, pmbr);
		
			t.var('vObjectLimitSetup.UsedCredLimit.Amount', vobjectlimitsetup.usedcredlimit.amount);
			t.var('vObjectLimitSetup.UsedCashLimit.Amount', vobjectlimitsetup.usedcashlimit.amount);
		
			IF ppan IS NOT NULL
			THEN
				vdeltacred := calclimitdelta(vobjectlimitsetup.usedcredlimit.amount
											,pvalue
											,gettypelimitperiod(clk_creditlimit, pcurno, ppan, pmbr));
			END IF;
		
			IF pupdatecashlimit
			THEN
				vdeltacash := calclimitdelta(vobjectlimitsetup.usedcashlimit.amount
											,pvalue
											,gettypelimitperiod(clk_cashlimit, pcurno, ppan, pmbr));
			END IF;
		
			updateusedlimits(vobjectlimitsetup.curno
							,vobjectlimitsetup.pan
							,vobjectlimitsetup.mbr
							,vdeltacred
							,vdeltacash);
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END updateobjectusedlimits;
	
	BEGIN
		t.enter(cmethodname
			   ,'Value = ' || pvalue || ', Card = ' || masktodebug(ppan, pmbr) ||
				', pUpdateAllCards = ' || htools.b2s(pupdateallcards) || ', pUpdateCashLimit = ' ||
				htools.b2s(pupdatecashlimit));
	
		IF ifcurrencyisusedintype(pcurno, scontracttype, scontractno)
		THEN
		
			IF pupdateallcards
			THEN
			
				vcardlist := contract.getcardlist(scontractno);
			
				FOR i IN 1 .. vcardlist.count
				LOOP
					updateobjectusedlimits(pvalue, vcardlist(i).pan, vcardlist(i).mbr);
				END LOOP;
			
			ELSIF (ppan IS NOT NULL)
				  AND (contract.getcontractbycard(ppan, pmbr).contractno = scontractno)
			THEN
				updateobjectusedlimits(pvalue, ppan, pmbr);
			END IF;
		
			IF pupdatecashlimit
			THEN
				updateobjectusedlimits(pvalue);
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END changeusedlimits;

	PROCEDURE rollbackusedlimitschange(ppackno IN NUMBER) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.RollbackUsedLimitsChange';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vrollback typearrusedlimitsrollback;
	BEGIN
		t.enter(cmethodname, ppackno);
	
		DELETE FROM tcontractlimitrollback
		WHERE  branch = cbranch
		AND    contractno = scontractno
		AND    packno = ppackno
		RETURNING branch, packno, contractno, pan, mbr, currencynumber, usedcredlimit, usedcashlimit BULK COLLECT INTO vrollback;
	
		FOR i IN 1 .. vrollback.count
		LOOP
			updateusedlimits(vrollback   (i).currencynumber
							,vrollback   (i).pan
							,vrollback   (i).mbr
							,-vrollback  (i).usedcredlimit
							,-vrollback  (i).usedcashlimit
							,c_norollback);
		END LOOP;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END rollbackusedlimitschange;

	PROCEDURE savetrxntolist
	(
		pcurno       IN NUMBER
	   ,potrxnrec    IN OUT NOCOPY typetrxnrec
	   ,pregularmode IN BOOLEAN := TRUE
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SaveTrxnToList';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	BEGIN
		t.enter(cmethodname);
	
		IF potrxnrec.amount > 0
		THEN
		
			potrxnrec.packno := getpackno;
			potrxnrec.recno  := seqtrxnlistrecno.nextval;
		
			s.say(cmethodname || ': ContractNo = ' || scontractno || ', AccountNo = ' ||
				  potrxnrec.accountno || ', PackNo = ' || potrxnrec.packno || ', RecNo = ' ||
				  potrxnrec.recno || ', GroupID = ' || potrxnrec.groupid || ', TranType = ' ||
				  potrxnrec.trantype || ', TranDate = ' || potrxnrec.trandate || ', PostDate = ' ||
				  potrxnrec.postdate || ', DocNo = ' || potrxnrec.docno || ', EntryNo = ' ||
				  potrxnrec.entryno || ', IntStartDate = ' || htools.d2s(potrxnrec.intstartdate) ||
				  ', PaidFull = ' || potrxnrec.paidfull || ', PaidFullDate = ' ||
				  htools.d2s(potrxnrec.paidfulldate));
		
			INSERT INTO tcontracttrxnlist
			VALUES
				(cbranch
				,scontractno
				,potrxnrec.accountno
				,potrxnrec.packno
				,potrxnrec.recno
				,potrxnrec.groupid
				,potrxnrec.trantype
				,potrxnrec.trandate
				,potrxnrec.postdate
				,potrxnrec.amount
				,potrxnrec.paidamount
				,potrxnrec.paidfull
				,potrxnrec.rate
				,potrxnrec.intstartdate
				,potrxnrec.intenddate
				,potrxnrec.paidfulldate
				,potrxnrec.docno
				,potrxnrec.entryno
				,potrxnrec.pan
				,potrxnrec.mbr
				,potrxnrec.debitentcode
				,potrxnrec.offbalance);
		
			IF pregularmode
			THEN
				custom_overdueparameterscalculation.prepareupd_contrstminpaymdata(scontractno
																				 ,potrxnrec.accountno
																				 ,pcurno
																				 ,potrxnrec.packno
																				 ,potrxnrec.postdate
																				 ,potrxnrec.amount
																				 ,potrxnrec.trantype
																				 ,snowstatementdate
																				 ,snowduedate);
			END IF;
		
			IF potrxnrec.trantype IN (ctrxntype_debit, ctrxntype_creditrev)
			THEN
			
				IF potrxnrec.grouptype = ctrxngrp_payments
				THEN
					changeusedlimits(pcurno, -potrxnrec.amount, NULL, NULL, FALSE, TRUE);
				
				ELSE
					changeusedlimits(pcurno
									,-potrxnrec.amount
									,potrxnrec.pan
									,potrxnrec.mbr
									,FALSE
									,potrxnrec.grouptype = ctrxngrp_cash);
				END IF;
			END IF;
		
			IF potrxnrec.trantype IN (ctrxntype_debit, ctrxntype_creditrev)
			THEN
				contracttypeschema.screditsum := nvl(contracttypeschema.screditsum, 0) +
												 contracttools.getsumincurrency(potrxnrec.amount
																			   ,sdepaccount(pcurno)
																				.currencyno
																			   ,seance.getcurrency);
			END IF;
		
		END IF;
	
		IF potrxnrec.docno > slastdocno(pcurno)
		THEN
			slastdocno(pcurno) := potrxnrec.docno;
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END savetrxntolist;

	FUNCTION gettrxn
	(
		paccountno IN typeaccountno
	   ,pdocno     IN typedocno
	   ,pentryno   IN typeentryno
	) RETURN typetrxnrec IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetTrxn [by DocNo/No]';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vresult typetrxnrec;
	BEGIN
		t.enter(cmethodname
			   ,'AccountNo = ' || paccountno || ', DocNo = ' || pdocno || ', EntryNo = ' ||
				pentryno);
	
		SELECT t.*
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
		INTO   vresult
		FROM   tcontracttrxnlist t
		WHERE  t.branch = cbranch
		AND    t.accountno = paccountno
		AND    t.docno = pdocno
		AND    t.entryno = pentryno;
	
		t.leave(cmethodname, vresult.recno);
		RETURN vresult;
	EXCEPTION
		WHEN no_data_found THEN
			error.raiseerror('Transaction by account <' || paccountno || '> with DocNo/EntryNo = ' ||
							 pdocno || '/' || pentryno || ' not found!');
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END gettrxn;

	FUNCTION gettrxn(ptrxnid IN NUMBER) RETURN typetrxnrec IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetTrxn [by ID]';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vresult typetrxnrec;
	BEGIN
		t.enter(cmethodname, ptrxnid);
	
		SELECT t.*
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
		INTO   vresult
		FROM   tcontracttrxnlist t
		WHERE  branch = cbranch
		AND    t.recno = ptrxnid;
	
		t.leave(cmethodname);
		RETURN vresult;
	EXCEPTION
		WHEN no_data_found THEN
			error.raiseerror('Transaction with ID <' || ptrxnid || '> not found!');
			t.leave(cmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END gettrxn;

	FUNCTION getdebittrxns
	(
		pcurno      IN NUMBER
	   ,pcredittrxn IN typetrxnrec
	   ,pmigration  IN BOOLEAN
	) RETURN typetrxnarray IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetDebitTrxns';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		coperdate   CONSTANT DATE := seance.getoperdate;
	
		vdatecondition VARCHAR2(20) := service.iif(pmigration, '<=', NULL);
		vacolumns      types.arrstr4000;
		vsortorder     VARCHAR2(50);
		vresult        typetrxnarray;
		vsql           VARCHAR2(8000);
		vcurrentsd     DATE;
	
		PROCEDURE buildquery
		(
			posql           IN OUT NOCOPY VARCHAR2
		   ,prevgroup       IN NUMBER
		   ,pgroupcondition IN VARCHAR2
		   ,pdatecondition  IN VARCHAR2 := NULL
		) IS
			cmethodname CONSTANT typemethodname := getdebittrxns.cmethodname || '.BuildQuery';
		BEGIN
			t.enter(cmethodname);
		
			IF posql IS NULL
			THEN
				posql := 'SELECT * FROM (' || chr(10);
			
			ELSE
				posql := posql || chr(10) || ' UNION ALL' || chr(10);
			END IF;
		
			posql := posql ||
					 'SELECT l.Branch, l.ContractNo, l.AccountNo, l.PackNo, l.RecNo, l.GroupID, l.TranType, l.TranDate, l.PostDate, l.Amount, l.PaidAmount, l.PaidFull, l.Rate,' ||
					 chr(10) ||
					 '       l.IntStartDate, l.IntEndDate, l.PaidFullDate, l.DocNo, l.EntryNo, l.PAN, l.MBR, l.DebitEntCode, l.OffBalance, null as GroupType, null as TranCode, null as EntType, null as ParentDocNo, null as ParentEntryNo, null as ChildDocNo,' ||
					 chr(10) || prevgroup ||
					 ' as RevGroup, greatest(c.NextStatementDate, sys_context(''CLIENTCONTEXT'', ''CurrentSD'')) as NextSD, g.Priority, null as InstCheck, null as InstContractNo, null as InstAccountNo, null as LoanNo, null as InstTotalSum' ||
					 chr(10) || '  FROM tContractTrxnList l' || chr(10) ||
					 '  JOIN tContractProfileGroup g ON g.Branch = l.Branch AND g.GroupID = l.GroupID' ||
					 chr(10) ||
					 '  JOIN tContractStCycle c ON c.Branch = l.Branch AND c.ContractNo = l.ContractNo' ||
					 chr(10) || ' WHERE l.Branch = sys_context(''CLIENTCONTEXT'', ''Branch'')' ||
					 chr(10) ||
					 '   AND l.AccountNo = sys_context(''CLIENTCONTEXT'', ''AccountNo'')' ||
					 chr(10) || '   AND l.TranType < 3' || chr(10) || '   AND l.PaidFull = 0' ||
					 chr(10) ||
					 '   AND l.PostDate BETWEEN nvl(c.StatementDate + 1, l.PostDate) and c.NextStatementDate' ||
					 chr(10) ||
					 '   AND g.ProfileID = sys_context(''CLIENTCONTEXT'', ''ProfileID'')';
		
			IF pgroupcondition IS NOT NULL
			THEN
				dbms_session.set_context('CLIENTCONTEXT', 'GroupID', pcredittrxn.groupid);
				posql := posql || chr(10) || '   AND l.GroupID ' || pgroupcondition ||
						 ' sys_context(''CLIENTCONTEXT'', ''GroupID'')';
			END IF;
		
			IF pdatecondition IS NOT NULL
			THEN
				dbms_session.set_context('CLIENTCONTEXT', 'PostDate', pcredittrxn.postdate);
				posql := posql || chr(10) || '   AND l.PostDate ' || pdatecondition ||
						 ' sys_context(''CLIENTCONTEXT'', ''PostDate'')';
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END buildquery;
	
		FUNCTION getprevioussd(ptrxndate IN DATE) RETURN DATE IS
			cmethodname CONSTANT typemethodname := getdebittrxns.cmethodname || '.GetPreviousSD';
			vresult DATE;
		BEGIN
			t.enter(cmethodname, ptrxndate);
		
			SELECT MAX(statementdate)
			INTO   vresult
			FROM   tcontractstcycle
			WHERE  branch = cbranch
			AND    contractno = scontractno
			AND    statementdate <= ptrxndate;
		
			t.leave(cmethodname, vresult);
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END getprevioussd;
	
	BEGIN
		t.enter(cmethodname);
	
		IF pcredittrxn.trantype = ctrxntype_repayment
		THEN
			buildquery(vsql, 1, NULL, vdatecondition);
		
		ELSE
			buildquery(vsql, 1, '=', vdatecondition);
			buildquery(vsql, 2, '<>', vdatecondition);
		END IF;
	
		IF pmigration
		THEN
		
			vdatecondition := '>';
		
			IF pcredittrxn.trantype = ctrxntype_repayment
			THEN
				buildquery(vsql, 3, NULL, vdatecondition);
			ELSE
				buildquery(vsql, 3, '=', vdatecondition);
				buildquery(vsql, 4, '<>', vdatecondition);
			END IF;
		END IF;
	
		t.var('Repayment order'
			 ,sprofile(sprofileid(pcurno))
			  (custom_contractprofiles.cp_repayorder) ||
			  ', [1 - Transaction date then Group priority, 2 - Group priority then transaction date]');
		t.var('Repayment settings'
			 ,sprofile(sprofileid(pcurno))
			  (custom_contractprofiles.cp_repaysettings) ||
			  ', [1 - Not used, 2 - At first billed transaction only, 3 - Pay transactions by cycle]');
	
		CASE sprofile(sprofileid(pcurno)) (custom_contractprofiles.cp_repayorder)
		
			WHEN 1 THEN
			
				CASE sprofile(sprofileid(pcurno)) (custom_contractprofiles.cp_repaysettings)
				
					WHEN 1 THEN
						vsortorder := 'TranDate, Priority';
						vcurrentsd := NULL;
					
					WHEN 2 THEN
						vsortorder := 'NextSD, TranDate, Priority';
						vcurrentsd := nvl(getcurrentcycle().statementdate, coperdate);
					
					WHEN 3 THEN
						vsortorder := 'NextSD, TranDate, Priority';
						vcurrentsd := sdepaccount(pcurno).createdate - 1;
					
					ELSE
						error.raiseerror('Unknown repayment settings mode <' ||
										 sprofile(sprofileid(pcurno))
										 (custom_contractprofiles.cp_repaysettings) || '>!');
					
				END CASE;
			
			WHEN 2 THEN
			
				CASE sprofile(sprofileid(pcurno)) (custom_contractprofiles.cp_repaysettings)
				
					WHEN 1 THEN
						IF pmigration
						THEN
							vsortorder := 'NextSD, Priority, TranDate';
							vcurrentsd := pcredittrxn.postdate;
						ELSE
							vsortorder := 'Priority, TranDate';
							vcurrentsd := NULL;
						END IF;
					
					WHEN 2 THEN
						vsortorder := 'NextSD, Priority, TranDate';
						vcurrentsd := nvl(CASE pmigration
											  WHEN TRUE THEN
											   getprevioussd(pcredittrxn.postdate)
											  ELSE
											   getcurrentcycle().statementdate
										  END
										 ,sdepaccount(pcurno).createdate - 1);
					
					WHEN 3 THEN
						vsortorder := 'NextSD, Priority, TranDate';
						vcurrentsd := sdepaccount(pcurno).createdate - 1;
					
					ELSE
						error.raiseerror('Unknown repayment settings mode <' ||
										 sprofile(sprofileid(pcurno))
										 (custom_contractprofiles.cp_repaysettings) || '>!');
				END CASE;
			
			ELSE
				error.raiseerror('Unknown repayment order mode <' || sprofile(sprofileid(pcurno))
								 (custom_contractprofiles.cp_repayorder) || '>!');
		END CASE;
	
		t.var('vSortOrder', vsortorder);
		t.var('vCurrentSD', vcurrentsd);
	
		vsql := vsql || chr(10) || ')' || chr(10) || 'ORDER BY RevGroup, ';
	
		IF pmigration
		THEN
		
			vacolumns := contracttools.parsestring(REPLACE(vsortorder, ' ', NULL), ',');
		
			FOR i IN 1 .. vacolumns.count
			LOOP
				vsql := vsql || 'case when RevGroup < 3 then ' || vacolumns(i) || ' end, ';
			END LOOP;
		
			vsql := vsql ||
					'case when RevGroup > 2 then PostDate end, case when RevGroup > 2 then Priority end, ';
		
		ELSE
			vsql := vsql || vsortorder || ', ';
		END IF;
	
		vsql := vsql || 'RecNo';
	
		t.var('vSQL', vsql);
	
		dbms_session.set_context('CLIENTCONTEXT', 'Branch', cbranch);
		dbms_session.set_context('CLIENTCONTEXT', 'AccountNo', sdepaccount(pcurno).accountno);
		dbms_session.set_context('CLIENTCONTEXT', 'ProfileID', sprofileid(pcurno));
		dbms_session.set_context('CLIENTCONTEXT', 'CurrentSD', vcurrentsd);
	
		EXECUTE IMMEDIATE vsql BULK COLLECT
			INTO vresult;
	
		t.leave(cmethodname, vresult.count);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getdebittrxns;

	FUNCTION getcredittrxns(pcurno IN NUMBER) RETURN typetrxnarray IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCreditTrxns';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vresult typetrxnarray;
	BEGIN
		t.enter(cmethodname, pcurno);
	
		SELECT l.*
			  ,g.cashadvance
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL
			  ,NULL BULK COLLECT
		INTO   vresult
		FROM   tcontracttrxnlist l
		JOIN   tcontractentrygroup g
		ON     g.branch = l.branch
		AND    g.groupid = l.groupid
		WHERE  l.branch = cbranch
		AND    l.accountno = sdepaccount(pcurno).accountno
		AND    l.trantype IN (ctrxntype_repayment, ctrxntype_debitrev)
		AND    l.paidfull = 0
		ORDER  BY trandate
				 ,recno;
	
		t.leave(cmethodname, vresult.count);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcredittrxns;

	PROCEDURE dorepayment
	(
		pcurno    IN NUMBER
	   ,podbttrxn IN OUT NOCOPY typetrxnrec
	   ,pocrdtrxn IN OUT NOCOPY typetrxnrec
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.DoRepayment';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vamount NUMBER;
		vpackno NUMBER;
	
		PROCEDURE updatetrxnafterrepayment
		(
			potrxn  IN OUT NOCOPY typetrxnrec
		   ,pamount IN NUMBER
		   ,pdate   IN DATE
		) IS
			cmethodname CONSTANT typemethodname := dorepayment.cmethodname ||
												   '.UpdateTrxnAfterRepayment';
		BEGIN
			t.enter(cmethodname, pamount);
		
			potrxn.paidamount := potrxn.paidamount + pamount;
		
			IF potrxn.paidamount = potrxn.amount
			THEN
				potrxn.paidfull     := 1;
				potrxn.paidfulldate := greatest(potrxn.postdate, pdate);
			END IF;
		
			UPDATE tcontracttrxnlist
			SET    paidamount   = potrxn.paidamount
				  ,paidfull     = potrxn.paidfull
				  ,paidfulldate = potrxn.paidfulldate
			WHERE  branch = cbranch
			AND    recno = potrxn.recno;
		
			t.leave(cmethodname, 'PaidFull: ' || htools.i2s(potrxn.paidfull));
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END updatetrxnafterrepayment;
	
	BEGIN
		t.enter(cmethodname);
	
		s.say('Unpaid debit transaction: RecNo = ' || podbttrxn.recno || ' GroupID = ' ||
			  podbttrxn.groupid || ' TranType = ' || podbttrxn.trantype || ' TranDate = ' ||
			  podbttrxn.trandate || ' PostDate = ' || podbttrxn.postdate || ' Amount = ' ||
			  podbttrxn.amount || ' PaidAmount = ' || podbttrxn.paidamount);
		t.var('Available credit amount', pocrdtrxn.amount - pocrdtrxn.paidamount);
	
		IF pocrdtrxn.paidamount < pocrdtrxn.amount
		THEN
		
			vamount := least(pocrdtrxn.amount - pocrdtrxn.paidamount
							,podbttrxn.amount - podbttrxn.paidamount);
			t.var('Pay amount', vamount);
		
			IF vamount > 0
			THEN
			
				vpackno := getpackno;
			
				INSERT INTO tcontracttrxnrepayment
				VALUES
					(cbranch
					,vpackno
					,seqtrxnlistrecno.nextval
					,podbttrxn.recno
					,pocrdtrxn.recno
					,greatest(podbttrxn.trandate, pocrdtrxn.trandate)
					,greatest(podbttrxn.postdate, pocrdtrxn.postdate)
					,vamount);
			
				savetrxntorollback(podbttrxn);
				savetrxntorollback(pocrdtrxn);
			
				updatetrxnafterrepayment(podbttrxn, vamount, pocrdtrxn.postdate);
				updatetrxnafterrepayment(pocrdtrxn, vamount, podbttrxn.postdate);
			
				IF pocrdtrxn.trantype = ctrxntype_repayment
				THEN
					changeusedlimits(pcurno, vamount, NULL, NULL, TRUE, TRUE);
				
				ELSE
					changeusedlimits(pcurno
									,vamount
									,pocrdtrxn.pan
									,pocrdtrxn.mbr
									,FALSE
									,pocrdtrxn.grouptype = ctrxngrp_cash);
				END IF;
			
				IF podbttrxn.debitentcode MEMBER OF sprconentcode
				THEN
				
					contracttypeschema.screditprcoffsum := nvl(contracttypeschema.screditprcoffsum
															  ,0) +
														   contracttools.getsumincurrency(vamount
																						 ,sdepaccount(pcurno)
																						  .currencyno
																						 ,seance.getcurrency);
				ELSE
				
					contracttypeschema.screditoffsum := nvl(contracttypeschema.screditoffsum, 0) +
														contracttools.getsumincurrency(vamount
																					  ,sdepaccount(pcurno)
																					   .currencyno
																					  ,seance.getcurrency);
				END IF;
			
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END dorepayment;

	PROCEDURE dorepayment
	(
		pcurno IN NUMBER
	   ,potrxn IN OUT NOCOPY typetrxnrec
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.DoRepayment';
		vatrxns typetrxnarray;
	BEGIN
		t.enter(cmethodname, potrxn.recno);
	
		IF potrxn.trantype IN (ctrxntype_debit, ctrxntype_creditrev)
		THEN
		
			vatrxns := getcredittrxns(pcurno);
		
			FOR i IN 1 .. vatrxns.count
			LOOP
				dorepayment(pcurno, potrxn, vatrxns(i));
			
				EXIT WHEN potrxn.paidfull = 1;
			END LOOP;
		
		ELSE
		
			vatrxns := getdebittrxns(pcurno, potrxn, FALSE);
		
			FOR i IN 1 .. vatrxns.count
			LOOP
				dorepayment(pcurno, vatrxns(i), potrxn);
			
				EXIT WHEN potrxn.paidfull = 1;
			END LOOP;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END dorepayment;

	PROCEDURE buildtransaction
	(
		pcurno       IN NUMBER
	   ,potrxnrec    IN OUT NOCOPY typetrxnrec
	   ,pregularmode IN BOOLEAN := TRUE
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.BuildTransaction';
		coperdate   CONSTANT DATE := seance.getoperdate;
	
		vorigdebit BOOLEAN;
		vcurrdebit BOOLEAN;
	
		FUNCTION getentriescount(pdocno IN typedocno) RETURN NUMBER IS
			cmethodname CONSTANT typemethodname := buildtransaction.cmethodname ||
												   '.GetEntriesCount';
			cbranch     CONSTANT NUMBER := seance.getbranch;
		BEGIN
			t.enter(cmethodname, pdocno);
		
			contracttools.checkvalue_exists(pdocno, 'Financial document number');
		
			IF NOT sentriescount.exists(pdocno)
			THEN
				SELECT COUNT(*)
				INTO   sentriescount(pdocno)
				FROM   tentry
				WHERE  branch = cbranch
				AND    docno = pdocno;
			END IF;
		
			t.leave(cmethodname, sentriescount(pdocno));
			RETURN sentriescount(pdocno);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END getentriescount;
	
	BEGIN
		t.enter(cmethodname);
	
		IF pregularmode
		THEN
			IF (sactparam(cctp_correction) = 0)
			   AND (getcurrentcycle().statementdate IS NOT NULL)
			   AND (potrxnrec.postdate <= getcurrentcycle().statementdate)
			THEN
				error.raiseerror('When processing new transactions a transaction relating to the previous cycle is found <' ||
								 htools.d2s(potrxnrec.postdate) || ' ' || potrxnrec.amount || '>!');
			END IF;
			IF (potrxnrec.postdate > getcurrentcycle().nextstatementdate)
			THEN
				error.raiseerror('When processing new transactions a transaction relating to the next cycle is found <' ||
								 htools.d2s(potrxnrec.postdate) || ' ' || potrxnrec.amount || '>!');
			END IF;
		END IF;
	
		IF smulticurrency
		   AND (potrxnrec.postdate <> coperdate)
		THEN
			potrxnrec.rate := getrate(sdepaccount       (pcurno).currencyno
									 ,sdepaccount       (getvaluebycurno(pcurno, 2, 1)).currencyno
									 ,potrxnrec.postdate);
		ELSE
			potrxnrec.rate := smulticurrencyrate(pcurno);
		END IF;
	
		potrxnrec.offbalance := htools.b2i(((potrxnrec.debitentcode MEMBER OF sprconentcode) AND
										   (sblockparam.state.chargeint =
										   contractstatereference.cintoffbalance)) OR
										   ((potrxnrec.debitentcode = sdelfeeonentcode) AND
										   (sblockparam.state.chargeovdfee =
										   contractstatereference.covdfeeoffbalance)));
	
		IF potrxnrec.amount > 0
		THEN
			potrxnrec.trantype := CASE potrxnrec.grouptype
									  WHEN ctrxngrp_payments THEN
									   ctrxntype_repayment
									  ELSE
									   ctrxntype_debitrev
								  END;
		
		ELSIF potrxnrec.amount < 0
		THEN
			potrxnrec.trantype := CASE potrxnrec.grouptype
									  WHEN ctrxngrp_payments THEN
									   ctrxntype_creditrev
									  ELSE
									   ctrxntype_debit
								  END;
		END IF;
	
		potrxnrec.amount := abs(potrxnrec.amount);
	
		IF NOT card.existaccountcardlink(potrxnrec.pan, potrxnrec.mbr, potrxnrec.accountno)
		THEN
			potrxnrec.pan := NULL;
			potrxnrec.mbr := NULL;
		END IF;
	
		IF potrxnrec.trantype IN (ctrxntype_creditrev, ctrxntype_debit)
		THEN
		
			IF pregularmode
			THEN
			
				IF sopergroup(sprofileid(pcurno)) (potrxnrec.groupid)
				 (custom_contractprofiles.cpg_chargeint) = '0'
				THEN
					potrxnrec.intstartdate := coperdate;
				ELSE
				
					CASE sopergroup(sprofileid(pcurno)) (potrxnrec.groupid)
					 (custom_contractprofiles.cpg_startdate)
					
						WHEN 1 THEN
							potrxnrec.intstartdate := potrxnrec.trandate;
						
						WHEN 2 THEN
							potrxnrec.intstartdate := potrxnrec.postdate;
						
						WHEN 3 THEN
							potrxnrec.intstartdate := getcurrentcycle().nextstatementdate;
						
						WHEN 4 THEN
							potrxnrec.intstartdate := getnextduedate;
						
						WHEN 5 THEN
							potrxnrec.intstartdate := getcurrentcycle().nextstatementdate + 1;
						ELSE
							error.raiseerror('Internal error: unsupported interest calculation start date mode <' ||
											 sopergroup(sprofileid(pcurno)) (potrxnrec.groupid)
											 (custom_contractprofiles.cpg_startdate) || '>!');
					END CASE;
				
					potrxnrec.intstartdate := potrxnrec.intstartdate +
											  sopergroup(sprofileid(pcurno)) (potrxnrec.groupid)
											  (custom_contractprofiles.cpg_shiftdays);
				
				END IF;
			
				potrxnrec.intenddate := potrxnrec.intstartdate - 1;
			
			ELSE
			
				IF getcurrentcycle().nextstatementdate = coperdate
				THEN
					potrxnrec.intstartdate := getcurrentcycle().nextstatementdate;
				
				ELSE
					potrxnrec.intstartdate := nvl(getcurrentcycle().statementdate
												 ,potrxnrec.trandate - 1);
				END IF;
			
				potrxnrec.intenddate := potrxnrec.intstartdate;
			
			END IF;
		
		END IF;
	
		s.say(cmethodname || '  IntStartDate = ' || htools.d2s(potrxnrec.intstartdate) ||
			  ', IntEndDate = ' || htools.d2s(potrxnrec.intenddate));
	
		IF pregularmode
		THEN
		
			IF susereversalent
			THEN
			
				IF potrxnrec.parentdocno IS NULL
				THEN
				
					IF (potrxnrec.trancode IS NOT NULL)
					   AND (potrxnrec.enttype = 'R')
					THEN
					
						potrxnrec.parentdocno := findocument.getoriginaldocno(potrxnrec.docno);
					
						IF potrxnrec.parentdocno IS NOT NULL
						THEN
						
							IF getentriescount(potrxnrec.parentdocno) =
							   getentriescount(potrxnrec.docno)
							THEN
								potrxnrec.parententryno := potrxnrec.entryno;
							END IF;
						END IF;
					END IF;
				
				ELSE
				
					potrxnrec.parententryno := entryreverse.getparententryno(potrxnrec.docno
																			,potrxnrec.entryno
																			,c_noexception);
				END IF;
			
				IF potrxnrec.parentdocno IS NOT NULL
				THEN
				
					IF potrxnrec.parententryno IS NOT NULL
					THEN
						vorigdebit := gettrxn(sdepaccount(pcurno).accountno, potrxnrec.parentdocno, potrxnrec.parententryno)
									  .trantype IN (ctrxntype_debit, ctrxntype_creditrev);
						vcurrdebit := potrxnrec.trantype IN (ctrxntype_debit, ctrxntype_creditrev);
					END IF;
				
					IF (potrxnrec.parententryno IS NULL)
					   OR (vorigdebit AND vcurrdebit)
					   OR NOT (vorigdebit OR vcurrdebit)
					THEN
						potrxnrec.parentdocno := NULL;
					END IF;
				
				END IF;
			
			END IF;
		
			potrxnrec.instcheck := htools.b2i((potrxnrec.trantype = ctrxntype_debit) AND
											  (nvl(potrxnrec.childdocno, potrxnrec.parentdocno) IS NULL) AND
											  (potrxnrec.grouptype <> ctrxngrp_payments));
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END buildtransaction;

	FUNCTION addtrxnfromentry
	(
		pcurno      IN NUMBER
	   ,paccountno  IN typeaccountno
	   ,pamount     IN NUMBER
	   ,pentryident IN VARCHAR2
	   ,pvaluedate  IN DATE := NULL
	   ,pdocno      IN typedocno := NULL
	   ,pentryno    IN typeentryno := NULL
	) RETURN typetrxnrec IS
		cmethodname CONSTANT typemethodname := cpackagename || '.AddTrxnFromEntry';
		vtrxnrec typetrxnrec;
	BEGIN
		t.enter(cmethodname, pcurno);
	
		IF paccountno = sdepaccount(pcurno).accountno
		THEN
		
			vtrxnrec.branch   := seance.getbranch;
			vtrxnrec.docno    := nvl(pdocno, sdocno);
			vtrxnrec.entryno  := nvl(pentryno, sentryno);
			vtrxnrec.postdate := seance.getoperdate;
			vtrxnrec.trandate := least(nvl(pvaluedate, vtrxnrec.postdate), vtrxnrec.postdate);
			contracttools.readentcode(vtrxnrec.debitentcode, pentryident);
			vtrxnrec.grouptype := custom_contractprofiles.getgrouptypebyentrycode(vtrxnrec.debitentcode);
			vtrxnrec.groupid   := custom_contractprofiles.getgroupidbyentcode(vtrxnrec.debitentcode);
			vtrxnrec.accountno := paccountno;
			vtrxnrec.amount    := pamount;
		
			buildtransaction(pcurno, vtrxnrec);
		
			savetrxntolist(pcurno, vtrxnrec);
		
		END IF;
	
		t.leave(cmethodname, vtrxnrec.accountno);
		RETURN vtrxnrec;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END addtrxnfromentry;

	FUNCTION doentry
	(
		pcurno         IN NUMBER
	   ,odebitaccount  IN OUT contracttools.taccountrecord
	   ,ocreditaccount IN OUT contracttools.taccountrecord
	   ,pcurrency      IN NUMBER
	   ,psum           IN NUMBER
	   ,pentryident    IN typeentryident
	   ,pshortremark   IN typeshortremark := NULL
	   ,pfullremark    IN typefullremark := NULL
	   ,pcheckavl      IN NUMBER := entry.flnocheck
	   ,pvaluedate     IN DATE := NULL
	   ,pdotrxn        IN BOOLEAN := TRUE
	) RETURN typetrxnrec IS
		cmethodname CONSTANT typemethodname := cpackagename || '.DoEntry';
		vresult typetrxnrec;
	BEGIN
		t.enter(cmethodname, psum);
	
		contracttools.validatenumber(psum, 'Entry sum', contracttools.cnum_nonnegative);
	
		sdummynum := contracttools.addentry(contracttypeschema.scontractrow
										   ,sdocno
										   ,sentryno
										   ,odebitaccount
										   ,ocreditaccount
										   ,pcurrency
										   ,psum
										   ,pentryident
										   ,pshortremark
										   ,NULL
										   ,pcheckavl
										   ,pfullremark
										   ,pvaluedate => pvaluedate);
	
		IF pdotrxn
		THEN
		
			IF psum > 0
			THEN
			
				vresult := addtrxnfromentry(pcurno
										   ,odebitaccount.accountno
										   ,-psum
										   ,pentryident
										   ,pvaluedate);
			
				IF vresult.accountno IS NULL
				THEN
					vresult := addtrxnfromentry(pcurno
											   ,ocreditaccount.accountno
											   ,psum
											   ,pentryident
											   ,pvaluedate);
				END IF;
			
				IF vresult.accountno IS NULL
				THEN
					t.note(cmethodname
						  ,'Warning: transaction creation skipped as there is no card account in entry!');
				END IF;
			
			ELSE
				t.note(cmethodname, 'Warning: transaction creation skipped as entry sum is 0!');
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END doentry;

	PROCEDURE doentry
	(
		pcurno         IN NUMBER
	   ,odebitaccount  IN OUT contracttools.taccountrecord
	   ,ocreditaccount IN OUT contracttools.taccountrecord
	   ,pcurrency      IN NUMBER
	   ,psum           IN NUMBER
	   ,pentryident    IN typeentryident
	   ,pshortremark   IN typeshortremark := NULL
	   ,pfullremark    IN typefullremark := NULL
	   ,pcheckavl      IN NUMBER := entry.flnocheck
	   ,pvaluedate     IN DATE := NULL
	   ,pdotrxn        IN BOOLEAN := TRUE
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.DoEntry';
		vtrxnrec typetrxnrec;
	BEGIN
		t.enter(cmethodname, psum);
	
		vtrxnrec := doentry(pcurno
						   ,odebitaccount
						   ,ocreditaccount
						   ,pcurrency
						   ,psum
						   ,pentryident
						   ,pshortremark
						   ,pfullremark
						   ,pcheckavl
						   ,pvaluedate
						   ,pdotrxn);
	
		IF pdotrxn
		   AND (vtrxnrec.accountno IS NOT NULL)
		THEN
			dorepayment(pcurno, vtrxnrec);
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END doentry;

	PROCEDURE chargelimitchangefee
	(
		pcurno     IN NUMBER
	   ,pparamid   IN NUMBER
	   ,poldvalue  IN NUMBER
	   ,pnewvalue  IN NUMBER
	   ,poperation IN PLS_INTEGER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ChargeLimitChangeFee';
		vprofileid  valuechangefee.typeprofileid := sactparamccy(pcurno) (pparamid);
		vcommission NUMBER;
	BEGIN
		t.enter(cmethodname
			   ,'CurNo = ' || pcurno || ', ParamID = ' || pparamid || ', OldValue = ' || poldvalue ||
				', NewValue = ' || pnewvalue);
	
		IF vprofileid IS NOT NULL
		THEN
		
			vcommission := valuechangefee.calccommission(vprofileid
														,poldvalue
														,pnewvalue
														,sprecision(pcurno)
														,seance.getoperdate);
		
			IF vcommission > 0
			THEN
				doentry(pcurno
					   ,sdepaccount(pcurno)
					   ,sabaccounts(pcurno) (cb_incacclimitchangefee)
					   ,sdepaccount(pcurno).currencyno
					   ,vcommission
					   ,referenceentry.getident(valuechangefee.getprofile(vprofileid).entrycode)
					   ,pdotrxn => poperation = cadjusting);
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END chargelimitchangefee;

	PROCEDURE getinstallmentcontract
	(
		pcurno                IN NUMBER
	   ,pcontracttype         IN typecontracttype
	   ,psearchforexisting    IN BOOLEAN
	   ,poinstallmentcontract IN OUT NOCOPY apitypes.typecontractrecord
	   ,oinstallmentaccount   OUT NOCOPY contracttools.taccountrecord
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetInstallmentContract';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vnoarray contractlink.typecontractarray;
	BEGIN
		t.enter(cmethodname);
	
		IF psearchforexisting
		   AND (contractlink.getlinkno(scontractno
									  ,contractlink.cmain
									  ,vnoarray
									  ,cinstlinkname
									  ,sdepaccount(pcurno).currencyno) > 0)
		THEN
			FOR i IN 1 .. vnoarray.count
			LOOP
				poinstallmentcontract := contract.getcontractrecord(vnoarray(i).cno);
				EXIT WHEN(poinstallmentcontract.type = pcontracttype) AND(NOT
																		   contract.checkstatus(poinstallmentcontract.status
																							   ,contract.stat_close));
				poinstallmentcontract := NULL;
			END LOOP;
		END IF;
	
		IF poinstallmentcontract.no IS NULL
		THEN
		
			poinstallmentcontract.type     := pcontracttype;
			poinstallmentcontract.idclient := contract.getidclient(scontractno);
		
			contract.createcontract(poinstallmentcontract
								   ,'MAINCNTRNO=' || scontractno || ';LIMIT=1@0@100');
			contractrb.setlabel(crl_createcontract);
			contractrb.setcvalue('NO', poinstallmentcontract.no);
		
			SELECT *
			INTO   contracttypeschema.scontractrow
			FROM   tcontract
			WHERE  branch = cbranch
			AND    no = scontractno;
		
		ELSIF NOT contractlink.existscontractlink(contractlink.cmain
												 ,scontractno
												 ,poinstallmentcontract.no
												 ,cinstlinkname
												 ,sdepaccount(pcurno).currencyno)
		THEN
		
			contractlink.addcontractlink(contractlink.cmain
										,scontractno
										,poinstallmentcontract.no
										,cinstlinkname
										,sdepaccount(pcurno).currencyno);
			contractrb.setlabel(crl_linkcontract);
			contractrb.setcvalue('NO', poinstallmentcontract.no);
			contractrb.setcvalue('LC', sdepaccount(pcurno).currencyno);
		
		END IF;
	
		contracttools.loadcontractaccountbyaccno(getinstallmentaccount(poinstallmentcontract.no)
												,oinstallmentaccount
												,c_doexception);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getinstallmentcontract;

	PROCEDURE startnewinstallment
	(
		pcurno          IN NUMBER
	   ,pinstcontractno IN typecontractno
	   ,pmode           IN PLS_INTEGER
	   ,ploanno         IN NUMBER
	   ,pamount         IN NUMBER
	   ,pdocno          IN typedocno
	   ,pentryno        IN typeentryno
	   ,precno          IN NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.StartNewInstallment';
		coperdate   CONSTANT DATE := seance.getoperdate;
		cbranch     CONSTANT NUMBER := seance.getbranch;
	BEGIN
		t.enter(cmethodname);
	
		CASE pmode
		
			WHEN cim_manual THEN
				INSERT INTO tcontracttrxninstallment
				VALUES
					(cbranch
					,scontractno
					,sdepaccount(pcurno).accountno
					,pinstcontractno
					,0
					,precno
					,pdocno
					,pentryno
					,ploanno
					,pmode
					,0
					,0
					,pamount
					,coperdate
					,NULL);
			
			WHEN cim_auto THEN
				INSERT INTO tcontracttrxninstallment
				VALUES
					(cbranch
					,scontractno
					,sdepaccount(pcurno).accountno
					,pinstcontractno
					,getpackno
					,precno
					,pdocno
					,pentryno
					,ploanno
					,pmode
					,1
					,0
					,pamount
					,coperdate
					,coperdate);
			
			ELSE
				error.raiseerror('Internal error: unsupported installment create type <' || pmode || '>!');
		END CASE;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END startnewinstallment;

	PROCEDURE installmententrypost
	(
		pcurno      IN NUMBER
	   ,paccountno  IN typeaccountno
	   ,pamount     IN NUMBER
	   ,pentryident IN typeentryident
	   ,pdocno      IN typedocno
	   ,pentryno    IN typeentryno
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.InstallmentEntryPost';
		vtrxnrec typetrxnrec;
	BEGIN
		t.enter(cmethodname);
	
		vtrxnrec := addtrxnfromentry(pcurno
									,paccountno
									,pamount
									,pentryident
									,NULL
									,pdocno
									,pentryno);
	
		dorepayment(pcurno, vtrxnrec);
	
		t.leave(cmethodname, vtrxnrec.accountno);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END installmententrypost;

	FUNCTION checkright
	(
		popercode IN VARCHAR2
	   ,pprop     IN VARCHAR2
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CheckRight';
	BEGIN
		RETURN contract.checkoperright(contract.right_modify_oper
									  ,contracttypeschema.scontractrow.no
									  ,popercode
									  ,pprop);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END checkright;

	FUNCTION getcardrecord
	(
		ppan IN typepan
	   ,pmbr IN typembr
	) RETURN apitypes.typecardrecord IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCardRecord';
		vresult apitypes.typecardrecord;
	BEGIN
		t.enter(cmethodname, masktodebug(ppan, pmbr));
	
		err.seterror(0, cmethodname);
		vresult := card.getcardrecord(ppan, pmbr);
		error.raisewhenerr;
	
		t.leave(cmethodname);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcardrecord;

	FUNCTION getcardrecord(ppanmbr IN VARCHAR2) RETURN apitypes.typecardrecord IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCardRecord';
		vpan typepan;
		vmbr typembr;
	BEGIN
		contracttools.parsecardstring(ppanmbr, vpan, vmbr, '-');
		RETURN getcardrecord(vpan, vmbr);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcardrecord;

	FUNCTION getcardownership
	(
		ppan IN typepan
	   ,pmbr IN typembr
	) RETURN PLS_INTEGER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCardOwnership';
	BEGIN
		IF getcardrecord(ppan, pmbr).idclient = contract.getidclient(scontractno)
		THEN
			RETURN cco_primary;
		ELSE
			RETURN cco_supplementary;
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcardownership;

	FUNCTION getpackno RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetPackNo';
	BEGIN
		IF spackno IS NULL
		THEN
			spackno := seqtrxnlistpackno.nextval;
		END IF;
		RETURN spackno;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getpackno;

	PROCEDURE adddocnotorollback IS
		cmethodname CONSTANT typemethodname := cpackagename || '.AddDocNoToRollback';
	BEGIN
		t.enter(cmethodname);
	
		IF (sdocno IS NOT NULL)
		   AND (sentryno <> 0)
		THEN
			contractrbstd.setentry(sdocno);
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END adddocnotorollback;

	PROCEDURE addadjustingpacknotorollback(plabel IN contractrb.tlabel) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.AddAdjustingPackNoToRollback';
	BEGIN
		t.enter(cmethodname, plabel);
	
		contractrbstd.changecontractparam(scontractno
										 ,'LastAdPackNo'
										 ,contractadjustingpack.getcurrentpackno);
	
		contractrb.setlabel(plabel);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END addadjustingpacknotorollback;

	PROCEDURE addcreditlimittorollback(pcurrency IN NUMBER) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.AddCreditLimitToRollback';
	BEGIN
		t.enter(cmethodname);
	
		contractrb.setlabel(crl_limit);
		contractrb.setnvalue('CC', pcurrency);
		contractrb.setcvalue('AC', sdepaccount(pcurrency).accountno);
		contractrb.setnvalue('CL', sdepaccount(pcurrency).overdraft);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END addcreditlimittorollback;

	PROCEDURE startoperation(pstartnewdocument IN BOOLEAN := TRUE) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.StartOperation';
	BEGIN
		t.enter(cmethodname, htools.b2s(pstartnewdocument));
	
		IF pstartnewdocument
		THEN
			startnewdocument;
		END IF;
	
		spackno      := NULL;
		shistpackno  := NULL;
		slimitpackno := NULL;
		schangedtrxns.delete;
	
		sprcchargedom.delete;
		sprcchargeint.delete;
	
		sminpaymentod.delete;
		sminpaymentdd.delete;
	
		ssdbalancedd.delete;
		ssdbalanceod.delete;
	
		custom_overdueparameterscalculation.clearcache;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END startoperation;

	PROCEDURE setoperationrollbackdata
	(
		pcyclerecno IN NUMBER := NULL
	   ,padddocno   IN BOOLEAN := TRUE
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SetOperationRollbackData';
	BEGIN
	
		IF padddocno
		THEN
			adddocnotorollback;
		END IF;
	
		IF spackno IS NOT NULL
		THEN
			contractrb.setlabel(crl_packnosaved);
			contractrb.setnvalue('PackNo', spackno);
			contractrb.setnvalue('IsDD', htools.b2i(snowduedate));
			contractrb.setnvalue('IsSD', htools.b2i(snowstatementdate));
		END IF;
	
		IF pcyclerecno IS NOT NULL
		THEN
			contractrb.setlabel(crl_calculatedsd);
			contractrb.setnvalue('RecNo', pcyclerecno);
		END IF;
	
		IF shistpackno IS NOT NULL
		THEN
			contractrb.setlabel(crl_histpacknosaved);
			contractrb.setnvalue('PackNo', shistpackno);
		END IF;
	
		IF slimitpackno IS NOT NULL
		THEN
			contractrb.setlabel(crl_limitpacknosaved);
			contractrb.setnvalue('PackNo', slimitpackno);
		END IF;
	
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END setoperationrollbackdata;

	PROCEDURE raiseextmethodcallerror
	(
		pcallername    IN typemethodname
	   ,pextmethodname IN typemethodname
	) IS
	BEGIN
		t.exc(pcallername);
		error.raiseerror('Cannot call method <' || pextmethodname || '>!');
	END raiseextmethodcallerror;

	FUNCTION getmasteraccount(pcurrency IN NUMBER) RETURN typeaccountno IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetMasterAccount';
		vresult typeaccountno;
	BEGIN
		t.enter(cmethodname, pcurrency);
	
		EXECUTE IMMEDIATE 'begin :Result:= SCH_Corporate.GetMasterAccount(:ContractNo, :Currency); end;'
			USING OUT vresult, IN getcorpcontractnumber, IN pcurrency;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getmasteraccount;

	FUNCTION getparentaccount
	(
		pcurrency      IN NUMBER
	   ,pfromaggregate IN BOOLEAN
	) RETURN typeaccountno IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetParentAccount';
		vresult typeaccountno;
	BEGIN
		t.enter(cmethodname, pcurrency);
	
		EXECUTE IMMEDIATE 'begin :Result:= SCH_Corporate.GetParentAccount(:ContractNo, :Currency,' ||
						  htools.b2s(pfromaggregate) || ').AccountNo; end;'
			USING OUT vresult, IN getcorpcontractnumber, IN pcurrency;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getparentaccount;

	FUNCTION getpaymentaccount(pcurrency IN NUMBER) RETURN typeaccountno IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetPaymentAccount';
		vresult typeaccountno;
	BEGIN
		t.enter(cmethodname, pcurrency);
	
		EXECUTE IMMEDIATE 'begin :Result:= SCH_Corporate.GetPaymentAccount(:ContractNo, :Currency).AccountNo; end;'
			USING OUT vresult, IN getcorpcontractnumber, IN pcurrency;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getpaymentaccount;

	FUNCTION getcorporatebankaccount
	(
		pcurrency    IN NUMBER
	   ,pdoexception IN BOOLEAN := c_doexception
	) RETURN typeaccountno IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCorporateBankAccount';
		vresult typeaccountno;
	BEGIN
		t.enter(cmethodname, pcurrency);
	
		EXECUTE IMMEDIATE 'begin :Result:= SCH_Corporate.GetBankAccount(:ContractNo, :Currency, :DoException); end;'
			USING OUT vresult, IN getcorpcontractnumber, IN pcurrency, IN htools.b2i(pdoexception);
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcorporatebankaccount;

	FUNCTION credlimitexceedcorplimit
	(
		pcurno    IN NUMBER
	   ,pnewlimit IN NUMBER
	   ,oavllimit OUT NUMBER
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CredLimitExceedCorpLimit';
		vresult BOOLEAN := FALSE;
		vdelta  NUMBER;
		vret    NUMBER;
	BEGIN
		t.enter(cmethodname, pcurno);
	
		IF hascorporatecontract
		THEN
		
			vdelta := pnewlimit - getobjectlimitssetup(scontractno, pcurno).credlimit.amount;
		
			IF vdelta > 0
			THEN
			
				EXECUTE IMMEDIATE 'begin :Result:= Service.Iif(SCH_Corporate.CredLimitCanBeSet(:ContractNo, :Currency, :Delta, :AvlLimit), 0, 1); end;'
					USING OUT vret, IN getcorpcontractnumber, IN sdepaccount(pcurno).currencyno, IN vdelta, OUT oavllimit;
				vresult := htools.i2b(vret);
			
			END IF;
		
		END IF;
	
		t.leave(cmethodname, htools.b2s(vresult));
		RETURN vresult;
	EXCEPTION
		WHEN excmethodnotfound THEN
			t.exc(cmethodname);
			error.raiseerror('Internal error: cannot call ''CredLimitCanBeSet''~method from ''SCH_Corporate'' package!');
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END credlimitexceedcorplimit;

	FUNCTION cashlimitexceedcorplimit
	(
		pcurno        IN NUMBER
	   ,pcurrentlimit IN NUMBER
	   ,pnewlimit     IN NUMBER
	   ,oavllimit     OUT NUMBER
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CashLimitExceedCorpLimit';
		vresult BOOLEAN := FALSE;
		vdelta  NUMBER;
		vret    NUMBER;
	BEGIN
		t.enter(cmethodname, pcurno);
	
		IF hascorporatecontract
		THEN
		
			vdelta := pnewlimit - pcurrentlimit;
		
			IF vdelta > 0
			THEN
			
				EXECUTE IMMEDIATE 'begin :Result:= Service.Iif(SCH_Corporate.CashLimitCanBeSet(:ContractNo, :Currency, :Delta, :AvlLimit), 0, 1); end;'
					USING OUT vret, IN getcorpcontractnumber, IN sdepaccount(pcurno).currencyno, IN vdelta, OUT oavllimit;
				vresult := htools.i2b(vret);
			
			END IF;
		
		END IF;
	
		t.leave(cmethodname, htools.b2s(vresult));
		RETURN vresult;
	EXCEPTION
		WHEN excmethodnotfound THEN
			t.exc(cmethodname);
			error.raiseerror('Internal error: cannot call ''CashLimitCanBeSet''~method from ''SCH_Corporate'' package!');
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END cashlimitexceedcorplimit;

	FUNCTION canexceedlimit
	(
		pcurrency IN NUMBER
	   ,oavllimit OUT NUMBER
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CanExceedLimit';
		vresult BOOLEAN;
		vret    NUMBER;
	BEGIN
		t.enter(cmethodname, pcurrency);
	
		EXECUTE IMMEDIATE 'begin :Result:= hTools.b2i(SCH_Corporate.CanExceedLimit(:ContractNo, :Currency, :Limit)); end;'
			USING OUT vret, IN getcorpcontractnumber, IN pcurrency, OUT oavllimit;
		vresult := htools.i2b(vret);
	
		t.leave(cmethodname, htools.b2s(vresult));
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END canexceedlimit;

	FUNCTION canexceedacccashlimit
	(
		pcurrencyno            IN NUMBER
	   ,oavailableacccashlimit OUT NUMBER
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CanExceedAccCashLimit';
		vresult BOOLEAN := TRUE;
		vret    NUMBER;
	BEGIN
		t.enter(cmethodname, pcurrencyno);
	
		IF hascorporatecontract
		THEN
		
			EXECUTE IMMEDIATE 'begin :Result:= hTools.b2i(SCH_Corporate.CanExceedAccCashLimit(:ContractNo, :Currency, :AvlLimit)); end;'
				USING OUT vret, IN getcorpcontractnumber, IN pcurrencyno, OUT oavailableacccashlimit;
			vresult := htools.i2b(vret);
		
		END IF;
	
		t.leave(cmethodname, htools.b2s(vresult));
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END canexceedacccashlimit;

	FUNCTION wasoverdraft
	(
		pcontractno IN typecontractno
	   ,pcurrency   IN NUMBER
	   ,pbegindate  IN DATE
	   ,penddate    IN DATE
	) RETURN BOOLEAN IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.WasOverdraft';
		cextmethodname CONSTANT typemethodname := ccorppackagename || '.WasOverdraft';
		vresult NUMBER;
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		EXECUTE IMMEDIATE 'begin :Result:= hTools.b2i(' || cextmethodname ||
						  '(:ContractNo, :Currency, :BeginDate, :EndDate)); end;'
			USING OUT vresult, IN pcontractno, IN pcurrency, IN pbegindate, IN penddate;
	
		t.leave(cmethodname, vresult);
		RETURN htools.i2b(vresult);
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END wasoverdraft;

	FUNCTION getinstallmentmanagementdialog RETURN NUMBER IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.GetInstallmentManagementDialog';
		cextmethodname CONSTANT typemethodname := cinstpackagename ||
												  '.InstallmentManagementDialog';
		vresult NUMBER;
	BEGIN
		t.enter(cmethodname);
	
		EXECUTE IMMEDIATE 'begin :Result:= ' || cextmethodname ||
						  '(:ContractNo, :PaidToInst, :DepAccountArray); end;'
			USING OUT vresult, IN scontractno, IN spaidtoinst, IN sdepaccount;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getinstallmentmanagementdialog;

	FUNCTION getinstallmentaccount(pcontractno IN typecontractno) RETURN typeaccountno IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.GetInstallmentAccount';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.GetAccountNo';
		vresult typeaccountno;
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		EXECUTE IMMEDIATE 'begin :Result:= ' || cextmethodname || '(:ContractNo); end;'
			USING OUT vresult, IN pcontractno;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getinstallmentaccount;

	FUNCTION getinstallmentloanno
	(
		pdocno   IN typedocno
	   ,pentryno IN typeentryno
	) RETURN NUMBER IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.GetInstallmentLoanNo';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.GetLoanNoByEntry';
		vresult NUMBER := 0;
	BEGIN
		t.enter(cmethodname, 'DocNo = ' || pdocno || ', pEntryNo = ' || pentryno);
	
		IF sactparam(cctp_useinst) = '1'
		THEN
			EXECUTE IMMEDIATE 'begin :Result:= ' || cextmethodname || '(:DocNo, :EntryNo); end;'
				USING OUT vresult, IN pdocno, IN pentryno;
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getinstallmentloanno;

	FUNCTION gettransferfeeparams
	(
		pcontractno   IN typecontractno
	   ,ploanno       IN NUMBER
	   ,pprecision    IN NUMBER
	   ,ofeemode      OUT NUMBER
	   ,pamount       IN NUMBER
	   ,ofeeaccountno OUT NOCOPY typeaccountno
	) RETURN NUMBER IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.GetTransferFeeParams';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.GetTransferFeeParams';
		vfeeamount NUMBER;
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		EXECUTE IMMEDIATE 'begin :Result:= ' || cextmethodname ||
						  '(:ContractNo, :pLoanNo, :pPrecision, :pFeeMode, :pAmount, :pAccount); end;'
			USING OUT vfeeamount, IN pcontractno, IN ploanno, IN pprecision, OUT ofeemode, IN pamount, OUT ofeeaccountno;
	
		t.leave(cmethodname
			   ,'FeeMode = ' || ofeemode || ', FeeAmount = ' || vfeeamount || ', FeeAccount = ' ||
				ofeeaccountno);
		RETURN vfeeamount;
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END gettransferfeeparams;

	FUNCTION getusedinstallmentlimit(pcontractno IN typecontractno) RETURN NUMBER IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.GetUsedInstallmentLimit';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.GetUsedLimit';
		vresult NUMBER;
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		EXECUTE IMMEDIATE 'begin :Result:= ' || cextmethodname || '(:ContractNo); end;'
			USING OUT vresult, IN pcontractno;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getusedinstallmentlimit;

	FUNCTION getinstallmentrepaymentamount
	(
		pcontractno    IN typecontractno
	   ,pstatementdate IN DATE
	   ,poperation     IN PLS_INTEGER := cadjusting
	) RETURN NUMBER IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.GetInstallmentRepaymentAmount';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.GetRepaymentAmount';
		vresult NUMBER;
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		EXECUTE IMMEDIATE 'begin :Result:= ' || cextmethodname ||
						  '(:ContractNo, :Date, :Operation); end;'
			USING OUT vresult, IN pcontractno, IN pstatementdate, IN poperation;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getinstallmentrepaymentamount;

	FUNCTION getinstallmentunpaidinterest(pcontractno IN typecontractno) RETURN NUMBER IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.GetInstallmentUnpaidInterest';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.UnpaidPercent';
		vresult NUMBER;
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		EXECUTE IMMEDIATE 'begin :Result:= ' || cextmethodname || '(:ContractNo); end;'
			USING OUT vresult, IN pcontractno;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getinstallmentunpaidinterest;

	PROCEDURE autocreateinstallment
	(
		pcontractno IN typecontractno
	   ,poanewtrxns IN OUT NOCOPY typetrxnarray
	) IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.AutoCreateInstallment';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.CreateLoanAuto';
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		EXECUTE IMMEDIATE 'begin ' || cextmethodname || '(:ContractNo, :NewTrxns); end;'
			USING IN pcontractno, IN OUT poanewtrxns;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END autocreateinstallment;

	FUNCTION createloanforamount
	(
		pcontractno IN typecontractno
	   ,pamount     IN NUMBER
	) RETURN NUMBER IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.CreateLoanForAmount';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.CreateLoanForAmount';
		vresult NUMBER;
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		EXECUTE IMMEDIATE 'begin :Result:= ' || cextmethodname || '(:ContractNo, :Amount); end;'
			USING OUT vresult, IN pcontractno, IN pamount;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END createloanforamount;

	PROCEDURE installmentrepayment
	(
		pcurno     IN NUMBER
	   ,poperation IN PLS_INTEGER
	) IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.InstallmentRepayment';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.InstallmentRepayment';
	BEGIN
		t.enter(cmethodname);
	
		IF sactparam(cctp_useinst) = '1'
		THEN
			EXECUTE IMMEDIATE 'begin ' || cextmethodname ||
							  '(:CurNo, :DocNo, :EntryNo, :Operation, :ContractNo, :CycleRecNo, :NowStDate, :InstDoOneEntry, :CardAccNo, :CardAccCur, :CardAccRemain); end;'
				USING IN pcurno, IN OUT sdocno, IN OUT sentryno, IN poperation, IN scontractno, IN getcurrentcycle().recno, IN htools.b2i(snowstatementdate), IN sactparam(cctp_instdooneentry), IN sdepaccount(pcurno).accountno, IN sdepaccount(pcurno).currencyno, IN OUT sdepaccount(pcurno).remain;
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END installmentrepayment;

	FUNCTION reverseinstallment
	(
		pcurno  IN NUMBER
	   ,ploanno IN NUMBER
	   ,psum    IN NUMBER
	) RETURN NUMBER IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.ReverseInstallment';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.ReverseTransaction';
		vresult NUMBER := 0;
	BEGIN
		t.enter(cmethodname);
	
		IF sactparam(cctp_useinst) = '1'
		THEN
			EXECUTE IMMEDIATE 'begin :Result:= ' || cextmethodname ||
							  '(:DocNo, :EntryNo, :ContractNo, :CycleRecNo, :CardAccNo, :CardAccCur, :CardAccRemain, :LoanNo, :Sum); end;'
				USING OUT vresult, IN OUT sdocno, IN OUT sentryno, IN scontractno, IN getcurrentcycle().recno, IN sdepaccount(pcurno).accountno, IN sdepaccount(pcurno).currencyno, IN OUT sdepaccount(pcurno).remain, IN ploanno, IN psum;
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END reverseinstallment;

	PROCEDURE dofutureinterestentry(ploanno IN NUMBER) IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.DoFutureInterestEntry';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.DoFutureInterestEntry';
	BEGIN
		t.enter(cmethodname);
	
		EXECUTE IMMEDIATE 'begin ' || cextmethodname || '(:DocNo, :EntryNo, :LoanNo); end;'
			USING IN OUT sdocno, IN OUT sentryno, IN ploanno;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dofutureinterestentry;

	PROCEDURE installmentcontractsclosure(pcurno IN NUMBER) IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.InstallmentContractsClosure';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.CloseContract';
		vnoarray contractlink.typecontractarray;
	BEGIN
		t.enter(cmethodname, 'pCurNo = ' || pcurno || ', sContractNo = ' || scontractno);
	
		installmentrepayment(pcurno, cclosing);
	
		IF contractlink.getlinkno(scontractno
								 ,contractlink.cmain
								 ,vnoarray
								 ,cinstlinkname
								 ,sdepaccount(pcurno).currencyno) > 0
		THEN
			FOR i IN 1 .. vnoarray.count
			LOOP
			
				IF contract.getcontractrecord(vnoarray(i).cno).closedate IS NULL
				THEN
					EXECUTE IMMEDIATE 'begin ' || cextmethodname || '(:ContractNo, null); end;'
						USING IN vnoarray(i).cno;
				END IF;
			END LOOP;
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END installmentcontractsclosure;

	PROCEDURE commitloan
	(
		ploanno  IN NUMBER
	   ,pentryno IN typeentryno
	) IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.CommitLoan';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.CommitLoan';
	BEGIN
		t.enter(cmethodname, ploanno);
	
		EXECUTE IMMEDIATE 'begin ' || cextmethodname || '(:LoanNo, :DocNo, :EntryNo); end;'
			USING IN ploanno, IN sdocno, IN pentryno;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END commitloan;

	PROCEDURE undocommitloan(ploanno IN NUMBER) IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.UndoCommitLoan';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.UndoCommitLoan';
	BEGIN
		t.enter(cmethodname, ploanno);
	
		EXECUTE IMMEDIATE 'begin ' || cextmethodname || '(:LoanNo); end;'
			USING IN ploanno;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END undocommitloan;

	PROCEDURE rollbackloan(ploanno IN NUMBER) IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.RollbackLoan';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.RollbackLoan';
	BEGIN
		t.enter(cmethodname, ploanno);
	
		EXECUTE IMMEDIATE 'begin ' || cextmethodname || '(:LoanNo); end;'
			USING IN ploanno;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END rollbackloan;

	PROCEDURE undoloanrepayment
	(
		ploanno IN NUMBER
	   ,ppackno IN NUMBER
	) IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.UndoLoanRepayment';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.UndoLoanRepayment';
	BEGIN
		t.enter(cmethodname, 'pLoanNo = ' || ploanno || ', pPackNo = ' || ppackno);
	
		EXECUTE IMMEDIATE 'begin ' || cextmethodname || '(:LoanNo, :PackNo); end;'
			USING IN ploanno, IN ppackno;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END undoloanrepayment;

	PROCEDURE tamcclearcache IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.TAMCClearCache';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.TAMCCacheClear';
	BEGIN
		t.enter(cmethodname);
	
		IF sactparam(cctp_useinst) = '1'
		THEN
			EXECUTE IMMEDIATE 'begin ' || cextmethodname || '; end;';
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END tamcclearcache;

	FUNCTION markforinstallmenttransfer
	(
		prcmaccountno   IN typeaccountno
	   ,pdocno          IN typedocno
	   ,pentryno        IN typeentryno
	   ,pinstcontractno IN typecontractno
	   ,ptransfermode   IN PLS_INTEGER
	   ,pcycles         IN NUMBER
	   ,pregrepayment   IN NUMBER
	) RETURN NUMBER IS
		cmethodname    CONSTANT typemethodname := cpackagename || '.MarkForInstallmentTransfer';
		cextmethodname CONSTANT typemethodname := cinstpackagename || '.RCM_MarkForTransfer';
	
		vtrxn   typetrxnrec;
		vamount NUMBER;
		vloanno NUMBER;
		vcurno  NUMBER;
	
	BEGIN
		t.enter(cmethodname);
	
		contracttools.raiseif(sactparam(cctp_useinst) <> '1'
							 ,'Installments are not used in contract type <' || scontracttype || '>!');
	
		vcurno := getcurnobyaccountno(prcmaccountno);
	
		contracttools.raiseif(NOT ifcurrencyisusedintype(vcurno, scontracttype)
							 ,'Currency <' || slabel(vcurno) || '> is not used in contract type <' ||
							  scontracttype || '>!');
	
		vtrxn := gettrxn(prcmaccountno, pdocno, pentryno);
	
		contracttools.raiseif(vtrxn.trantype <> ctrxntype_debit
							 ,'Transaction with type <' || gettrxntypedescription(vtrxn.trantype) ||
							  '> cannot be transferred to installment!');
	
		CASE ptransfermode
		
			WHEN cunpaidonly THEN
			
				contracttools.raiseif(vtrxn.paidfull = 1
									 ,'Transaction with DocNo/EntryNo <' || pdocno || '/' ||
									  pentryno || '> has already been paid!');
			
				vamount := vtrxn.amount - vtrxn.paidamount;
			
			WHEN cfullamount THEN
			
				vamount := vtrxn.amount;
			
			ELSE
				error.raiseerror('Error: unsupported amount transfer mode <' || ptransfermode || '>!');
		END CASE;
	
		EXECUTE IMMEDIATE 'begin :Result:= ' || cextmethodname ||
						  '(:RCMContractNo, :RCMAccountNo, :InstContractNo, :DocNo, :EntryNo, :RecNo, :Amount, :Cycles, :RegRepayment); end;'
			USING OUT vloanno, IN scontractno, IN prcmaccountno, IN pinstcontractno, IN pdocno, IN pentryno, IN vtrxn.recno, IN vamount, IN pcycles, IN pregrepayment;
	
		contractrb.setlabel(crl_instmark, scontractno);
	
		contractrb.setnvalue('LoanNo', vloanno);
	
		t.leave(cmethodname, vamount);
		RETURN vamount;
	EXCEPTION
		WHEN excmethodnotfound THEN
			raiseextmethodcallerror(cmethodname, cextmethodname);
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END markforinstallmenttransfer;

	FUNCTION ext_markforinstallmenttransfer
	(
		prcmaccountno   IN typeaccountno
	   ,pdocno          IN typedocno
	   ,pentryno        IN typeentryno
	   ,pinstcontractno IN typecontractno
	   ,pmode           IN PLS_INTEGER
	   ,pcycles         IN NUMBER := NULL
	   ,pregrepayment   IN NUMBER := NULL
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Ext_MarkForInstallmentTransfer';
		vrcmcontractno typecontractno;
		vresult        NUMBER;
	BEGIN
		t.enter(cmethodname);
	
		vrcmcontractno := contract.getcontractbyaccount(prcmaccountno, c_doexception).contractno;
	
		contracttools.raiseif(contracttools.notequal(upper(contracttypeschema.getschemapackagebycontractno(vrcmcontractno))
													,upper(cpackagename))
							 ,'Contract <' || vrcmcontractno || '> does not belong to RCM module!');
	
		initcontract(vrcmcontractno);
	
		vresult := markforinstallmenttransfer(prcmaccountno
											 ,pdocno
											 ,pentryno
											 ,pinstcontractno
											 ,pmode
											 ,pcycles
											 ,pregrepayment);
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END ext_markforinstallmenttransfer;

	FUNCTION gettemplimitdescr
	(
		plimittype           IN PLS_INTEGER
	   ,pobjectlimitsettings IN typeobjectlimitsettings
	) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetTempLimitDescr';
	BEGIN
		RETURN 'Temporary ' || CASE plimittype WHEN ctempcredlimit THEN 'credit' ELSE 'cash' END || ' limit in ' || getvaluebycurno(pobjectlimitsettings.curno
																																   ,'domestic'
																																   ,'international') || ' currency ' || service.iif(pobjectlimitsettings.pan IS NULL
																																												   ,'for account'
																																												   ,'for card ' ||
																																													masktolog(pobjectlimitsettings.pan
																																															 ,pobjectlimitsettings.mbr));
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END gettemplimitdescr;

	FUNCTION getlimittypedescr(plimittype IN PLS_INTEGER) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetLimitTypeDescr [by limit type]';
		vresult VARCHAR2(20);
	BEGIN
		t.enter(cmethodname, plimittype);
	
		IF calimittypelabel.exists(plimittype)
		THEN
			vresult := calimittypelabel(plimittype);
		ELSE
			error.raiseerror('Unknown limit type <' || plimittype || '>!');
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getlimittypedescr;

	FUNCTION getlimittype_int(pcontractno IN typecontractno) RETURN PLS_INTEGER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetLimitType_Int';
		vresult PLS_INTEGER;
	
		PROCEDURE getdata
		(
			pcurno     IN NUMBER
		   ,oacardlist OUT NOCOPY apitypes.typeaccount2cardlist
		   ,ocardcount OUT NUMBER
		) IS
			cmethodname CONSTANT typemethodname := getlimittype_int.cmethodname || '.GetData';
		BEGIN
			t.enter(cmethodname, pcurno);
		
			IF ifcurrencyisusedintype(pcurno, contracttypeschema.scontractrow.type, pcontractno)
			   AND sdepaccount.exists(pcurno)
			THEN
				oacardlist := account.getcardlist(sdepaccount(pcurno).accountno);
				ocardcount := oacardlist.count +
							  customer.getcustomercount(sdepaccount(pcurno).accountno);
			ELSE
				oacardlist.delete;
				ocardcount := 0;
			END IF;
		
			t.leave(cmethodname, ocardcount);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END getdata;
	
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		getdata(1, scardlist1, scardcount1);
		getdata(2, scardlist2, scardcount2);
	
		IF (scardcount1 = 0)
		   AND (scardcount2 = 0)
		THEN
			vresult := cnotdefined;
		
		ELSIF ifcurrencyisusedintype(1, contracttypeschema.scontractrow.type, pcontractno)
			  AND ifcurrencyisusedintype(2, contracttypeschema.scontractrow.type, pcontractno)
		THEN
		
			vresult := service.iif(((scardcount1 > 0) AND (scardcount2 > 0)), cseparate, caggregate);
		ELSE
		
			vresult := cnotused;
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getlimittype_int;

	FUNCTION getlimittypedescr_int(pcontractno IN typecontractno) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetLimitTypeDescr_Int';
	BEGIN
		RETURN getlimittypedescr(getlimittype_int(pcontractno));
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getlimittypedescr_int;

	FUNCTION getaggrlimitcurno RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetAggrLimitCurNo';
		vresult NUMBER;
	BEGIN
		t.enter(cmethodname);
	
		IF scardcount1 > 0
		THEN
			IF scardcount2 = 0
			THEN
				vresult := 1;
			ELSE
				error.raiseerror('Method call for separate limit!');
			END IF;
		ELSIF scardcount2 > 0
		THEN
			vresult := 2;
		ELSE
			error.raiseerror('Method call for not defined limit!');
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getaggrlimitcurno;

	FUNCTION getoppositecurno(pcurno IN NUMBER) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetOppositeCurNo';
	BEGIN
		CASE pcurno
			WHEN 1 THEN
				RETURN 2;
			WHEN 2 THEN
				RETURN 1;
			ELSE
				error.raiseerror('Internal error: unsupported currency number <' || pcurno || '>!');
		END CASE;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getoppositecurno;

	FUNCTION getlimittype(pcontractno IN typecontractno) RETURN PLS_INTEGER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetLimitType';
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		scontracttype                      := contract.gettype(pcontractno);
		contracttypeschema.scontractrow.no := pcontractno;
	
		readsetupscheme(FALSE);
		getcontractdata;
	
		t.leave(cmethodname);
		RETURN getlimittype_int(pcontractno);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getlimittype;

	FUNCTION getlimittypedescr(pcontractno IN typecontractno) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetLimitTypeDescr';
	BEGIN
		RETURN getlimittypedescr(getlimittype(pcontractno));
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getlimittypedescr;

	FUNCTION gettypelimitsetup
	(
		plimitkind IN NUMBER
	   ,pcurno     IN NUMBER
	   ,ppan       IN typepan := NULL
	   ,pmbr       IN typembr := NULL
	) RETURN contracttypelimits.typelimitrecord IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetTypeLimitSetup';
		vobjecttype NUMBER;
		vownership  NUMBER;
	BEGIN
	
		IF ppan IS NULL
		THEN
			vobjecttype := referencelimit.objtype_account;
			vownership  := cco_primary;
		
		ELSE
			vobjecttype := referencelimit.objtype_acc2card;
			vownership  := getcardownership(ppan, pmbr);
		END IF;
		RETURN contracttypelimits.getlimitsettings(scontracttype
												  ,plimitkind
												  ,vobjecttype
												  ,vownership
												  ,pcurno);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END gettypelimitsetup;

	FUNCTION gettypelimitperiod
	(
		plimitkind IN NUMBER
	   ,pcurno     IN NUMBER
	   ,ppan       IN typepan := NULL
	   ,pmbr       IN typembr := NULL
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetTypeLimitPeriod';
	BEGIN
		RETURN gettypelimitsetup(plimitkind, pcurno, ppan, pmbr).periodtype;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END gettypelimitperiod;

	FUNCTION limitrowtorecord(plimitsetuprow IN typelimitsetuprow) RETURN typeobjectlimitsettings IS
		cmethodname CONSTANT typemethodname := cpackagename || '.LimitRowToRecord';
		vresult typeobjectlimitsettings := NULL;
	BEGIN
	
		vresult.curno := plimitsetuprow.currencynumber;
		vresult.pan   := plimitsetuprow.pan;
		vresult.mbr   := plimitsetuprow.mbr;
	
		vresult.credlimit.calcmethod := plimitsetuprow.credlimittype;
		vresult.credlimit.amount     := plimitsetuprow.credlimitamount;
		vresult.credlimit.percent    := plimitsetuprow.credlimitprc;
	
		vresult.cashlimit.calcmethod := plimitsetuprow.cashlimittype;
		vresult.cashlimit.amount     := plimitsetuprow.cashlimitamount;
		vresult.cashlimit.percent    := plimitsetuprow.cashlimitprc;
	
		vresult.tempcredlimit.calcmethod := plimitsetuprow.tempcredlimittype;
		vresult.tempcredlimit.amount     := plimitsetuprow.tempcredlimitamount;
		vresult.tempcredlimit.percent    := plimitsetuprow.tempcredlimitprc;
		vresult.tempcredlimit.validfrom  := plimitsetuprow.tempcredlimitdatefrom;
		vresult.tempcredlimit.validto    := plimitsetuprow.tempcredlimitdate;
		vresult.tempcredlimit.active     := htools.i2b(plimitsetuprow.tempcredlimitactive);
	
		vresult.tempcashlimit.calcmethod := plimitsetuprow.tempcashlimittype;
		vresult.tempcashlimit.amount     := plimitsetuprow.tempcashlimitamount;
		vresult.tempcashlimit.percent    := plimitsetuprow.tempcashlimitprc;
		vresult.tempcashlimit.validfrom  := plimitsetuprow.tempcashlimitdatefrom;
		vresult.tempcashlimit.validto    := plimitsetuprow.tempcashlimitdate;
		vresult.tempcashlimit.active     := htools.i2b(plimitsetuprow.tempcashlimitactive);
	
		vresult.usedcredlimit.amount := plimitsetuprow.usedcredlimit;
		vresult.usedcashlimit.amount := plimitsetuprow.usedcashlimit;
	
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END limitrowtorecord;

	FUNCTION getobjectlimitssetup
	(
		pcontractno IN typecontractno
	   ,pcurno      IN NUMBER
	   ,ppan        IN typepan := NULL
	   ,pmbr        IN typembr := NULL
	) RETURN typeobjectlimitsettings IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetObjectLimitsSetup';
		ciscard     CONSTANT BOOLEAN := ppan IS NOT NULL;
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vcardrecord     apitypes.typecardrecord;
		vresult         typelimitsetuprow;
		vobjectcommited BOOLEAN;
	
		PROCEDURE updateactivityflags(plimitsetuprow IN typelimitsetuprow) IS
			PRAGMA AUTONOMOUS_TRANSACTION;
			cmethodname CONSTANT typemethodname := cpackagename || '.UpdateActivityFlags';
		BEGIN
		
			IF ciscard
			THEN
			
				UPDATE tcontractlimitparams
				SET    tempcredlimitactive = plimitsetuprow.tempcredlimitactive
					  ,tempcashlimitactive = plimitsetuprow.tempcashlimitactive
				WHERE  branch = cbranch
				AND    contractno = pcontractno
				AND    pan = ppan
				AND    mbr = pmbr
				AND    currencynumber = pcurno;
			
			ELSE
			
				UPDATE tcontractlimitparams
				SET    tempcredlimitactive = plimitsetuprow.tempcredlimitactive
					  ,tempcashlimitactive = plimitsetuprow.tempcashlimitactive
				WHERE  branch = cbranch
				AND    contractno = pcontractno
				AND    pan IS NULL
				AND    mbr IS NULL
				AND    currencynumber = pcurno;
			
			END IF;
		
			COMMIT;
		
		EXCEPTION
			WHEN OTHERS THEN
				ROLLBACK;
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END updateactivityflags;
	
		FUNCTION int_getlimitsetup
		(
			pcontractno IN typecontractno
		   ,pcurno      IN NUMBER
		   ,ppan        IN typepan
		   ,pmbr        IN typembr
		) RETURN typelimitsetuprow IS
			cmethodname CONSTANT typemethodname := getobjectlimitssetup.cmethodname ||
												   '.Int_GetLimitSetup';
			vresult typelimitsetuprow;
		BEGIN
			t.enter(cmethodname);
		
			IF ciscard
			THEN
			
				SELECT *
				INTO   vresult
				FROM   tcontractlimitparams
				WHERE  branch = cbranch
				AND    contractno = pcontractno
				AND    pan = ppan
				AND    mbr = pmbr
				AND    currencynumber = pcurno;
			
			ELSE
			
				SELECT *
				INTO   vresult
				FROM   tcontractlimitparams
				WHERE  branch = cbranch
				AND    contractno = pcontractno
				AND    pan IS NULL
				AND    mbr IS NULL
				AND    currencynumber = pcurno;
			
			END IF;
		
			IF (vresult.tempcredlimitactive IS NULL)
			   OR (vresult.tempcashlimitactive IS NULL)
			THEN
				vresult.tempcredlimitactive := coalesce(vresult.tempcredlimitactive
													   ,htools.b2i(vresult.tempcredlimitdate IS NOT NULL));
				vresult.tempcashlimitactive := coalesce(vresult.tempcashlimitactive
													   ,htools.b2i(vresult.tempcashlimitdate IS NOT NULL));
				updateactivityflags(vresult);
			END IF;
		
			t.leave(cmethodname, vresult.contractno);
			RETURN vresult;
		EXCEPTION
			WHEN no_data_found THEN
				t.leave(cmethodname);
				RETURN NULL;
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_getlimitsetup;
	
		PROCEDURE savelimitparams(plimitsetuprow IN typelimitsetuprow) IS
			PRAGMA AUTONOMOUS_TRANSACTION;
			cmethodname CONSTANT typemethodname := cpackagename || '.SaveLimitParams';
		BEGIN
			INSERT INTO tcontractlimitparams VALUES plimitsetuprow;
			COMMIT;
		EXCEPTION
			WHEN OTHERS THEN
				ROLLBACK;
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END savelimitparams;
	
	BEGIN
		t.enter(cmethodname
			   ,'pContractNo = ' || pcontractno || ', pCurNo = ' || pcurno || ', pCard = ' ||
				masktodebug(ppan, pmbr));
	
		IF ciscard
		THEN
		
			IF contracttools.notequal(contract.getcontractbycard(ppan, pmbr).contractno
									 ,pcontractno)
			THEN
				error.raiseerror('Card <' || masktodialog(ppan, pmbr) ||
								 '> does not belong to contract <' || pcontractno || '>!');
			END IF;
		
			vobjectcommited := contracttools.contractcommited(pcontractno) AND
							   contracttools.cardcommited(ppan, pmbr);
		
		ELSE
		
			IF NOT ifcurrencyisusedintype(pcurno, pcontractno => pcontractno)
			THEN
				error.raiseerror('Currency <' || pcurno || '> is not used in contract!');
			END IF;
		
			vobjectcommited := contracttools.contractcommited(pcontractno);
		
		END IF;
	
		vresult := int_getlimitsetup(pcontractno, pcurno, ppan, pmbr);
	
		IF vresult.contractno IS NULL
		THEN
		
			IF ciscard
			THEN
				vcardrecord := getcardrecord(ppan, pmbr);
				IF vcardrecord.parentpan IS NOT NULL
				THEN
					vresult := int_getlimitsetup(pcontractno
												,pcurno
												,vcardrecord.parentpan
												,vcardrecord.parentmbr);
				END IF;
			END IF;
		
			vresult.pan := ppan;
			vresult.mbr := pmbr;
		
			IF vresult.contractno IS NULL
			THEN
			
				vresult.branch         := cbranch;
				vresult.contractno     := pcontractno;
				vresult.currencynumber := pcurno;
			
				vresult.cashlimittype := clmtastype;
			
				vresult.tempcredlimittype   := clmtnotused;
				vresult.tempcredlimitactive := 0;
			
				vresult.tempcashlimittype   := clmtnotused;
				vresult.tempcashlimitactive := 0;
			
				vresult.usedcashlimit := 0;
			
				IF ciscard
				THEN
					vresult.credlimittype := clmtastype;
					vresult.usedcredlimit := 0;
				ELSE
					vresult.credlimittype   := clmtdefined;
					vresult.credlimitamount := sdepaccount(pcurno).overdraft;
				END IF;
			
			END IF;
		
			IF vobjectcommited
			THEN
				savelimitparams(vresult);
			
			ELSE
				INSERT INTO tcontractlimitparams VALUES vresult;
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
		RETURN limitrowtorecord(vresult);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getobjectlimitssetup;

	FUNCTION checklimitbyscore
	(
		pnewlimit IN NUMBER
	   ,pcurno    IN NUMBER
	   ,pscore    OUT NUMBER
	) RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.CheckLimitByScore';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vscoremin NUMBER;
		vscoremax NUMBER;
		vscoreid  NUMBER;
	BEGIN
		t.var('pCurNo', pcurno);
		t.var('OldLimit', sdepaccount(pcurno).overdraft);
		t.var('NewLimit', pnewlimit);
	
		IF nvl(sdepaccount(pcurno).overdraft, 0) = pnewlimit
		THEN
			s.say(cmethodname || ' -> Limit is not changed');
			RETURN 0;
		END IF;
	
		BEGIN
			SELECT scoreid
			INTO   vscoreid
			FROM   tcontractrevscore
			WHERE  branch = cbranch
			AND    contracttype = scontracttype
			AND    scoreprocid = 1
			AND    currencynumber = pcurno;
		EXCEPTION
			WHEN no_data_found THEN
				s.say(cmethodname || ' -> Scoring not used');
				RETURN 0;
		END;
	
		FOR i IN (SELECT *
				  FROM   tcontractrevscorerange
				  WHERE  branch = cbranch
				  AND    contracttype = scontracttype
				  AND    scoreprocid = 1
				  AND    currencynumber = pcurno
				  AND    INTERVAL <= pnewlimit
				  ORDER  BY INTERVAL DESC)
		LOOP
			vscoremin := i.scoremin;
			vscoremax := i.scoremax;
			t.var('vScoreMin', vscoremin);
			t.var('vScoreMax', vscoremax);
			EXIT;
		END LOOP;
		pscore := scoring.calcscore(vscoreid);
		t.var('pScore', pscore);
		IF pscore >= vscoremax
		THEN
			RETURN 1;
		END IF;
		IF pscore >= vscoremin
		THEN
			RETURN 2;
		END IF;
		RETURN 3;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END checklimitbyscore;

	FUNCTION calcobjectlimits
	(
		pcurno      IN NUMBER
	   ,ppan        IN typepan := NULL
	   ,pmbr        IN typembr := NULL
	   ,pconsiderpb IN BOOLEAN := TRUE
	) RETURN typelimitvaluerecord IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CalcObjectLimits';
	
		vresult       typelimitvaluerecord;
		vacccredlimit NUMBER;
		visprimary    BOOLEAN;
		vpbusemode    NUMBER;
		vpbuse        BOOLEAN;
	
		vlimitsforclosedcard referencelimit.tlimitarray;
		vaccountlimitsetup   typeobjectlimitsettings;
		vcardlimitsetup      typeobjectlimitsettings;
		vcardrecord          apitypes.typecardrecord;
	
		FUNCTION calcallowableoverlimit
		(
			pcalctype     IN PLS_INTEGER
		   ,paccountlimit IN NUMBER
		   ,pprc          IN NUMBER
		   ,pflatamount   IN NUMBER
		   ,pprecision    IN NUMBER
		) RETURN NUMBER IS
			cmethodname CONSTANT typemethodname := calcobjectlimits.cmethodname ||
												   '.CalcAllowableOverlimit';
			vresult NUMBER;
			vprc    NUMBER;
		BEGIN
			t.enter(cmethodname
				   ,'pCalcType = ' || pcalctype || ', pAccountLimit = ' || paccountlimit ||
					', pPrc = ' || pprc || ', pFlatAmount = ' || pflatamount || ', pPrecision = ' ||
					pprecision);
		
			vprc := pprc * paccountlimit / 100;
			t.var('Calculated percent from credit limit (vPrc)', vprc);
		
			CASE pcalctype
				WHEN clmtnotdefined THEN
					vresult := 0;
				WHEN clmttotal THEN
					vresult := round(pflatamount + vprc, pprecision);
				WHEN clmtmax THEN
					vresult := round(greatest(pflatamount, vprc), pprecision);
				WHEN clmtmin THEN
					vresult := round(least(pflatamount, vprc), pprecision);
				ELSE
					error.raiseerror('Internal error: unknown calculation method <' || pcalctype || '>!');
			END CASE;
		
			t.leave(cmethodname, vresult);
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END calcallowableoverlimit;
	
	BEGIN
		t.enter(cmethodname
			   ,'Currency number = ' || pcurno || ', Card = ' || masktodebug(ppan, pmbr));
	
		IF ifcurrencyisusedintype(pcurno, scontracttype, scontractno)
		THEN
		
			vaccountlimitsetup := getobjectlimitssetup(scontractno, pcurno);
		
			vacccredlimit := service.iif(vaccountlimitsetup.tempcredlimit.active
										,vaccountlimitsetup.tempcredlimit.amount
										,vaccountlimitsetup.credlimit.amount);
			t.var('Selected AccCredLimit', vacccredlimit);
		
			IF ppan IS NULL
			THEN
			
				vresult.credlimit := vacccredlimit;
			
				IF pconsiderpb
				   AND (sactparamccy(pcurno) (cctp_acccashlimitpbtype) = cpb_increasebase)
				THEN
					vacccredlimit := vacccredlimit + greatest(sdepaccount(pcurno).remain, 0);
				END IF;
			
				IF vaccountlimitsetup.tempcashlimit.active
				THEN
					vresult.cashlimit := contracttypelimits.calclimitvalue(vaccountlimitsetup.tempcashlimit.calcmethod
																		  ,vacccredlimit
																		  ,vaccountlimitsetup.tempcashlimit.percent
																		  ,vaccountlimitsetup.tempcashlimit.amount
																		  ,sprecision(pcurno));
				
				ELSE
				
					IF vaccountlimitsetup.cashlimit.calcmethod = clmtastype
					THEN
						vresult.cashlimit := contracttypelimits.calclimitvalue(scontracttype
																			  ,clk_cashlimit
																			  ,referencelimit.objtype_account
																			  ,cco_primary
																			  ,pcurno
																			  ,vacccredlimit
																			  ,sprecision(pcurno));
					
					ELSE
						vresult.cashlimit := contracttypelimits.calclimitvalue(vaccountlimitsetup.cashlimit.calcmethod
																			  ,vacccredlimit
																			  ,vaccountlimitsetup.cashlimit.percent
																			  ,vaccountlimitsetup.cashlimit.amount
																			  ,sprecision(pcurno));
					END IF;
				END IF;
			
				IF pconsiderpb
				   AND (sactparamccy(pcurno) (cctp_acccashlimitpbtype) = cpb_addtolimit)
				THEN
					vresult.cashlimit := vresult.cashlimit +
										 greatest(sdepaccount(pcurno).remain, 0);
				END IF;
			
				IF nvl(sactparamccy(pcurno) (cctp_accincrscashlimbyallwovl), 0) = 1
				THEN
					vresult.cashlimit := vresult.cashlimit +
										 calcallowableoverlimit(sacparamccy(pcurno) (cp_accoltype)
															   ,vacccredlimit
															   ,sacparamccy(pcurno) (cp_accolprc)
															   ,sacparamccy(pcurno)
																(cp_accolamount)
															   ,sprecision(pcurno));
				END IF;
			
			ELSE
			
				vcardrecord := getcardrecord(ppan, pmbr);
			
				visprimary := vcardrecord.idclient = contract.getidclient(scontractno);
			
				vcardlimitsetup := getobjectlimitssetup(scontractno, pcurno, ppan, pmbr);
			
				IF vcardrecord.pcstat <> referencecrd_stat.card_closed
				THEN
				
					vpbuse := pconsiderpb AND
							  (sactparamccy(pcurno)
							   (service.iif(visprimary, cctp_prilimitbpuse, cctp_suplimitbpuse)) = '1');
				
					IF vpbuse
					THEN
						vpbusemode := sactparamccy(pcurno)
									  (service.iif(visprimary
												  ,cctp_pricashlimitpbtype
												  ,cctp_supcashlimitpbtype));
					END IF;
				
					IF vcardlimitsetup.tempcredlimit.calcmethod = clmtnotused
					THEN
					
						IF vcardlimitsetup.credlimit.calcmethod = clmtastype
						THEN
						
							vresult.credlimit := contracttypelimits.calclimitvalue(scontracttype
																				  ,clk_creditlimit
																				  ,referencelimit.objtype_acc2card
																				  ,service.iif(visprimary
																							  ,cco_primary
																							  ,cco_supplementary)
																				  ,pcurno
																				  ,vacccredlimit
																				  ,sprecision(pcurno));
						
						ELSE
							vresult.credlimit := contracttypelimits.calclimitvalue(vcardlimitsetup.credlimit.calcmethod
																				  ,vacccredlimit
																				  ,vcardlimitsetup.credlimit.percent
																				  ,vcardlimitsetup.credlimit.amount
																				  ,sprecision(pcurno));
						END IF;
					
					ELSE
						vresult.credlimit := contracttypelimits.calclimitvalue(vcardlimitsetup.tempcredlimit.calcmethod
																			  ,vacccredlimit
																			  ,vcardlimitsetup.tempcredlimit.percent
																			  ,vcardlimitsetup.tempcredlimit.amount
																			  ,sprecision(pcurno));
					END IF;
				
					IF vpbuse
					   AND (vpbusemode = cpb_increasebase)
					THEN
						vresult.credlimit := vresult.credlimit +
											 greatest(sdepaccount(pcurno).remain, 0);
					END IF;
				
					IF nvl(sactparamccy(pcurno) (service.iif(visprimary
									   ,cctp_priincrscrdlimbyallwovl
									   ,cctp_supincrscrdlimbyallwovl))
						  ,0) = 1
					THEN
						vresult.credlimit := vresult.credlimit +
											 calcallowableoverlimit(sacparamccy(pcurno)
																	(cp_accoltype)
																   ,vacccredlimit
																   ,sacparamccy(pcurno)
																	(cp_accolprc)
																   ,sacparamccy(pcurno)
																	(cp_accolamount)
																   ,sprecision(pcurno));
					END IF;
				
					IF vcardlimitsetup.tempcashlimit.calcmethod = clmtnotused
					THEN
					
						IF vcardlimitsetup.cashlimit.calcmethod = clmtastype
						THEN
							vresult.cashlimit := contracttypelimits.calclimitvalue(scontracttype
																				  ,clk_cashlimit
																				  ,referencelimit.objtype_acc2card
																				  ,service.iif(visprimary
																							  ,cco_primary
																							  ,cco_supplementary)
																				  ,pcurno
																				  ,vresult.credlimit
																				  ,sprecision(pcurno));
						
						ELSE
							vresult.cashlimit := contracttypelimits.calclimitvalue(vcardlimitsetup.cashlimit.calcmethod
																				  ,vresult.credlimit
																				  ,vcardlimitsetup.cashlimit.percent
																				  ,vcardlimitsetup.cashlimit.amount
																				  ,sprecision(pcurno));
						END IF;
					
					ELSE
						vresult.cashlimit := contracttypelimits.calclimitvalue(vcardlimitsetup.tempcashlimit.calcmethod
																			  ,vresult.credlimit
																			  ,vcardlimitsetup.tempcashlimit.percent
																			  ,vcardlimitsetup.tempcashlimit.amount
																			  ,sprecision(pcurno));
					END IF;
				
					IF vpbuse
					   AND (vpbusemode = cpb_addtolimit)
					THEN
						vresult.cashlimit := vresult.cashlimit +
											 greatest(sdepaccount(pcurno).remain, 0);
					END IF;
				
					IF nvl(sactparamccy(pcurno) (service.iif(visprimary
									   ,cctp_priincrscashlimbyallwovl
									   ,cctp_supincrscashlimbyallwovl))
						  ,0) = 1
					THEN
						vresult.cashlimit := vresult.cashlimit +
											 calcallowableoverlimit(sacparamccy(pcurno)
																	(cp_accoltype)
																   ,vacccredlimit
																   ,sacparamccy(pcurno)
																	(cp_accolprc)
																   ,sacparamccy(pcurno)
																	(cp_accolamount)
																   ,sprecision(pcurno));
					END IF;
				
					IF vpbuse
					   AND (vpbusemode IN (cpb_donotuse, cpb_addtolimit))
					THEN
						vresult.credlimit := vresult.credlimit +
											 greatest(sdepaccount(pcurno).remain, 0);
					END IF;
				
				ELSE
				
					s.say(cmethodname || '     "Card ' || masktodebug(ppan, pmbr) ||
						  ', account number (sDepAccount(' || pcurno || ').AccountNo) = ' || sdepaccount(pcurno)
						  .accountno || ' IS CLOSED');
				
					vlimitsforclosedcard := referencelimit.getacc2cardlimits(ppan
																			,pmbr
																			,sdepaccount(pcurno)
																			 .accountno);
				
					FOR i IN 1 .. vlimitsforclosedcard.count
					LOOP
						IF vlimitsforclosedcard(i).limitid = 102
						THEN
							vresult.cashlimit := nvl(vlimitsforclosedcard(i).maxvalue, 0);
						ELSIF vlimitsforclosedcard(i).limitid = 3
						THEN
							vresult.credlimit := nvl(vlimitsforclosedcard(i).maxvalue, 0);
						END IF;
					END LOOP;
				
					vresult.cashlimit := nvl(vresult.cashlimit, 0);
					vresult.credlimit := nvl(vresult.credlimit, 0);
				
					t.var('vResult.CashLimit', vresult.cashlimit);
					t.var('vResult.CredLimit', vresult.credlimit);
				
				END IF;
			
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END calcobjectlimits;

	FUNCTION getobjectlimits
	(
		pcurno     IN NUMBER
	   ,plimittype IN PLS_INTEGER
	   ,ppan       IN typepan := NULL
	   ,pmbr       IN typembr := NULL
	) RETURN typelimitvaluerecord IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetObjectLimits';
		vsecondlimit typelimitvaluerecord;
		vresult      typelimitvaluerecord;
		vsecondcurno NUMBER;
		vaggrcurno   NUMBER;
	BEGIN
		t.enter(cmethodname);
	
		IF plimittype = caggregate
		THEN
		
			vaggrcurno := getaggrlimitcurno;
		
			vsecondcurno := getoppositecurno(vaggrcurno);
		
			vresult := calcobjectlimits(vaggrcurno, ppan, pmbr);
		
			vsecondlimit := calcobjectlimits(vsecondcurno, ppan, pmbr);
		
			vresult.credlimit := vresult.credlimit +
								 contracttools.getsumincurrency(vsecondlimit.credlimit
															   ,sdepaccount(vsecondcurno).currencyno
															   ,sdepaccount(vaggrcurno).currencyno
															   ,sactparam(cctp_exchangerate));
			vresult.cashlimit := vresult.cashlimit +
								 contracttools.getsumincurrency(vsecondlimit.cashlimit
															   ,sdepaccount(vsecondcurno).currencyno
															   ,sdepaccount(vaggrcurno).currencyno
															   ,sactparam(cctp_exchangerate));
		
		ELSE
			vresult := calcobjectlimits(pcurno, ppan, pmbr);
		END IF;
	
		t.leave(cmethodname);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getobjectlimits;

	PROCEDURE checkifobjectlimitcanbeset
	(
		pobjectlimitsettings IN typeobjectlimitsettings
	   ,poperation           IN PLS_INTEGER
	   ,pdialog              IN NUMBER := 0
	   ,pcheckscoring        IN BOOLEAN := TRUE
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CheckIfObjectLimitCanBeSet';
		cdialogmode CONSTANT BOOLEAN := poperation = csetcredlimit;
	
		PROCEDURE focusandraiseerror
		(
			pitemtogo     IN VARCHAR2
		   ,perrormessage IN VARCHAR2
		) IS
			cmethodname CONSTANT typemethodname := checkifobjectlimitcanbeset.cmethodname ||
												   '.FocusAndRaiseError';
		BEGIN
			IF cdialogmode
			THEN
				dialog.goitem(pdialog, pitemtogo);
				error.raiseerror(perrormessage);
			ELSE
				error.raiseerror(REPLACE(perrormessage, '~', ' '));
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END focusandraiseerror;
	
		FUNCTION checkandcalclimit
		(
			pcurno             IN PLS_INTEGER
		   ,plimitsettings     IN typelimitsettings
		   ,plimitkind         IN PLS_INTEGER
		   ,pobjecttype        IN PLS_INTEGER
		   ,pownership         IN PLS_INTEGER
		   ,pbaseamount        IN NUMBER
		   ,pitemtogo          IN typeitemname
		   ,pcheckedlimitdescr IN VARCHAR2 := NULL
		   ,pbaseamountdescr   IN VARCHAR2 := NULL
		) RETURN NUMBER IS
			cmethodname CONSTANT typemethodname := checkifobjectlimitcanbeset.cmethodname ||
												   '.CheckAndCalcLimit';
			vmaxamount NUMBER;
			vresult    NUMBER;
		
			PROCEDURE reportiferror
			(
				pcondition    IN BOOLEAN
			   ,perrormessage IN VARCHAR2
			) IS
				cmethodname CONSTANT typemethodname := checkandcalclimit.cmethodname ||
													   '.ReportIfError';
			BEGIN
				t.enter(cmethodname);
			
				IF pcondition
				THEN
				
					CASE poperation
					
						WHEN csetcredlimit THEN
							IF NOT htools.ask('Confirm'
											 ,perrormessage || '~~Set this credit limit value?')
							THEN
							
								dialog.goitem(pdialog, pitemtogo);
							
								RAISE exccancelledbyuser;
							END IF;
						
						WHEN cadjusting THEN
							contractadjwarning.appendwarning(REPLACE(perrormessage, '~', ' '));
						
						ELSE
							error.raiseerror(REPLACE(perrormessage, '~', ' '));
					END CASE;
				
				END IF;
			
				t.leave(cmethodname);
			EXCEPTION
				WHEN OTHERS THEN
					t.exc(cmethodname);
					error.save(cmethodname);
					RAISE;
			END reportiferror;
		
		BEGIN
			t.enter(cmethodname);
		
			contracttools.checkvalue_exists(plimitsettings.calcmethod, 'Limit sum');
		
			IF plimitsettings.calcmethod <> clmtnotused
			THEN
			
				contracttools.checkvalue_exists(pbaseamount, 'Base amount');
			
				CASE plimitsettings.calcmethod
				
					WHEN clmtnotdefined THEN
						vresult := pbaseamount;
					
					WHEN clmtastype THEN
						vresult := contracttypelimits.calclimitvalue(scontracttype
																	,plimitkind
																	,pobjecttype
																	,pownership
																	,pcurno
																	,pbaseamount
																	,sprecision(pcurno));
					
					ELSE
					
						contracttools.checkvalue_exists(plimitsettings.amount, 'Flat amount');
						contracttools.checkvalue_exists(plimitsettings.percent, 'Percent value');
						vresult := contracttypelimits.calclimitvalue(plimitsettings.calcmethod
																	,pbaseamount
																	,plimitsettings.percent
																	,plimitsettings.amount
																	,sprecision(pcurno));
				END CASE;
			
				IF poperation <> coperationundo
				THEN
				
					reportiferror(vresult > pbaseamount
								 ,pcheckedlimitdescr || ' (' ||
								  formatmoneywithabbr(vresult, pcurno) || ') exceed~' ||
								  pbaseamountdescr || ' (' ||
								  formatmoneywithabbr(pbaseamount, pcurno) || ')!');
				
					IF (pobjecttype = referencelimit.objtype_acc2card)
					   AND (plimitkind = clk_creditlimit)
					THEN
					
						vmaxamount := sactparamccy(pcurno)
									  (service.iif(pownership = cco_primary
												  ,cctp_pricardlimitmax
												  ,cctp_supcardlimitmax));
					
						reportiferror((vmaxamount IS NOT NULL) AND (vresult > vmaxamount)
									 ,pcheckedlimitdescr || ' (' ||
									  formatmoneywithabbr(vresult, pcurno) ||
									  ') exceed~maximum limit value in contract type settings (' ||
									  formatmoneywithabbr(vmaxamount, pcurno) || ')!');
					
					END IF;
				
				END IF;
			
			END IF;
		
			t.leave(cmethodname, vresult);
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END checkandcalclimit;
	
		PROCEDURE checklimit
		(
			pcurno             IN PLS_INTEGER
		   ,plimitsettings     IN typelimitsettings
		   ,plimitkind         IN PLS_INTEGER
		   ,pobjecttype        IN PLS_INTEGER
		   ,pownership         IN PLS_INTEGER
		   ,pbaseamount        IN NUMBER
		   ,pitemtogo          IN typeitemname
		   ,pcheckedlimitdescr IN VARCHAR2 := NULL
		   ,pbaseamountdescr   IN VARCHAR2 := NULL
		) IS
			cmethodname CONSTANT typemethodname := checkifobjectlimitcanbeset.cmethodname ||
												   '.CheckLimit';
		BEGIN
			sdummynum := checkandcalclimit(pcurno
										  ,plimitsettings
										  ,plimitkind
										  ,pobjecttype
										  ,pownership
										  ,pbaseamount
										  ,pitemtogo
										  ,pcheckedlimitdescr
										  ,pbaseamountdescr);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END checklimit;
	
		PROCEDURE checkifacccredlimitcanbeset
		(
			pcurno        IN NUMBER
		   ,pnewcredlimit IN NUMBER
		   ,pistemplimit  IN BOOLEAN
		) IS
			cmethodname CONSTANT typemethodname := checkifobjectlimitcanbeset.cmethodname ||
												   '.CheckIfAccCredLimitCanBeSet';
			citemtogo   CONSTANT VARCHAR2(100) := service.iif(pistemplimit
															 ,'TempCredLimitType'
															 ,'Limit');
		
			vlimitstring      VARCHAR2(30) := formatmoneywithabbr(pnewcredlimit, pcurno);
			vlimitsetup       typeobjectlimitsettings;
			vcardlist         apitypes.typecardlist;
			vscoringerrorcode NUMBER;
			vscoreresult      NUMBER;
			vavllimit         NUMBER;
			vscore            NUMBER;
		
		BEGIN
			t.enter(cmethodname, htools.b2s(pcheckscoring));
		
			contracttools.checkvalue_exists(pnewcredlimit, 'Limit sum');
		
			IF credlimitexceedcorplimit(pcurno, pnewcredlimit, vavllimit)
			THEN
				focusandraiseerror(citemtogo
								  ,'According to corporate contract settings maximum~credit limit value cannot exceed ' ||
								   formatmoneywithabbr(vavllimit + sdepaccount(pcurno).overdraft
													  ,pcurno) || '!');
			END IF;
		
			IF poperation IN (cadjusting, csetcredlimit, cbatchparamchange, cexternalapicall)
			THEN
			
				vcardlist := contract.getcardlist(scontractno);
			
				FOR i IN 1 .. 2
				LOOP
				
					IF ifcurrencyisusedintype(i, scontracttype, scontractno)
					THEN
					
						FOR j IN 1 .. vcardlist.count
						LOOP
						
							vlimitsetup := getobjectlimitssetup(scontractno
															   ,i
															   ,vcardlist  (j).pan
															   ,vcardlist  (j).mbr);
						
							checklimit(i
									  ,vlimitsetup.credlimit
									  ,clk_creditlimit
									  ,referencelimit.objtype_acc2card
									  ,getcardownership(vcardlist(j).pan, vcardlist(j).mbr)
									  ,pnewcredlimit
									  ,citemtogo
									  ,'Credit limit of card ' || masktodialog(vcardlist(j))
									  ,'account ' || sdepaccount(i).accountno ||
									   service.iif(pistemplimit, ' temporary', '') ||
									   ' credit limit');
						
						END LOOP;
					
					END IF;
				
				END LOOP;
			
				IF pnewcredlimit < nvl(sactparamccy(pcurno) (cctp_acccredlimitmin), pnewcredlimit)
				THEN
					focusandraiseerror(citemtogo
									  ,'Account credit limit (' || vlimitstring ||
									   ') cannot be less~than contract type minimum value (' ||
									   formatmoneywithabbr(sactparamccy(pcurno)
														   (cctp_acccredlimitmin)
														  ,pcurno) || ')!');
				ELSIF pnewcredlimit >
					  nvl(sactparamccy(pcurno) (cctp_acccredlimitmax), pnewcredlimit)
				THEN
					focusandraiseerror(citemtogo
									  ,'Account credit limit (' || vlimitstring ||
									   ') cannot be greater~than contract type maximum value (' ||
									   formatmoneywithabbr(sactparamccy(pcurno)
														   (cctp_acccredlimitmax)
														  ,pcurno) || ')!');
				END IF;
			
				IF pcheckscoring
				THEN
				
					vscoreresult := checklimitbyscore(pnewcredlimit, pcurno, vscore);
				
					IF vscoreresult > 1
					THEN
					
						vscoringerrorcode := CASE poperation
												 WHEN cbatchparamchange THEN
												  cerror_credlimitscorecheck
												 ELSE
												  err.ue_other
											 END;
					
						IF contract.checkoperright(contract.right_modify_oper
												  ,scontractno
												  ,copersetcreditlimit
												  ,CASE vscoreresult
													   WHEN 2 THEN
														'SET_CNFRM'
													   ELSE
														'SET_PRHBT'
												   END)
						THEN
						
							IF cdialogmode
							THEN
							
								IF ((vscoreresult = 2) AND
								   (NOT
									htools.ask('Confirm'
												,'According to the scoring rating (' ||
												 round(vscore, 2) ||
												 ') it is necessary to confirm setting of the credit limit value (' ||
												 vlimitstring || ').~Set this credit limit value?')))
								   OR ((vscoreresult = 3) AND
								   (NOT htools.ask('Confirm'
													  ,'The scoring rating (' || round(vscore, 2) ||
													   ') does not allow setting the credit limit value (' ||
													   vlimitstring ||
													   ').~Set this credit limit value?')))
								THEN
								
									RAISE exccancelledbyuser;
								END IF;
							
							ELSE
								error.raiseerror(vscoringerrorcode
												,'The scoring rating (' || round(vscore, 2) ||
												 ') does not allow to set the credit limit value (' ||
												 vlimitstring || ') without confirmation!');
							END IF;
						
						ELSE
							error.raiseerror(vscoringerrorcode
											,'According to the scoring rating (' ||
											 round(vscore, 2) ||
											 ') it is necessary to confirm setting of the credit limit value (' ||
											 vlimitstring ||
											 ').~You have not enough permission for operation confirmation!');
						END IF;
					
					END IF;
				
				END IF;
			
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END checkifacccredlimitcanbeset;
	
		PROCEDURE checkifacccashlimitcanbeset
		(
			pobjectlimitsettings IN typeobjectlimitsettings
		   ,pchecktemplimit      IN BOOLEAN
		   ,pusetempbaseamount   IN BOOLEAN
		) IS
			cmethodname CONSTANT typemethodname := checkifobjectlimitcanbeset.cmethodname ||
												   '.CheckIfAccCashLimitCanBeSet';
		
			ccheckedlimitdescr CONSTANT VARCHAR2(100) := 'Account ' || sdepaccount(pobjectlimitsettings.curno)
														.accountno || service.iif(pchecktemplimit
																				 ,' temporary'
																				 ,'') ||
														 ' cash limit';
			cbaseamountdescr   CONSTANT VARCHAR2(100) := 'account' || service.iif(pusetempbaseamount
																				 ,' temporary'
																				 ,'') ||
														 ' credit limit';
			cbaseamount        CONSTANT NUMBER := service.iif(pusetempbaseamount
															 ,pobjectlimitsettings.tempcredlimit.amount
															 ,pobjectlimitsettings.credlimit.amount);
			citemtogo          CONSTANT typeitemname := service.iif(pchecktemplimit
																   ,'TempCashLimitType'
																   ,'CashLimitType');
		
			vcurrentcashlimit NUMBER;
			vnewcashlimit     NUMBER;
			vavllimit         NUMBER;
		
		BEGIN
			t.enter(cmethodname);
		
			IF pchecktemplimit
			THEN
				vnewcashlimit := checkandcalclimit(pobjectlimitsettings.curno
												  ,pobjectlimitsettings.tempcashlimit
												  ,clk_cashlimit
												  ,referencelimit.objtype_account
												  ,cco_primary
												  ,cbaseamount
												  ,citemtogo
												  ,ccheckedlimitdescr
												  ,cbaseamountdescr);
			ELSE
				vnewcashlimit := checkandcalclimit(pobjectlimitsettings.curno
												  ,pobjectlimitsettings.cashlimit
												  ,clk_cashlimit
												  ,referencelimit.objtype_account
												  ,cco_primary
												  ,cbaseamount
												  ,citemtogo
												  ,ccheckedlimitdescr
												  ,cbaseamountdescr);
			END IF;
		
			vcurrentcashlimit := calcobjectlimits(pobjectlimitsettings.curno).cashlimit;
		
			IF cashlimitexceedcorplimit(pobjectlimitsettings.curno
									   ,vcurrentcashlimit
									   ,vnewcashlimit
									   ,vavllimit)
			THEN
				focusandraiseerror(citemtogo
								  ,'According to corporate contract settings maximum~cash limit value cannot exceed ' ||
								   formatmoneywithabbr(vavllimit + vcurrentcashlimit
													  ,pobjectlimitsettings.curno) || '!');
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END checkifacccashlimitcanbeset;
	
		PROCEDURE checkiflimitdatecanbeset
		(
			pdate     IN DATE
		   ,pitemtogo IN typeitemname
		) IS
			cmethodname CONSTANT typemethodname := checkifobjectlimitcanbeset.cmethodname ||
												   '.CheckIfLimitDateCanBeSet';
		BEGIN
		
			IF (poperation <> coperationundo)
			   AND (pdate < seance.getoperdate)
			THEN
				focusandraiseerror(pitemtogo, 'Date cannot be less than current business date!');
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END checkiflimitdatecanbeset;
	
		PROCEDURE checkaccountlimitsettings(paccountlimitsettings IN typeobjectlimitsettings) IS
			cmethodname CONSTANT typemethodname := checkifobjectlimitcanbeset.cmethodname ||
												   '.CheckAccountLimitSettings';
		BEGIN
			t.enter(cmethodname, paccountlimitsettings.curno);
		
			checkifacccredlimitcanbeset(paccountlimitsettings.curno
									   ,paccountlimitsettings.credlimit.amount
									   ,FALSE);
		
			checkifacccashlimitcanbeset(paccountlimitsettings, FALSE, FALSE);
		
			IF paccountlimitsettings.tempcredlimit.calcmethod = clmtdefined
			THEN
			
				checkifacccredlimitcanbeset(paccountlimitsettings.curno
										   ,paccountlimitsettings.tempcredlimit.amount
										   ,TRUE);
			
				IF NOT paccountlimitsettings.tempcredlimit.active
				THEN
					checkiflimitdatecanbeset(paccountlimitsettings.tempcredlimit.validfrom
											,'TempCredLimitDateFrom');
				END IF;
			
				checkiflimitdatecanbeset(paccountlimitsettings.tempcredlimit.validto
										,'TempCredLimitDateTo');
			
				checkifacccashlimitcanbeset(paccountlimitsettings, FALSE, TRUE);
			
			END IF;
		
			IF paccountlimitsettings.tempcashlimit.calcmethod <> clmtnotused
			THEN
			
				IF NOT paccountlimitsettings.tempcashlimit.active
				THEN
					checkiflimitdatecanbeset(paccountlimitsettings.tempcashlimit.validfrom
											,'TempCashLimitDateFrom');
				END IF;
			
				checkiflimitdatecanbeset(paccountlimitsettings.tempcashlimit.validto
										,'TempCashLimitDateTo');
			
				IF (paccountlimitsettings.tempcredlimit.calcmethod = clmtnotused)
				   OR (paccountlimitsettings.tempcashlimit.validfrom <
				   paccountlimitsettings.tempcredlimit.validfrom)
				   OR (paccountlimitsettings.tempcashlimit.validto >
				   paccountlimitsettings.tempcredlimit.validto)
				THEN
				
					checkifacccashlimitcanbeset(paccountlimitsettings, TRUE, FALSE);
				END IF;
			
				IF (paccountlimitsettings.tempcredlimit.calcmethod = clmtdefined)
				   AND ((paccountlimitsettings.tempcashlimit.validfrom <=
				   paccountlimitsettings.tempcredlimit.validto) OR
				   (paccountlimitsettings.tempcashlimit.validto >=
				   paccountlimitsettings.tempcredlimit.validfrom))
				THEN
				
					checkifacccashlimitcanbeset(paccountlimitsettings, TRUE, TRUE);
				END IF;
			
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END checkaccountlimitsettings;
	
		PROCEDURE checkcardlimitsettings(pcardlimitsettings IN typeobjectlimitsettings) IS
			cmethodname CONSTANT typemethodname := checkifobjectlimitcanbeset.cmethodname ||
												   '.CheckCardLimitSettings';
		
			ccard    CONSTANT VARCHAR2(30) := 'Card ' ||
											  masktodialog(pcardlimitsettings.pan
														  ,pcardlimitsettings.mbr);
			caccount CONSTANT VARCHAR2(30) := ' account ' || sdepaccount(pcardlimitsettings.curno)
											 .accountno;
		
			vaccountlimitsettings typeobjectlimitsettings;
			vcardtempcreditlimit1 NUMBER;
			vcardtempcreditlimit2 NUMBER;
			vcardcreditlimit1     NUMBER;
			vcardcreditlimit2     NUMBER;
			vownership            PLS_INTEGER;
		
		BEGIN
			t.enter(cmethodname, masktodebug(pcardlimitsettings.pan, pcardlimitsettings.mbr));
		
			vownership := getcardownership(pcardlimitsettings.pan, pcardlimitsettings.mbr);
		
			vaccountlimitsettings := getobjectlimitssetup(scontractno, pcardlimitsettings.curno);
		
			vcardcreditlimit1 := checkandcalclimit(pcardlimitsettings.curno
												  ,pcardlimitsettings.credlimit
												  ,clk_creditlimit
												  ,referencelimit.objtype_acc2card
												  ,vownership
												  ,vaccountlimitsettings.credlimit.amount
												  ,'CredLimitType'
												  ,ccard || ' credit limit'
												  ,caccount || ' credit limit');
		
			IF vaccountlimitsettings.tempcredlimit.calcmethod <> clmtnotused
			THEN
				vcardcreditlimit2 := checkandcalclimit(pcardlimitsettings.curno
													  ,pcardlimitsettings.credlimit
													  ,clk_creditlimit
													  ,referencelimit.objtype_acc2card
													  ,vownership
													  ,vaccountlimitsettings.tempcredlimit.amount
													  ,'CredLimitType'
													  ,ccard || ' credit limit'
													  ,caccount || ' temporary credit limit');
			END IF;
		
			checklimit(pcardlimitsettings.curno
					  ,pcardlimitsettings.cashlimit
					  ,clk_cashlimit
					  ,referencelimit.objtype_acc2card
					  ,vownership
					  ,vcardcreditlimit1
					  ,'CashLimitType'
					  ,ccard || ' cash limit'
					  ,' card credit limit');
		
			IF vcardcreditlimit2 IS NOT NULL
			THEN
				checklimit(pcardlimitsettings.curno
						  ,pcardlimitsettings.cashlimit
						  ,clk_cashlimit
						  ,referencelimit.objtype_acc2card
						  ,vownership
						  ,vcardcreditlimit2
						  ,'CashLimitType'
						  ,ccard || ' cash limit'
						  ,' card credit limit');
			END IF;
		
			IF pcardlimitsettings.tempcredlimit.calcmethod <> clmtnotused
			THEN
			
				checkiflimitdatecanbeset(pcardlimitsettings.tempcredlimit.validto
										,'TempCredLimitDate');
			
				vcardtempcreditlimit1 := checkandcalclimit(pcardlimitsettings.curno
														  ,pcardlimitsettings.tempcredlimit
														  ,clk_creditlimit
														  ,referencelimit.objtype_acc2card
														  ,vownership
														  ,vaccountlimitsettings.credlimit.amount
														  ,'TempCredLimitType'
														  ,ccard || ' temporary credit limit'
														  ,caccount || ' credit limit');
			
				checklimit(pcardlimitsettings.curno
						  ,pcardlimitsettings.cashlimit
						  ,clk_cashlimit
						  ,referencelimit.objtype_acc2card
						  ,vownership
						  ,vcardtempcreditlimit1
						  ,'CashLimitType'
						  ,ccard || ' cash limit'
						  ,' card temporary credit limit');
			
				IF (vaccountlimitsettings.tempcredlimit.calcmethod = clmttotal)
				   AND (pcardlimitsettings.tempcredlimit.validto >
				   vaccountlimitsettings.tempcredlimit.validfrom)
				THEN
				
					vcardtempcreditlimit2 := checkandcalclimit(pcardlimitsettings.curno
															  ,pcardlimitsettings.tempcredlimit
															  ,clk_creditlimit
															  ,referencelimit.objtype_acc2card
															  ,vownership
															  ,vaccountlimitsettings.tempcredlimit.amount
															  ,'TempCredLimitType'
															  ,ccard || ' temporary credit limit'
															  ,caccount ||
															   ' temporary credit limit');
				
					checklimit(pcardlimitsettings.curno
							  ,pcardlimitsettings.cashlimit
							  ,clk_cashlimit
							  ,referencelimit.objtype_acc2card
							  ,vownership
							  ,vcardtempcreditlimit2
							  ,'CashLimitType'
							  ,ccard || ' cash limit'
							  ,caccount || ' temporary credit limit');
				
				END IF;
			
			END IF;
		
			IF pcardlimitsettings.tempcashlimit.calcmethod <> clmtnotused
			THEN
			
				checkiflimitdatecanbeset(pcardlimitsettings.tempcashlimit.validto
										,'TempCashLimitDate');
			
				IF (pcardlimitsettings.tempcredlimit.calcmethod = clmtnotused)
				   OR (pcardlimitsettings.tempcredlimit.validto <
				   pcardlimitsettings.tempcashlimit.validto)
				THEN
				
					checklimit(pcardlimitsettings.curno
							  ,pcardlimitsettings.tempcashlimit
							  ,clk_cashlimit
							  ,referencelimit.objtype_acc2card
							  ,vownership
							  ,vcardcreditlimit1
							  ,'TempCashLimitType'
							  ,ccard || ' temporary cash limit'
							  ,' card credit limit');
				END IF;
			
				IF pcardlimitsettings.tempcredlimit.calcmethod <> clmtnotused
				THEN
				
					checklimit(pcardlimitsettings.curno
							  ,pcardlimitsettings.tempcashlimit
							  ,clk_cashlimit
							  ,referencelimit.objtype_acc2card
							  ,vownership
							  ,vcardtempcreditlimit1
							  ,'TempCashLimitType'
							  ,ccard || ' temporary cash limit'
							  ,caccount || ' credit limit');
				
					IF vcardtempcreditlimit2 IS NOT NULL
					THEN
					
						checklimit(pcardlimitsettings.curno
								  ,pcardlimitsettings.tempcashlimit
								  ,clk_cashlimit
								  ,referencelimit.objtype_acc2card
								  ,vownership
								  ,vcardtempcreditlimit2
								  ,'TempCashLimitType'
								  ,ccard || ' temporary cash limit'
								  ,caccount || ' temporary credit limit');
					END IF;
				
				END IF;
			
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END checkcardlimitsettings;
	
	BEGIN
		t.enter(cmethodname);
	
		IF pobjectlimitsettings.pan IS NULL
		THEN
			checkaccountlimitsettings(pobjectlimitsettings);
		ELSE
			checkcardlimitsettings(pobjectlimitsettings);
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END checkifobjectlimitcanbeset;

	PROCEDURE dml_limitsetup_updaterecord
	(
		pnewlimitsettings IN typeobjectlimitsettings
	   ,poperation        IN PLS_INTEGER
	   ,pchecklimits      IN BOOLEAN := TRUE
	   ,pcheckscoring     IN BOOLEAN := TRUE
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.DML_LimitSetup_UpdateRecord';
		ccurno      CONSTANT NUMBER := pnewlimitsettings.curno;
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		voldlimitsettings    typeobjectlimitsettings;
		vlimitsetuprow       typelimitsetuprow;
		vtempcredlimitactive NUMBER;
		vtempcashlimitactive NUMBER;
		vactiontype          NUMBER;
	
		FUNCTION getsetupstring(plimitsettings IN typelimitsettings) RETURN VARCHAR IS
			cmethodname CONSTANT typemethodname := dml_limitsetup_updaterecord.cmethodname ||
												   '.GetSetupString';
			vamount VARCHAR(30);
			vresult VARCHAR(200);
		BEGIN
			t.enter(cmethodname, plimitsettings.calcmethod);
		
			IF nvl(plimitsettings.calcmethod, clmtdefined) IN
			   (clmttotal, clmtmax, clmtmin, clmtdefined)
			THEN
				vamount := formatmoneywithabbr(plimitsettings.amount, ccurno);
			END IF;
		
			CASE nvl(plimitsettings.calcmethod, clmtdefined)
				WHEN clmtnotdefined THEN
					vresult := '"Not defined (100% of initial value)';
				WHEN clmttotal THEN
					vresult := '"Total of ' || vamount || ' and ' || plimitsettings.percent ||
							   '% of initial value';
				WHEN clmtmax THEN
					vresult := '"Maximum between ' || vamount || ' and ' || plimitsettings.percent ||
							   '% of initial value';
				WHEN clmtmin THEN
					vresult := '"Minimum between ' || vamount || ' and ' || plimitsettings.percent ||
							   '% of initial value';
				WHEN clmtnotused THEN
					vresult := '"Not used';
				WHEN clmtastype THEN
					vresult := '"Use contract type setup';
				WHEN clmtdefined THEN
					vresult := '"' || vamount;
				ELSE
					error.raiseerror('Unknown calculation method <' || plimitsettings.calcmethod || '>!');
			END CASE;
		
			IF plimitsettings.validfrom IS NOT NULL
			THEN
				vresult := vresult || ' valid from ' || plimitsettings.validfrom || ' to ' ||
						   plimitsettings.validto;
			
			ELSIF plimitsettings.validto IS NOT NULL
			THEN
				vresult := vresult || ' valid to ' || plimitsettings.validto;
			END IF;
		
			t.leave(cmethodname, vresult || '"');
			RETURN vresult || '"';
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END getsetupstring;
	
		PROCEDURE addobjectlimittorollback
		(
			poldobjectlimitsettings IN typeobjectlimitsettings
		   ,pnewobjectlimitsettings IN typeobjectlimitsettings
		) IS
			cmethodname CONSTANT typemethodname := dml_limitsetup_updaterecord.cmethodname ||
												   '.AddObjectLimitToRollback';
		
			PROCEDURE addlimittorollback
			(
				poldlimitsettings IN typelimitsettings
			   ,pnewlimitsettings IN typelimitsettings
			   ,plimittype        IN PLS_INTEGER
			) IS
				cmethodname CONSTANT typemethodname := addobjectlimittorollback.cmethodname ||
													   '.AddLimitToRollback';
				vcalcmethodchanged BOOLEAN;
				vamountchanged     BOOLEAN;
				vpercentchanged    BOOLEAN;
				vvalidfromchanged  BOOLEAN;
				vvalidtochanged    BOOLEAN;
				vactivechanged     BOOLEAN;
			BEGIN
				t.enter(cmethodname);
			
				vcalcmethodchanged := contracttools.notequal(poldlimitsettings.calcmethod
															,pnewlimitsettings.calcmethod);
				vamountchanged     := contracttools.notequal(poldlimitsettings.amount
															,pnewlimitsettings.amount);
				vpercentchanged    := contracttools.notequal(poldlimitsettings.percent
															,pnewlimitsettings.percent);
				vvalidfromchanged  := contracttools.notequal(poldlimitsettings.validfrom
															,pnewlimitsettings.validfrom);
				vvalidtochanged    := contracttools.notequal(poldlimitsettings.validto
															,pnewlimitsettings.validto);
				vactivechanged     := contracttools.notequal(poldlimitsettings.active
															,pnewlimitsettings.active);
			
				IF vcalcmethodchanged
				   OR vamountchanged
				   OR vpercentchanged
				   OR vvalidfromchanged
				   OR vvalidtochanged
				   OR vactivechanged
				THEN
				
					contractrb.setlabel(crl_objectlimit);
					contractrb.setnvalue('CURNO', poldobjectlimitsettings.curno);
					contractrb.setcvalue('PAN', poldobjectlimitsettings.pan);
					contractrb.setnvalue('MBR', poldobjectlimitsettings.mbr);
					contractrb.setnvalue('LMTTYPE', plimittype);
				
					IF vcalcmethodchanged
					THEN
						contractrb.setnvalue('CM', poldlimitsettings.calcmethod);
					END IF;
				
					IF vamountchanged
					THEN
						contractrb.setnvalue('AMT', poldlimitsettings.amount);
					END IF;
				
					IF vpercentchanged
					THEN
						contractrb.setnvalue('PRC', poldlimitsettings.percent);
					END IF;
				
					IF vvalidfromchanged
					THEN
						contractrb.setdvalue('VF', poldlimitsettings.validfrom);
					END IF;
				
					IF vvalidtochanged
					THEN
						contractrb.setdvalue('VT', poldlimitsettings.validto);
					END IF;
				
					IF vactivechanged
					THEN
						contractrb.setnvalue('ACT', htools.b2i(poldlimitsettings.active));
					END IF;
				
				END IF;
			
				t.leave(cmethodname);
			EXCEPTION
				WHEN OTHERS THEN
					t.exc(cmethodname);
					error.save(cmethodname);
					RAISE;
			END addlimittorollback;
		
		BEGIN
			t.enter(cmethodname);
		
			addlimittorollback(poldobjectlimitsettings.credlimit
							  ,pnewobjectlimitsettings.credlimit
							  ,ccredlimit);
			addlimittorollback(poldobjectlimitsettings.cashlimit
							  ,pnewobjectlimitsettings.cashlimit
							  ,ccashlimit);
			addlimittorollback(poldobjectlimitsettings.tempcredlimit
							  ,pnewobjectlimitsettings.tempcredlimit
							  ,ctempcredlimit);
			addlimittorollback(poldobjectlimitsettings.tempcashlimit
							  ,pnewobjectlimitsettings.tempcashlimit
							  ,ctempcashlimit);
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END addobjectlimittorollback;
	
		PROCEDURE logsettingschanges
		(
			poldsettings IN typelimitsettings
		   ,pnewsettings IN typelimitsettings
		   ,pactiontype  IN NUMBER
		   ,pparamprefix IN VARCHAR2
		   ,pparamdescr  IN VARCHAR2
		) IS
			cmethodname CONSTANT typemethodname := dml_limitsetup_updaterecord.cmethodname ||
												   '.LogSettingsChanges';
		BEGIN
			t.enter(cmethodname, pparamprefix);
		
			a4mlog.cleanparamlist;
		
			a4mlog.addparamrec(pparamprefix || 'Type'
							  ,poldsettings.calcmethod
							  ,pnewsettings.calcmethod);
			a4mlog.addparamrec(pparamprefix || 'Amount', poldsettings.amount, pnewsettings.amount);
			a4mlog.addparamrec(pparamprefix || 'Prc', poldsettings.percent, pnewsettings.percent);
			a4mlog.addparamrec(pparamprefix || 'ValidTo'
							  ,poldsettings.validto
							  ,pnewsettings.validto);
			a4mlog.addparamrec(pparamprefix || 'ValidFrom'
							  ,poldsettings.validfrom
							  ,pnewsettings.validfrom);
		
			IF a4mlog.getparamlistcount > 0
			THEN
			
				IF pnewlimitsettings.pan IS NULL
				THEN
					a4mlog.addparamrec('Account', sdepaccount(ccurno).accountno);
				ELSE
					a4mlog.addparamrec(contract.clogparam_pan, pnewlimitsettings.pan);
					a4mlog.addparamrec('MBR', pnewlimitsettings.mbr);
				END IF;
			
				a4mlog.logobject(object.gettype(contract.object_name)
								,scontractno
								,service.iif(pnewlimitsettings.pan IS NULL, 'Account ', 'Card ') ||
								 pparamdescr || ' settings changed from ' ||
								 getsetupstring(poldsettings) || ' to ' ||
								 getsetupstring(pnewsettings) || ' by operation "' ||
								 getoperationdescr(poperation) || '"'
								,pactiontype
								,a4mlog.putparamlist
								,powner => getclientid);
			
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END logsettingschanges;
	
		PROCEDURE logtemplimitactivation
		(
			plimittype IN PLS_INTEGER
		   ,poldmode   IN BOOLEAN
		   ,pnewmode   IN BOOLEAN
		) IS
			cmethodname CONSTANT typemethodname := dml_limitsetup_updaterecord.cmethodname ||
												   '.LogTempLimitActivation';
			vaddkey      typehistaddkey;
			vkey         typehistkey;
			vactiondescr VARCHAR2(200);
			voldmode     VARCHAR2(3);
			vnewmode     VARCHAR2(3);
		BEGIN
			t.enter(cmethodname, plimittype);
		
			t.var('pOldMode', htools.b2s(poldmode));
			t.var('pNewMode', htools.b2s(pnewmode));
		
			IF poldmode <> pnewmode
			THEN
			
				voldmode := service.iif(poldmode, 'ON', 'OFF');
				vnewmode := service.iif(pnewmode, 'ON', 'OFF');
			
				vactiondescr := gettemplimitdescr(plimittype, pnewlimitsettings) || ' was ' ||
								service.iif(pnewmode, 'activated', 'deactivated');
			
				IF poperation IN (cadjusting, csetcredlimit, cbatchparamchange)
				THEN
				
					CASE plimittype
						WHEN ctempcredlimit THEN
							vkey := 'TEMP_CREDIT_LIMIT';
						WHEN ctempcashlimit THEN
							vkey := 'TEMP_CASH_LIMIT';
						ELSE
							error.raiseerror('Internal error: <' || plimittype ||
											 '> is not a temporary limit!');
					END CASE;
				
					vaddkey := upper(getvaluebycurno(pnewlimitsettings.curno, 'DOM:', 'INT:') ||
									 service.iif(pnewlimitsettings.pan IS NULL
												,'ACCOUNT'
												,pnewlimitsettings.pan || '-' ||
												 pnewlimitsettings.mbr));
				
					contractparams.writehistory(scontractno
											   ,shistpackno
											   ,vkey
											   ,vaddkey
											   ,vnewmode
											   ,vactiondescr);
				
				END IF;
			
				vactiondescr := vactiondescr || ' by operation "' || getoperationdescr(poperation) || '"';
			
				a4mlog.cleanparamlist;
			
				a4mlog.addparamrec('TempLimitType', plimittype);
			
				a4mlog.addparamrec('TempLimitMode', voldmode, vnewmode);
			
				IF pnewlimitsettings.pan IS NULL
				THEN
					a4mlog.addparamrec('Account', sdepaccount(pnewlimitsettings.curno).accountno);
				ELSE
					a4mlog.addparamrec(contract.clogparam_pan, pnewlimitsettings.pan);
					a4mlog.addparamrec('MBR', pnewlimitsettings.mbr);
				END IF;
			
				a4mlog.logobject(object.gettype(contract.object_name)
								,scontractno
								,vactiondescr
								,a4mlog.act_change
								,a4mlog.putparamlist
								,powner => getclientid);
			
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END logtemplimitactivation;
	
	BEGIN
		t.enter(cmethodname);
	
		IF pchecklimits
		THEN
			checkifobjectlimitcanbeset(pnewlimitsettings
									  ,poperation
									  ,pcheckscoring => pcheckscoring);
		END IF;
	
		IF pnewlimitsettings.pan IS NULL
		THEN
		
			DELETE FROM tcontractlimitparams clp
			WHERE  branch = cbranch
			AND    contractno = scontractno
			AND    pan IS NULL
			AND    mbr IS NULL
			AND    currencynumber = pnewlimitsettings.curno
			RETURNING branch, contractno, NULL, NULL, currencynumber, credlimittype, credlimitamount, credlimitprc, cashlimittype, cashlimitamount, cashlimitprc, tempcredlimittype, tempcredlimitamount, tempcredlimitprc, tempcredlimitdate, tempcashlimittype, tempcashlimitamount, tempcashlimitprc, tempcashlimitdate, usedcredlimit, usedcashlimit, tempcredlimitdatefrom, tempcashlimitdatefrom, tempcredlimitactive, tempcashlimitactive INTO vlimitsetuprow;
		
		ELSE
		
			DELETE FROM tcontractlimitparams
			WHERE  branch = cbranch
			AND    contractno = scontractno
			AND    pan = pnewlimitsettings.pan
			AND    mbr = pnewlimitsettings.mbr
			AND    currencynumber = pnewlimitsettings.curno
			RETURNING branch, contractno, pan, mbr, currencynumber, credlimittype, credlimitamount, credlimitprc, cashlimittype, cashlimitamount, cashlimitprc, tempcredlimittype, tempcredlimitamount, tempcredlimitprc, tempcredlimitdate, tempcashlimittype, tempcashlimitamount, tempcashlimitprc, tempcashlimitdate, usedcredlimit, usedcashlimit, tempcredlimitdatefrom, tempcashlimitdatefrom, tempcredlimitactive, tempcashlimitactive INTO vlimitsetuprow;
		
		END IF;
	
		vactiontype := CASE SQL%ROWCOUNT
						   WHEN 0 THEN
							a4mlog.act_add
						   ELSE
							a4mlog.act_change
					   END;
	
		vtempcredlimitactive := htools.b2i(pnewlimitsettings.tempcredlimit.active);
		vtempcashlimitactive := htools.b2i(pnewlimitsettings.tempcashlimit.active);
	
		INSERT INTO tcontractlimitparams
		VALUES
			(cbranch
			,scontractno
			,pnewlimitsettings.pan
			,pnewlimitsettings.mbr
			,pnewlimitsettings.curno
			,pnewlimitsettings.credlimit.calcmethod
			,pnewlimitsettings.credlimit.amount
			,pnewlimitsettings.credlimit.percent
			,pnewlimitsettings.cashlimit.calcmethod
			,pnewlimitsettings.cashlimit.amount
			,pnewlimitsettings.cashlimit.percent
			,pnewlimitsettings.tempcredlimit.calcmethod
			,pnewlimitsettings.tempcredlimit.amount
			,pnewlimitsettings.tempcredlimit.percent
			,pnewlimitsettings.tempcredlimit.validto
			,pnewlimitsettings.tempcashlimit.calcmethod
			,pnewlimitsettings.tempcashlimit.amount
			,pnewlimitsettings.tempcashlimit.percent
			,pnewlimitsettings.tempcashlimit.validto
			,pnewlimitsettings.usedcredlimit.amount
			,pnewlimitsettings.usedcashlimit.amount
			,pnewlimitsettings.tempcredlimit.validfrom
			,pnewlimitsettings.tempcashlimit.validfrom
			,vtempcredlimitactive
			,vtempcashlimitactive);
	
		voldlimitsettings := limitrowtorecord(vlimitsetuprow);
	
		IF poperation IN (cadjusting, cbatchparamchange)
		THEN
			addobjectlimittorollback(voldlimitsettings, pnewlimitsettings);
		END IF;
	
		logsettingschanges(voldlimitsettings.credlimit
						  ,pnewlimitsettings.credlimit
						  ,vactiontype
						  ,'CredLimit'
						  ,'credit limit');
		logsettingschanges(voldlimitsettings.cashlimit
						  ,pnewlimitsettings.cashlimit
						  ,vactiontype
						  ,'CashLimit'
						  ,'cash limit');
		logsettingschanges(voldlimitsettings.tempcredlimit
						  ,pnewlimitsettings.tempcredlimit
						  ,vactiontype
						  ,'TempCredLimit'
						  ,'temporary credit limit');
		logsettingschanges(voldlimitsettings.tempcashlimit
						  ,pnewlimitsettings.tempcashlimit
						  ,vactiontype
						  ,'TempCashLimit'
						  ,'temporary cash limit');
		logsettingschanges(voldlimitsettings.usedcredlimit
						  ,pnewlimitsettings.usedcredlimit
						  ,vactiontype
						  ,'UsedCredLimit'
						  ,'used credit limit');
		logsettingschanges(voldlimitsettings.usedcashlimit
						  ,pnewlimitsettings.usedcashlimit
						  ,vactiontype
						  ,'UsedCashLimit'
						  ,'used cash limit');
	
		logtemplimitactivation(ctempcredlimit
							  ,voldlimitsettings.tempcredlimit.active
							  ,pnewlimitsettings.tempcredlimit.active);
		logtemplimitactivation(ctempcashlimit
							  ,voldlimitsettings.tempcashlimit.active
							  ,pnewlimitsettings.tempcashlimit.active);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dml_limitsetup_updaterecord;

	PROCEDURE undoobjectlimitschange(pcontractno IN typecontractno) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UndoObjectLimitsChange';
		vlimitsetuprecord typeobjectlimitsettings;
		vlimittype        PLS_INTEGER;
	
		PROCEDURE undolimitchange(olimitsettings IN OUT NOCOPY typelimitsettings) IS
			cmethodname CONSTANT typemethodname := undoobjectlimitschange.cmethodname ||
												   '.UndoLimitChange';
			vactive NUMBER;
		BEGIN
			t.enter(cmethodname);
		
			contractrb.putexistingnvalue(olimitsettings.calcmethod, 'CM');
			contractrb.putexistingnvalue(olimitsettings.amount, 'AMT');
			contractrb.putexistingnvalue(olimitsettings.percent, 'PRC');
			contractrb.putexistingdvalue(olimitsettings.validfrom, 'VF');
			contractrb.putexistingdvalue(olimitsettings.validto, 'VT');
		
			IF contractrb.getnvalue('ACT', vactive)
			THEN
				olimitsettings.active := htools.i2b(vactive);
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END undolimitchange;
	
	BEGIN
		t.enter(cmethodname);
	
		vlimitsetuprecord := getobjectlimitssetup(pcontractno
												 ,contractrb.getnvalue('CURNO')
												 ,contractrb.getcvalue('PAN')
												 ,contractrb.getnvalue('MBR'));
		vlimittype        := contractrb.getnvalue('LMTTYPE');
	
		CASE vlimittype
		
			WHEN ccredlimit THEN
				undolimitchange(vlimitsetuprecord.credlimit);
			
			WHEN ccashlimit THEN
				undolimitchange(vlimitsetuprecord.cashlimit);
			
			WHEN ctempcredlimit THEN
				undolimitchange(vlimitsetuprecord.tempcredlimit);
			
			WHEN ctempcashlimit THEN
				undolimitchange(vlimitsetuprecord.tempcashlimit);
			
			ELSE
				error.raiseerror('Internal error: unknown limit type <' || vlimittype || '>!');
		END CASE;
	
		dml_limitsetup_updaterecord(vlimitsetuprecord, coperationundo);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END undoobjectlimitschange;

	FUNCTION processobjecttemplimits
	(
		poldlimitsettings  IN typeobjectlimitsettings
	   ,ponewlimitsettings IN OUT NOCOPY typeobjectlimitsettings
	   ,poperation         IN PLS_INTEGER
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ProcessObjectTempLimits';
		vissettingschanged BOOLEAN := FALSE;
	
		PROCEDURE processtemplimit
		(
			plimittype       IN PLS_INTEGER
		   ,polimitsettings  IN OUT NOCOPY typelimitsettings
		   ,osettingschanged IN OUT BOOLEAN
		) IS
			cmethodname CONSTANT typemethodname := processobjecttemplimits.cmethodname ||
												   '.ProcessTempLimit';
			coperdate   CONSTANT DATE := seance.getoperdate;
		
			PROCEDURE resetsettings
			(
				polimitsettings  IN OUT NOCOPY typelimitsettings
			   ,osettingschanged IN OUT BOOLEAN
			) IS
			BEGIN
				polimitsettings            := NULL;
				polimitsettings.calcmethod := clmtnotused;
				polimitsettings.active     := FALSE;
				osettingschanged           := TRUE;
			END resetsettings;
		
		BEGIN
			t.enter(cmethodname, plimittype);
		
			IF polimitsettings.active
			THEN
			
				IF (polimitsettings.calcmethod = clmtnotused)
				   OR ((poperation = cadjusting) AND (polimitsettings.validto <= coperdate))
				THEN
					resetsettings(polimitsettings, osettingschanged);
				END IF;
			
			ELSE
			
				IF (poperation = cadjusting)
				   AND (polimitsettings.validto <= coperdate)
				THEN
					resetsettings(polimitsettings, osettingschanged);
					contractadjwarning.appendwarning(gettemplimitdescr(plimittype
																	  ,ponewlimitsettings) ||
													 ' activation skipped, as it is already expired (Activation date = ' ||
													 htools.d2s(polimitsettings.validfrom) ||
													 ', Deactivation date = ' ||
													 htools.d2s(polimitsettings.validto));
				
				ELSIF (polimitsettings.calcmethod <> clmtnotused)
					  AND ((ponewlimitsettings.pan IS NOT NULL) OR
					  (polimitsettings.validfrom <= coperdate))
				THEN
					polimitsettings.active := TRUE;
					osettingschanged       := TRUE;
				END IF;
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END processtemplimit;
	
	BEGIN
		t.enter(cmethodname
			   ,'pCurNo = ' || ponewlimitsettings.curno || ', Card = ' ||
				masktodebug(ponewlimitsettings.pan, ponewlimitsettings.mbr));
	
		processtemplimit(ctempcredlimit, ponewlimitsettings.tempcredlimit, vissettingschanged);
		processtemplimit(ctempcashlimit, ponewlimitsettings.tempcashlimit, vissettingschanged);
	
		IF ponewlimitsettings.tempcredlimit.active
		THEN
		
			IF poldlimitsettings.tempcredlimit.active
			THEN
				chargelimitchangefee(ponewlimitsettings.curno
									,cctp_lcf_acccredtemplmtprofileid
									,poldlimitsettings.tempcredlimit.amount
									,ponewlimitsettings.tempcredlimit.amount
									,poperation);
			
			ELSE
				chargelimitchangefee(ponewlimitsettings.curno
									,cctp_lcf_acccredtemplmtprofileid
									,poldlimitsettings.credlimit.amount
									,ponewlimitsettings.tempcredlimit.amount
									,poperation);
			END IF;
		
		END IF;
	
		t.leave(cmethodname, htools.b2s(vissettingschanged));
		RETURN vissettingschanged;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END processobjecttemplimits;

	PROCEDURE processobjecttemplimits
	(
		poldlimitsettings     IN typeobjectlimitsettings
	   ,poobjectlimitsettings IN OUT NOCOPY typeobjectlimitsettings
	   ,poperation            IN PLS_INTEGER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ProcessObjectTempLimits';
		vdummy BOOLEAN;
	BEGIN
		vdummy := processobjecttemplimits(poldlimitsettings, poobjectlimitsettings, poperation);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END processobjecttemplimits;

	PROCEDURE processcontracttemplimits(poperation IN PLS_INTEGER) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ProcessContractTempLimits';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vobjectlimitsettings typeobjectlimitsettings;
	BEGIN
		t.enter(cmethodname);
	
		FOR i IN (SELECT *
				  FROM   tcontractlimitparams
				  WHERE  branch = cbranch
				  AND    contractno = scontractno)
		LOOP
		
			vobjectlimitsettings := limitrowtorecord(i);
		
			IF processobjecttemplimits(limitrowtorecord(i), vobjectlimitsettings, poperation)
			THEN
				dml_limitsetup_updaterecord(vobjectlimitsettings
										   ,poperation
										   ,pcheckscoring => FALSE);
			END IF;
		
		END LOOP;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END processcontracttemplimits;

	FUNCTION getcalclimitsvalue
	(
		pcurno      IN NUMBER
	   ,pcontractno IN typecontractno := NULL
	   ,ppan        IN typepan := NULL
	   ,pmbr        IN typembr := NULL
	   ,pconsiderpb IN BOOLEAN := TRUE
	) RETURN typelimitvaluerecord IS
		cmethodname CONSTANT VARCHAR2(150) := cpackagename || '.GetCalcLimitsValue';
	
		vcontracttype typecontracttype;
		vcontractno   typecontractno;
		vresult       typelimitvaluerecord;
	
	BEGIN
		t.enter(cmethodname
			   ,'pCurNo = ' || pcurno || ', pContractNo = ' || pcontractno || ', Card = ' ||
				masktodebug(ppan, pmbr));
	
		IF ppan IS NOT NULL
		THEN
		
			vcontractno := contract.getcontractnobycard(ppan, pmbr, c_doexception);
		
			s.say(cmethodname || '     Found contract number by pPAN-pMBR (vContractNo) = ' ||
				  vcontractno);
			IF (pcontractno IS NOT NULL)
			   AND (vcontractno <> pcontractno)
			THEN
				error.raiseerror('Contract does not match to one specified in parameters!');
			END IF;
			s.say(cmethodname || '     - info: ACCOUNT-CARD LINK LIMITS IS GOING TO BE CALCULATED');
		
		ELSIF pcontractno IS NOT NULL
		THEN
		
			s.say(cmethodname ||
				  '     - info: Contract number was taken from input parameters (as pContractNo)');
			vcontractno := pcontractno;
			s.say(cmethodname || '     - info: ACCOUNT CASH LIMIT IS GOING TO BE CALCULATED');
		
		ELSE
			error.raiseerror('Either contract number or PAN should be specified!');
		END IF;
	
		vcontracttype := contract.gettype(vcontractno);
	
		s.say(cmethodname || '     sContractType = ' || scontracttype || ', vContractType = ' ||
			  vcontracttype);
		IF (scontracttype IS NULL)
		   OR (scontracttype <> vcontracttype)
		THEN
			scontracttype := vcontracttype;
			sactparam     := loadparam(scontracttype, cactp_ident);
			sact_cparam   := loadparam(scontracttype, cacp_ident, FALSE);
			FOR i IN 1 .. 2
			LOOP
				sitem(i).dep := contracttypeitems.getitemcode(scontracttype
															 ,'ItemDeposit' || slabel(i));
				sitem(i).ovd := contracttypeitems.getitemcode(scontracttype
															 ,'ItemOverdraft' || slabel(i));
			END LOOP;
		
			IF ifcurrencyisusedintype(1, vcontracttype, vcontractno)
			THEN
				sactparamccy(1) := loadparam(scontracttype, cactp_dom_ident);
			END IF;
			IF ifcurrencyisusedintype(2, vcontracttype, vcontractno)
			THEN
				sactparamccy(2) := loadparam(scontracttype, cactp_int_ident);
			END IF;
		
			s.say(cmethodname || '     - info: Contract type settings was read');
		ELSE
			s.say(cmethodname || '     - info: Contract type settings has been read already');
		END IF;
	
		scontractno := vcontractno;
		IF ifcurrencyisusedintype(pcurno, scontracttype, scontractno)
		THEN
			contracttools.loadcontractaccount(sitem(pcurno).dep, sdepaccount(pcurno), vcontractno);
			sprecision(pcurno) := referencecurrency.getprecision(sdepaccount(pcurno).currencyno);
		END IF;
	
		vresult := calcobjectlimits(pcurno, ppan, pmbr, pconsiderpb);
	
		t.leave(cmethodname
			   ,'CashLimit = ' || vresult.cashlimit || ', CredLimit = ' || vresult.credlimit);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcalclimitsvalue;

	FUNCTION getcurrencybyregister
	(
		pregister   IN contractcollection.typeregister
	   ,pregisterid IN contractcollection.typeregisterid
	) RETURN PLS_INTEGER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCurrencyByRegister';
		vcurno1 PLS_INTEGER := NULL;
		vcurno2 PLS_INTEGER := NULL;
		vresult PLS_INTEGER;
	BEGIN
		t.enter(cmethodname, 'pRegister=' || pregister || ' pRegisterID=' || pregisterid);
	
		IF pregister IS NOT NULL
		THEN
			vcurno1 := getcurnobyvalue(pregister, slabel(1), slabel(2));
		END IF;
	
		IF pregisterid IS NOT NULL
		THEN
			vcurno2 := getcurnobyvalue(pregisterid
									  ,sdepaccount(1).accountno
									  ,sdepaccount(2).accountno);
		END IF;
	
		IF (vcurno1 IS NOT NULL)
		   AND (vcurno2 IS NOT NULL)
		   AND (vcurno1 <> vcurno2)
		THEN
			error.raiseerror('Error: register ID <' || pregisterid ||
							 '> does not correspond with register <' || pregister || '>!');
		END IF;
	
		vresult := nvl(vcurno1, vcurno2);
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcurrencybyregister;

	FUNCTION collectionrulesetupdialog
	(
		pcontracttype IN typecontracttype
	   ,pregister     IN contractcollection.typeregister
	   ,pruleid       IN contractcollection.typeruleid
	   ,oinuse        OUT NUMBER
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CollectionRuleSetupDialog';
		vresult NUMBER;
	BEGIN
		t.enter(cmethodname, 'pRegister=' || pregister || ' pRuleID=' || pruleid);
		t.leave(cmethodname, 'oInUse=' || oinuse || ' vResult=' || vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END collectionrulesetupdialog;

	FUNCTION collectiongetcontractamount
	(
		pcontractno IN typecontractno
	   ,pregister   IN contractcollection.typeregister
	   ,pregisterid IN contractcollection.typeregisterid
	   ,pamountcode IN NUMBER
	   ,oamount     OUT NOCOPY contracttypeschema.typecollectionamount
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CollectionGetContractAmount';
		vresult NUMBER := contractcollection.camtrestypenotsuported;
		vcurno  PLS_INTEGER;
	
		FUNCTION int_getcontractamount
		(
			pcurno      IN PLS_INTEGER
		   ,pamountcode IN NUMBER
		) RETURN NUMBER IS
			cmethodname CONSTANT typemethodname := collectiongetcontractamount.cmethodname ||
												   '.Int_GetContractAmount';
			voverdueamount NUMBER;
			vresult        NUMBER;
		BEGIN
			t.enter(cmethodname, pcurno);
		
			CASE pamountcode
			
				WHEN contractcollection.camtbalance THEN
					vresult := sdepaccount(pcurno).remain;
				
				WHEN contractcollection.camtlimit THEN
					vresult := sdepaccount(pcurno).overdraft;
				
				WHEN contractcollection.camtoverlimit THEN
					vresult := sovdaccount(pcurno).remain;
				
				WHEN contractcollection.camtoverdue THEN
					getdueamount(sdepaccount(pcurno).accountno
								,seance.getoperdate
								,sdummynum
								,voverdueamount);
					vresult := abs(voverdueamount);
				ELSE
					error.raiseerror('Internal error: amount code <' || pamountcode ||
									 '> is not supported!');
			END CASE;
		
			t.leave(cmethodname, vresult);
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_getcontractamount;
	
	BEGIN
		t.enter(cmethodname
			   ,'pRegister=' || pregister || ', pRegisterID=' || pregisterid || ', pAmountCode=' ||
				pamountcode);
	
		IF pamountcode IN (contractcollection.camtbalance
						  ,contractcollection.camtlimit
						  ,contractcollection.camtoverlimit
						  ,contractcollection.camtoverdue)
		THEN
		
			initcontract(pcontractno);
		
			vcurno := getcurrencybyregister(pregister, pregisterid);
		
			IF vcurno IS NULL
			THEN
			
				IF ifcurrencyisusedintype(1, scontracttype, scontractno)
				THEN
				
					oamount.amount   := int_getcontractamount(1, pamountcode);
					oamount.currency := sdepaccount(1).currencyno;
				
					IF ifcurrencyisusedintype(2, scontracttype, scontractno)
					THEN
					
						oamount.amount := oamount.amount +
										  contracttools.getsumincurrency(int_getcontractamount(2
																							  ,pamountcode)
																		,sdepaccount(2).currencyno
																		,sdepaccount(1).currencyno);
					END IF;
				
				ELSE
					oamount.amount   := int_getcontractamount(2, pamountcode);
					oamount.currency := sdepaccount(2).currencyno;
				END IF;
			
			ELSE
				IF ifcurrencyisusedintype(vcurno, scontracttype, scontractno)
				THEN
					oamount.amount   := int_getcontractamount(vcurno, pamountcode);
					oamount.currency := sdepaccount(vcurno).currencyno;
				ELSE
					error.raiseerror('Error: requested currency <' || vcurno ||
									 '> is not used in contract type!');
				END IF;
			END IF;
		
			vresult := contractcollection.camtresok;
		
		END IF;
	
		t.leave(cmethodname
			   ,'vResult=' || vresult || ', Amount=' || oamount.amount || ', Currency=' ||
				oamount.currency);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END collectiongetcontractamount;

	FUNCTION collectioncheckrule
	(
		pcontractno IN typecontractno
	   ,pregister   IN contractcollection.typeregister
	   ,pruleid     IN contractcollection.typeruleid
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CollectionCheckRule';
		vresult NUMBER;
	BEGIN
		t.enter(cmethodname, 'pRegister=' || pregister || ' pRuleID=' || pruleid);
	
		contracttools.checkvalue_exists(pruleid, 'Rule ID');
	
		error.raiseerror('Rule <' || pruleid || '> is not supported by financial scheme.');
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END collectioncheckrule;

	FUNCTION collectionperformaction
	(
		pcontractno IN typecontractno
	   ,paction     IN contracttypeschema.typecollectionperformedaction
	   ,oresult     OUT NOCOPY contracttypeschema.typecollectionactionresult
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CollectionPerformAction';
		vresult NUMBER := contractcollection.cactionresok;
	
		PROCEDURE processfee
		(
			paction IN contracttypeschema.typecollectionperformedaction
		   ,pcharge IN BOOLEAN
		) IS
			cmethodname CONSTANT typemethodname := collectionperformaction.cmethodname ||
												   '.ProcessFee';
			vfeeaccount contracttools.taccountrecord;
			vcurno      PLS_INTEGER;
		BEGIN
			t.enter(cmethodname, htools.b2s(pcharge));
		
			vcurno := getcurnotopostentry(paction.feecurrency);
		
			contracttools.loadcontractaccountbyaccno(paction.feeincomeaccount
													,vfeeaccount
													,c_doexception);
		
			startnewdocument;
		
			IF pcharge
			THEN
				doentry(vcurno
					   ,sdepaccount(vcurno)
					   ,vfeeaccount
					   ,paction.feecurrency
					   ,paction.feeamount
					   ,referenceentry.getident(paction.feeentrycode)
					   ,pdotrxn => FALSE);
			ELSE
				doentry(vcurno
					   ,vfeeaccount
					   ,sdepaccount(vcurno)
					   ,paction.feecurrency
					   ,paction.feeamount
					   ,referenceentry.getident(paction.feeentrycode)
					   ,pdotrxn => FALSE);
			END IF;
		
			adddocnotorollback;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END processfee;
	
	BEGIN
		t.enter(cmethodname);
	
		t.var('pAction.FeeIncomeAccount', paction.feeincomeaccount);
	
		initcontract(pcontractno);
	
		CASE paction.actioncode
		
			WHEN contractcollection.cchargefee THEN
				processfee(paction, TRUE);
			
			WHEN contractcollection.creturnfee THEN
				processfee(paction, FALSE);
			
			ELSE
				vresult := contractcollection.cactionresnotsupported;
			
		END CASE;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			vresult         := contractcollection.cactionresschemeexception;
			oresult.message := substr(SQLERRM, 12);
			t.leave(cmethodname
				   ,'Message=' || oresult.message || ' RollbackData=' || oresult.rollbackdata ||
					' vResult=' || vresult);
			RETURN vresult;
	END collectionperformaction;

	FUNCTION collectiongetschemerules RETURN contractcollection.typestandardspecificrulearray IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CollectionGetSchemeRules';
		vresult contractcollection.typestandardspecificrulearray;
	BEGIN
		t.enter(cmethodname);
		t.leave(cmethodname, vresult.count);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END collectiongetschemerules;

	FUNCTION getrepaymentamount
	(
		pcontractno IN typecontractno
	   ,pstartdate  IN DATE
	   ,penddate    IN DATE
	) RETURN contracttypeschema.typecollectionamount IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetRepaymentAmount';
		vresult contracttypeschema.typecollectionamount;
	BEGIN
		t.enter(cmethodname, 'pStartDate=' || pstartdate || ' pEndDate=' || penddate);
	
		initcontract(pcontractno);
	
		IF NOT ifcurrencyisusedintype(2, scontracttype, scontractno)
		THEN
			vresult.amount   := getpaymentamount(sdepaccount(1).accountno, pstartdate, penddate);
			vresult.currency := sdepaccount(1).currencyno;
		ELSIF NOT ifcurrencyisusedintype(1, scontracttype, scontractno)
		THEN
			vresult.amount   := getpaymentamount(sdepaccount(2).accountno, pstartdate, penddate);
			vresult.currency := sdepaccount(2).currencyno;
		
		ELSE
			vresult.amount   := getpaymentamount(sdepaccount(1).accountno, pstartdate, penddate) +
								contracttools.getsumincurrency(getpaymentamount(sdepaccount(2)
																				.accountno
																			   ,pstartdate
																			   ,penddate)
															  ,sdepaccount(2).currencyno
															  ,sdepaccount(1).currencyno);
			vresult.currency := sdepaccount(1).currencyno;
		END IF;
	
		t.outpar('vResult.Amount', vresult.amount);
		t.outpar('vResult.Currency', vresult.currency);
	
		t.leave(cmethodname);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getrepaymentamount;

	FUNCTION getruleblock(pruleid IN contractcollection.typeruleid) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetRuleBlock';
		vresult VARCHAR2(2000) := NULL;
	BEGIN
		t.enter(cmethodname, 'pRuleID=' || pruleid);
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getruleblock;

	FUNCTION getcyclecalendar
	(
		pcontractno IN typecontractno
	   ,pstartdate  IN DATE
	   ,pcount      IN NUMBER
	) RETURN contracttypeschema.typecollectiondatelist IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCycleCalendar';
	BEGIN
		RETURN getstdatelist(pcontractno, coalesce(pstartdate, seance.getoperdate), 0, pcount);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcyclecalendar;

	FUNCTION getcontractstructure(pcontractno IN typecontractno)
		RETURN contracttypeschema.typecontractcollectionstruct IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetContractStructure';
		vresult contracttypeschema.typecontractcollectionstruct;
		vcount  NUMBER := 1;
	BEGIN
		t.enter(cmethodname);
	
		initcontract(pcontractno);
	
		vresult.maincontractno := pcontractno;
	
		FOR i IN 1 .. 2
		LOOP
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			THEN
				vresult.registerlist(vcount).register := slabel(i);
				vresult.registerlist(vcount).registerid := sdepaccount(i).accountno;
				vresult.registerlist(vcount).registercurrency := sdepaccount(i).currencyno;
				vcount := vcount + 1;
			END IF;
		END LOOP;
	
		t.leave(cmethodname);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcontractstructure;

	FUNCTION collectionavailable RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CollectionAvailable';
	BEGIN
		t.enter(cmethodname);
	
		IF scollectionavailable IS NULL
		THEN
			scollectionavailable := nvl(contractcollection.isavailable, FALSE);
		END IF;
	
		t.leave(cmethodname, htools.b2s(scollectionavailable));
		RETURN scollectionavailable;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END collectionavailable;

	FUNCTION getcollectionattributes(pcurno IN PLS_INTEGER)
		RETURN contractcollection.typeregisterattributearray IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCollectionAttributes';
		coperdate   CONSTANT DATE := seance.getoperdate;
	
		vresult contractcollection.typeregisterattributearray;
		vvalue  NUMBER;
		vdate   DATE;
	
		PROCEDURE addattribute
		(
			prulecode  IN VARCHAR2
		   ,pvalue     IN NUMBER
		   ,preqamount IN NUMBER := NULL
		   ,preqdate   IN DATE := NULL
		) IS
		BEGIN
			vresult(vresult.count + 1).code := prulecode;
			vresult(vresult.count).attributeid := prulecode;
			vresult(vresult.count).nvalue := pvalue;
			vresult(vresult.count).requiredamount := preqamount;
			vresult(vresult.count).requireddate := preqdate;
		END addattribute;
	
		FUNCTION getdebtaspositive(pdebt IN NUMBER) RETURN NUMBER IS
		BEGIN
			RETURN abs(least(pdebt, 0));
		END getdebtaspositive;
	
		FUNCTION calcprc
		(
			ppartamount IN NUMBER
		   ,pfullamount IN NUMBER
		) RETURN NUMBER IS
		BEGIN
			IF pfullamount <> 0
			THEN
				RETURN abs(round(ppartamount * 100 / pfullamount, 2));
			ELSIF ppartamount = 0
			THEN
				RETURN 0;
			END IF;
			RETURN 100;
		END calcprc;
	
	BEGIN
		t.enter(cmethodname);
	
		vvalue := getdebtaspositive(sdepaccount(pcurno).remain);
		addattribute(contractcollection.cbalanceflat, vvalue);
	
		addattribute(contractcollection.cbalanceprclimit
					,calcprc(vvalue, sdepaccount(pcurno).overdraft));
	
		getoverdueinfo(sdepaccount(pcurno).accountno, pcurno, coperdate, vdate, vvalue);
	
		addattribute(contractcollection.coverdueamountflat, vvalue, vvalue, vdate);
	
		addattribute(contractcollection.coverdueamountprcmp
					,calcprc(vvalue, getminpaymentamount(pcurno))
					,vvalue
					,vdate);
	
		addattribute(contractcollection.coverdueamountprclimit
					,calcprc(vvalue, sdepaccount(pcurno).overdraft)
					,vvalue
					,vdate);
	
		vvalue := getdebtaspositive(sovdaccount(pcurno).remain);
		IF vvalue > 0
		THEN
			vdate := fintools.getlastremainchangedate(sovdaccount(pcurno).accountno
													 ,fintools.c_chgtonegative
													 ,coperdate);
		ELSE
			vdate := NULL;
		END IF;
	
		addattribute(contractcollection.coverlimitamountflat, vvalue, vvalue, vdate);
	
		addattribute(contractcollection.coverlimitamountprclimit
					,calcprc(vvalue, sdepaccount(pcurno).overdraft)
					,vvalue
					,vdate);
	
		FOR i IN 1 .. vresult.count
		LOOP
			t.note(cmethodname
				  ,'Attr ' || vresult(i).code || ': NValue = ' || vresult(i).nvalue ||
				   ', RequiredAmount = ' || vresult(i).requiredamount || ', RequiredDate = ' ||
				   htools.d2s(vresult(i).requireddate));
		END LOOP;
	
		t.leave(cmethodname, vresult.count);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcollectionattributes;

	FUNCTION execcollectionoperation(popercode IN VARCHAR2) RETURN PLS_INTEGER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ExecCollectionOperation';
		varegister contractcollection.typecontractregisterarray;
		vresult    PLS_INTEGER := contracttypeschema.c_oper_completed;
	BEGIN
		t.enter(cmethodname, popercode);
	
		FOR i IN 1 .. 2
		LOOP
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			THEN
				varegister(i).register := slabel(i);
				varegister(i).registername := referencecurrency.getabbreviation(sdepaccount(i)
																				.currencyno);
			END IF;
		END LOOP;
	
		contractcollection.execoperation(popercode, scontractno, varegister);
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END execcollectionoperation;

	FUNCTION getcalendarid(pcontractno IN typecontractno) RETURN tcontractcalendar.calendarid%TYPE IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCalendarID';
		vresult       tcontractcalendar.calendarid%TYPE;
		vtypearray    contractlink.typenumber;
		vcontracttype typecontracttype;
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		vresult := contractparams.loadnumber(contractparams.ccontract
											,pcontractno
											,'BillCycleCalendar'
											,c_noexception);
		t.var('Calendar ID on contract level', vresult);
		vresult := nullif(vresult, -1);
	
		IF vresult IS NULL
		THEN
			vcontracttype := contract.gettype(pcontractno, c_doexception);
			IF contractparams.loadbool(contractparams.ccontracttype, vcontracttype, 'CorpMode')
			THEN
				IF contractlink.getlinktypes(vcontracttype, contractlink.clink, vtypearray) <> 1
				THEN
					error.raiseerror('Incorrect contract types link settings for customer contract type ' ||
									 vcontracttype);
				END IF;
				vresult := contractparams.loadnumber(contractparams.ccontracttype
													,vtypearray(1)
													,'CalendarID');
			ELSE
				vresult := contractparams.loadnumber(contractparams.ccontracttype
													,vcontracttype
													,'CalendarID'
													,c_noexception);
			END IF;
		END IF;
	
		t.var('Finally chosen Calendar ID', vresult);
		IF vresult IS NULL
		THEN
			error.raiseerror('Undefined contract type parameter Calendar for contract <' ||
							 pcontractno || '>');
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcalendarid;

	PROCEDURE addlog
	(
		omplog IN OUT NOCOPY VARCHAR
	   ,pstr   IN VARCHAR
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.AddLog';
	BEGIN
		IF sactparam(cctp_intlog) = '1'
		THEN
			omplog := omplog || pstr || ';';
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END addlog;

	FUNCTION getmonthlyfeewaiveramount
	(
		pcurno IN NUMBER
	   ,pdate  IN DATE
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetMonthlyFeeWaiverAmount';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vresult NUMBER;
	BEGIN
		t.enter(cmethodname, 'CurNo = ' || pcurno || ', Date = ' || htools.d2s(pdate));
	
		SELECT MIN(amount)
		INTO   vresult
		FROM   tcontracttrxnlist
		WHERE  branch = cbranch
		AND    accountno = sdepaccount(pcurno).accountno
		AND    trantype = ctrxntype_debit
		AND    postdate = pdate
		AND    debitentcode = ssrvfeeonentcode;
	
		vresult := round(nvl(vresult, 0), sprecision(pcurno));
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getmonthlyfeewaiveramount;

	FUNCTION getfullpaymentdate
	(
		paccountno typeaccountno
	   ,pstartdate DATE
	   ,penddate   DATE
	) RETURN DATE IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetFullPaymentDate';
	
		ventryarray    contracttypeschema.tentryarray;
		vvaluetoreturn DATE := to_date('01.01.1900', 'dd.mm.yyyy');
	BEGIN
		s.say(cmethodname || '    --<< BEGIN');
		s.say(cmethodname || '      -> INPUT PARAMETERS: ');
		s.say(cmethodname || '        pAccountNo = ' || paccountno || ', pStartDate = ' ||
			  htools.d2s(pstartdate) || ', pEndDate = ' || htools.d2s(penddate));
		s.say(cmethodname || '        ');
	
		ventryarray := contracttools.getentryarray(paccount   => paccountno
												  ,pstartdate => nvl(pstartdate
																	,to_date('01.01.1900'
																			,'dd.mm.yyyy'))
												  ,penddate   => penddate
												  ,pmaxcount  => NULL
												  ,parchive   => FALSE);
	
		FOR i IN 1 .. ventryarray.count
		LOOP
			IF ventryarray(i).remain >= 0
			THEN
				vvaluetoreturn := ventryarray(i).opdate;
				s.say(cmethodname || '        Full payment remain ( vEntryArray (' || i ||
					  ').Remain ) = ' || ventryarray(i).remain);
				EXIT;
			END IF;
		END LOOP;
	
		s.say(cmethodname || '        Fully payment date (vValueToReturn) = ' ||
			  htools.d2s(vvaluetoreturn));
		s.say(cmethodname || '    -->> END');
		RETURN vvaluetoreturn;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getfullpaymentdate;

	FUNCTION getlastregisteredprofiles
	(
		pcontractno IN typecontractno
	   ,pcurno      IN NUMBER
	   ,pdate       IN DATE := NULL
	) RETURN tinterestandmp_profhistory%ROWTYPE IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetLastRegisteredProfiles';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		coperdate   CONSTANT DATE := seance.getoperdate;
		vresult tinterestandmp_profhistory%ROWTYPE;
	BEGIN
		s.say(cmethodname || '    --<< BEGIN');
		s.say(cmethodname || '     - INPUT PARAMETERS: pContractNo = ' || pcontractno ||
			  ', pCurNo = ' || pcurno || ', pDate = ' || htools.d2s(pdate));
		FOR cc IN (SELECT *
				   FROM   tinterestandmp_profhistory
				   WHERE  contractno = pcontractno
				   AND    currencynumber = pcurno
				   AND    operdate BETWEEN to_date('01.01.1900', 'dd.mm.yyyy') AND
						  nvl(pdate, coperdate)
				   AND    branch = cbranch
				   ORDER  BY profilehistid DESC)
		LOOP
			vresult := cc;
			s.say(cmethodname ||
				  '      - info: Last registered profiles were found. ID (vRecordToReturn.ProfileHistId) = ' ||
				  vresult.profilehistid);
			EXIT;
		END LOOP;
	
		s.say(cmethodname || '    -->> END');
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getlastregisteredprofiles;

	PROCEDURE undoregisterstate(ppackno IN NUMBER) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UndoRegisterState';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	BEGIN
		DELETE FROM tcontractstatehistory
		WHERE  branch = cbranch
		AND    contractno = scontractno
		AND    packno = ppackno;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END undoregisterstate;

	PROCEDURE undooverduefeelog(ppackno IN NUMBER) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UndoOverdueFeeLog';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	BEGIN
		DELETE FROM toverduefeecalclogmain
		WHERE  packno = ppackno
		AND    branch = cbranch;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END undooverduefeelog;

	PROCEDURE setcycleduedate
	(
		precno IN NUMBER
	   ,pdate  IN DATE
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SetCycleDueDate';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	BEGIN
		t.enter(cmethodname);
	
		UPDATE tcontractstcycle
		SET    lastduedate = pdate
		WHERE  branch = cbranch
		AND    recno = precno;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END setcycleduedate;

	PROCEDURE undoprofilehistorysave(ppackno IN NUMBER) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UndoProfileHistorySave';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	BEGIN
		t.enter(cmethodname, ppackno);
	
		DELETE FROM tinterestandmp_profhistory
		WHERE  branch = cbranch
		AND    contractno = scontractno
		AND    packno = ppackno;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END undoprofilehistorysave;

	PROCEDURE setcorporatecontract
	(
		pnewcontractno IN typecontractno
	   ,pdorollback    IN BOOLEAN
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SetCorporateContract';
		valinkedcontracts contractlink.typecontractarray;
		voldcontractno    typecontractno := NULL;
		vlinkcount        NUMBER;
	BEGIN
		t.enter(cmethodname, pnewcontractno);
	
		vlinkcount := contractlink.getlinkno(scontractno, contractlink.clink, valinkedcontracts);
	
		IF vlinkcount IS NULL
		THEN
			error.raiseerror('Error getting linked corporate contract!');
		
		ELSIF vlinkcount > 0
		THEN
		
			voldcontractno := valinkedcontracts(1).cno;
		END IF;
	
		IF contracttools.notequal(voldcontractno, pnewcontractno)
		THEN
		
			IF (pnewcontractno IS NOT NULL)
			   AND (NOT contract.contractexists(pnewcontractno))
			THEN
				error.raiseerror('Error: corporate contract <' || pnewcontractno ||
								 '> does not exist!');
			END IF;
		
			IF voldcontractno IS NOT NULL
			THEN
				contractlink.delcontractlink(contractlink.clink, scontractno, voldcontractno);
			END IF;
		
			IF pnewcontractno IS NOT NULL
			THEN
				contractlink.addcontractlink(contractlink.clink, scontractno, pnewcontractno);
			END IF;
		
			IF pdorollback
			THEN
				contractrb.setlabel(crl_corp);
				contractrb.setcvalue('OC', voldcontractno);
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END setcorporatecontract;

	PROCEDURE setdafgenmode
	(
		pnewmode    IN NUMBER
	   ,pdorollback IN BOOLEAN
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SetDAFGenMode';
		voldmode NUMBER;
	BEGIN
		t.enter(cmethodname, pnewmode);
	
		IF NOT (pnewmode IN (cdaf_default, cdaf_generate, cdaf_skip))
		THEN
			error.raiseerror('Internal error: unsupported DAF generation mode: ' || pnewmode || '!');
		END IF;
	
		voldmode := contractparams.loadnumber(contractparams.ccontract
											 ,scontractno
											 ,'GenDAF'
											 ,FALSE);
	
		IF contracttools.notequal(voldmode, pnewmode)
		THEN
		
			contractrbstd.changecontractparam(scontractno
											 ,'GenDAF'
											 ,pnewmode
											 ,poldvalue   => voldmode
											 ,pwritelog   => TRUE);
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END setdafgenmode;

	PROCEDURE setdafprofile
	(
		pcurrency   IN NUMBER
	   ,pnewprofile IN NUMBER
	   ,pdorollback IN BOOLEAN
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SetDAFProfile';
		cparamname  CONSTANT VARCHAR2(20) := 'DAFProfile' || slabel(pcurrency);
		voldprofile NUMBER;
	BEGIN
		t.enter(cmethodname, pnewprofile);
	
		voldprofile := contractddreference.loadvalue(contractddreference.ccontract
													,scontractno
													,cparamname
													,FALSE);
	
		IF contracttools.notequal(voldprofile, pnewprofile)
		THEN
		
			IF pnewprofile IS NULL
			THEN
			
				contractddreference.deletevalue(contractddreference.ccontract
											   ,scontractno
											   ,cparamname);
			ELSE
			
				contractddreference.savevalue(contractddreference.ccontract
											 ,scontractno
											 ,cparamname
											 ,pnewprofile
											 ,'Direct Debit Amount calculation profile for ' ||
											  sfulllabel(pcurrency));
			END IF;
		
			IF pdorollback
			THEN
				contractrb.setlabel(crl_daf_profile);
				contractrb.setnvalue('CURRENCY', pcurrency);
				contractrb.setnvalue('OLD_PROFILE', voldprofile);
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END setdafprofile;

	FUNCTION getnewnextsd(pcalendarid IN NUMBER) RETURN DATE IS
		cmethodname   CONSTANT typemethodname := cpackagename || '.GetNewNextSD';
		cprevoperdate CONSTANT DATE := seance.getoperdate - 1;
		vresult DATE;
	BEGIN
		t.enter(cmethodname, pcalendarid);
	
		vresult := contractcalendar.getnextstatementdate(pcalendarid
														,greatest(nvl(getcurrentcycle().duedate
																	 ,cprevoperdate)
																 ,cprevoperdate));
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getnewnextsd;

	FUNCTION needchangenextsd
	(
		pnewsd     IN DATE
	   ,poperation IN PLS_INTEGER
	   ,owarning   OUT NOCOPY VARCHAR2
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.NeedChangeNextSD';
		vcurrentsd DATE;
		vresult    BOOLEAN;
	BEGIN
		t.enter(cmethodname, pnewsd);
	
		vcurrentsd := getcurrentcycle().statementdate;
	
		vresult := (pnewsd <> getcurrentcycle().nextstatementdate) AND
				   (supdatesd OR ((poperation IN (csetcontractparams, cbatchparamchange)) AND
				   (vcurrentsd IS NULL)));
	
		IF vresult
		   AND (vcurrentsd IS NOT NULL)
		   AND (months_between(pnewsd, vcurrentsd) > 1)
		THEN
		
			owarning := 'Difference between current statement date (' || htools.d2s(vcurrentsd) ||
						')~and next (' || htools.d2s(pnewsd) ||
						') statement date is more, than a month!';
		
			IF poperation = csetcontractparams
			THEN
				owarning := owarning || '~~Change calendar anyway?';
			
			ELSE
				owarning := REPLACE(owarning, '~', ' ');
			END IF;
		
		END IF;
	
		t.leave(cmethodname, htools.b2s(vresult));
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END needchangenextsd;

	PROCEDURE updatenextsd
	(
		pnewsd     IN DATE
	   ,poperation IN PLS_INTEGER
	   ,precno     IN NUMBER := NULL
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UpdateNextSD';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vrecno NUMBER;
		voldsd DATE;
	BEGIN
		t.enter(cmethodname
			   ,'New next SD  = ' || pnewsd || ', Operation = ' || getoperationdescr(poperation) ||
				', RecNo = ' || precno);
	
		IF (poperation = coperationundo)
		   AND (pnewsd < seance.getoperdate)
		THEN
			error.raiseerror('Cannot rollback cycle ' || precno || ' next statement date to ' ||
							 htools.d2s(pnewsd) || ' as this date is already passed!');
		END IF;
	
		vrecno := coalesce(precno, getcurrentcycle().recno);
	
		voldsd := getcurrentcycle().nextstatementdate;
	
		UPDATE tcontractstcycle
		SET    nextstatementdate = pnewsd
		WHERE  branch = cbranch
		AND    recno = vrecno;
	
		IF poperation IN (cadjusting, cbatchparamchange)
		THEN
			contractrb.setlabel(crl_nextsd);
			contractrb.setnvalue('RecNo', vrecno);
			contractrb.setdvalue('NextSD', voldsd);
		END IF;
	
		a4mlog.cleanparamlist;
		a4mlog.addparamrec('Next SD', voldsd, pnewsd);
		IF a4mlog.getparamlistcount > 0
		THEN
			a4mlog.logobject(object.gettype(contract.object_name)
							,scontractno
							,'Cycle ' || vrecno || ' next statement date was changed from ' ||
							 htools.d2s(voldsd) || ' to ' || htools.d2s(pnewsd) ||
							 ' by operation "' || getoperationdescr(poperation) || '"'
							,a4mlog.act_change
							,a4mlog.putparamlist
							,powner => getclientid);
		END IF;
	
		resetcurrentcycle;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END updatenextsd;

	PROCEDURE setbillingcalendar
	(
		pcalendarid IN NUMBER
	   ,poperation  IN PLS_INTEGER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SetBillingCalendar';
		vnewcalendarid NUMBER := nvl(pcalendarid, -1);
		voldcalendarid NUMBER;
		vwarning       VARCHAR2(200);
		vnewsd         DATE;
	
		FUNCTION getdescr(pcalendarid IN NUMBER) RETURN VARCHAR2 IS
			cmethodname CONSTANT typemethodname := setbillingcalendar.cmethodname || '.GetDescr';
		BEGIN
			RETURN '<' || CASE pcalendarid WHEN - 1 THEN 'Default' ELSE to_char(pcalendarid) END || '>';
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END getdescr;
	
	BEGIN
		t.enter(cmethodname, vnewcalendarid);
	
		voldcalendarid := contractparams.loadnumber(contractparams.ccontract
												   ,scontractno
												   ,'BILLCYCLECALENDAR'
												   ,FALSE);
	
		IF contracttools.notequal(voldcalendarid, vnewcalendarid)
		THEN
		
			contractparams.savenumber(contractparams.ccontract
									 ,scontractno
									 ,'BILLCYCLECALENDAR'
									 ,vnewcalendarid
									 ,pwhitelog => TRUE);
			sacparam(cp_billcyclecalendar) := vnewcalendarid;
		
			a4mlog.cleanparamlist;
			a4mlog.addparamrec('Billing cycle calendar'
							  ,getdescr(voldcalendarid)
							  ,getdescr(vnewcalendarid));
			IF a4mlog.getparamlistcount > 0
			THEN
				a4mlog.logobject(object.gettype(contract.object_name)
								,scontractno
								,'Billing cycle calendar was changed from ' ||
								 getdescr(voldcalendarid) || ' to ' || getdescr(vnewcalendarid) ||
								 ' by operation "' || getoperationdescr(poperation) || '"'
								,a4mlog.act_change
								,a4mlog.putparamlist
								,powner => getclientid);
			END IF;
		
			IF poperation = cbatchparamchange
			THEN
			
				contractrb.setlabel(crl_billcycleclndr);
				contractrb.setnvalue('BILLCYCLECLNDR', voldcalendarid);
			
				vnewsd := getnewnextsd(getbillingcyclecalendar);
			
				IF needchangenextsd(vnewsd, poperation, vwarning)
				THEN
				
					IF vwarning IS NOT NULL
					THEN
						t.note(cmethodname, vwarning);
					END IF;
				
					updatenextsd(vnewsd, poperation);
				
				END IF;
			
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END setbillingcalendar;

	PROCEDURE uchangestate(pcontractno IN typecontractno) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UChangeState';
	BEGIN
		IF contractrb.getcvalue('OS') = contractstatereference.c_stateauto
		THEN
			contractstatereference.resetcontractstate(pcontractno, getpackno);
		ELSE
			contractstatereference.setcontractstate(pcontractno
												   ,getpackno
												   ,contractrb.getcvalue('OS')
												   ,contractrb.getcvalue('OD'));
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END uchangestate;

	PROCEDURE uchangelimit IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UChangeLimit';
		vaccount  contracttools.taccountrecord;
		vavllimit NUMBER;
		vcurno    NUMBER;
		vlimit    NUMBER;
	BEGIN
	
		contracttools.loadcontractaccountbyaccno(contractrb.getcvalue('AC')
												,vaccount
												,c_doexception);
		vcurno := contractrb.getnvalue('CC');
		vlimit := contractrb.getnvalue('CL');
	
		IF credlimitexceedcorplimit(vcurno, vlimit, vavllimit)
		THEN
			error.raiseerror('According to corporate contract settings, maximum account credit limit value should not exceed ' ||
							 formatmoneywithabbr(vavllimit + vaccount.overdraft, vcurno) ||
							 ' for this customer contract!');
		END IF;
	
		IF (NOT canexceedacccashlimit(sdepaccount(vcurno).currencyno, vavllimit))
		   AND (vavllimit IS NOT NULL)
		   AND
		   (getalllimitsvalue_fromhistory(scontractno) (vcurno)('-').estabcashlimit > vavllimit)
		THEN
			error.raiseerror('According to corporate contract settings, maximum account cash limit value should not exceed ' ||
							 formatmoneywithabbr(vavllimit, vcurno) ||
							 ' for this customer contract!');
		END IF;
	
		contracttools.setoverdraft(vaccount, vlimit);
	
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END uchangelimit;

	PROCEDURE uchangecardstatus IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UChangeCardStatus';
	
		vcardrecord apitypes.typecardrecord;
		vcardinfo   typecardinfo;
	
		vnewreissuesign    typereissuesign := NULL;
		vnewstatus         typecardstatus := NULL;
		vnewstate          typecardstate := NULL;
		vcardchangeallowed BOOLEAN;
	
	BEGIN
		t.enter(cmethodname);
	
		IF contractrb.getcvalue('PAN') IS NOT NULL
		THEN
		
			vcardrecord := getcardrecord(contractrb.getcvalue('PAN'), contractrb.getnvalue('MBR'));
		
			vcardchangeallowed := cardchangeallowed(vcardrecord, coperationundo);
			IF vcardchangeallowed
			THEN
				vnewstate  := contractrb.getnvalue('SIGN');
				vnewstatus := contractrb.getcvalue('STS');
			END IF;
		
			IF reissuesignchangeallowed(vcardrecord, contractrb.getnvalue('RES'))
			THEN
			
				vnewreissuesign := contractrb.getnvalue('RES');
			
				contractparams.savechar(contractparams.ccontract
									   ,scontractno
									   ,'ReIssueBan_' || vcardrecord.pan || '-' || vcardrecord.mbr
									   ,vnewreissuesign
									   ,pmaskmode => contractparams.cmaskkey);
			
			END IF;
		
			updatecardsattributes(vcardrecord
								 ,vnewstate
								 ,vnewstatus
								 ,vnewreissuesign
								 ,getoperationdescr(coperationundo));
		
			IF vcardchangeallowed
			   AND (contractrb.getcvalue('SM') IS NOT NULL)
			THEN
			
				vcardinfo.lockstate     := contractrb.getnvalue('SIGN');
				vcardinfo.lockstatus    := contractrb.getcvalue('STS');
				vcardinfo.setmode       := contractrb.getcvalue('SM');
				vcardinfo.sticktype     := contractrb.getcvalue('ST');
				vcardinfo.autounstick   := contractrb.getcvalue('SAU');
				vcardinfo.stateofsticky := contractrb.getnvalue('DSS');
			
				savecardinfo(vcardinfo, c_norollback);
			
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END uchangecardstatus;

	PROCEDURE undopackno
	(
		ppackno          IN NUMBER
	   ,pisduedate       IN BOOLEAN
	   ,pisstatementdate IN BOOLEAN
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UndoPackNo';
	BEGIN
		t.enter(cmethodname, ppackno);
	
		custom_overdueparameterscalculation.clearcache;
	
		rollbacktrxnlist(ppackno);
	
		FOR i IN 1 .. 2
		LOOP
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			THEN
				contracttools.loadcontractaccount(contracttypeitems.getitemcode(scontracttype
																			   ,'ItemDeposit' ||
																				slabel(i))
												 ,sdepaccount(i)
												 ,scontractno);
				custom_overdueparameterscalculation.fillstminpaymentdataarrays(sdepaccount(i)
																			   .accountno
																			  ,i
																			  ,NULL);
				custom_overdueparameterscalculation.rollbackaggregatedtrxn(sdepaccount(i).accountno
																		  ,i
																		  ,ppackno
																		  ,pisduedate
																		  ,pisstatementdate);
			END IF;
		END LOOP;
	
		custom_overdueparameterscalculation.clearcache;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END undopackno;

	FUNCTION getcontractoperations
	(
		pcontractno IN typecontractno
	   ,pstartdate  IN DATE
	   ,penddate    IN DATE
	   ,parchive    IN NUMBER := 0
	) RETURN contracttypeschema.tentryarray IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetContractOperations';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		ventarray contracttypeschema.tentryarray;
		vcount    NUMBER := 0;
	BEGIN
		scontracttype := contract.gettype(pcontractno);
		FOR i IN 1 .. 2
		LOOP
			IF ifcurrencyisusedintype(i, scontracttype)
			THEN
				contracttools.loadcontractaccount(contracttypeitems.getitemcode(scontracttype
																			   ,'ItemDeposit' ||
																				slabel(i))
												 ,sdepaccount(i)
												 ,pcontractno);
				FOR j IN (SELECT docno
								,entryno
								,trantype
						  FROM   tcontracttrxnlist
						  WHERE  branch = cbranch
						  AND    accountno = sdepaccount(i).accountno
						  AND    postdate BETWEEN pstartdate AND penddate)
				LOOP
					vcount := vcount + 1;
					ventarray(vcount).docno := j.docno;
					ventarray(vcount).no := j.entryno;
					ventarray(vcount).accountno := sdepaccount(i).accountno;
					ventarray(vcount).debit := j.trantype IN (ctrxntype_debit, ctrxntype_creditrev);
				END LOOP;
			END IF;
		END LOOP;
		RETURN ventarray;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getcontractoperations;

	FUNCTION getstatementgenerationsign(pcontractno IN typecontractno) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetStatementGenerationSign';
		vregisteredstaterow contractstatereference.typeregisteredstaterow;
		vresult             BOOLEAN;
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		vregisteredstaterow := contractstatereference.getlastregisteredstate(pcontractno);
		vresult             := htools.i2b(contractstatereference.getstate(vregisteredstaterow.statecode)
										  .statementgen);
	
		t.leave(cmethodname, htools.b2s(vresult));
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getstatementgenerationsign;

	FUNCTION initoper
	(
		pcontracttype IN typecontracttype
	   ,popcode       IN NUMBER
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.InitOper';
	BEGIN
		t.enter(cmethodname, popcode);
	
		err.seterror(0, cmethodname);
		scontracttype                        := pcontracttype;
		contracttypeschema.scontractrow.type := scontracttype;
	
		IF popcode NOT IN (contracttypeschema.operacc_out, contracttypeschema.operacc_in)
		THEN
			error.raiseerror('Operation ' || popcode || ' is not supported!');
		END IF;
	
		sopercode := popcode;
		readsetupscheme(FALSE);
	
		t.leave(cmethodname);
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END initoper;

	FUNCTION execoper RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ExecOper';
	
		vparams        contracttypeschema.trecparam := contracttypeschema.sparameters;
		vcreditaccount contracttools.taccountrecord;
		vdebitaccount  contracttools.taccountrecord;
		vcurno         NUMBER;
	
		PROCEDURE selectaccounts
		(
			ocurno         OUT NUMBER
		   ,obankaccount   OUT NOCOPY contracttools.taccountrecord
		   ,oschemaaccount OUT NOCOPY contracttools.taccountrecord
		) IS
			cmethodname CONSTANT typemethodname := cpackagename || '.SelectAccounts';
		BEGIN
			t.enter(cmethodname);
		
			contracttools.loadcontractaccountbyaccno(vparams.accountno
													,obankaccount
													,c_doexception);
		
			IF NOT ifcurrencyisusedintype(1, contracttypeschema.scontractrow.type, scontractno)
			THEN
				ocurno := 2;
			ELSIF NOT ifcurrencyisusedintype(2, contracttypeschema.scontractrow.type, scontractno)
			THEN
				ocurno := 1;
			ELSE
				ocurno := service.iif(vparams.currencysum = sdepaccount(1).currencyno, 1, 2);
			END IF;
		
			oschemaaccount := sdepaccount(ocurno);
		
			t.leave(cmethodname, ocurno);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END selectaccounts;
	
	BEGIN
		t.enter(cmethodname);
	
		contracttools.checkvalue_exists(vparams.currencysum, 'Currency sum');
	
		scontractstat := contract.getstatus(contracttypeschema.scontractrow.no);
		scontractno   := contracttypeschema.scontractrow.no;
		s.say(cmethodname || ' -> No:' || contracttypeschema.scontractrow.no || ' Stat:' ||
			  scontractstat);
	
		IF contract.checkstatus(scontractstat, contract.stat_close)
		THEN
			error.raiseerror('Contract is already closed!');
		END IF;
	
		getcontractdata;
		IF cycleisclosed
		THEN
			error.raiseerror('Can''t process this operation, as it is SD and contract ' ||
							 scontractno || ' has already been adjusted!');
		END IF;
	
		s.say(cmethodname || ' -> NextStatementDate = ' ||
			  htools.d2s(getcurrentcycle().nextstatementdate));
		IF seance.getoperdate > getcurrentcycle().nextstatementdate
		THEN
			s.say(cmethodname ||
				  ' -> ERROR! Transaction denied. You should close previous cycle first. Please, perform contract adjustment on <' || getcurrentcycle()
				  .nextstatementdate || '>');
			error.raiseerror('Transaction denied. You should close previous cycle first. Please, perform contract adjustment on <' ||
							 htools.d2s(getcurrentcycle().nextstatementdate) || '>');
		END IF;
	
		IF sopercode = contracttypeschema.operacc_in
		THEN
			selectaccounts(vcurno, vdebitaccount, vcreditaccount);
		ELSIF sopercode = contracttypeschema.operacc_out
		THEN
			selectaccounts(vcurno, vcreditaccount, vdebitaccount);
		
		ELSE
			error.raiseerror('Operation ' || sopercode || ' is not supported!');
		END IF;
	
		IF vparams.value > 0
		THEN
			startnewdocument;
			doentry(vcurno
				   ,vdebitaccount
				   ,vcreditaccount
				   ,vparams.currencysum
				   ,vparams.value
				   ,vparams.entident
				   ,vparams.shortremark
				   ,vparams.fullremark
				   ,service.iif(vparams.checkavl, entry.flcheck, entry.flnocheck)
				   ,vparams.valuedate
				   ,FALSE);
			contracttypeschema.sdocno := sdocno;
		END IF;
	
		t.leave(cmethodname);
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END execoper;

	PROCEDURE getstatelist4dc
	(
		pcontracttype IN typecontracttype
	   ,ostatelist    OUT NOCOPY apitypesfordc.typecontractstatelist
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetStateList4DC';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	BEGIN
		t.enter(cmethodname);
	
		SELECT stateid
			  ,statecode
			  ,statename
			  ,1 BULK COLLECT
		INTO   ostatelist
		FROM   tcontractstatereference
		WHERE  branch = cbranch
		ORDER  BY sortorder;
	
		t.leave(cmethodname, ostatelist.count);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getstatelist4dc;

	PROCEDURE initgetdata4dc(pcontracttype IN typecontracttype) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.InitGetData4DC';
	BEGIN
		scontracttype                        := pcontracttype;
		contracttypeschema.scontractrow.type := scontracttype;
		readsetupscheme;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END initgetdata4dc;

	FUNCTION checkautoopencase RETURN BOOLEAN IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.CheckAutoOpenCase';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		coperdate   CONSTANT DATE := seance.getoperdate;
		vodparams      contractdcsetup.typeparamarray;
		volparams      contractdcsetup.typeparamarray;
		vdcparam       contractdcsetup.typectsettingsrecord;
		vparamvalue    contractdcsetup.typeparamrecord;
		vdate          DATE;
		vstatementdate DATE;
		vminpayment    NUMBER;
		vodminpayment  NUMBER;
		vvalue         NUMBER;
		vret           NUMBER;
		vresult        BOOLEAN := FALSE;
		vrate          NUMBER;
	BEGIN
		s.say(cmethodname || '  --<< BEGIN');
		sdcstate.delete;
		sdcoverduedate   := NULL;
		sdcoverlimitdate := NULL;
		FOR i IN 1 .. 2
		LOOP
			sdcoverlimitdates(i) := NULL;
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			THEN
				sdcstate(i).overlimit := FALSE;
				sdcstate(i).overdue := FALSE;
				IF i = 1
				THEN
					vodparams := sodparamsdom;
					volparams := solparamsdom;
					vdcparam  := sdcparamdom;
				ELSE
					vodparams := sodparamsint;
					volparams := solparamsint;
					vdcparam  := sdcparamint;
				END IF;
				IF vdcparam.usedc
				THEN
					s.say(cmethodname || '    -> Use DC for currency=' || i);
					IF vdcparam.dctype = contractdcsetup.cusestandard
					THEN
						s.say(cmethodname || '    -> Use standard params');
						IF coperdate >= getcurrentcycle().duedate
						THEN
							vstatementdate := getcurrentcycle().statementdate;
						ELSE
							vstatementdate := getpreviouscycle().statementdate;
						END IF;
						s.say(cmethodname || '    vStatementDate =' || vstatementdate);
						IF vstatementdate IS NOT NULL
						THEN
							s.say(cmethodname || '    sContractNo =' || scontractno);
							SELECT b.minpayment
							INTO   vminpayment
							FROM   tcontractstcycle          a
								  ,tcontractstminpaymentdata b
							WHERE  a.branch = cbranch
							AND    a.contractno = scontractno
							AND    a.statementdate = vstatementdate
							AND    b.branch = a.branch
							AND    b.screcno = a.recno
							AND    b.currencynumber = i;
							IF sdeldate(i) IS NOT NULL
							THEN
								vminpayment := greatest(vminpayment - custom_overdueparameterscalculation.getrepaymentamounts(sdepaccount(i).accountno, i, coperdate)
														.mp_repayment
													   ,0);
							ELSE
								vminpayment := 0;
							END IF;
							sdcoverdueamount(i) := vminpayment;
							s.say(cmethodname || '    -> Unpaid MP=' || vminpayment ||
								  ' DC Settings=' || vparamvalue.paramvalue);
						
							vparamvalue := contractdcsetup.getparamvalue(vodparams
																		,'OVERDUE_AMOUNT');
							IF vparamvalue.paramuse
							   AND sdeldate(i) IS NOT NULL
							THEN
								s.say(cmethodname || '    -> Use OVERDUE_AMOUNT');
								IF vparamvalue.paramvalue <= vminpayment
								THEN
									sdcstate(i).overdue := TRUE;
									vresult := TRUE;
								END IF;
							END IF;
						
							vparamvalue := contractdcsetup.getparamvalue(vodparams
																		,'OVERDUE_PERIOD');
							IF sdeldate(i) IS NOT NULL
							THEN
								sdcoverduedate := least(sdeldate(i)
													   ,nvl(sdcoverduedate, sdeldate(i)));
								s.say(cmethodname || '    -> Overdue Period=' ||
									  (coperdate - sdeldate(i)));
							END IF;
							IF vparamvalue.paramuse
							   AND sdeldate(i) IS NOT NULL
							THEN
								s.say(cmethodname || '    -> Use OVERDUE_PERIOD');
								s.say(cmethodname || '    -> DC Settings=' ||
									  vparamvalue.paramvalue);
								IF vparamvalue.paramvalue <= coperdate - sdeldate(i)
								THEN
									sdcstate(i).overdue := TRUE;
									vresult := TRUE;
								END IF;
							END IF;
						END IF;
					
						sdcoverlimitamount(i) := abs(sovdaccount(i).remain);
					
						vparamvalue := contractdcsetup.getparamvalue(volparams, 'OVERLIMIT_AMOUNT');
						IF vparamvalue.paramuse
						   AND sovdaccount(i).accountno IS NOT NULL
						   AND sovdaccount(i).remain <> 0
						THEN
							s.say(cmethodname || '    -> Use OVERLIMIT_AMOUNT');
							IF vparamvalue.paramvalue <= abs(sovdaccount(i).remain)
							THEN
								sdcstate(i).overlimit := TRUE;
								vresult := TRUE;
							END IF;
							s.say(cmethodname || '    -> Overlimit=' || abs(sovdaccount(i).remain) ||
								  ' DC Settings=' || vparamvalue.paramvalue);
						END IF;
					
						vparamvalue := contractdcsetup.getparamvalue(volparams, 'OVERLIMIT_RATE');
						IF vparamvalue.paramuse
						   AND sovdaccount(i).accountno IS NOT NULL
						   AND sovdaccount(i).remain <> 0
						THEN
							s.say(cmethodname || '    -> Use OVERLIMIT_RATE');
							vrate := 0;
							IF sdepaccount(i).overdraft = 0
							THEN
								IF sovdaccount(i).remain < 0
								THEN
									vrate := 100;
									sdcstate(i).overlimit := TRUE;
									vresult := TRUE;
								END IF;
							ELSE
								vrate := abs(sovdaccount(i).remain) * 100 / sdepaccount(i)
										.overdraft;
								IF vparamvalue.paramvalue <= vrate
								THEN
									sdcstate(i).overlimit := TRUE;
									vresult := TRUE;
								END IF;
							END IF;
							s.say(cmethodname || '    -> Overlimit Rate=' || vrate ||
								  ' DC Settings=' || vparamvalue.paramvalue);
						END IF;
					
						vparamvalue := contractdcsetup.getparamvalue(volparams, 'OVERLIMIT_PERIOD');
						IF sovdaccount(i).accountno IS NOT NULL
							AND sovdaccount(i).remain <> 0
						THEN
							vdate := nvl(contracttools.getfirstnotnullremaindate(sovdaccount(i)
																				 .accountno
																				,sovdaccount(i)
																				 .createdate - 1
																				,coperdate + 1)
										,sovdaccount(i).createdate);
							sdcoverlimitdates(i) := vdate;
							sdcoverlimitdate := least(vdate, nvl(sdcoverlimitdate, vdate));
							s.say(cmethodname || '    -> Overlimit Period=' || (coperdate - vdate));
						END IF;
						IF vparamvalue.paramuse
						   AND sovdaccount(i).accountno IS NOT NULL
						   AND sovdaccount(i).remain <> 0
						THEN
							s.say(cmethodname || '    -> Use OVERLIMIT_PERIOD');
							s.say(cmethodname || '    -> DC Settings=' || vparamvalue.paramvalue);
							IF vparamvalue.paramvalue <= (coperdate - vdate)
							THEN
								sdcstate(i).overlimit := TRUE;
								vresult := TRUE;
							END IF;
						END IF;
					ELSE
						s.say(cmethodname || '    -> Use PLSQL block');
						contractdcsetup.setcurrentcontractno(scontractno);
						contractdcsetup.clearcontractparamarray;
						contractdcsetup.setdelinquencystate(sblockparam.state.statecode);
						contractdcsetup.addcontractparam('OVERDUE_PERIOD'
														,coperdate - nvl(sdeldate(i), coperdate));
						s.say(cmethodname || ' ->  OVERDUE_PERIOD=' ||
							  (coperdate - nvl(sdeldate(i), coperdate)));
						IF sdeldate(i) IS NOT NULL
						THEN
							sdcoverduedate := least(sdeldate(i), nvl(sdcoverduedate, sdeldate(i)));
						END IF;
					
						IF sdeldate(i) IS NOT NULL
						THEN
							IF coperdate >= getcurrentcycle().duedate
							THEN
								vstatementdate := getcurrentcycle().statementdate;
							ELSE
								vstatementdate := getpreviouscycle().statementdate;
							END IF;
							IF vstatementdate IS NULL
							THEN
								error.raiseerror('Business day is less than contract first Payment Due date');
							END IF;
							SELECT b.minpayment
							INTO   vminpayment
							FROM   tcontractstcycle          a
								  ,tcontractstminpaymentdata b
							WHERE  a.branch = cbranch
							AND    a.contractno = scontractno
							AND    a.statementdate = vstatementdate
							AND    b.branch = a.branch
							AND    b.screcno = a.recno
							AND    b.currencynumber = i;
							vodminpayment := greatest(vminpayment - custom_overdueparameterscalculation.getrepaymentamounts(sdepaccount(i).accountno, i, coperdate)
													  .mp_repayment
													 ,0);
						ELSE
							vodminpayment := 0;
						END IF;
						sdcoverdueamount(i) := vodminpayment;
						s.say(cmethodname || '    ->  OVERDUE_AMOUNT=' || vodminpayment);
						contractdcsetup.addcontractparam('OVERDUE_AMOUNT', vodminpayment);
						IF vminpayment > 0
						THEN
							contractdcsetup.addcontractparam('OVERDUE_PERCENT'
															,round(vodminpayment / vminpayment * 100
																  ,2));
						END IF;
						IF sovdaccount(i).remain <> 0
						THEN
							vdate := nvl(contracttools.getfirstnotnullremaindate(sovdaccount(i)
																				 .accountno
																				,sovdaccount(i)
																				 .createdate - 1
																				,coperdate + 1)
										,sovdaccount(i).createdate);
							vvalue := coperdate - vdate;
							sdcoverlimitdates(i) := vdate;
							sdcoverlimitdate := least(vdate, nvl(sdcoverlimitdate, vdate));
						ELSE
							vvalue := 0;
						END IF;
						s.say(cmethodname || '    ->  OVERLIMIT_PERIOD=' || vvalue);
						contractdcsetup.addcontractparam('OVERLIMIT_PERIOD', vvalue);
						s.say(cmethodname || '    ->  OVERLIMIT_AMOUNT=' ||
							  abs(sovdaccount(i).remain));
						contractdcsetup.addcontractparam('OVERLIMIT_AMOUNT'
														,abs(sovdaccount(i).remain));
						IF sdepaccount(i).overdraft <> 0
						THEN
							contractdcsetup.addcontractparam('OVERLIMIT_PERCENT'
															,round(abs(sovdaccount(i).remain) / sdepaccount(i)
																   .overdraft * 100
																  ,2));
						END IF;
						contractdcsetup.addcontractparam('CURRENCY', i);
						sdcoverlimitamount(i) := abs(sovdaccount(i).remain);
						vret := dynasql.runone(vdcparam.plsqlcode, TRUE);
						s.say(cmethodname || '    -> PL/SQL Result=' || vret);
						IF vret IS NULL
						THEN
							error.raiseerror('PL/SQL Block is incorrect');
						END IF;
						IF vret = 1
						THEN
							sdcstate(i).overlimit := TRUE;
							vresult := TRUE;
							sdcoverdueamount(i) := 0;
						ELSIF vret = 2
						THEN
							sdcstate(i).overdue := TRUE;
							vresult := TRUE;
							sdcoverlimitamount(i) := 0;
						ELSIF vret = 3
						THEN
							sdcstate(i).overdue := TRUE;
							sdcstate(i).overlimit := TRUE;
							vresult := TRUE;
						END IF;
					END IF;
				END IF;
			END IF;
		END LOOP;
	
		s.say(cmethodname || '    -> End=' || service.iif(vresult, 'True', 'False'));
		s.say(cmethodname || '  -->> END');
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END checkautoopencase;

	PROCEDURE execgetdata4dc
	(
		pcontractno   IN typecontractno
	   ,pocontractsh  IN OUT NOCOPY apitypesfordc.typecontractsnapshotrecord
	   ,pitemsshlist  IN apitypesfordc.typecontractitemshapshotlist
	   ,ocontractrec  OUT NOCOPY apitypesfordc.typecontractrecord
	   ,oitemslist    OUT NOCOPY apitypesfordc.typecontractitemlist
	   ,otranslist    OUT NOCOPY apitypesfordc.typedctranslist
	   ,orollbackdata OUT NOCOPY VARCHAR2
	   ,ooverduelist  OUT NOCOPY apitypesfordc.typecontractoverduelist
	) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.ExecGetData4DC';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		coperdate   CONSTANT DATE := seance.getoperdate;
	
		vcontractdc contractdcsetup.typesettingsrecord;
		vautoopen   BOOLEAN := FALSE;
		vtranscount NUMBER := 0;
	
		vchangecondition    BOOLEAN := FALSE;
		voverlimitindicator NUMBER;
		voverdueindicator   NUMBER;
		vstatus             NUMBER;
		vlastdocno          NUMBER;
		vcycleold           VARCHAR(20);
		vcyclenew           VARCHAR(20);
		vhistory            BOOLEAN := FALSE;
		viscaseopened       BOOLEAN;
	
		PROCEDURE fillpaidhistorydata IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename ||
												 '.ExecGetData4DC.FillPaidHistoryData';
			vcount NUMBER := 0;
		BEGIN
			IF vhistory
			THEN
				FOR i IN 1 .. 2
				LOOP
					IF sdepaccount(i).accountno IS NOT NULL
					THEN
						FOR j IN REVERSE 1 .. spaidhistarray(i).count
						LOOP
							IF spaidhistarray(i)(j).overdueamount IS NOT NULL
							THEN
								vcount := vcount + 1;
								ooverduelist(vcount).contractno := pcontractno;
								ooverduelist(vcount).currency := sdepaccount(i).currencyno;
								ooverduelist(vcount).cycle := vcount;
								ooverduelist(vcount).overduedate := spaidhistarray(i)(j).duedate;
								ooverduelist(vcount).overdueamt := spaidhistarray(i)(j)
																  .overdueamount;
							END IF;
						END LOOP;
					END IF;
				END LOOP;
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END;
	
		PROCEDURE fillcontractdata IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.ExecGetData4DC.FillContractData';
			vdocno     NUMBER;
			vcount     NUMBER;
			vshcount   NUMBER;
			vcycles    NUMBER;
			vmaxcycles NUMBER;
		BEGIN
			vchangecondition := FALSE;
		
			vlastdocno := nvl(pocontractsh.lastdocno, 0);
			IF slastdocno(1) IS NOT NULL
			THEN
				vdocno := slastdocno(1);
			END IF;
			IF slastdocno(2) IS NOT NULL
			THEN
				vdocno := greatest(slastdocno(2), nvl(vdocno, slastdocno(2)));
			END IF;
			voverlimitindicator := pocontractsh.overlimitindicator;
			voverdueindicator   := pocontractsh.overdueindicator;
			vstatus             := pocontractsh.status;
		
			s.say(cmethodname || ' -> vLastDocNo=' || vlastdocno);
			s.say(cmethodname || ' -> vOverLimitIndicator=' || pocontractsh.overlimitindicator);
			s.say(cmethodname || ' -> vOverdueIndicator=' || pocontractsh.overdueindicator);
			s.say(cmethodname || ' -> vStatus=' || pocontractsh.status);
		
			pocontractsh.contractno    := pcontractno;
			pocontractsh.branchpart    := contracttypeschema.scontractrow.branchpart;
			pocontractsh.clientid      := contracttypeschema.scontractrow.idclient;
			pocontractsh.opendate      := contracttypeschema.scontractrow.createdate;
			pocontractsh.closedate     := contracttypeschema.scontractrow.closedate;
			pocontractsh.contracttype  := contracttypeschema.scontractrow.type;
			pocontractsh.overduedate   := sdcoverduedate;
			pocontractsh.overlimitdate := sdcoverlimitdate;
			IF contract.checkstatus(scontractstat, contract.stat_close)
			THEN
				pocontractsh.status        := 9;
				pocontractsh.currstatedesc := 'Contract is closed';
			ELSIF contract.checkstatus(scontractstat, contract.stat_violate)
			THEN
				pocontractsh.status        := 2;
				pocontractsh.currstatedesc := 'Contract is violated';
			ELSE
				pocontractsh.status        := 1;
				pocontractsh.currstatedesc := 'Contract is opened';
			END IF;
			s.say(cmethodname || ' -> NewStatus=' || pocontractsh.status);
			pocontractsh.statementformat := 1;
			pocontractsh.statement       := '';
			pocontractsh.updatesysdate   := SYSDATE;
		
			pocontractsh.lastdocno          := vdocno;
			pocontractsh.overlimitindicator := htools.b2i(sdcoverlimitdate IS NOT NULL);
			pocontractsh.overdueindicator   := htools.b2i(sdcoverduedate IS NOT NULL);
			pocontractsh.startoverlimitdate := sdcoverlimitdate;
			pocontractsh.stopoverlimitdate  := NULL;
			pocontractsh.startoverduedate   := sdcoverduedate;
			pocontractsh.stopoverduedate    := NULL;
			pocontractsh.state              := sblockparam.state.statecode;
		
			ocontractrec.contractno      := pocontractsh.contractno;
			ocontractrec.branchpart      := pocontractsh.branchpart;
			ocontractrec.clientid        := pocontractsh.clientid;
			ocontractrec.opendate        := pocontractsh.opendate;
			ocontractrec.closedate       := pocontractsh.closedate;
			ocontractrec.contracttype    := pocontractsh.contracttype;
			ocontractrec.overduedate     := pocontractsh.overduedate;
			ocontractrec.overlimitdate   := pocontractsh.overlimitdate;
			ocontractrec.status          := pocontractsh.status;
			ocontractrec.currstatedesc   := pocontractsh.currstatedesc;
			ocontractrec.statementformat := pocontractsh.statementformat;
			ocontractrec.statement       := pocontractsh.statement;
			ocontractrec.state           := pocontractsh.state;
			ocontractrec.customertype    := service.iif(hascorporatecontract
													   ,'Corporate'
													   ,'Individual');
			ocontractrec.limittype       := getlimittypedescr_int(pocontractsh.contractno);
			ocontractrec.statustitle     := contract.getstatusname(scontractstat);
		
			vcount     := 0;
			vmaxcycles := 0;
			FOR i IN 1 .. 2
			LOOP
				IF sdepaccount(i).accountno IS NOT NULL
				THEN
					vcount := vcount + 1;
					IF sdeldate(i) IS NOT NULL
					THEN
						SELECT COUNT(*) + 1
						INTO   vcycles
						FROM   tcontractstcycle
						WHERE  branch = cbranch
						AND    contractno = scontractno
						AND    statementdate >= sdeldate(i)
						AND    duedate <= coperdate;
					ELSE
						vcycles := 0;
					END IF;
					vmaxcycles := greatest(vmaxcycles, vcycles);
					oitemslist(vcount).contractno := scontractno;
					oitemslist(vcount).accountno := sdepaccount(i).accountno;
					oitemslist(vcount).accounttype := sdepaccount(i).accounttype;
					oitemslist(vcount).currency := sdepaccount(i).currencyno;
					oitemslist(vcount).credit := sdepaccount(i).overdraft;
					oitemslist(vcount).currentbalance := sdepaccount(i).remain;
					oitemslist(vcount).totaldue := getcurrentmp(i);
					oitemslist(vcount).overdue := sdcoverdueamount(i);
					oitemslist(vcount).overlimit := sdcoverlimitamount(i);
					oitemslist(vcount).overduedate := sdeldate(i);
					oitemslist(vcount).overduecycle := vcycles;
					oitemslist(vcount).overlimitdate := sdcoverlimitdates(i);
					oitemslist(vcount).reqpayment := getminpaymentamount(i);
				
					vshcount := NULL;
					FOR j IN 1 .. pitemsshlist.count
					LOOP
						IF pitemsshlist(j).currency = oitemslist(vcount).currency
						THEN
							vshcount := j;
						END IF;
					END LOOP;
					IF vshcount IS NOT NULL
					THEN
						IF pitemsshlist(vshcount).credit <> oitemslist(vcount).credit
						THEN
							vchangecondition := TRUE;
						END IF;
					END IF;
				END IF;
			END LOOP;
			pocontractsh.overduecycle := vmaxcycles;
			ocontractrec.overduecycle := vmaxcycles;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END;
	
		PROCEDURE fillchangedata IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.ExecGetData4DC.FillChangeData';
		BEGIN
			IF vchangecondition
			THEN
				vtranscount := vtranscount + 1;
				otranslist(vtranscount).trancode := apitypesfordc.cchangeconditions;
				otranslist(vtranscount).contractno := scontractno;
				otranslist(vtranscount).time := SYSDATE;
				otranslist(vtranscount).textmessage := 'Credit Limit is changed';
			END IF;
			vcycleold := nvl(contractparams.loadchar(contractparams.ccontract
													,scontractno
													,'DelCycle4DC'
													,FALSE)
							,0);
			vcyclenew := contractstatereference.getlastregisteredstate(scontractno, coperdate)
						 .statecode;
			s.say(cmethodname || ' *************** vCycleOld =' || vcycleold);
			s.say(cmethodname || ' *************** vCycleNew =' || vcyclenew);
			IF (vcycleold <> vcyclenew)
			   AND (schargeparam.genevent)
			THEN
				vtranscount := vtranscount + 1;
				otranslist(vtranscount).trancode := apitypesfordc.cchangestate;
				otranslist(vtranscount).contractno := scontractno;
				otranslist(vtranscount).time := SYSDATE;
				otranslist(vtranscount).textmessage := 'Contract State is changed from ' ||
													   vcycleold || ' to ' || vcyclenew;
				contractparams.savechar(contractparams.ccontract
									   ,scontractno
									   ,'DelCycle4DC'
									   ,vcyclenew);
				orollbackdata := orollbackdata || '#DCS' || vcycleold;
			END IF;
		
			IF nvl(voverlimitindicator, 0) = 0
			   AND pocontractsh.overlimitindicator = 1
			THEN
				vtranscount := vtranscount + 1;
				otranslist(vtranscount).trancode := apitypesfordc.coverlimiton;
				otranslist(vtranscount).contractno := scontractno;
				otranslist(vtranscount).time := SYSDATE;
				otranslist(vtranscount).textmessage := 'Over-Limit is On';
			END IF;
			IF nvl(voverlimitindicator, 0) = 1
			   AND pocontractsh.overlimitindicator = 0
			THEN
				vtranscount := vtranscount + 1;
				otranslist(vtranscount).trancode := apitypesfordc.coverlimitoff;
				otranslist(vtranscount).contractno := scontractno;
				otranslist(vtranscount).time := SYSDATE;
				otranslist(vtranscount).textmessage := 'Over-Limit is Off';
			END IF;
			IF nvl(voverdueindicator, 0) = 0
			   AND pocontractsh.overdueindicator = 1
			THEN
				vtranscount := vtranscount + 1;
				otranslist(vtranscount).trancode := apitypesfordc.coverdueon;
				otranslist(vtranscount).contractno := scontractno;
				otranslist(vtranscount).time := SYSDATE;
				otranslist(vtranscount).textmessage := 'OverDue is On';
			END IF;
			IF nvl(voverdueindicator, 0) = 1
			   AND pocontractsh.overdueindicator = 0
			THEN
				vtranscount := vtranscount + 1;
				otranslist(vtranscount).trancode := apitypesfordc.coverdueoff;
				otranslist(vtranscount).contractno := scontractno;
				otranslist(vtranscount).time := SYSDATE;
				otranslist(vtranscount).textmessage := 'OverDue is Off';
			END IF;
			IF nvl(vstatus, 1) = 1
			   AND pocontractsh.status = 2
			THEN
				vtranscount := vtranscount + 1;
				otranslist(vtranscount).trancode := apitypesfordc.cblock_;
				otranslist(vtranscount).contractno := scontractno;
				otranslist(vtranscount).time := SYSDATE;
				otranslist(vtranscount).textmessage := 'Contract is blocked';
			END IF;
			IF nvl(vstatus, 1) = 2
			   AND pocontractsh.status = 1
			THEN
				vtranscount := vtranscount + 1;
				otranslist(vtranscount).trancode := apitypesfordc.copen_;
				otranslist(vtranscount).contractno := scontractno;
				otranslist(vtranscount).time := SYSDATE;
				otranslist(vtranscount).textmessage := 'Contract is unblocked';
			END IF;
			IF coperdate = getcurrentcycle().duedate
			THEN
				vtranscount := vtranscount + 1;
				otranslist(vtranscount).trancode := apitypesfordc.ccontractcycleend;
				otranslist(vtranscount).contractno := scontractno;
				otranslist(vtranscount).time := SYSDATE;
				otranslist(vtranscount).textmessage := 'Today is Due Date';
				vhistory := TRUE;
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END;
	
		PROCEDURE filloperdata IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.ExecGetData4DC.FillOperData';
		BEGIN
			s.say(cmethodname || ' -> LastDocNo=' || vlastdocno);
			FOR i IN 1 .. 2
			LOOP
				IF ifcurrencyisusedintype(i, NULL, pcontractno)
				THEN
					s.say(cmethodname || ' -> !!! Currency=' || i);
					FOR e IN (SELECT -a.value VALUE
									,a.docno docno
									,nvl(d.cashadvance, 0) enttype
									,a.valuedate valuedate
							  FROM   tentry                  a
									,tdocument               b
									,tcontractentrygrouplist c
									,tcontractentrygroup     d
							  WHERE  a.branch = cbranch
							  AND    a.debitaccount = sdepaccount(i).accountno
							  AND    a.docno > vlastdocno
							  AND    b.branch = a.branch
							  AND    b.docno = a.docno
							  AND    b.newdocno IS NULL
							  AND    c.branch(+) = a.branch
							  AND    c.entcode(+) = a.debitentcode
							  AND    d.branch(+) = c.branch
							  AND    d.groupid(+) = c.groupid
							  UNION ALL
							  SELECT a.value VALUE
									,a.docno docno
									,nvl(d.cashadvance, 0) enttype
									,a.valuedate valuedate
							  FROM   tentry                  a
									,tdocument               b
									,tcontractentrygrouplist c
									,tcontractentrygroup     d
							  WHERE  a.branch = cbranch
							  AND    a.creditaccount = sdepaccount(i).accountno
							  AND    a.docno > vlastdocno
							  AND    b.branch = a.branch
							  AND    b.docno = a.docno
							  AND    b.newdocno IS NULL
							  AND    c.branch(+) = a.branch
							  AND    c.entcode(+) = a.debitentcode
							  AND    d.branch(+) = c.branch
							  AND    d.groupid(+) = c.groupid)
					LOOP
						vtranscount := vtranscount + 1;
						s.say(cmethodname || ' -> DocNo=' || e.docno || ' Amount=' || e.value ||
							  ' Type=' || e.enttype);
						IF e.value > 0
						THEN
							IF e.enttype = 2
							THEN
								otranslist(vtranscount).trancode := apitypesfordc.cpayoff;
								vhistory := TRUE;
							ELSE
								otranslist(vtranscount).trancode := apitypesfordc.ccredit;
							END IF;
						ELSE
							IF e.enttype = 3
							THEN
								otranslist(vtranscount).trancode := apitypesfordc.ccharge;
							ELSE
								otranslist(vtranscount).trancode := apitypesfordc.cdebit;
							END IF;
						END IF;
						otranslist(vtranscount).contractno := scontractno;
						otranslist(vtranscount).docno := e.docno;
						otranslist(vtranscount).amount := abs(e.value);
						otranslist(vtranscount).time := e.valuedate;
						otranslist(vtranscount).currency := sdepaccount(i).currencyno;
					END LOOP;
				END IF;
			END LOOP;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END;
	
		PROCEDURE opencase IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.ExecGetData4DC.OpenCase';
		BEGIN
			fillcontractdata;
			IF NOT viscaseopened
			THEN
				vtranscount := vtranscount + 1;
				otranslist(vtranscount).trancode := apitypesfordc.copencase;
				otranslist(vtranscount).contractno := scontractno;
				otranslist(vtranscount).time := SYSDATE;
				IF vcontractdc.opencase
				THEN
					otranslist(vtranscount).textmessage := vcontractdc.textmessage;
				ELSE
					otranslist(vtranscount).textmessage := 'Automatic open case';
				END IF;
				IF contract.setstatus(scontractno, contract.stat_investigation, TRUE) <> 0
				THEN
					error.raiseerror(err.getfullmessage);
				END IF;
				orollbackdata := orollbackdata || '#IOn';
			
			END IF;
			fillchangedata;
			filloperdata;
			fillpaidhistorydata;
			IF vcontractdc.opencase
			THEN
				contractparams.deletevalue(contractparams.ccontract
										  ,scontractno
										  ,'DC_OpenCaseManually');
				orollbackdata := orollbackdata || '#OCM';
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END;
	
		PROCEDURE closecase IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.ExecGetData4DC.CloseCase';
			vlasttime BOOLEAN;
		BEGIN
			vlasttime := nvl(contractparams.loadbool(contractparams.ccontract
													,scontractno
													,'DCLastTimeSendData'
													,FALSE)
							,FALSE);
			IF NOT viscaseopened
			   AND NOT vlasttime
			THEN
				RETURN;
			END IF;
			fillcontractdata;
			IF vlasttime
			THEN
				vchangecondition := TRUE;
			END IF;
			fillchangedata;
			IF viscaseopened
			THEN
				filloperdata;
				fillpaidhistorydata;
				IF contract.checkstatus(scontractstat, contract.stat_close)
				THEN
					vtranscount := vtranscount + 1;
					otranslist(vtranscount).trancode := apitypesfordc.cclose_;
					otranslist(vtranscount).contractno := scontractno;
					otranslist(vtranscount).time := SYSDATE;
				END IF;
			
				vtranscount := vtranscount + 1;
				otranslist(vtranscount).trancode := apitypesfordc.cclosecase;
				otranslist(vtranscount).contractno := scontractno;
				otranslist(vtranscount).time := SYSDATE;
				IF vcontractdc.closecase
				THEN
					otranslist(vtranscount).textmessage := vcontractdc.textmessage;
					otranslist(vtranscount).responsecode := 5;
				ELSE
					otranslist(vtranscount).textmessage := 'Automatic close case';
					otranslist(vtranscount).responsecode := 1;
				END IF;
				IF vcontractdc.closecase
				THEN
					contractparams.deletevalue(contractparams.ccontract
											  ,scontractno
											  ,'DC_CloseCaseManually');
					orollbackdata := orollbackdata || '#CCM';
				END IF;
				IF contract.setstatus(scontractno, contract.stat_investigation, FALSE) <> 0
				THEN
					error.raiseerror(err.getfullmessage);
				END IF;
				orollbackdata := orollbackdata || '#IOf';
				contractparams.savebool(contractparams.ccontract
									   ,scontractno
									   ,'DCLastTimeSendData'
									   ,TRUE);
				orollbackdata := orollbackdata || '#LTS';
			END IF;
			IF vlasttime
			THEN
				contractparams.savebool(contractparams.ccontract
									   ,scontractno
									   ,'DCLastTimeSendData'
									   ,FALSE);
				orollbackdata := orollbackdata || '#LTD';
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END;
	
		PROCEDURE updatecase IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.ExecGetData4DC.UpdateCase';
		BEGIN
			IF viscaseopened
			THEN
				fillcontractdata;
				fillchangedata;
				filloperdata;
				fillpaidhistorydata;
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END;
	BEGIN
		s.say(cmethodname || ' -> Start ContractNo=' || pcontractno);
		scontractno := pcontractno;
		SELECT *
		INTO   contracttypeschema.scontractrow
		FROM   tcontract
		WHERE  branch = cbranch
		AND    no = scontractno;
		scontractstat := contract.getstatus(contracttypeschema.scontractrow.no);
		viscaseopened := contract.checkstatus(scontractstat, contract.stat_investigation);
	
		IF (NOT viscaseopened)
		   AND contract.checkstatus(scontractstat, contract.stat_close)
		THEN
			RETURN;
		END IF;
	
		FOR i IN 1 .. 2
		LOOP
			sdcoverdueamount(i) := 0;
			sdcoverlimitamount(i) := 0;
		END LOOP;
	
		getcontractdata;
		contractdcsetup.loadvalues(pcontractno, vcontractdc);
	
		IF contract.checkstatus(scontractstat, contract.stat_close)
		THEN
			s.say(cmethodname || ' -> Contract is closed');
			closecase;
		END IF;
	
		s.say(cmethodname || ' -> Cycle.StatementDate =' || getcurrentcycle().statementdate);
		s.say(cmethodname || ' -> Cycle.DueDate =' || getcurrentcycle().duedate);
		s.say(cmethodname || ' -> Cycle.NextStatementDate =' || getcurrentcycle()
			  .nextstatementdate);
	
		s.say(cmethodname || ' -> LastCycle.StatementDate =' || getpreviouscycle().statementdate);
		s.say(cmethodname || ' -> LastCycle.DueDate =' || getpreviouscycle().duedate);
		s.say(cmethodname || ' -> LastCycle.NextStatementDate =' || getpreviouscycle()
			  .nextstatementdate);
	
		IF NOT vcontractdc.dontuseauto
		THEN
			s.say(cmethodname || ' -> Use Auto selection');
			vautoopen := checkautoopencase;
		END IF;
	
		IF vcontractdc.opencase
		THEN
			s.say(cmethodname || ' -> Manual open case');
			opencase;
		ELSIF vcontractdc.closecase
		THEN
			s.say(cmethodname || ' -> Manual close case');
			closecase;
		ELSIF vautoopen
		THEN
			s.say(cmethodname || ' -> Auto open case');
			opencase;
		ELSE
			s.say(cmethodname || ' -> Auto close case');
			IF schargeparam.autoclose
			THEN
				closecase;
			ELSE
				updatecase;
			END IF;
		END IF;
	
		s.say(cmethodname || ' -> End');
	
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	PROCEDURE downgetdata4dc(pcontracttype IN typecontracttype) IS
	BEGIN
		NULL;
	END downgetdata4dc;

	PROCEDURE undogetdata4dc
	(
		pcontractno   IN typecontractno
	   ,prollbackdata IN VARCHAR2
	) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.UndoGetData4DC';
		vcount NUMBER;
		vkey   VARCHAR(10);
		vvalue VARCHAR(100);
	BEGIN
		IF prollbackdata IS NULL
		THEN
			RETURN;
		END IF;
		contracttypeschema.srollbackdata := prollbackdata;
		vcount                           := 1;
		LOOP
			vkey := contracttools.getdataforundo(vcount, vvalue);
			EXIT WHEN vkey IS NULL;
			IF vkey = '#OCM'
			THEN
				contractparams.savebool(contractparams.ccontract
									   ,pcontractno
									   ,'DC_OpenCaseManually'
									   ,TRUE);
			ELSIF vkey = '#CCM'
			THEN
				contractparams.savebool(contractparams.ccontract
									   ,pcontractno
									   ,'DC_CloseCaseManually'
									   ,TRUE);
			ELSIF vkey = '#IOn'
			THEN
				IF contract.setstatus(pcontractno, contract.stat_investigation, FALSE) <> 0
				THEN
					error.raiseerror(err.getfullmessage);
				END IF;
			ELSIF vkey = '#IOf'
			THEN
				IF contract.setstatus(pcontractno, contract.stat_investigation, TRUE) <> 0
				THEN
					error.raiseerror(err.getfullmessage);
				END IF;
			ELSIF vkey = '#DCS'
			THEN
				contractparams.savenumber(contractparams.ccontract
										 ,pcontractno
										 ,'DelCycle4DC'
										 ,vvalue);
			ELSIF vkey = '#LTD'
			THEN
				contractparams.savebool(contractparams.ccontract
									   ,pcontractno
									   ,'DCLastTimeSendData'
									   ,TRUE);
			ELSIF vkey = '#LTS'
			THEN
				contractparams.savebool(contractparams.ccontract
									   ,pcontractno
									   ,'DCLastTimeSendData'
									   ,FALSE);
			END IF;
		END LOOP;
	
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	PROCEDURE complyrequest
	(
		pactions      IN apitypesfordc.typeactionrecord
	   ,orollbackdata OUT NOCOPY VARCHAR2
	) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.ComplyRequest';
		coperdate   CONSTANT DATE := seance.getoperdate;
		vcontractstat    VARCHAR(10);
		vaccnum          NUMBER;
		vstateid         NUMBER;
		vdescription     VARCHAR(100);
		vlastregstaterow contractstatereference.typeregisteredstaterow;
	BEGIN
		vcontractstat := contract.getstatus(pactions.contractno);
		IF pactions.actiontype = apitypesfordc.cactionreportcase
		THEN
			IF pactions.casestatus = apitypesfordc.ccaseopened
			THEN
				IF NOT contract.checkstatus(vcontractstat, contract.stat_investigation)
				THEN
					IF contract.setstatus(pactions.contractno, contract.stat_investigation, TRUE) <> 0
					THEN
						error.raiseerror(err.getfullmessage);
					END IF;
					a4mlog.cleanparamlist;
					a4mlog.addparamrec('Clerk', pactions.clerk);
					a4mlog.addparamrec('ContractStatus'
									  ,contract.getstatusnamebycode(contract.stat_investigation));
					a4mlog.logobject(object.gettype(contract.object_name)
									,pactions.contractno
									,pactions.clerk || ', Debt Collector: set contract status "' ||
									 contract.getstatusnamebycode(vcontractstat) || '"'
									,a4mlog.act_change
									,a4mlog.putparamlist
									,powner => contract.getclientid(pactions.contractno));
					orollbackdata := '#IOn';
				END IF;
			ELSIF pactions.casestatus IN
				  (apitypesfordc.ccaseclosed
				  ,apitypesfordc.ccaseclosedsuccess
				  ,apitypesfordc.ccaseclosedunsuccess
				  ,apitypesfordc.ccaseclosedpartsuccess)
			THEN
				IF contract.checkstatus(vcontractstat, contract.stat_investigation)
				THEN
					IF contract.setstatus(pactions.contractno, contract.stat_investigation, FALSE) <> 0
					THEN
						error.raiseerror(err.getfullmessage);
					END IF;
					a4mlog.cleanparamlist;
					a4mlog.addparamrec('Clerk', pactions.clerk);
					a4mlog.addparamrec('ContractStatus'
									  ,contract.getstatusnamebycode(contract.stat_investigation));
					a4mlog.logobject(object.gettype(contract.object_name)
									,pactions.contractno
									,pactions.clerk || ', Debt Collector: reset contract status "' ||
									 contract.getstatusnamebycode(vcontractstat) || '"'
									,a4mlog.act_change
									,a4mlog.putparamlist
									,powner => contract.getclientid(pactions.contractno));
					orollbackdata := '#IOf';
				END IF;
			ELSIF pactions.casestatus = apitypesfordc.ccasepromisetopay
			THEN
				NULL;
			ELSIF pactions.casestatus = apitypesfordc.ccasepromisetostopusage
			THEN
				NULL;
			END IF;
		ELSIF pactions.actiontype = apitypesfordc.cactioncharge
		THEN
			IF contract.checkstatus(vcontractstat, contract.stat_close)
			THEN
				error.raiseerror('Contract is closed');
			END IF;
			scontracttype                        := contract.gettype(pactions.contractno);
			contracttypeschema.scontractrow.type := scontracttype;
			readsetupscheme;
			contracttypeschema.scontractrow.no := pactions.contractno;
			getcontractdata;
			IF schargeparam.usecharge
			THEN
				IF (schargeparam.chargefrom = 1 AND
				   NOT ifcurrencyisusedintype(1, scontracttype, pactions.contractno))
				   OR (schargeparam.chargefrom = 2 AND
				   NOT ifcurrencyisusedintype(2, scontracttype, pactions.contractno))
				THEN
					error.raiseerror('Fee payment account is defined incorrectly');
				END IF;
				IF NOT ifcurrencyisusedintype(1, scontracttype, pactions.contractno)
				THEN
					vaccnum := 2;
				ELSIF NOT ifcurrencyisusedintype(2, scontracttype, pactions.contractno)
				THEN
					vaccnum := 1;
				ELSIF sdepaccount(2).currencyno = pactions.currency
				THEN
					vaccnum := 2;
				ELSE
					vaccnum := 1;
				END IF;
				sentryno := 0;
				sdocno   := execop.getnextdocno;
				IF sdocno = 0
				THEN
					error.raiseerror(err.getfullmessage);
				END IF;
				IF contracttools.addentry(sdocno
										 ,sentryno
										 ,sdepaccount(vaccnum).accountno
										 ,schargeparam.incomeacc
										 ,schargeparam.entrycode
										 ,pactions.currency
										 ,pactions.amount
										 ,'DC Charge'
										 ,NULL
										 ,entry.flnocheck) <> 0
				THEN
					error.raiseerror(err.getfullmessage);
				END IF;
				a4mlog.cleanparamlist;
				a4mlog.addparamrec('Clerk', pactions.clerk);
				a4mlog.addparamrec('Currency', pactions.currency);
				a4mlog.addparamrec('Amount', pactions.amount);
				a4mlog.logobject(object.gettype(contract.object_name)
								,pactions.contractno
								,pactions.clerk || ', Debt Collector: Debit ' || pactions.amount || ' (' ||
								 referencecurrency.getabbreviation(pactions.currency) || ')'
								,a4mlog.act_change
								,a4mlog.putparamlist
								,powner => contract.getclientid(pactions.contractno));
				orollbackdata := '#DOC' || sdocno;
			END IF;
		ELSIF pactions.actiontype = apitypesfordc.cactionchangestat
		THEN
			vlastregstaterow := contractstatereference.getlastregisteredstate(pactions.contractno
																			 ,coperdate);
			IF vlastregstaterow.stickmode = contractstatereference.cstickmanual
			THEN
				vstateid := contractstatereference.getstateid(vlastregstaterow.statecode);
			END IF;
			IF pactions.contractstate IS NULL
			THEN
				IF vstateid IS NOT NULL
				THEN
					orollbackdata := '#SIS' || vstateid || '@' || vdescription;
					a4mlog.cleanparamlist;
					a4mlog.addparamrec('Clerk', pactions.clerk);
					a4mlog.addparamrec('ContractState', vstateid);
					a4mlog.logobject(object.gettype(contract.object_name)
									,pactions.contractno
									, pactions.clerk || ', Debt Collector: reset contract state ' ||
									  vstateid || ' (' || contractstatereference.getstate(vstateid)
									 .statename || ')'
									,a4mlog.act_change
									,a4mlog.putparamlist
									,powner => contract.getclientid(pactions.contractno));
					contractstatereference.resetcontractstate(pactions.contractno, getpackno);
				END IF;
			ELSE
				IF vstateid IS NULL
				THEN
					orollbackdata := '#SIR';
				ELSE
					orollbackdata := '#SIS' || vstateid || '@' || vdescription;
				END IF;
				contractstatereference.setcontractstate(pactions.contractno
													   ,getpackno
													   ,pactions.contractstate
													   ,'Set by Debt Collector');
				a4mlog.cleanparamlist;
				a4mlog.addparamrec('Clerk', pactions.clerk);
				a4mlog.addparamrec('ContractState', to_char(vstateid), pactions.contractstate);
				a4mlog.logobject(object.gettype(contract.object_name)
								,pactions.contractno
								,pactions.clerk || ', Debt Collector: change contract state from ' ||
								 vstateid || ' to ' || pactions.contractstate
								,a4mlog.act_change
								,a4mlog.putparamlist
								,powner => contract.getclientid(pactions.contractno));
			END IF;
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	PROCEDURE undocomplyrequest
	(
		pactions      IN apitypesfordc.typeactionrecord
	   ,prollbackdata IN VARCHAR2
	) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.UndoComplyRequest';
		vaarg contracttools.typevarchar50;
	BEGIN
		IF prollbackdata = '#IOf'
		THEN
			IF contract.setstatus(pactions.contractno, contract.stat_investigation, TRUE) <> 0
			THEN
				error.raiseerror(err.getfullmessage);
			END IF;
			a4mlog.cleanparamlist;
			a4mlog.addparamrec('Clerk', pactions.clerk);
			a4mlog.logobject(object.gettype(contract.object_name)
							,pactions.contractno
							,pactions.clerk || ', Debt Collector: undo reset contract status'
							,a4mlog.act_change
							,a4mlog.putparamlist
							,powner => contract.getclientid(pactions.contractno));
		ELSIF prollbackdata = '#IOn'
		THEN
			IF contract.setstatus(pactions.contractno, contract.stat_investigation, FALSE) <> 0
			THEN
				error.raiseerror(err.getfullmessage);
			END IF;
			a4mlog.cleanparamlist;
			a4mlog.addparamrec('Clerk', pactions.clerk);
			a4mlog.logobject(object.gettype(contract.object_name)
							,pactions.contractno
							,pactions.clerk || ', Debt Collector: undo set contract status'
							,a4mlog.act_change
							,a4mlog.putparamlist
							,powner => contract.getclientid(pactions.contractno));
		ELSIF substr(prollbackdata, 1, 4) = '#DOC'
		THEN
			IF entry.undo(entry.flnocheck
						 ,to_number(substr(prollbackdata, 5, length(prollbackdata) - 4))) <> 0
			THEN
				error.raiseerror(err.getfullmessage);
			END IF;
			a4mlog.cleanparamlist;
			a4mlog.addparamrec('Clerk', pactions.clerk);
			a4mlog.addparamrec('DocNo'
							  ,to_number(substr(prollbackdata, 5, length(prollbackdata) - 4)));
			a4mlog.logobject(object.gettype(contract.object_name)
							,pactions.contractno
							,pactions.clerk || ', Debt Collector: Undo docNo ' ||
							 to_number(substr(prollbackdata, 5, length(prollbackdata) - 4))
							,a4mlog.act_change
							,a4mlog.putparamlist
							,powner => contract.getclientid(pactions.contractno));
		ELSIF prollbackdata = '#SIR'
		THEN
			contractstatereference.resetcontractstate(pactions.contractno, getpackno);
			a4mlog.cleanparamlist;
			a4mlog.addparamrec('Clerk', pactions.clerk);
			a4mlog.logobject(object.gettype(contract.object_name)
							,pactions.contractno
							,pactions.clerk || ', Debt Collector: Undo setting contract state'
							,a4mlog.act_change
							,a4mlog.putparamlist
							,powner => contract.getclientid(pactions.contractno));
		ELSIF substr(prollbackdata, 1, 4) = '#SIS'
		THEN
			sdummynum := contracttools.getargforundo(substr(prollbackdata
														   ,5
														   ,length(prollbackdata) - 4)
													,vaarg);
			contractstatereference.setcontractstate(pactions.contractno
												   ,getpackno
												   ,vaarg(1)
												   ,vaarg(2));
			a4mlog.cleanparamlist;
			a4mlog.addparamrec('Clerk', pactions.clerk);
			a4mlog.logobject(object.gettype(contract.object_name)
							,pactions.contractno
							,pactions.clerk || ', Debt Collector: Undo setting contract state'
							,a4mlog.act_change
							,a4mlog.putparamlist
							,powner => contract.getclientid(pactions.contractno));
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END undocomplyrequest;

	FUNCTION rangesetupdialog RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.RangeSetupDialog';
		vdialog NUMBER;
	BEGIN
		vdialog := dialog.new('Range setup', 0, 0, 54, 7, pextid => cmethodname);
		dialog.bevel(vdialog, 1, 1, 53, 4, dialog.bevel_frame);
		dialog.inputmoney(vdialog, 'Range', 36, 2, 'Min Range Amount', 'Min Range Amount:');
		dialog.inputmoney(vdialog
						 ,'Min'
						 ,36
						 ,3
						 ,'Score for Confirmed Permission'
						 ,'Score for Confirmed Permission:');
		dialog.inputmoney(vdialog, 'Max', 36, 4, 'Score for Permission', 'Score for Permission:');
	
		dialog.button(vdialog, 'Ok', 15, 6, 12, 'OK', dialog.cmok, 0, 'Save and exit dialog');
		dialog.setdefault(vdialog, 'Ok');
		dialog.button(vdialog
					 ,'Cancel'
					 ,29
					 ,6
					 ,12
					 ,'Cancel'
					 ,dialog.cmcancel
					 ,0
					 ,'Cancel data saving and exit dialog');
		dialog.setdialogpre(vdialog, cpackagename || '.RangeSetupDialogProc');
		dialog.setdialogvalid(vdialog, cpackagename || '.RangeSetupDialogProc');
		RETURN vdialog;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	PROCEDURE rangesetupdialogproc
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR
	   ,pcmd      IN NUMBER
	) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.RangeSetupDialogProc';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vrange NUMBER;
		vmin   NUMBER;
		vmax   NUMBER;
		vcount NUMBER;
	BEGIN
		IF pwhat = dialog.wtdialogpre
		THEN
			dialog.putnumber(pdialog, 'Range', sscorerange);
			dialog.putnumber(pdialog, 'Min', sscoremin);
			dialog.putnumber(pdialog, 'Max', sscoremax);
			IF sscorerange = 0
			THEN
				dialog.setitemattributies(pdialog, 'Range', dialog.selectoff);
			END IF;
		ELSIF pwhat = dialog.wtdialogvalid
		THEN
			vrange := dialog.getnumber(pdialog, 'Range');
			vmin   := dialog.getnumber(pdialog, 'Min');
			vmax   := dialog.getnumber(pdialog, 'Max');
			IF vrange IS NULL
			   OR vrange < 0
			THEN
				dialog.goitem(pdialog, 'Range');
				dialog.sethothint(pdialog, 'Incorrect Value');
				RETURN;
			END IF;
			IF sscorerange IS NULL
			   OR (sscorerange <> vrange)
			THEN
				SELECT COUNT(*)
				INTO   vcount
				FROM   tcontractrevscorerange
				WHERE  branch = cbranch
				AND    contracttype = scontracttype
				AND    scoreprocid = sscoreprocid
				AND    currencynumber = scurrencynumber
				AND    INTERVAL = vrange;
				IF vcount > 0
				THEN
					dialog.goitem(pdialog, 'Range');
					dialog.sethothint(pdialog, 'Range value already exists');
					RETURN;
				END IF;
			END IF;
			IF vmin IS NULL
			   OR vmin < 0
			THEN
				dialog.goitem(pdialog, 'Min');
				dialog.sethothint(pdialog, 'Incorrect Value');
				RETURN;
			END IF;
			IF vmax IS NULL
			   OR vmax < 0
			   OR vmax < vmin
			THEN
				dialog.goitem(pdialog, 'Max');
				dialog.sethothint(pdialog, 'Incorrect Value');
				RETURN;
			END IF;
			sscorerange := vrange;
			sscoremin   := vmin;
			sscoremax   := vmax;
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION scoresetupdialog
	(
		pscoreprocid IN NUMBER
	   ,pcurno       IN NUMBER
	   ,pscoreid     IN NUMBER
	   ,preadonly    IN BOOLEAN
	) RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.ScoreSetupDialog';
		vdialog NUMBER;
		vpos    NUMBER;
	
		FUNCTION getscorepos(pscoreprocid IN NUMBER) RETURN NUMBER IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetScorePos';
		BEGIN
			FOR i IN 1 .. sscoreproc.count
			LOOP
				IF sscoreproc(i).id = pscoreprocid
				THEN
					RETURN i;
				END IF;
			END LOOP;
			RETURN NULL;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END getscorepos;
	
	BEGIN
		vpos            := getscorepos(pscoreprocid);
		sscoreprocid    := pscoreprocid;
		scurrencynumber := pcurno;
		sscoreid        := pscoreid;
		vdialog         := dialog.new(sscoreproc(vpos).name, 0, 0, 70, 7, pextid => cmethodname);
		dialog.bevel(vdialog, 1, 1, 69, 13, dialog.bevel_frame);
		dialog.inputcheck(vdialog
						 ,'Use'
						 ,18
						 ,2
						 ,33
						 ,'Use scoring for this operation'
						 ,'Use scoring for this operation');
		dialog.setitempost(vdialog, 'Use', cpackagename || '.ScoreSetupDialogProc');
		scoring.makecombobox(vdialog, 'ScoreId', 18, 3, 46, 'Scoring Model:', 'Scoring Model');
		dialog.bevel(vdialog
					,1
					,4
					,69
					,1
					,dialog.bevel_top
					,pcaption => sscoreproc(vpos).intervalname);
		dialog.list(vdialog, 'RangeList', 3, 6, 49, 6, 'Operation list');
		dialog.listaddfield(vdialog, 'RangeList', 'Range', 'N', 15, 1, 'R');
		dialog.listaddfield(vdialog, 'RangeList', 'Confirm', 'C', 14, 1, 'R');
		dialog.listaddfield(vdialog, 'RangeList', 'Permit', 'C', 14, 1, 'R');
		dialog.setcaption(vdialog, 'RangeList', 'Range from:~Confirm permit~Permit');
		dialog.setitempost(vdialog, 'RangeList', cpackagename || '.ScoreSetupDialogProc');
		dialog.button(vdialog, 'Add', 56, 6, 12, 'Add', 0, 0, 'Add new range');
		dialog.button(vdialog, 'Delete', 56, 8, 12, 'Delete', 0, 0, 'Delete range');
		dialog.setitempre(vdialog, 'Add', cpackagename || '.ScoreSetupDialogProc');
		dialog.setitempre(vdialog, 'Delete', cpackagename || '.ScoreSetupDialogProc');
	
		dlg_tools.drawbutton(vdialog
							,'Ok'
							,23
							,15
							,12
							,'OK'
							,'Save and exit dialog'
							,dialog.cmok
							,preadonly
							,TRUE);
		dlg_tools.drawbutton(vdialog
							,'Cancel'
							,37
							,15
							,12
							,'Cancel'
							,'Cancel data saving and exit dialog'
							,dialog.cmcancel);
	
		dialog.setdialogpre(vdialog, cpackagename || '.ScoreSetupDialogProc');
		dialog.setdialogvalid(vdialog, cpackagename || '.ScoreSetupDialogProc');
		RETURN vdialog;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	PROCEDURE scoresetupdialogproc
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR
	   ,pcmd      IN NUMBER
	) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.ScoreSetupDialogProc';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vscorerange NUMBER;
	
		PROCEDURE enableok IS
		BEGIN
			IF (scurright_contype = c_canmodify)
			   AND ((dialog.getlistreccount(pdialog, 'RangeList') > 0) OR
			   (NOT dialog.getbool(pdialog, 'Use')))
			THEN
				dialog.setitemattributies(pdialog, 'Ok', dialog.selecton);
			ELSE
				dialog.setitemattributies(pdialog, 'Ok', dialog.selectoff);
			END IF;
		END;
	
		PROCEDURE fillrangelist IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename ||
												 '.ScoreSetupDialogProc.FillRangeList';
		BEGIN
			dialog.listclear(pdialog, 'RangeList');
			FOR i IN (SELECT *
					  FROM   tcontractrevscorerange
					  WHERE  branch = cbranch
					  AND    contracttype = scontracttype
					  AND    scoreprocid = sscoreprocid
					  AND    currencynumber = scurrencynumber
					  ORDER  BY INTERVAL)
			LOOP
				dialog.listaddrecord(pdialog
									,'RangeList'
									,i.interval || '~' || i.scoremin || '~' || i.scoremax);
			END LOOP;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END;
	
	BEGIN
		IF pwhat = dialog.wtdialogpre
		THEN
			IF sscoreid IS NOT NULL
			THEN
				scoring.selectmodelincombo(pdialog, 'ScoreId', sscoreid);
				dialog.putbool(pdialog, 'Use', TRUE);
			ELSE
				INSERT INTO tcontractrevscore
				VALUES
					(cbranch
					,scontracttype
					,sscoreprocid
					,scurrencynumber
					,0);
				dialog.setitemattributies(pdialog, 'Add', dialog.selectoff);
				dialog.setitemattributies(pdialog, 'Delete', dialog.selectoff);
				dialog.setitemattributies(pdialog, 'RangeList', dialog.selectoff);
				dialog.setitemattributies(pdialog, 'ScoreId', dialog.selectoff);
			END IF;
			fillrangelist;
			enableok;
		ELSIF pwhat = dialog.wtitempre
		THEN
			IF pitemname = 'ADD'
			THEN
				sscoremin := NULL;
				sscoremax := NULL;
				IF dialog.getlistreccount(pdialog, 'RangeList') = 0
				THEN
					sscorerange := 0;
				ELSE
					sscorerange := NULL;
				END IF;
				IF dialog.exec(rangesetupdialog) = dialog.cmok
				THEN
					INSERT INTO tcontractrevscorerange
					VALUES
						(cbranch
						,scontracttype
						,sscoreprocid
						,scurrencynumber
						,sscorerange
						,sscoremin
						,sscoremax);
					fillrangelist;
					dialog.setcurrecbyvalue(pdialog, 'RangeList', 'Range', sscorerange);
					enableok;
					dialog.setitemattributies(pdialog, 'Delete', dialog.selecton);
				END IF;
			ELSIF pitemname = 'DELETE'
			THEN
				IF dialog.getcurrentrecordnumber(pdialog, 'RangeList', 'Range') = 0
				THEN
					htools.message('Error', 'Impossible to delete record for range 0');
					RETURN;
				END IF;
				IF htools.ask('Attention', 'Do you want to delete selected range ?')
				THEN
					sscorerange := dialog.getcurrentrecordnumber(pdialog, 'RangeList', 'Range');
					DELETE FROM tcontractrevscorerange
					WHERE  branch = cbranch
					AND    contracttype = scontracttype
					AND    scoreprocid = sscoreprocid
					AND    currencynumber = scurrencynumber
					AND    INTERVAL = sscorerange;
				
				END IF;
				fillrangelist;
			END IF;
		ELSIF pwhat = dialog.wtitempost
		THEN
			IF pitemname = 'USE'
			THEN
				IF dialog.getbool(pdialog, 'Use')
				THEN
					dialog.setitemattributies(pdialog, 'Add', dialog.selecton);
					dialog.setitemattributies(pdialog, 'RangeList', dialog.selecton);
					dialog.setitemattributies(pdialog, 'ScoreId', dialog.selecton);
					IF dialog.getlistreccount(pdialog, 'RangeList') > 0
					THEN
						dialog.setitemattributies(pdialog, 'Delete', dialog.selecton);
					END IF;
				ELSE
					dialog.setitemattributies(pdialog, 'Add', dialog.selectoff);
					dialog.setitemattributies(pdialog, 'RangeList', dialog.selectoff);
					dialog.setitemattributies(pdialog, 'ScoreId', dialog.selectoff);
					dialog.setitemattributies(pdialog, 'Delete', dialog.selectoff);
				END IF;
				enableok;
			ELSE
				sscoremin   := dialog.getcurrentrecordnumber(pdialog, 'RangeList', 'Confirm');
				sscoremax   := dialog.getcurrentrecordnumber(pdialog, 'RangeList', 'Permit');
				sscorerange := dialog.getcurrentrecordnumber(pdialog, 'RangeList', 'Range');
				vscorerange := sscorerange;
				IF dialog.exec(rangesetupdialog) = dialog.cmok
				THEN
					UPDATE tcontractrevscorerange
					SET    INTERVAL = sscorerange
						  ,scoremin = sscoremin
						  ,scoremax = sscoremax
					WHERE  branch = cbranch
					AND    contracttype = scontracttype
					AND    scoreprocid = sscoreprocid
					AND    currencynumber = scurrencynumber
					AND    INTERVAL = vscorerange;
					fillrangelist;
					dialog.setcurrecbyvalue(pdialog, 'RangeList', 'Range', sscorerange);
				END IF;
			END IF;
		ELSIF pwhat = dialog.wtdialogvalid
		THEN
			IF pcmd = dialog.cmok
			THEN
				IF dialog.getbool(pdialog, 'Use')
				THEN
					sscoreid := scoring.getselectedmodel(pdialog, 'ScoreId');
					IF sscoreid IS NULL
					THEN
						dialog.goitem(pdialog, 'ScoreId');
						dialog.sethothint(pdialog, 'Value must be specified');
						RETURN;
					END IF;
					UPDATE tcontractrevscore
					SET    scoreid = sscoreid
					WHERE  branch = cbranch
					AND    contracttype = scontracttype
					AND    scoreprocid = sscoreprocid
					AND    currencynumber = scurrencynumber;
				ELSE
					DELETE FROM tcontractrevscore
					WHERE  branch = cbranch
					AND    contracttype = scontracttype
					AND    scoreprocid = sscoreprocid
					AND    currencynumber = scurrencynumber;
				END IF;
			END IF;
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			error.show(pwhere => cmethodname);
			dialog.goitem(pdialog, 'Cancel');
	END;

	FUNCTION canlinkcontracttype
	(
		pcontracttype IN NUMBER
	   ,plinkname     IN VARCHAR
	   ,plinkcode     IN VARCHAR
	) RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.CanLinkContractType';
		vcurrency NUMBER;
		vcurarr   types.arrnum;
		vlinkcode VARCHAR(100);
	BEGIN
		IF plinkname = 'DEFAULT'
		THEN
			FOR i IN 1 .. 2
			LOOP
				vcurarr(i) := NULL;
				IF nvl(contractparams.loadbool(contractparams.ccontracttype
											  ,pcontracttype
											  ,'UseCur' || slabel(i)
											  ,FALSE)
					  ,FALSE)
				THEN
					vcurrency := getcurrency(pcontracttype, 'ItemDeposit' || slabel(i));
					IF vcurrency IS NULL
					THEN
						RETURN contractlink.cfalse;
					END IF;
					vcurarr(i) := vcurrency;
				END IF;
			END LOOP;
			IF vcurarr(1) IS NULL
			THEN
				vlinkcode := vcurarr(2);
			ELSIF vcurarr(2) IS NULL
			THEN
				vlinkcode := vcurarr(1);
			ELSE
				vlinkcode := vcurarr(1) || '_' || vcurarr(2);
			END IF;
			IF vlinkcode IS NOT NULL
			   AND vlinkcode = plinkcode
			THEN
				RETURN contractlink.ctrue;
			END IF;
		ELSIF plinkname = cinstlinkname
		THEN
			FOR i IN 1 .. 2
			LOOP
				IF nvl(contractparams.loadbool(contractparams.ccontracttype
											  ,pcontracttype
											  ,'UseCur' || slabel(i)
											  ,FALSE)
					  ,FALSE)
				THEN
					vcurrency := getcurrency(pcontracttype, 'ItemDeposit' || slabel(i));
					IF vcurrency IS NOT NULL
					   AND to_char(vcurrency) = plinkcode
					THEN
						RETURN contractlink.ctrue;
					END IF;
				END IF;
			END LOOP;
		END IF;
		RETURN contractlink.cfalse;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END canlinkcontracttype;

	FUNCTION canlinkaccttocust
	(
		pcontractno IN VARCHAR
	   ,paccountno  IN VARCHAR
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CanLinkAcctToCust';
		vcardlist apitypes.typeaccount2cardlist;
	BEGIN
		vcardlist := account.getcardlist(paccountno);
		RETURN least(vcardlist.count, 1);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END canlinkaccttocust;

	PROCEDURE fillsecurityarray(popercode IN VARCHAR2) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.FillSecurityArray';
	BEGIN
		t.enter(cmethodname, popercode);
	
		IF popercode = contracttype.get_scheme_parameters_rights
		THEN
			security.cleararray;
			security.addrecord(cright_viewparams, 'View parameters');
			security.addrecord(cright_modifyparams, 'Modify parameters');
			security.addrecord(cright_viewreference, 'View dictionaries');
			security.addrecord(cright_modifyreference, 'Modify dictionaries');
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END fillsecurityarray;

	PROCEDURE updatecardinfo(pocardinfo IN OUT NOCOPY typecardinfo) IS
		PRAGMA AUTONOMOUS_TRANSACTION;
		cmethodname CONSTANT typemethodname := cpackagename || '.UpdateCardInfo';
	BEGIN
		t.enter(cmethodname);
	
		savecardinfo(pocardinfo, c_norollback);
		pocardinfo.infosaved   := TRUE;
		pocardinfo.cardchanged := FALSE;
		COMMIT;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			ROLLBACK;
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END updatecardinfo;

	PROCEDURE getcardinfo
	(
		pcardrecord IN apitypes.typecardrecord
	   ,ocardinfo   OUT NOCOPY typecardinfo
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCardInfo [by record]';
		vcardinfo typeparamvalue;
		vaparams  types.arrstr4000;
	BEGIN
		t.enter(cmethodname, masktodebug(pcardrecord));
	
		vcardinfo := contractparams.loadchar(contractparams.ccontract
											,scontractno
											,'Card_Locked_' || pcardrecord.pan || '-' ||
											 pcardrecord.mbr
											,c_noexception
											,contractparams.cmaskkey);
	
		vaparams := contracttools.parsestring(vcardinfo, '^', pparamcount => 6);
	
		ocardinfo.pan        := pcardrecord.pan;
		ocardinfo.mbr        := pcardrecord.mbr;
		ocardinfo.infosaved  := vcardinfo IS NOT NULL;
		ocardinfo.currstate  := pcardrecord.a4mstat;
		ocardinfo.currstatus := pcardrecord.pcstat;
		ocardinfo.lockstate  := vaparams(6);
		ocardinfo.lockstatus := nvl(vaparams(1), ocardinfo.currstatus);
	
		ocardinfo.cardchanged := (nvl(ocardinfo.lockstate, pcardrecord.a4mstat) <>
								 pcardrecord.a4mstat) OR
								 (ocardinfo.lockstatus <> pcardrecord.pcstat);
	
		IF NOT ocardinfo.infosaved
		THEN
		
			IF pcardrecord.pcstat = referencecrd_stat.card_open
			THEN
				ocardinfo.setmode     := 'A';
				ocardinfo.sticktype   := 'U';
				ocardinfo.autounstick := 'Y';
				updatecardinfo(ocardinfo);
			END IF;
		
		ELSE
		
			IF ocardinfo.cardchanged
			THEN
				ocardinfo.lockstate   := ocardinfo.currstate;
				ocardinfo.lockstatus  := ocardinfo.currstatus;
				ocardinfo.setmode     := 'M';
				ocardinfo.sticktype   := 'S';
				ocardinfo.autounstick := 'N';
				updatecardinfo(ocardinfo);
			
			ELSE
				ocardinfo.setmode       := nvl(vaparams(2), 'A');
				ocardinfo.sticktype     := nvl(vaparams(3), 'U');
				ocardinfo.autounstick   := nvl(vaparams(4), 'Y');
				ocardinfo.stateofsticky := vaparams(5);
			END IF;
		END IF;
	
		t.outpar('Info saved', htools.b2s(ocardinfo.infosaved));
		t.outpar('Lock state', ocardinfo.lockstate);
		t.outpar('Lock status', ocardinfo.lockstatus);
		t.outpar('Current state', ocardinfo.currstate);
		t.outpar('Current status', ocardinfo.currstatus);
		t.outpar('Card changed', htools.b2s(ocardinfo.cardchanged));
		t.outpar('Set mode', ocardinfo.setmode);
		t.outpar('Stick type', ocardinfo.sticktype);
		t.outpar('Auto unstick', ocardinfo.autounstick);
		t.outpar('State of sticky', ocardinfo.stateofsticky);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			ROLLBACK;
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcardinfo;

	FUNCTION cardchangeallowed
	(
		pcardrecord IN apitypes.typecardrecord
	   ,poperation  IN PLS_INTEGER
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CardChangeAllowed';
	
		vresult        BOOLEAN := FALSE;
		vcardinfo      typecardinfo;
		vcardunchanged BOOLEAN;
	
		FUNCTION isstickchecksallowchange RETURN BOOLEAN IS
			cmethodname CONSTANT typemethodname := cardchangeallowed.cmethodname ||
												   '.IsStickChecksAllowChange';
			vstickcardstatus NUMBER := 0;
			vresult          BOOLEAN := TRUE;
		BEGIN
			t.enter(cmethodname, poperation);
		
			IF poperation = coperationundo
			THEN
			
				vresult := vcardinfo.setmode = 'A';
			
			ELSIF poperation IN (cadjusting, csetcontrstate)
			THEN
			
				IF vcardinfo.sticktype = 'S'
				THEN
				
					IF vcardinfo.stateofsticky IS NOT NULL
					THEN
					
						vstickcardstatus := nvl(contractstatereference.getstate(vcardinfo.stateofsticky)
												.stickcardstatus
											   ,0);
					END IF;
				
					vresult := scrdstsautounstick AND (vcardinfo.setmode = 'A') AND
							   (vstickcardstatus = 0);
				END IF;
			
			END IF;
		
			t.leave(cmethodname, htools.b2s(vresult));
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END isstickchecksallowchange;
	
	BEGIN
		t.enter(cmethodname, poperation);
	
		IF poperation IN (csetcardstatus, coperationundo, cdebtrefinance)
		THEN
			vresult := TRUE;
		ELSE
		
			sacparam(cp_cardlock) := contractparams.loadnumber(contractparams.ccontracttype
															  ,contracttypeschema.scontractrow.type
															  ,'CARDLOCK');
		
			IF sacparam(cp_cardlock) <> ccrdstatset_never
			THEN
			
				getcardinfo(pcardrecord, vcardinfo);
			
				IF vcardinfo.infosaved
				THEN
				
					vcardunchanged := (vcardinfo.lockstatus = pcardrecord.pcstat) AND
									  ((vcardinfo.lockstate IS NULL) OR
									  (vcardinfo.lockstate = pcardrecord.a4mstat));
				
					CASE sacparam(cp_cardlock)
					
						WHEN ccrdstatset_open THEN
						
							vresult := (pcardrecord.pcstat = referencecrd_stat.card_open) OR
									   (vcardunchanged AND isstickchecksallowchange);
						
						WHEN ccrdstatset_auto THEN
						
							vresult := vcardunchanged AND isstickchecksallowchange;
						
						ELSE
							error.raiseerror('Parameter "Change card status" has an unknown value: ' ||
											 sacparam(cp_cardlock) || '!');
					END CASE;
				
				END IF;
			
			END IF;
		
		END IF;
	
		t.leave(cmethodname, htools.b2s(vresult));
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END cardchangeallowed;

	FUNCTION reissuesignchangeallowed
	(
		pcardrecord     IN apitypes.typecardrecord
	   ,pnewreissuesign IN typereissuesign
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ReissueSignChangeAllowed';
		vresult BOOLEAN;
	BEGIN
		t.enter(cmethodname, pnewreissuesign);
	
		vresult := (pnewreissuesign IS NOT NULL) AND (pcardrecord.remakedisable <> pnewreissuesign) AND
				   ((pnewreissuesign = card.remake_disable) OR
				   (nvl(contractparams.loadchar(contractparams.ccontract
												,scontractno
												,'ReIssueBan_' || pcardrecord.pan || '-' ||
												 pcardrecord.mbr
												,FALSE
												,contractparams.cmaskkey)
						,card.remake_enable) = card.remake_disable));
	
		t.leave(cmethodname, htools.b2s(vresult));
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END reissuesignchangeallowed;

	FUNCTION selectcardstatustoset
	(
		pstate  IN typecardstate
	   ,pstatus IN typecardstatus
	) RETURN typecardstatus IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SelectCardStatusToSet';
		vresult typecardstatus;
	BEGIN
		t.enter(cmethodname, pstate);
	
		IF pstate IS NULL
		THEN
		
			IF pstatus IS NULL
			THEN
				error.raiseerror('Internal error: neither card state nor card status are passed!');
			END IF;
		
			vresult := pstatus;
		
		ELSE
		
			IF pstatus IS NOT NULL
			THEN
				error.raiseerror('Internal error: card state and status should not be passed simultaneously!');
			END IF;
		
			vresult := referencecardsign.getsignrec(pstate).crd_stat;
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END selectcardstatustoset;

	PROCEDURE setcardsstatusintwo
	(
		pnewstate  IN typecardstate
	   ,pnewstatus IN typecardstatus
	   ,poperation IN PLS_INTEGER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SetCardsStatusInTWO';
		vcardlist  apitypes.typecardlist;
		vnewstatus typecardstatus;
	BEGIN
		t.enter(cmethodname, pnewstatus);
	
		vnewstatus := selectcardstatustoset(pnewstate, pnewstatus);
	
		IF vnewstatus IS NOT NULL
		THEN
		
			vcardlist := contract.getcardlist(scontractno);
		
			FOR i IN 1 .. vcardlist.count
			LOOP
			
				IF cardchangeallowed(vcardlist(i), poperation)
				THEN
				
					remoteonline.setcardstatus(vcardlist(i).pan, vcardlist(i).mbr, vnewstatus);
				
				END IF;
			
			END LOOP;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END setcardsstatusintwo;

	PROCEDURE savecontractparam
	(
		pparamname  IN VARCHAR2
	   ,pvalue      IN typeparamvalue
	   ,pdorollback IN BOOLEAN
	   ,pmaskmode   IN NUMBER := NULL
	   ,ppan        IN typepan := NULL
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SaveContractParam';
	BEGIN
		IF pdorollback
		THEN
			contractrbstd.changecontractparam(scontractno
											 ,pparamname
											 ,pvalue
											 ,pmaskmode
											 ,c_writelog);
		ELSE
			contractparams.savechar(contractparams.ccontract
								   ,scontractno
								   ,pparamname
								   ,pvalue
								   ,c_writelog
								   ,pmaskmode                => pmaskmode
								   ,ppan4mask                => ppan);
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END savecontractparam;

	PROCEDURE savecardinfo
	(
		pcardinfo   IN typecardinfo
	   ,pdorollback IN BOOLEAN
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SaveCardInfo';
		vvalue typeparamvalue;
	BEGIN
		vvalue := pcardinfo.lockstatus || '^' || pcardinfo.setmode || '^' || pcardinfo.sticktype || '^' ||
				  pcardinfo.autounstick || '^' || pcardinfo.stateofsticky || '^' ||
				  pcardinfo.lockstate;
		savecontractparam('Card_Locked_' || pcardinfo.pan || '-' || pcardinfo.mbr
						 ,vvalue
						 ,pdorollback
						 ,contractparams.cmaskkey
						 ,pcardinfo.pan);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END savecardinfo;

	PROCEDURE updatecardsattributes
	(
		pcardrecord     IN apitypes.typecardrecord
	   ,pnewstate       IN typecardstate
	   ,pnewstatus      IN typecardstatus
	   ,pnewreissuesign IN typereissuesign
	   ,pcomment        IN VARCHAR2
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UpdateCardsAttributes';
		vhandle NUMBER;
	BEGIN
		t.enter(cmethodname, masktodebug(pcardrecord));
	
		vhandle := card.newobject(pcardrecord.pan, pcardrecord.mbr, 'W');
		IF vhandle = 0
		THEN
			error.raisewhenerr;
		END IF;
	
		IF pnewstate IS NOT NULL
		THEN
			card.setsignstat(vhandle, pnewstate, pcomment => pcomment);
			error.raisewhenerr;
		END IF;
	
		IF pnewstatus IS NOT NULL
		THEN
			card.setcrd_stat(vhandle, pnewstatus, pcomment => pcomment);
			error.raisewhenerr;
		END IF;
	
		IF pnewreissuesign IS NOT NULL
		THEN
			card.cardremakedisable(vhandle) := pnewreissuesign;
		END IF;
	
		card.writeobject(vhandle);
		error.raisewhenerr;
	
		card.freeobject(vhandle);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			IF vhandle <> 0
			THEN
				card.freeobject(vhandle);
			END IF;
			RAISE;
	END updatecardsattributes;

	PROCEDURE changecardattributes
	(
		pcardrecord     IN apitypes.typecardrecord
	   ,pnewstate       IN typecardstate
	   ,pnewstatus      IN typecardstatus
	   ,pnewreissuesign IN typereissuesign
	   ,poperation      IN PLS_INTEGER
	   ,pdorollback     IN BOOLEAN
	   ,pautomode       IN BOOLEAN
	   ,pchangedintwo   IN BOOLEAN := FALSE
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ChangeCardAttributes';
	
		vnewcardinfo typecardinfo;
	
		vcardchangeallowed     BOOLEAN;
		vneedchangereissuesign BOOLEAN;
		vneedchangestatus      BOOLEAN;
		vneedchangestate       BOOLEAN;
	
		vlogmsg VARCHAR2(1000);
	
		FUNCTION makecardinfo
		(
			pcardrecord IN apitypes.typecardrecord
		   ,pnewstate   IN typecardstate
		   ,pnewstatus  IN typecardstatus
		   ,poperation  IN PLS_INTEGER
		   ,pautomode   IN BOOLEAN
		) RETURN typecardinfo IS
			cmethodname CONSTANT typemethodname := cpackagename || '.MakeCardInfo';
			vresult typecardinfo;
		BEGIN
			t.enter(cmethodname);
		
			vresult.pan         := pcardrecord.pan;
			vresult.mbr         := pcardrecord.mbr;
			vresult.infosaved   := TRUE;
			vresult.currstate   := nvl(pnewstate, pcardrecord.a4mstat);
			vresult.currstatus  := nvl(pnewstatus, pcardrecord.pcstat);
			vresult.lockstate   := pnewstate;
			vresult.lockstatus  := vresult.currstatus;
			vresult.cardchanged := FALSE;
		
			IF poperation = csetcardstatus
			THEN
				vresult.setmode := service.iif(pautomode, 'A', 'M');
			
			ELSIF poperation IN (csetcontrstate, cadjusting, cdebtrefinance)
			THEN
				vresult.setmode := 'A';
			ELSE
				error.raiseerror('Internal error: operation <' || poperation ||
								 '> is not supported!');
			END IF;
		
			IF vresult.setmode = 'M'
			THEN
				vresult.sticktype := 'S';
			
			ELSE
				vresult.sticktype     := service.iif(nvl(sblockparam.state.stickcardstatus, 0) = 1
													,'S'
													,'U');
				vresult.stateofsticky := sblockparam.state.stateid;
			END IF;
		
			vresult.autounstick := CASE vresult.sticktype
									   WHEN 'S' THEN
										'N'
									   WHEN 'U' THEN
										'Y'
									   ELSE
										'?'
								   END;
		
			t.leave(cmethodname);
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makecardinfo;
	
	BEGIN
		t.enter(cmethodname, masktodebug(pcardrecord));
	
		vcardchangeallowed := cardchangeallowed(pcardrecord, poperation);
	
		vneedchangestate       := vcardchangeallowed AND (pnewstate IS NOT NULL) AND
								  (pcardrecord.a4mstat <> pnewstate);
		vneedchangestatus      := vcardchangeallowed AND (pnewstatus IS NOT NULL) AND
								  (pcardrecord.pcstat <> pnewstatus);
		vneedchangereissuesign := reissuesignchangeallowed(pcardrecord, pnewreissuesign);
	
		IF vneedchangestate
		   OR vneedchangestatus
		   OR vneedchangereissuesign
		THEN
			updatecardsattributes(pcardrecord
								 ,service.iif(vneedchangestate, pnewstate, NULL)
								 ,service.iif(vneedchangestatus, pnewstatus, NULL)
								 ,service.iif(vneedchangereissuesign, pnewreissuesign, NULL)
								 ,getoperationdescr(poperation));
		END IF;
	
		IF vcardchangeallowed
		THEN
		
			vnewcardinfo := makecardinfo(pcardrecord, pnewstate, pnewstatus, poperation, pautomode);
		
			savecardinfo(vnewcardinfo, pdorollback);
		
		END IF;
	
		IF vneedchangereissuesign
		THEN
			contractparams.savechar(contractparams.ccontract
								   ,scontractno
								   ,'ReIssueBan_' || pcardrecord.pan || '-' || pcardrecord.mbr
								   ,pnewreissuesign
								   ,pmaskmode => contractparams.cmaskkey);
		END IF;
	
		IF pdorollback
		   AND (vneedchangestate OR vneedchangestatus OR vneedchangereissuesign)
		THEN
		
			contractrb.setlabel(crl_cardstatus);
		
			contractrb.setcvalue('PAN', pcardrecord.pan);
			contractrb.setnvalue('MBR', pcardrecord.mbr);
		
			IF vneedchangestate
			THEN
				contractrb.setnvalue('SIGN', pcardrecord.a4mstat);
			END IF;
		
			IF vneedchangestatus
			   OR vneedchangestate
			THEN
				contractrb.setcvalue('STS', pcardrecord.pcstat);
			END IF;
		
			IF vneedchangereissuesign
			THEN
				contractrb.setnvalue('RES', pcardrecord.remakedisable);
			END IF;
		
		END IF;
	
		IF poperation IN (csetcontrstate, csetcardstatus)
		THEN
		
			a4mlog.cleanparamlist;
		
			IF vneedchangestate
			THEN
				a4mlog.addparamrec('CardState', pcardrecord.a4mstat, pnewstate);
				vlogmsg := vlogmsg || chr(10) || '- changed card state from <' ||
						   referencecardsign.getname(pcardrecord.a4mstat) || '> to <' ||
						   referencecardsign.getname(pnewstate) || '>;';
			END IF;
		
			IF vneedchangestatus
			THEN
				a4mlog.addparamrec('CardStatus', pcardrecord.pcstat, pnewstatus);
				vlogmsg := vlogmsg || chr(10) || '- changed card status from <' ||
						   referencecrd_stat.getname(pcardrecord.pcstat) || '> to <' ||
						   referencecrd_stat.getname(pnewstatus) || '> ' ||
						   service.iif(pchangedintwo, '(TWO and TWCMS)', '(TWCMS only)') || ';';
			END IF;
		
			IF vneedchangereissuesign
			THEN
				a4mlog.addparamrec('Reissue sign', pcardrecord.remakedisable, pnewreissuesign);
				vlogmsg := vlogmsg || chr(10) || '- card reissue ' ||
						   service.iif(pnewreissuesign = 0, 'enabled', 'disabled') || ';';
			END IF;
		
			a4mlog.addparamrec('LocalChange', NULL, htools.b2s(NOT pchangedintwo));
		
			IF a4mlog.getparamlistcount > 0
			THEN
			
				vlogmsg := 'Card ' || masktolog(pcardrecord) || ' attributes changed:' ||
						   substr(vlogmsg, 1, length(vlogmsg) - 1) || '.';
			
				a4mlog.logobject(object.gettype(contract.object_name)
								,scontractno
								,vlogmsg
								,a4mlog.act_change
								,a4mlog.putparamlist
								,powner => getclientid);
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END changecardattributes;

	PROCEDURE setcardsstatusintwcms
	(
		pnewstate       IN typecardstate
	   ,pnewstatus      IN typecardstatus
	   ,pnewreissuesign IN typereissuesign
	   ,poperation      IN PLS_INTEGER
	   ,pdorollback     IN BOOLEAN
	   ,pautomode       IN BOOLEAN
	   ,pchangedintwo   IN BOOLEAN := FALSE
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SetCardsStatusInTWCMS';
		vcardlist  apitypes.typecardlist;
		vnewstatus typecardstatus;
	BEGIN
		t.enter(cmethodname, pnewstatus);
	
		vnewstatus := selectcardstatustoset(pnewstate, pnewstatus);
	
		vcardlist := contract.getcardlist(scontractno);
		FOR i IN 1 .. vcardlist.count
		LOOP
			changecardattributes(vcardlist(i)
								,pnewstate
								,vnewstatus
								,pnewreissuesign
								,poperation
								,pdorollback
								,pautomode
								,pchangedintwo);
		END LOOP;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END setcardsstatusintwcms;

	FUNCTION changecreditlimit
	(
		pcontractno    IN typecontractno
	   ,pvalue         IN NUMBER
	   ,paccounthandle IN NUMBER
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ChangeCreditLimit';
		vlimitsetuprecord typeobjectlimitsettings;
		vcurno            NUMBER;
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		contracttools.checkvalue_exists(paccounthandle, 'Account handle');
	
		initcontract(pcontractno);
	
		vcurno := getcurnobyaccountno(account.getaccountno(paccounthandle));
	
		vlimitsetuprecord := getobjectlimitssetup(scontractno, vcurno);
	
		vlimitsetuprecord.credlimit.amount := pvalue;
	
		BEGIN
			SAVEPOINT sp_setcreditlimit;
			contractrb.init;
			dml_limitsetup_updaterecord(vlimitsetuprecord, cbatchparamchange);
			contracttypeschema.srollbackdata := contractrb.getrbdata;
			contractrb.done;
		EXCEPTION
			WHEN OTHERS THEN
				ROLLBACK TO sp_setcreditlimit;
				contractrb.clearlaststate;
				RAISE;
		END;
	
		t.leave(cmethodname, contracttypeschema.srollbackdata);
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END changecreditlimit;

	FUNCTION undochangecreditlimit
	(
		pcontractno   IN typecontractno
	   ,prollbackdata IN VARCHAR2
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UndoChangeCreditLimit';
	BEGIN
		t.enter(cmethodname, prollbackdata);
	
		contractrb.undo(pcontractno, prollbackdata);
	
		t.leave(cmethodname);
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END undochangecreditlimit;

	PROCEDURE undoinstallmentclosure_legacy(phistpackno NUMBER := NULL) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.UndoInstallmentContrClosure';
		vrollbackremaining VARCHAR2(1000);
	BEGIN
		s.say(cmethodname || '    --<< BEGIN');
		s.say(cmethodname ||
			  '     -> INPUT PARAMETERS (implicit only): Contract Number (sContractNo) = ' ||
			  scontractno);
		s.say(cmethodname || '');
	
		vrollbackremaining := contractrb.undo(scontractno
											 ,contractparams.loadchar(contractparams.ccontract
																	 ,scontractno
																	 ,'LINKED_INST_CLOSED' ||
																	  phistpackno
																	 ,FALSE));
		s.say(cmethodname ||
			  'info: String for rollback remaining after UNDONE Installment Contract Closure (vRollbackRemaining) = ' ||
			  vrollbackremaining);
	
		contractparams.deletevalue(contractparams.ccontract
								  ,scontractno
								  ,'LINKED_INST_CLOSED' || phistpackno);
		s.say(cmethodname || 'info: Contract Parameter LINKED_INST_CLOSED' || phistpackno ||
			  ' has been deleted');
		s.say(cmethodname || '    -->> END');
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END undoinstallmentclosure_legacy;

	PROCEDURE getriskgroup
	(
		plastregovdperiod tcontractstatehistory.calculatedovdperiodinterval%TYPE
	   ,plastregoverlimit tcontractstatehistory.overlimit%TYPE
	   ,
		
		pcurrentovdperiod tcontractstatehistory.overdue%TYPE
	   ,pcurrentovdamount NUMBER
	   ,pcurrentoverlimit tcontractstatehistory.overlimit%TYPE
	   ,
		
		olastreggroupindex OUT NUMBER
	   ,ocurrentgroupindex OUT NUMBER
	) IS
		cmethodname CONSTANT VARCHAR2(100) := cpackagename || '.GetRiskGroup';
	
		vlastreggroup_periodindex NUMBER;
	
		vifoveduewaspaidwithinstate BOOLEAN := FALSE;
		vifovdthresholdwasexceeded  BOOLEAN := TRUE;
	
		vindexfornegativeperiod NUMBER := 1;
		vfoundnegativeperiod    NUMBER;
	
	BEGIN
		s.say(cmethodname || '    --<< BEGIN');
		s.say(cmethodname || '      - INPUT PARAMETERS: ');
		s.say(cmethodname ||
			  '           Last registered group: Overdue period (pLastRegOvdPeriod) = ' ||
			  plastregovdperiod || ', Overlimit (pLastRegOverLimit) = ' || plastregoverlimit);
		s.say(cmethodname || '           Current group: Overdue period (pCurrentOvdPeriod) = ' ||
			  pcurrentovdperiod || ', Overdue amount (pCurrentOvdAmount) = ' || pcurrentovdamount ||
			  ', Overlimit (pCurrentOverlimit) = ' || pcurrentoverlimit);
		s.say(cmethodname || '');
	
		s.say(cmethodname || '');
		s.say(cmethodname ||
			  '             - info: LAST REGISTERED DELINQUENCY GROUP INDEX IS GOING TO BE CALCULATED');
	
		FOR i IN REVERSE 1 .. sdelstatus.count
		LOOP
		
			IF nvl(plastregovdperiod, -0.75) > -0.75
			   AND sdelstatus(i).period > -0.75
			THEN
				s.say(cmethodname || '              Delinquency group index (i) = ' || i ||
					  ', Ovd period (sDelStatus(i).Period) = ' || sdelstatus(i).period ||
					  ', Overlimit (sDelStatus(i).OverLimit) = ' || sdelstatus(i).overlimit);
				IF nvl(plastregovdperiod, -0.75) >= sdelstatus(i).period
				   AND nvl(plastregoverlimit, 0) >= sdelstatus(i).overlimit
				THEN
					olastreggroupindex        := i;
					vlastreggroup_periodindex := sdelstatus(i).period;
					s.say(cmethodname || '                - info: exit point 1');
					EXIT;
				END IF;
			
			ELSIF nvl(plastregovdperiod, -0.75) <= -0.75
				  AND sdelstatus(i).period <= -0.75
			THEN
			
				s.say(cmethodname ||
					  '                      Delinquency group index (vIndexForNegativePeriod) = ' ||
					  vindexfornegativeperiod ||
					  ', Ovd period (sDelStatus(vIndexForNegativePeriod).Period) = ' || sdelstatus(vindexfornegativeperiod)
					  .period ||
					  ', Ovl amount ( sDelStatus(vIndexForNegativePeriod).OverLimit ) = ' || sdelstatus(vindexfornegativeperiod)
					  .overlimit);
			
				IF -nvl(plastregovdperiod, -0.75) >= -sdelstatus(vindexfornegativeperiod).period
				   AND nvl(plastregoverlimit, 0) >= sdelstatus(vindexfornegativeperiod).overlimit
				   AND (vfoundnegativeperiod IS NULL OR
						vfoundnegativeperiod = sdelstatus(vindexfornegativeperiod).period)
				THEN
					vfoundnegativeperiod      := sdelstatus(vindexfornegativeperiod).period;
					vlastreggroup_periodindex := sdelstatus(vindexfornegativeperiod).period;
					olastreggroupindex        := vindexfornegativeperiod;
				END IF;
			
				s.say(cmethodname || '                      vFoundNegativePeriod = ' ||
					  vfoundnegativeperiod);
				IF vfoundnegativeperiod IS NOT NULL
				   AND vfoundnegativeperiod <> sdelstatus(vindexfornegativeperiod).period
				THEN
					s.say(cmethodname || '                - info: exit point 2');
					EXIT;
				END IF;
			
				vindexfornegativeperiod := vindexfornegativeperiod + 1;
			
			END IF;
		END LOOP;
		s.say(cmethodname ||
			  '              Last registered group period index (vLastRegGroup_PeriodIndex) = ' ||
			  vlastreggroup_periodindex);
		s.say(cmethodname || '              oLastRegGroupIndex = ' || olastreggroupindex);
	
		s.say(cmethodname || '');
		s.say(cmethodname ||
			  '             - info: CURRENT DELINQUENCY GROUP INDEX IS GOING TO BE CALCULATED');
	
		vindexfornegativeperiod := 1;
		vfoundnegativeperiod    := NULL;
	
		FOR i IN REVERSE 1 .. sdelstatus.count
		LOOP
			IF nvl(pcurrentovdperiod, -0.75) <= -0.75
			   AND sdelstatus(i).period <= -0.75
			THEN
			
				s.say(cmethodname ||
					  '                      Delinquency group index (vIndexForNegativePeriod) = ' ||
					  vindexfornegativeperiod ||
					  ', Ovd period (sDelStatus(vIndexForNegativePeriod).Period) = ' || sdelstatus(vindexfornegativeperiod)
					  .period ||
					  ', Ovl amount ( sDelStatus(vIndexForNegativePeriod).OverLimit ) = ' || sdelstatus(vindexfornegativeperiod)
					  .overlimit);
				IF -nvl(pcurrentovdperiod, -0.75) >= -sdelstatus(vindexfornegativeperiod).period
				   AND nvl(pcurrentoverlimit, 0) >= sdelstatus(vindexfornegativeperiod).overlimit
				   AND (vfoundnegativeperiod IS NULL OR
						vfoundnegativeperiod = sdelstatus(vindexfornegativeperiod).period)
				THEN
					vfoundnegativeperiod       := sdelstatus(vindexfornegativeperiod).period;
					ocurrentgroupindex         := vindexfornegativeperiod;
					vifovdthresholdwasexceeded := NULL;
				END IF;
			
				s.say(cmethodname || '                      vFoundNegativePeriod = ' ||
					  vfoundnegativeperiod);
				IF vfoundnegativeperiod IS NOT NULL
				   AND vfoundnegativeperiod <> sdelstatus(vindexfornegativeperiod).period
				THEN
					s.say(cmethodname || '                - info: exit point 3');
					EXIT;
				END IF;
			
				vindexfornegativeperiod := vindexfornegativeperiod + 1;
			
			ELSIF nvl(pcurrentovdperiod, -0.75) > -0.75
				  AND sdelstatus(i).period >= -0.75
			THEN
				s.say(cmethodname || '              Delinquency group index (i) = ' || i ||
					  ', Ovd period (sDelStatus(i).Period) = ' || sdelstatus(i).period ||
					  ', Overlimit (sDelStatus(i).OverLimit) = ' || sdelstatus(i).overlimit);
				IF nvl(pcurrentovdperiod, -0.75) >= sdelstatus(i).period
				THEN
					IF nvl(pcurrentovdamount, -0.75) >= sdelstatus(i).overdueamount_threshold
					   AND nvl(pcurrentoverlimit, 0) >= sdelstatus(i).overlimit
					THEN
						ocurrentgroupindex := i;
						s.say(cmethodname || '                - info: exit point 4');
						EXIT;
					ELSIF nvl(pcurrentovdamount, -0.75) < sdelstatus(i).overdueamount_threshold
						  AND vlastreggroup_periodindex = sdelstatus(i).period
					THEN
						vifoveduewaspaidwithinstate := TRUE;
						vifovdthresholdwasexceeded  := FALSE;
						s.say(cmethodname || '                - info: preliminary exit point 5');
						EXIT;
					ELSIF nvl(pcurrentovdamount, -0.75) < sdelstatus(i).overdueamount_threshold
						  AND vlastreggroup_periodindex <> sdelstatus(i).period
					THEN
						vifovdthresholdwasexceeded := FALSE;
						s.say(cmethodname || '                - info: preliminary exit point 6');
						EXIT;
					END IF;
				END IF;
			END IF;
		END LOOP;
		s.say(cmethodname || '              vIfOvedueWasPaidWithinState = ' ||
			  service.iif(vifoveduewaspaidwithinstate, 'YES', 'NO'));
		s.say(cmethodname || '              vIfOvdThresholdWasExceeded = ' ||
			  service.iif(vifovdthresholdwasexceeded, 'YES', 'NO'));
		s.say(cmethodname ||
			  '              Preliminary current group index (oCurrentGroupIndex) = ' ||
			  ocurrentgroupindex ||
			  ', [if oCurrentGroupIndex is NULL then further analysis should be performed]');
	
		IF vifoveduewaspaidwithinstate
		   AND vifovdthresholdwasexceeded = FALSE
		THEN
			FOR i IN REVERSE 1 .. sdelstatus.count
			LOOP
				s.say(cmethodname || '               Delinquency group index (i) = ' || i);
				IF sdelstatus(i).period = -0.75
					AND nvl(pcurrentoverlimit, 0) >= sdelstatus(i).overlimit
				THEN
					ocurrentgroupindex := i;
					s.say(cmethodname || '                - info: exit point 7');
					EXIT;
				END IF;
			END LOOP;
		ELSIF vifovdthresholdwasexceeded = FALSE
		THEN
			FOR i IN REVERSE 1 .. sdelstatus.count
			LOOP
				s.say(cmethodname || '               Delinquency group index (i) = ' || i);
				IF sdelstatus(i).period = vlastreggroup_periodindex
					AND nvl(pcurrentoverlimit, 0) >= sdelstatus(i).overlimit
				THEN
					ocurrentgroupindex := i;
					s.say(cmethodname || '                - info: exit point 8');
					EXIT;
				END IF;
			END LOOP;
		END IF;
		s.say(cmethodname || '              Final current group index (oCurrentGroupIndex) = ' ||
			  ocurrentgroupindex);
	
		s.say(cmethodname || '    -->> END');
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname || '.GetRiskGroup');
			RAISE;
	END getriskgroup;

	FUNCTION getdescrforstickmode(pstickmode IN PLS_INTEGER) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetDescrForStickMode';
	BEGIN
		IF pstickmode IN (contractstatereference.cstick
						 ,contractstatereference.cstickbelow
						 ,contractstatereference.cstickabove)
		THEN
			RETURN 'Set automatically (' || contractstatereference.getdescr_stickmode(pstickmode) || ')';
		END IF;
		error.raiseerror('Error: stick mode <' || pstickmode || '> is not automatic!');
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getdescrforstickmode;

	PROCEDURE registernewstate
	(
		priskgroup       IN NUMBER
	   ,povdperiod       IN NUMBER
	   ,plmtperiod       IN NUMBER
	   ,paggrovdamount   IN NUMBER
	   ,paggrovdcurrency IN NUMBER
	   ,poperation       IN PLS_INTEGER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.RegisterNewState';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		coperdate   CONSTANT DATE := seance.getoperdate;
	
		voperation tcontractstatehistory.operation%TYPE;
		vcomment   tcontractstatehistory.comments%TYPE;
		vpackno    NUMBER;
	
	BEGIN
		t.enter(cmethodname);
	
		t.inpar('pRiskGroup', priskgroup);
		t.inpar('pOvdPeriod', povdperiod);
		t.inpar('pLmtPeriod', plmtperiod);
		t.inpar('pAggrOvdAmount', paggrovdamount);
		t.inpar('pAggrOvdCurrency', paggrovdcurrency);
	
		voperation := getoperationdescr(poperation);
	
		IF sdelstatus(priskgroup)
		 .state.stickstate IN (contractstatereference.cstick
								,contractstatereference.cstickbelow
								,contractstatereference.cstickabove)
		THEN
			vcomment := getdescrforstickmode(sdelstatus(priskgroup).state.stickstate);
		END IF;
	
		vpackno := getpackno;
	
		INSERT INTO tcontractstatehistory
			(branch
			,contractno
			,packno
			,recno
			,operdate
			,statecode
			,overdue
			,overlimit
			,operation
			,stickmode
			,aggregatedoverdueamount
			,aggregatedoverdueamountcurr
			,ovdamountthreshold
			,calculatedovdperiodinterval
			,comments)
		VALUES
			(cbranch
			,scontractno
			,vpackno
			,seqcontrstatehistrecno.nextval
			,coperdate
			,sdelstatus(priskgroup).state.statecode
			,povdperiod
			,plmtperiod
			,voperation
			,sdelstatus(priskgroup).state.stickstate
			,paggrovdamount
			,paggrovdcurrency
			,sdelstatus(priskgroup).overdueamount_threshold
			,sdelstatus(priskgroup).period
			,vcomment);
	
		contractrb.setlabel(crl_contractstate);
		contractrb.setnvalue('PackNo', vpackno);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END registernewstate;

	PROCEDURE getdelparameters(pdate IN DATE := NULL) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetDelParameters';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		coperdate   CONSTANT DATE := seance.getoperdate;
		ccalcdate   CONSTANT DATE := coalesce(pdate, coperdate);
	
		voverdueamount      NUMBER := 0;
		vlastoverduepaydate DATE;
		voverduedate        DATE;
		voverduedayscount   NUMBER;
		vnooverduedayscount NUMBER;
	
		volpercenttotal          NUMBER := 0;
		volpercent               types.arrnum;
		vovdperiod               NUMBER;
		vlmtperiod               NUMBER;
		vovldays                 types.arrnum;
		vovldate                 types.arrdate;
		vamntarr                 typeamnthistoryarray;
		vmaxovldate              DATE := NULL;
		vmaxovldays              NUMBER := 0;
		vlmtused                 types.arrnum;
		vmaxlmtused              NUMBER := 0;
		vhasoverlimit            BOOLEAN := FALSE;
		vhasoverdue              BOOLEAN := FALSE;
		vpaiddelperiod           NUMBER;
		vlastzeromp              DATE;
		vprevstaterow            contractstatereference.typeregisteredstaterow;
		vcurr                    NUMBER;
		vprev                    NUMBER;
		vstickmode               NUMBER;
		vifaggrlimitisused       BOOLEAN;
		vaggrlimitamount         NUMBER := 0;
		vaggroverlimitamount     NUMBER := 0;
		vaggrcurrency            NUMBER := NULL;
		vaccountremain           NUMBER := 0;
		vaggrremain              NUMBER := 0;
		vconvertedamount         NUMBER := 0;
		voverdueparameters       custom_overdueparameterscalculation.typeoverdueparamsrecord;
		vfairperiod              NUMBER;
		voverduecalcspecmodeused BOOLEAN := FALSE;
		vovdperioddatefrom       DATE;
		vovdperioddateto         DATE;
		vadeldates               types.arrdate;
	
	BEGIN
		t.enter(cmethodname);
	
		IF NOT ifcurrencyisusedintype(contracttools.getvalidnumber(sactparam(cctp_overdueamountcurr)
																  ,'Overdue amount currency'
																  ,pallowedvalues => tblnumber(1, 2))
									 ,contracttypeschema.scontractrow.type
									 ,scontractno)
		THEN
			error.raiseerror('Overdue amount currency <' ||
							 slabel(sactparam(cctp_overdueamountcurr)) ||
							 '> is not used in contract type <' || scontracttype || '>!');
		END IF;
	
		FOR i IN 1 .. 2
		LOOP
		
			IF ifcurrencyisusedintype(i, contracttypeschema.scontractrow.type, scontractno)
			THEN
			
				spaidhistarray(i) := custom_overdueparameterscalculation.getoverdueparameters(sdepaccount(i)
																							  .accountno
																							 ,i
																							 ,ccalcdate
																							 ,sdelparam.overdueint
																							 ,voverdueparameters);
			
				sdeldate(i) := voverdueparameters.overduedate;
			
				vlastoverduepaydate := greatest(nvl(vlastoverduepaydate
												   ,voverdueparameters.mp_payoffdate)
											   ,voverdueparameters.mp_payoffdate);
			
				voverdueamount := voverdueamount +
								  contracttools.getsumincurrency(voverdueparameters.overdueamount
																,sdepaccount                     (i)
																 .currencyno
																,sdepaccount                     (sactparam(cctp_overdueamountcurr))
																 .currencyno);
			
			ELSE
				sdeldate(i) := NULL;
			END IF;
		
		END LOOP;
	
		voverduedate := least(nvl(sdeldate(1), ccalcdate), nvl(sdeldate(2), ccalcdate));
		t.var('OverdueDate', voverduedate);
	
		voverduedayscount := ccalcdate - voverduedate;
		t.var('vOverdue days count', voverduedayscount);
	
		t.var('Last overdue pay date', vlastoverduepaydate);
	
		IF ((vlastoverduepaydate IS NULL) AND (voverduedayscount < 0))
		   OR ((vlastoverduepaydate IS NOT NULL) AND (vlastoverduepaydate > ccalcdate))
		THEN
			vlastoverduepaydate := ccalcdate;
		END IF;
	
		vnooverduedayscount := ccalcdate - nvl(vlastoverduepaydate, ccalcdate);
		t.var('No-overdue days', vnooverduedayscount);
	
		vifaggrlimitisused := getlimittype_int(contracttypeschema.scontractrow.no) = caggregate;
		s.say(cmethodname || ' -> Whether aggregated credit limit is used (vIfAggrLimitIsUsed): ' ||
			  service.iif(vifaggrlimitisused, 'YES', 'NO'));
	
		IF vifaggrlimitisused
		THEN
			FOR i IN 1 .. 2
			LOOP
				s.say(cmethodname || '     currency: ------<' || i || '>------');
				IF ifcurrencyisusedintype(i, scontracttype, contracttypeschema.scontractrow.no)
				THEN
					s.say(cmethodname || '    -> Currency number sDepAccount.(' || i ||
						  ').CurrencyNo = ' || sdepaccount(i).currencyno);
				
					IF vaggrcurrency IS NULL
					THEN
						vaggrcurrency := sdepaccount(i).currencyno;
						s.say(cmethodname ||
							  '    -> AGGREGATED CURRENCY NUMBER. Taken from sDepAccount(' || i ||
							  ').CurrencyNo = ' || vaggrcurrency);
					END IF;
				
					s.say(cmethodname || '     -> Account Credit Limit Amount (sDepAccount(' || i ||
						  ').OverDraft) = ' || sdepaccount(i).overdraft);
					vconvertedamount := contracttools.getsumincurrency(sdepaccount  (i).overdraft
																	  ,sdepaccount  (i).currencyno
																	  ,vaggrcurrency);
					vaccountremain   := contracttools.getsumincurrency(sdepaccount(i)
																	  ,vaggrcurrency);
				
					s.say(cmethodname ||
						  '     -> Converted Account Credit Limit Amount (vConvertedAmount) = ' ||
						  vconvertedamount);
					vaggrlimitamount := vaggrlimitamount + vconvertedamount;
					s.say(cmethodname || '     -> Converted Account Remain (vAccountRemain) = ' ||
						  vaccountremain);
					vaggrremain := vaggrremain + vaccountremain;
				END IF;
			
				IF sovdaccount(i).accountno IS NOT NULL
				THEN
					s.say(cmethodname || '     -> Overlimit Amount For (sOvdAccount (' || i ||
						  ').Remain) = ' || sovdaccount(i).remain);
					vconvertedamount := contracttools.getsumincurrency(sovdaccount(i)
																	  ,vaggrcurrency);
					s.say(cmethodname ||
						  '     -> Converted Overlimit Amount (vConvertedAmount) = ' ||
						  vconvertedamount);
					vaggroverlimitamount := vaggroverlimitamount + vconvertedamount;
				END IF;
			
			END LOOP;
			s.say(cmethodname || ' -> AGGREGATED CREDIT LIMIT AMOUNT (vAggrLimitAmount) = ' ||
				  vaggrlimitamount);
			s.say(cmethodname || ' -> AGGREGATED OVERLIMIT AMOUNT (vAggrOverLimitAmount) = ' ||
				  vaggroverlimitamount);
			s.say(cmethodname || ' -> AGGREGATED REMAIN AMOUNT (vAggrRemain) = ' || vaggrremain);
		END IF;
	
		FOR i IN 1 .. 2
		LOOP
		
			vovldays(i) := 0;
			vovldate(i) := NULL;
			vlmtused(i) := 0;
		
			s.say(cmethodname || ' -> sOvdAccount (' || i || ').Remain = ' || sovdaccount(i)
				  .remain);
		
			IF (sovdaccount(i).remain < 0)
			   OR (vaggroverlimitamount <> 0)
			THEN
				vhasoverlimit := TRUE;
			END IF;
			s.say(cmethodname || ' -> Whether overlimit exists: ' ||
				  service.iif(vhasoverlimit, 'YES', 'NO'));
		
			IF (sdeldate(i) IS NOT NULL)
			THEN
				vhasoverdue := TRUE;
			END IF;
		
			IF NOT ifcurrencyisusedintype(i, scontracttype, contracttypeschema.scontractrow.no)
			THEN
				volpercent(i) := 0;
			ELSE
			
				IF NOT vifaggrlimitisused
				THEN
				
					IF sdepaccount(i).overdraft = 0
					THEN
						s.say(cmethodname || ' -> sDepAccount (' || i || ').OverDraft = ' || sdepaccount(i)
							  .overdraft);
						IF sovdaccount(i).remain < 0
						THEN
							volpercent(i) := 100;
							vlmtused(i) := 100;
						ELSE
							volpercent(i) := 0;
							vlmtused(i) := 0;
						END IF;
					
					ELSE
						volpercent(i) := abs(sovdaccount(i).remain) * 100 / sdepaccount(i)
										.overdraft;
						vlmtused(i) := greatest(-sdepaccount(i).remain, 0) * 100 / sdepaccount(i)
									  .overdraft;
						s.say(cmethodname || ' -> sOLPercent (' || i || ') = ' || volpercent(i));
						s.say(cmethodname || ' -> vLmtUsed (' || i || ') = ' || vlmtused(i));
					END IF;
				END IF;
				vamntarr := getamnthistory(i);
				FOR j IN REVERSE 1 .. vamntarr.count
				LOOP
					IF vamntarr(j).balance = 0
					THEN
						EXIT;
					END IF;
					vovldate(i) := vamntarr(j).operdate;
				END LOOP;
				IF vovldate(i) IS NOT NULL
				THEN
					vovldays(i) := greatest(ccalcdate - vovldate(i), 0);
				END IF;
			END IF;
			vmaxovldays := greatest(vovldays(i), vmaxovldays);
			IF vovldate(i) IS NOT NULL
			THEN
				vmaxovldate := least(nvl(vmaxovldate, vovldate(i)), vovldate(i));
			END IF;
			IF NOT vifaggrlimitisused
			THEN
				vmaxlmtused     := greatest(vmaxlmtused, vlmtused(i));
				volpercenttotal := greatest(volpercenttotal, volpercent(i));
			END IF;
		END LOOP;
	
		IF vifaggrlimitisused
		THEN
			IF vaggrlimitamount = 0
			   AND vaggrremain < 0
			THEN
				volpercenttotal := 100;
				vmaxlmtused     := 100;
			ELSIF vaggrremain >= 0
			THEN
				volpercenttotal := 0;
				vmaxlmtused     := 0;
			ELSE
				volpercenttotal := abs((vaggroverlimitamount / vaggrlimitamount) * 100);
				vmaxlmtused     := (greatest(-vaggrremain, 0) / vaggrlimitamount) * 100;
			END IF;
		END IF;
		s.say(cmethodname || ' -> sOLPercentTotal -> ' || volpercenttotal);
		s.say(cmethodname || ' -> vMaxLmtUsed -> ' || vmaxlmtused);
	
		IF sdelparam.overdueint IN (contractdelinqsetup.covdday, contractdelinqsetup.covdfirstday)
		THEN
		
			vovdperiod     := voverduedayscount;
			vpaiddelperiod := vnooverduedayscount;
		
		ELSIF sdelparam.overdueint IN
			  (contractdelinqsetup.covdcycle, contractdelinqsetup.covdfirstcycle)
		THEN
		
			SELECT COUNT(*)
			INTO   vovdperiod
			FROM   tcontractstcycle a
			WHERE  a.branch = cbranch
			AND    a.contractno = scontractno
			AND    a.lastduedate BETWEEN voverduedate AND ccalcdate;
		
			vovdperiod := greatest(vovdperiod - 1, 0);
		
			CASE sacparam(cp_zerompcycles)
			
				WHEN cmp0_count THEN
					s.say(cmethodname || ' -> cMP0_Count');
					SELECT COUNT(*)
					INTO   vpaiddelperiod
					FROM   tcontractstcycle a
					WHERE  a.branch = cbranch
					AND    a.contractno = scontractno
					AND    a.lastduedate BETWEEN nvl(vlastoverduepaydate, ccalcdate) AND ccalcdate;
				
				WHEN cmp0_dontcount THEN
					s.say(cmethodname || ' -> cMP0_DontCount');
					SELECT COUNT(*)
					INTO   vpaiddelperiod
					FROM   (SELECT c.branch
								  ,c.contractno
								  ,c.lastduedate
								  ,MAX(d.minpayment) AS mp
							FROM   tcontractstcycle c
							JOIN   tcontractstminpaymentdata d
							ON     d.branch = c.branch
							AND    d.screcno = c.recno
							WHERE  c.branch = cbranch
							AND    c.contractno = scontractno
							AND    c.lastduedate BETWEEN nvl(vlastoverduepaydate, ccalcdate) AND
								   ccalcdate
							GROUP  BY c.branch
									 ,c.contractno
									 ,c.lastduedate)
					WHERE  mp > 0;
				
				WHEN cmp0_restart THEN
					s.say(cmethodname || ' -> cMP0_Restart');
					SELECT MAX(lastduedate)
					INTO   vlastzeromp
					FROM   (SELECT c.branch
								  ,c.contractno
								  ,c.lastduedate
								  ,MAX(d.minpayment) AS mp
							FROM   tcontractstcycle c
							JOIN   tcontractstminpaymentdata d
							ON     d.branch = c.branch
							AND    d.screcno = c.recno
							WHERE  c.branch = cbranch
							AND    c.contractno = scontractno
							AND    c.lastduedate BETWEEN nvl(vlastoverduepaydate, ccalcdate) AND
								   ccalcdate
							GROUP  BY c.branch
									 ,c.contractno
									 ,c.lastduedate)
					WHERE  mp = 0;
					s.say(cmethodname || ' -> vLastZeroMP=' || vlastzeromp);
					SELECT COUNT(*)
					INTO   vpaiddelperiod
					FROM   tcontractstcycle a
					WHERE  a.branch = cbranch
					AND    a.contractno = scontractno
					AND    a.lastduedate BETWEEN greatest(vlastoverduepaydate, vlastzeromp + 1) AND
						   ccalcdate;
				
			END CASE;
		
		END IF;
	
		vfairperiod := vovdperiod;
	
		IF ((sacparam(cp_ovdperiodcalcmode) = covdcalc_frzwithrep) AND vhasoverdue)
		   OR (sacparam(cp_ovdperiodcalcmode) = covdcalc_frzworep)
		THEN
		
			vovdperioddatefrom := to_date(sacparam(cp_ovdperioddatefrom)
										 ,contractparams.cparam_date_format);
			vovdperioddateto   := to_date(sacparam(cp_ovdperioddateto)
										 ,contractparams.cparam_date_format);
		
			IF (sacparam(cp_ovdperiodcalcmode) = covdcalc_frzworep)
			   AND (voverduedate <= vovdperioddateto)
			THEN
			
				FOR i IN 1 .. 2
				LOOP
				
					IF ifcurrencyisusedintype(i, contracttypeschema.scontractrow.type, scontractno)
					THEN
						vdummypha := custom_overdueparameterscalculation.getoverdueparameters(sdepaccount(i)
																							  .accountno
																							 ,i
																							 ,vovdperioddatefrom
																							 ,sdelparam.overdueint
																							 ,voverdueparameters);
						vadeldates(i) := voverdueparameters.overduedate;
					ELSE
						vadeldates(i) := NULL;
					END IF;
				
					t.var('vOverdueParameters.OverdueDate', voverdueparameters.overduedate);
				
				END LOOP;
			
				voverduedate := least(nvl(vadeldates(1), vovdperioddatefrom)
									 ,nvl(vadeldates(2), vovdperioddatefrom));
			
				vovdperiod := ccalcdate - voverduedate;
			
			END IF;
		
			t.var('vOvdPeriodDateFrom', vovdperioddatefrom);
			t.var('vOverdueDate', voverduedate);
			t.var('vOvdPeriod', vovdperiod);
			t.var('cOperDate', coperdate);
		
			voverduecalcspecmodeused := voverduedate <= vovdperioddateto;
		
			t.var('vOverdueCalcSpecModeUsed', htools.b2s(voverduecalcspecmodeused));
		
			IF voverduecalcspecmodeused
			THEN
			
				IF coperdate < vovdperioddateto
				THEN
					vovdperiod := vovdperiod -
								  (coperdate - greatest(voverduedate, vovdperioddatefrom));
					t.var('vOvdPeriod1', vovdperiod);
				ELSE
					vovdperiod := vovdperiod -
								  (vovdperioddateto - greatest(voverduedate, vovdperioddatefrom));
					t.var('vOvdPeriod2', vovdperiod);
				END IF;
			
			END IF;
		
		END IF;
	
		s.say(cmethodname || ' -> OvdPeriod =' || vovdperiod);
		s.say(cmethodname || ' -> PaidDelPeriod =' || vpaiddelperiod);
	
		IF sdelparam.limitint = contractdelinqsetup.covloverprc
		THEN
			vlmtperiod := volpercenttotal;
		ELSIF sdelparam.limitint = contractdelinqsetup.covllimitprc
		THEN
			vlmtperiod := vmaxlmtused;
			IF vmaxlmtused > 0
			THEN
				vhasoverlimit := TRUE;
			END IF;
		ELSIF sdelparam.limitint = contractdelinqsetup.covloverday
		THEN
			vlmtperiod := vmaxovldays;
		ELSIF sdelparam.limitint = contractdelinqsetup.covlovercycle
		THEN
			IF vmaxovldays = 0
			THEN
				vlmtperiod := 0;
			ELSE
				SELECT COUNT(*) - 1
				INTO   vlmtperiod
				FROM   tcontractstcycle a
				WHERE  a.branch = cbranch
				AND    a.contractno = scontractno
				AND    a.statementdate BETWEEN vmaxovldate AND ccalcdate;
				vlmtperiod := greatest(vlmtperiod, 0);
			END IF;
		END IF;
		s.say(cmethodname || ' -> LmtPeriod =' || vlmtperiod);
	
		vprevstaterow := contractstatereference.getlastregisteredstate(scontractno);
		s.say(cmethodname || ' -> Last Registered State (vPrevStateRow.StateCode) = ' ||
			  vprevstaterow.statecode || ', vPrevStateRow.Overdue = ' || vprevstaterow.overdue
			 ,1);
		s.say(cmethodname || ' -> vPaidDelPeriod = ' || vpaiddelperiod || ', vDelDate = ' ||
			  voverduedate || ', vOvdPeriod = ' || vovdperiod
			 ,1);
	
		getriskgroup(plastregovdperiod => nvl(vprevstaterow.calculatedovdperiodinterval
											 ,vprevstaterow.overdue)
					,plastregoverlimit => nvl(vprevstaterow.overlimit, 0)
					,
					 
					 pcurrentovdperiod => CASE
										  
											  WHEN sdeldate(1) || sdeldate(2) IS NOT NULL THEN
											   vovdperiod
										  
											  WHEN vpaiddelperiod = 0
												   AND nvl(vprevstaterow.overdue, 0) >= 0 THEN
											   NULL
										  
											  ELSE
											   -vpaiddelperiod
										  
										  END
					,pcurrentovdamount => voverdueamount
					,pcurrentoverlimit => nvl(vlmtperiod, 0)
					,
					 
					 olastreggroupindex => vprev
					,ocurrentgroupindex => vcurr);
	
		IF vprevstaterow.statecode IS NULL
		THEN
		
			vprevstaterow.statecode := sdelstatus(scontrtype_cache(scontracttype).defaultriskgroup)
									   .state.statecode;
		END IF;
	
		IF (vprev IS NOT NULL)
		   AND (vprevstaterow.stickmode <> contractstatereference.cstickmanual)
		   AND sautounstick
		   AND (vprevstaterow.statecode = sdelstatus(vcurr).state.statecode)
		THEN
		
			s.say(cmethodname ||
				  ' ->  - info: Stick mode should be taken from previous state with it possbile settings change (sDelStatus(' ||
				  vprev || ').State.StickState) = ' || sdelstatus(vprev).state.stickstate);
			vstickmode := sdelstatus(vprev).state.stickstate;
		ELSE
		
			s.say(cmethodname ||
				  ' -> info: Stick mode should be taken from previous state "AS IS" NOT CONSIDERING possible settings change (vPrevStateRow.StickMode) = ' ||
				  vprevstaterow.stickmode);
			vstickmode := vprevstaterow.stickmode;
		END IF;
	
		s.say(cmethodname || ' -> Chosen stick mode (vStickMode) = ' || vstickmode ||
			  ', [0 - Don''t stick, 1 - Stick automatically, 2 - Stick below, 3 - Stick above, 4- Stick manually]');
	
		s.say(cmethodname || ' -> Last registered delinquency group index (vPrev) = ' || vprev);
		s.say(cmethodname || ' -> Last registered state code (vPrevStateRow.StateCode) = ' ||
			  vprevstaterow.statecode);
		s.say(cmethodname || ' -> Current delinquency group index (vCurr) = ' || vcurr);
	
		sblockparam := sdelstatus(vcurr);
	
		IF (vstickmode = contractstatereference.cdontstick)
		   OR (vstickmode = contractstatereference.cstickbelow)
		   AND (vprev < vcurr)
		   OR (vstickmode = contractstatereference.cstickabove)
		   AND (vprev > vcurr)
		THEN
		
			sblockparam.statechangeallowed := TRUE;
			s.say(cmethodname ||
				  '  - info: Delinquency state should be changed according to current delinquency group index');
		
			IF NOT vhasoverdue
			THEN
				vovdperiod   := nullif(-vpaiddelperiod, 0);
				vfairperiod  := nullif(-vpaiddelperiod, 0);
				voverduedate := NULL;
			END IF;
			IF NOT vhasoverlimit
			THEN
				vlmtperiod := NULL;
			END IF;
		
		ELSE
		
			sblockparam.statechangeallowed := FALSE;
			s.say(cmethodname ||
				  ' - info: Last registered delinquency state should NOT be changed');
		
			sblockparam.stateid := contractstatereference.getstateid(vprevstaterow.statecode);
			sblockparam.state   := contractstatereference.getstate(sblockparam.stateid);
		END IF;
	
		s.say(cmethodname || ' -> Calculated state code (sBlockParam.State.StateCode) = ' ||
			  sblockparam.state.statecode);
	
		sblockparam.period                  := vovdperiod;
		sblockparam.fairperiod              := vfairperiod;
		sblockparam.deldate                 := voverduedate;
		sblockparam.overduecalcspecmodeused := voverduecalcspecmodeused;
		sblockparam.overduecalctype         := sactparam(cctp_periodtype);
		sblockparam.overlimitcalctype       := sactparam(cctp_overlimittype);
		sblockparam.overlimit               := vlmtperiod;
		sblockparam.aggregatedoverdueamount := voverdueamount;
		sblockparam.lastreggroupindex       := vprev;
		sblockparam.currentgroupindex       := vcurr;
		sblockparam.lastregisteredstatecode := vprevstaterow.statecode;
		sblockparam.lastregisteredstickmode := vprevstaterow.stickmode;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getdelparameters;

	FUNCTION getcontractdelinquencystate
	(
		pcontractno IN typecontractno
	   ,pdate       IN DATE := NULL
	) RETURN typedelstatusrecord IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetContractDelinquencyState';
	BEGIN
		t.enter(cmethodname);
	
		initcontract(pcontractno);
		getdelparameters(pdate);
	
		t.leave(cmethodname, sblockparam.state.statecode);
		RETURN sblockparam;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcontractdelinquencystate;

	FUNCTION getcurrencyabbr(paccnumber IN NUMBER) RETURN VARCHAR2 IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetCurrencyAbbr';
	BEGIN
		RETURN referencecurrency.getabbreviation(sdepaccount(paccnumber).currencyno);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION getcurrency
	(
		pcontracttype IN NUMBER
	   ,pitemname     IN VARCHAR
	) RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetCurrency';
	BEGIN
		RETURN planaccount.getcurrency(accounttype.getnoplan(contractaccount.getaccounttype(pcontracttype
																						   ,contracttypeitems.getitemcode(pcontracttype
																														 ,pitemname))));
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getcurrency;

	FUNCTION createnextcycle
	(
		pstdate         IN DATE
	   ,pduedate        IN DATE
	   ,pnextstdate     IN DATE
	   ,pprintedduedate IN DATE
	   ,pdafdate        IN DATE
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CreateNextCycle';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vresult NUMBER;
	BEGIN
		t.enter(cmethodname);
	
		INSERT INTO tcontractstcycle
		VALUES
			(cbranch
			,scontractno
			,seqstcyclerecno.nextval
			,pstdate
			,pduedate
			,pnextstdate
			,NULL
			,pprintedduedate
			,pdafdate)
		RETURNING recno INTO vresult;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END createnextcycle;

	PROCEDURE deletecycle(precno IN NUMBER) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.DeleteCycle';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	BEGIN
		DELETE FROM tcontractstcycle
		WHERE  branch = cbranch
		AND    recno = precno;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END deletecycle;

	PROCEDURE createstminpayrow
	(
		precno  IN NUMBER
	   ,pcurno  IN NUMBER
	   ,pamount IN NUMBER
	   ,
		
		psdamount NUMBER
		
	) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.CreateStMinPayRow';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	BEGIN
	
		INSERT INTO tcontractstminpaymentdata
			(branch
			,screcno
			,currencynumber
			,minpayment
			,repayment_atcycleend
			,unpaidsdamount_onduedate
			,sdamount
			,mp_payoffdate_atcycleend
			,prevmpovd_onduedate
			,overdueamount_onduedate
			,aggregatedtrxn)
		VALUES
			(cbranch
			,precno
			,pcurno
			,round(pamount, sprecision(pcurno))
			,0
			,0
			,psdamount
			,NULL
			,NULL
			,NULL
			,NULL);
	
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	PROCEDURE loadtrxnrepayments
	(
		precno         IN NUMBER
	   ,prepaymentdate IN NUMBER
	   ,oarepayments   OUT NOCOPY sch_prc.tarrtranche
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.LoadTrxnRepayments';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	BEGIN
	
		IF prepaymentdate = 1
		THEN
			SELECT docno
				  ,opdate
				  ,entcode
				  ,VALUE
				  ,shortrem BULK COLLECT
			INTO   oarepayments
			FROM   (SELECT recno    AS docno
						  ,trandate AS opdate
						  ,NULL     AS entcode
						  ,-amount  AS VALUE
						  ,NULL     AS shortrem
					FROM   tcontracttrxnlist
					WHERE  branch = cbranch
					AND    recno = precno
					UNION ALL
					SELECT recno    AS docno
						  ,trandate AS opdate
						  ,NULL     AS entcode
						  ,amount   AS VALUE
						  ,NULL     AS shortrem
					FROM   tcontracttrxnrepayment
					WHERE  branch = cbranch
					AND    debitrecno = precno)
			ORDER  BY opdate
					 ,docno;
		
		ELSE
			SELECT docno
				  ,opdate
				  ,entcode
				  ,VALUE
				  ,shortrem BULK COLLECT
			INTO   oarepayments
			FROM   (SELECT recno    AS docno
						  ,trandate AS opdate
						  ,NULL     AS entcode
						  ,-amount  AS VALUE
						  ,NULL     AS shortrem
					FROM   tcontracttrxnlist
					WHERE  branch = cbranch
					AND    recno = precno
					UNION ALL
					SELECT recno    AS docno
						  ,postdate AS opdate
						  ,NULL     AS entcode
						  ,amount   AS VALUE
						  ,NULL     AS shortrem
					FROM   tcontracttrxnrepayment
					WHERE  branch = cbranch
					AND    debitrecno = precno)
			ORDER  BY opdate
					 ,docno;
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END loadtrxnrepayments;

	PROCEDURE interestcharge(pcurno IN NUMBER) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.InterestCharge';
	
		cbranch   CONSTANT NUMBER := seance.getbranch;
		coperdate CONSTANT DATE := seance.getoperdate;
	
		SUBTYPE typecontractstcyclerec IS tcontractstcycle%ROWTYPE;
		TYPE typecontractstcyclearray IS TABLE OF typecontractstcyclerec INDEX BY PLS_INTEGER;
	
		CURSOR curtrxnlist
		(
			paccountno   IN typeaccountno
		   ,pgroupid     IN typegroupid
		   ,ppostenddate IN DATE
		) IS
			SELECT *
			FROM   tcontracttrxnlist
			WHERE  branch = cbranch
			AND    accountno = paccountno
			AND    trantype IN (ctrxntype_debit, ctrxntype_creditrev)
			AND    groupid = pgroupid
			AND    postdate <= ppostenddate
			AND    intenddate < least(nvl(paidfulldate, coperdate), coperdate)
			AND    intstartdate <= coperdate;
	
		vatranche          sch_prc.tarrtranche;
		varemain           sch_prc.tarrremain;
		vpostenddate       DATE;
		vchargeenddate     DATE;
		vduedateamount     NUMBER;
		vprcvalue          NUMBER;
		vgroupid           NUMBER;
		vgrpparams         types.arrstr1000;
		vdaysinyear        NUMBER;
		vprcid             NUMBER;
		vprcdatechoice     NUMBER;
		vfixprcdate        DATE;
		vfixamount         NUMBER;
		vfixperiod         NUMBER;
		vprctype           NUMBER;
		vprcperiodfrom     NUMBER;
		vprcstep           NUMBER;
		vperiod            NUMBER;
		vtotalinterest     NUMBER := 0;
		vusebaserate       BOOLEAN;
		vprefrateusagemode PLS_INTEGER;
		varates            referenceprchistory.typeprcarray;
		vdate              DATE;
		vremain            NUMBER;
		vindex             NUMBER;
		vinterval          NUMBER;
	
		vintgrplog  VARCHAR(1000);
		vintlog     VARCHAR(1000);
		vamountmode NUMBER;
	
		vreducedrateid         NUMBER;
		vgroupprcid            NUMBER;
		vreducedtermusage      tcontractredintsettings.reducedtermusage%TYPE;
		vprevprevstatementdate tcontractstcycle.statementdate%TYPE := NULL;
	
		vstcyclearray typecontractstcyclearray;
		vfullremark   typefullremark := NULL;
	
		vuseredrate BOOLEAN;
		vusepromo   BOOLEAN;
	
		voverdueparameters custom_overdueparameterscalculation.typeoverdueparamsrecord;
	
		vainterest         types.arrnum;
		vtrxnstoinstamount NUMBER := 0;
		vatrxnstoinst      typetrxnarray;
		vratetype          PLS_INTEGER;
		vfinalquantity     NUMBER;
	
		PROCEDURE addlog
		(
			pname  IN VARCHAR2
		   ,pvalue IN VARCHAR2
		) IS
			cmethodname CONSTANT typemethodname := interestcharge.cmethodname || '.AddLog';
		BEGIN
			t.note(cmethodname, pname || '=' || pvalue);
			IF sactparam(cctp_intlog) = '1'
			THEN
				vintlog := vintlog || pname || '=' || pvalue || ';';
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END addlog;
	
		PROCEDURE addsetuplog(plog IN VARCHAR2) IS
			cmethodname CONSTANT typemethodname := interestcharge.cmethodname || '.AddSetupLog';
		BEGIN
			t.note(cmethodname || '_SetupLog', plog);
			IF sactparam(cctp_intlog) = '1'
			THEN
				vintgrplog := vintgrplog || plog || ';';
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				s.say(length(vintgrplog) || '-' || vintgrplog);
				error.save(cmethodname);
				RAISE;
		END addsetuplog;
	
		PROCEDURE savelog
		(
			pgroupid      IN typegroupid
		   ,ptranrecno    IN NUMBER
		   ,pintstartdate IN DATE
		   ,pintlastdate  IN DATE
		   ,pfromdate     IN DATE
		   ,ptranamount   IN NUMBER
		   ,pbaseamount   IN NUMBER
		   ,prate         IN NUMBER
		   ,pdays         IN NUMBER
		) IS
			cmethodname CONSTANT typemethodname := interestcharge.cmethodname || '.SaveLog';
		BEGIN
			IF (sactparam(cctp_intlog) = '1')
			   AND (vintlog IS NOT NULL)
			THEN
				INSERT INTO tcontractinterestlog
				VALUES
					(cbranch
					,scontractno
					,coperdate
					,getpackno
					,ptranrecno
					,pgroupid
					,pintstartdate
					,pintlastdate
					,pfromdate
					,ptranamount
					,pbaseamount
					,prate
					,pdays
					,vintlog);
				vintlog := NULL;
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END savelog;
	
		PROCEDURE savelogbytiers
		(
			ptier          IN NUMBER
		   ,pamount        IN NUMBER
		   ,pinterest      IN NUMBER
		   ,pintervalcount IN NUMBER
		) IS
			cmethodname CONSTANT typemethodname := interestcharge.cmethodname || '.SaveLogByTiers';
		BEGIN
			IF (sactparam(cctp_intlog) = '1')
			THEN
				INSERT INTO tcontractinterestlog
				VALUES
					(cbranch
					,scontractno
					,coperdate
					,getpackno
					,pcurno
					,ptier
					,NULL
					,NULL
					,NULL
					,pamount
					,pinterest
					,NULL
					,pintervalcount
					,NULL);
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END savelogbytiers;
	
		PROCEDURE savesetuplog(pgroupid IN typegroupid) IS
			cmethodname CONSTANT typemethodname := interestcharge.cmethodname || '.SaveSetupLog';
		BEGIN
			IF (sactparam(cctp_intlog) = '1')
			   AND (vintgrplog IS NOT NULL)
			THEN
				INSERT INTO tcontractinterestsetuplog
				VALUES
					(cbranch
					,scontractno
					,pcurno
					,coperdate
					,getpackno
					,pgroupid
					,vintgrplog);
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END savesetuplog;
	
		PROCEDURE saveprofilelog IS
			cmethodname CONSTANT typemethodname := interestcharge.cmethodname || '.SaveProfileLog';
		BEGIN
			s.say(cmethodname || ': start');
			s.say(cmethodname || ': saCTParam(cCTP_IntLog)=' || sactparam(cctp_intlog));
			s.say(cmethodname || ': sProfileID(pCurNumber)=' || sprofileid(pcurno));
			s.say(cmethodname ||
				  ': sProfile(sProfileID(pCurNumber))(custom_contractprofiles.cP_ProfileId)=' ||
				  sprofile(sprofileid(pcurno)) (custom_contractprofiles.cp_profileid));
			IF sactparam(cctp_intlog) = '1'
			THEN
				INSERT INTO tcontractinterestprofilelog
				VALUES
					(cbranch
					,scontractno
					,pcurno
					,coperdate
					,getpackno
					,sprofileid(pcurno));
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END saveprofilelog;
	
		PROCEDURE clearlog IS
			cmethodname CONSTANT typemethodname := interestcharge.cmethodname || '.ClearLog';
		BEGIN
			vintlog    := NULL;
			vintgrplog := NULL;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END clearlog;
	
		PROCEDURE cleartranlog IS
			cmethodname CONSTANT typemethodname := interestcharge.cmethodname || '.ClearTranLog';
		BEGIN
			vintlog := NULL;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END cleartranlog;
	
		FUNCTION getperiod(pdate IN DATE) RETURN NUMBER IS
			cmethodname CONSTANT typemethodname := interestcharge.cmethodname || '.GetPeriod';
			vresult NUMBER := 0;
		BEGIN
			t.enter(cmethodname, pdate);
		
			FOR i IN REVERSE 1 .. vstcyclearray.count
			LOOP
				t.var('GetPeriod StatementDate', vstcyclearray(i).statementdate);
				EXIT WHEN vstcyclearray(i).statementdate < pdate;
				vresult := vresult + 1;
			END LOOP;
		
			t.leave(cmethodname, vresult);
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END getperiod;
	
		FUNCTION getcyclesnumber
		(
			pstartdate IN DATE
		   ,penddate   IN DATE
		) RETURN NUMBER IS
			cmethodname CONSTANT typemethodname := cpackagename || '.GetCyclesNumber';
			cbranch     CONSTANT NUMBER := seance.getbranch;
			vresult NUMBER;
		BEGIN
			t.enter(cmethodname);
		
			SELECT COUNT(*) - 1
			INTO   vresult
			FROM   tcontractstcycle
			WHERE  branch = cbranch
			AND    contractno = scontractno
			AND    statementdate BETWEEN pstartdate AND penddate - 1;
		
			t.leave(cmethodname, vresult);
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END getcyclesnumber;
	
		FUNCTION prefrateshouldbeapplied
		(
			pstartdate IN DATE
		   ,pgrpparams IN types.arrstr1000
		) RETURN BOOLEAN IS
			cmethodname CONSTANT typemethodname := cpackagename || '.PrefRateShouldBeApplied';
			vprehistarray referenceprchistory.typeprcarray;
			vresult       BOOLEAN := FALSE;
		BEGIN
			t.enter(cmethodname, pstartdate);
		
			IF getcyclesnumber(pstartdate, coperdate) <
			   pgrpparams(custom_contractprofiles.cpg_preuse)
			THEN
				vprehistarray := referenceprchistory.fillpercentarray(pgrpparams(custom_contractprofiles.cpg_preprchist)
																	 ,FALSE);
				addsetuplog('PrefRateValue=' ||
							referenceprchistory.getpercentvalue(vprehistarray, coperdate));
				vresult := TRUE;
			END IF;
		
			t.leave(cmethodname, htools.b2s(vresult));
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END prefrateshouldbeapplied;
	
		PROCEDURE settrxnintenddate
		(
			ptrxnrow    IN typetrxnrow
		   ,pintenddate IN DATE
		) IS
			cmethodname CONSTANT typemethodname := interestcharge.cmethodname ||
												   '.SetTrxnIntEndDate';
		BEGIN
			t.enter(cmethodname
				   ,'RecNo = ' || ptrxnrow.recno || ', pIntEndDate = ' || htools.d2s(pintenddate));
		
			savetrxntorollback(ptrxnrow);
		
			UPDATE tcontracttrxnlist
			SET    intenddate = pintenddate
			WHERE  branch = cbranch
			AND    recno = ptrxnrow.recno;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END settrxnintenddate;
	
		PROCEDURE setgroupintenddate
		(
			paccountno   IN typeaccountno
		   ,pgroupid     IN typegroupid
		   ,ppostenddate IN DATE
		   ,pintenddate  IN DATE
		) IS
			cmethodname CONSTANT typemethodname := interestcharge.cmethodname ||
												   '.SetGroupIntEndDate';
		BEGIN
			t.enter(cmethodname
				   ,'pAccountNo = ' || paccountno || 'pGroupID = ' || pgroupid ||
					', pPostEndDate = ' || htools.d2s(ppostenddate) || ', pIntEndDate = ' ||
					htools.d2s(pintenddate));
		
			FOR i IN (SELECT *
					  FROM   tcontracttrxnlist
					  WHERE  branch = cbranch
					  AND    accountno = paccountno
					  AND    trantype IN (ctrxntype_debit, ctrxntype_creditrev)
					  AND    groupid = pgroupid
					  AND    postdate <= ppostenddate
					  AND    intstartdate <= coperdate
					  AND    intenddate < least(nvl(paidfulldate, coperdate), coperdate))
			LOOP
				settrxnintenddate(i, pintenddate);
			END LOOP;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END setgroupintenddate;
	
		PROCEDURE makeinterestentry
		(
			pcurno      IN PLS_INTEGER
		   ,pgroupid    IN typegroupid
		   ,psum        IN NUMBER
		   ,pfullremark IN typefullremark
		   ,pratetype   IN PLS_INTEGER := NULL
		) IS
			cmethodname CONSTANT typemethodname := interestcharge.cmethodname ||
												   '.MakeInterestEntry';
			ventryident typeentryident := 'CHARGE_INTEREST_GROUP_' || pgroupid;
			vtrxn       typetrxnrec;
			vsum        NUMBER;
		BEGIN
			t.enter(cmethodname
				   ,'pCurNo = ' || pcurno || ', pGroupID = ' || pgroupid || ', pSum = ' || psum ||
					', pFullRemark = ' || pfullremark);
		
			vsum := round(psum, sprecision(pcurno));
		
			IF pratetype IS NOT NULL
			THEN
			
				ventryident := ventryident || '_' || caratesprefixes(pratetype);
			
				contracttools.addentry2reference(ventryident
												,'99'
												,'Charge interest for ' || pgroupid || ' (' ||
												 caratesdescr(pratetype) || ')');
			
			END IF;
		
			CASE sblockparam.state.chargeint
			
				WHEN contractstatereference.cintcharge THEN
				
					vtrxn := doentry(pcurno
									,sdepaccount(pcurno)
									,sabaccounts(pcurno) (cb_incacc)
									,sdepaccount(pcurno).currencyno
									,vsum
									,ventryident
									,'Crd%_' || pgroupid
									,pfullremark);
				
				WHEN contractstatereference.cintaccumulate THEN
				
					IF saccumintaccmode = cintaccmode_donotaccumulate
					THEN
						error.raiseerror('Contract state settings are not conform to branch settings!');
					END IF;
				
					IF saccumintaccmode = cintaccmode_bankincomeacc
					THEN
						doentry(pcurno
							   ,sintaccount(pcurno)
							   ,sabaccounts(pcurno) (cb_incacc)
							   ,sdepaccount(pcurno).currencyno
							   ,vsum
							   ,ventryident
							   ,'Accum%_' || pgroupid
							   ,pfullremark
							   ,pdotrxn => FALSE);
					ELSIF saccumintaccmode IN
						  (cintaccmode_intaccbalance, cintaccmode_intacctechnical)
					THEN
						doentry(pcurno
							   ,sintaccount(pcurno)
							   ,sabaccounts(pcurno) (cb_accumintacc)
							   ,sdepaccount(pcurno).currencyno
							   ,vsum
							   ,ventryident
							   ,'Accum%_' || pgroupid
							   ,pfullremark
							   ,pdotrxn => FALSE);
					ELSE
						error.raiseerror('Internal error: unsupported interest accumulation mode <' ||
										 saccumintaccmode || '>!');
					END IF;
				
				WHEN contractstatereference.cintoffbalance THEN
				
					vtrxn := doentry(pcurno
									,sdepaccount(pcurno)
									,sabaccounts(pcurno) (cb_incaccoffbal)
									,sdepaccount(pcurno).currencyno
									,vsum
									,ventryident
									,'Crd%_' || pgroupid
									,pfullremark);
				ELSE
					error.raiseerror('Internal error: unsupported interest charge mode <' ||
									 sblockparam.state.chargeint || '>!');
			END CASE;
		
			CASE pcurno
				WHEN 1 THEN
					sprcchargedom(sprcchargedom.count + 1).groupid := pgroupid;
					sprcchargedom(sprcchargedom.count).amount := vsum;
				WHEN 2 THEN
					sprcchargeint(sprcchargeint.count + 1).groupid := pgroupid;
					sprcchargeint(sprcchargeint.count).amount := vsum;
				ELSE
					error.raiseerror('Internal error: unsupported currency number <' || pcurno || '>!');
			END CASE;
		
			IF sinttoinston(pcurno)
			   AND (vtrxn.recno IS NOT NULL)
			THEN
				vatrxnstoinst(vatrxnstoinst.count + 1) := vtrxn;
				vtrxnstoinstamount := vtrxnstoinstamount + vsum;
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END makeinterestentry;
	
		FUNCTION promoblockresult
		(
			pblockid IN NUMBER
		   ,pdocno   IN typedocno
		) RETURN BOOLEAN IS
			cmethodname CONSTANT typemethodname := interestcharge.cmethodname ||
												   '.PromoBlockResult';
			vresult BOOLEAN := TRUE;
		BEGIN
			t.enter(cmethodname, pblockid);
		
			IF pblockid IS NOT NULL
			THEN
				dynasql.setvaluenum(pblockid, ':DOCNO', pdocno);
				vresult := htools.i2b(nvl(dynasql.runone(pblockid, TRUE, 1), 1));
			END IF;
		
			t.leave(cmethodname, htools.b2s(vresult));
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END promoblockresult;
	
		FUNCTION getlastcardcreationdate RETURN DATE IS
			cmethodname CONSTANT typemethodname := interestcharge.cmethodname ||
												   '.GetLastCardCreationDate';
			vcardlist apitypes.typecardlist;
			vresult   DATE;
		BEGIN
			t.enter(cmethodname);
		
			vcardlist := contract.getcardlist(scontractno);
		
			FOR i IN 1 .. vcardlist.count
			LOOP
				vresult := greatest(nvl(vresult, vcardlist(i).createdate), vcardlist(i).createdate);
			END LOOP;
		
			vresult := nvl(vresult, contracttypeschema.scontractrow.createdate);
		
			t.leave(cmethodname, vresult);
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END getlastcardcreationdate;
	
		PROCEDURE zerointerestarray(oainterest OUT NOCOPY types.arrnum) IS
			cmethodname CONSTANT typemethodname := interestcharge.cmethodname ||
												   '.ZeroInterestArray';
		BEGIN
			oainterest(crate_regular) := 0;
			oainterest(crate_reduced) := 0;
			oainterest(crate_promotional) := 0;
			oainterest(crate_preferential) := 0;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END zerointerestarray;
	
		PROCEDURE chargeinterestbyarray
		(
			pcurno      IN PLS_INTEGER
		   ,pgroupid    IN typegroupid
		   ,painterest  IN types.arrnum
		   ,pfullremark IN typefullremark
		) IS
			cmethodname CONSTANT typemethodname := interestcharge.cmethodname ||
												   '.ChargeInterestByArray';
		BEGIN
			FOR i IN painterest.first .. painterest.last
			LOOP
				IF painterest(i) > 0
				THEN
					makeinterestentry(pcurno, pgroupid, painterest(i), pfullremark, i);
				END IF;
			END LOOP;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END chargeinterestbyarray;
	
		PROCEDURE moveinteresttoinstallment
		(
			pcurno             IN PLS_INTEGER
		   ,pamount            IN NUMBER
		   ,poatrxnstotransfer IN OUT NOCOPY typetrxnarray
		) IS
			cmethodname CONSTANT typemethodname := interestcharge.cmethodname ||
												   '.MoveInterestToInstallment';
		
			vinstallmentcontract apitypes.typecontractrecord;
			vinstallmentaccount  contracttools.taccountrecord;
			vloanno              NUMBER;
		
		BEGIN
			t.enter(cmethodname);
		
			getinstallmentcontract(pcurno
								  ,sactparamccy(pcurno) (cctp_inttoinstct)
								  ,TRUE
								  ,vinstallmentcontract
								  ,vinstallmentaccount);
		
			vloanno := createloanforamount(vinstallmentcontract.no, pamount);
		
			FOR i IN 1 .. poatrxnstotransfer.count
			LOOP
				startnewinstallment(pcurno
								   ,vinstallmentcontract.no
								   ,cim_auto
								   ,vloanno
								   ,pamount
								   ,poatrxnstotransfer     (i).docno
								   ,poatrxnstotransfer     (i).entryno
								   ,poatrxnstotransfer     (i).recno);
			END LOOP;
		
			processinstallmenttrxns(pcurno
								   ,vinstallmentcontract.no
								   ,vloanno
								   ,vinstallmentaccount
								   ,pamount
								   ,poatrxnstotransfer
								   ,nvl(sactparamccy(pcurno) (cctp_instonfeecalc), 0) = 1
								   ,TRUE);
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END moveinteresttoinstallment;
	
	BEGIN
		t.enter(cmethodname
			   ,'pCurNo = ' || pcurno || ', Interest accumulation mode (sAccumIntAccMode) = ' ||
				saccumintaccmode || ', Profile number (sProfileID(pCurNo)) = ' ||
				sprofileid(pcurno));
	
		IF sblockparam.state.chargeint = contractstatereference.cintsuspend
		THEN
			t.leave(cmethodname, 'Charging Suspended');
			RETURN;
		END IF;
	
		vfullremark := getfullremark(pcurno, 'TransFullRemark');
	
		addsetuplog('IntChrgMode=' || sprofile(sprofileid(pcurno))
					(custom_contractprofiles.cp_intchrgmode));
	
		CASE sprofile(sprofileid(pcurno)) (custom_contractprofiles.cp_intchrgmode)
		
			WHEN 1 THEN
			
				SELECT * BULK COLLECT
				INTO   vstcyclearray
				FROM   tcontractstcycle
				WHERE  branch = cbranch
				AND    contractno = scontractno
				ORDER  BY nextstatementdate;
			
				s.say(cmethodname ||
					  ' Repayment date (sProfile(sProfileID(pCurNumber))(custom_contractprofiles.cP_RepayDate)) = ' ||
					  sprofile(sprofileid(pcurno)) (custom_contractprofiles.cp_repaydate) ||
					  ', [1 - Transaction date, 2 - Posting date]');
			
				IF (sprofile(sprofileid(pcurno)) (custom_contractprofiles.cp_chargetype) = '0')
				   AND
				   (sprofile(sprofileid(pcurno)) (custom_contractprofiles.cp_divintbyrates) = '1')
				THEN
					zerointerestarray(vainterest);
				END IF;
			
				<<operations_groups>>
				FOR i IN 1 .. sordergroup(sprofileid(pcurno)).count
				LOOP
				
					clearlog;
					vgroupid   := sordergroup(sprofileid(pcurno)) (i);
					vgrpparams := sopergroup(sprofileid(pcurno)) (vgroupid);
				
					s.say(cmethodname);
					s.say(cmethodname || ' ||-----------------||----------------||' ||
						  ' GROUPID = ' || vgroupid || ' ||----------------||-----------------||');
					s.say(cmethodname ||
						  '  Whether interest should be charged (vGrpParams(custom_contractprofiles.cPG_ChargeInt)) = ' ||
						  vgrpparams(custom_contractprofiles.cpg_chargeint) ||
						  ', [0 - don''t charge, 1 - charge]');
					s.say(cmethodname ||
						  '  Whether grace period is used (vGrpParams(custom_contractprofiles.cPG_UseGrace)) = ' ||
						  vgrpparams(custom_contractprofiles.cpg_usegrace) ||
						  ', [0 - don''t use, 1 - use]');
				
					IF vgrpparams(custom_contractprofiles.cpg_chargeint) = '0'
					THEN
						s.say(cmethodname ||
							  '         -info: Interest for this group should not be charged');
						setgroupintenddate(sdepaccount(pcurno).accountno
										  ,vgroupid
										  ,coperdate
										  ,coperdate);
					
					ELSIF ((getcurrentcycle().statementdate IS NOT NULL) OR
						  (vgrpparams(custom_contractprofiles.cpg_usegrace) = '0'))
					THEN
					
						IF (sprofile(sprofileid(pcurno))
							(custom_contractprofiles.cp_chargetype) = '1')
						   AND (sprofile(sprofileid(pcurno))
							(custom_contractprofiles.cp_divintbyrates) = '1')
						THEN
							zerointerestarray(vainterest);
						END IF;
					
						addsetuplog(service.iif(vgrpparams(custom_contractprofiles.cpg_usegrace) = '1'
											   ,'Grace=USED'
											   ,'Grace=NOT USED'));
					
						s.say(cmethodname || '  ++  CHECK WHETHER REDUCED TERM IS SATISFIED  ++ ');
						s.say(cmethodname ||
							  '       Number of reduced terms for the group (sOperGroupRedRates(sProfileID(pCurNumber))(vGroupID).count) = ' ||
							  sopergroupredrates(sprofileid(pcurno))(vgroupid).count);
					
						IF (sopergroupredrates(sprofileid(pcurno))(vgroupid).count = 0)
						   AND vgrpparams(custom_contractprofiles.cpg_usegrace) = '1'
						THEN
							error.raiseerror('At least one reduced rate has to be specified for operation group for which grace period was set!');
						END IF;
					
						vuseredrate := FALSE;
					
						<<reduced_rates>>
						FOR l IN 1 .. sopergroupredrates(sprofileid(pcurno))(vgroupid).count
						LOOP
						
							vreducedtermusage := nvl(sopergroupredrates(sprofileid(pcurno))
													 (vgroupid)(l).reducedtermusage
													,custom_contractprofiles.cgraceperusage_always);
							s.say(cmethodname || '       Reduced term to check = ' ||
								  sopergroupredrates(sprofileid(pcurno)) (vgroupid)(l)
								  .terms ||
								  ', [1 - MP is paid before due date, 2 - SD balance is paid before due date, 3 - Current balance is less than specified amount, 4 - Unpaid last SD amount on oper date is less than spec.amount, 5 - Unpaid SD Amount on Due Date is less than specified amount]');
							s.say(cmethodname ||
								  '       For what period Reduced Term should be applied (vReducedTermUsage) = ' ||
								  vreducedtermusage || ', [' ||
								  custom_contractprofiles.cgraceperusage_always || ' - Always, ' ||
								  custom_contractprofiles.cgraceperusage_prevcycleonly ||
								  ' - for previous cycle only]');
							addsetuplog('BasedOn=' || sopergroupredrates(sprofileid(pcurno))
										(vgroupid)(l).terms);
							addsetuplog('RedTermUsage=' || vreducedtermusage);
						
							CASE sopergroupredrates(sprofileid(pcurno)) (vgroupid)(l).terms
							
								WHEN custom_contractprofiles.cgrace_paidmp THEN
									vuseredrate := sminpaymentdd(pcurno) = 0;
									s.say(cmethodname ||
										  '       Unpaid Min. Payment on Due Date (sMinPaymentDD(pCurNumber)) = ' ||
										  sminpaymentdd(pcurno));
									addsetuplog('UnpaidAmnt=' || sminpaymentdd(pcurno));
								
								WHEN custom_contractprofiles.cgrace_paidsdbal THEN
									vuseredrate := ssdbalancedd(pcurno) = 0;
									s.say(cmethodname ||
										  '       Unpaid SD Amount on Due Date (sSDBalanceDD(pCurNumber)) = ' ||
										  ssdbalancedd(pcurno));
									addsetuplog('UnpaidAmnt=' || ssdbalancedd(pcurno));
								
								WHEN custom_contractprofiles.cgrace_currentbalisless THEN
									vuseredrate := sdepaccount(pcurno)
												   .remain >=
													-sopergroupredrates(sprofileid(pcurno))
													(vgroupid)(l).amount;
									s.say(cmethodname ||
										  '       Current balance (sDepAccount(pCurNumber).Remain)) = ' || sdepaccount(pcurno)
										  .remain);
									s.say(cmethodname ||
										  '       Specified amount (sOperGroupRedRates(sProfileID(pCurNumber))(vGroupID)(l).Amount) = ' ||
										  sopergroupredrates(sprofileid(pcurno)) (vgroupid)(l)
										  .amount);
									addsetuplog('UnpaidAmnt=' ||
												service.iif(vuseredrate
														   ,0
														   ,abs(sdepaccount(pcurno)
																.remain -
																 sopergroupredrates(sprofileid(pcurno))
																 (vgroupid)(l).amount)));
									addsetuplog('RedTermAmount=' ||
												sopergroupredrates(sprofileid(pcurno)) (vgroupid)(l)
												.amount);
								
								WHEN custom_contractprofiles.cgrace_unpdbaloflastsdisless THEN
									vuseredrate := ssdbalanceod(pcurno) <=
												   sopergroupredrates(sprofileid(pcurno))
												   (vgroupid)(l).amount;
									s.say(cmethodname ||
										  '       Unpaid SD balance on operational date (sSDBalanceOD) = ' ||
										  ssdbalanceod(pcurno));
									s.say(cmethodname ||
										  '       Specified amount (sOperGroupRedRates(sProfileID(pCurNumber))(vGroupID)(l).Amount) = ' ||
										  sopergroupredrates(sprofileid(pcurno)) (vgroupid)(l)
										  .amount);
									addsetuplog('UnpaidAmnt=' || ssdbalanceod(pcurno));
									addsetuplog('RedTermAmount=' ||
												sopergroupredrates(sprofileid(pcurno)) (vgroupid)(l)
												.amount);
								
								WHEN custom_contractprofiles.cgrace_unpaidsdamntonddisless THEN
									vuseredrate := ssdbalancedd(pcurno) <=
												   sopergroupredrates(sprofileid(pcurno))
												   (vgroupid)(l).amount;
									s.say(cmethodname ||
										  '       Unpaid SD Amount on Due Date (sSDBalanceDD) = ' ||
										  ssdbalancedd(pcurno));
									s.say(cmethodname ||
										  '       Specified Amount (sOperGroupRedRates(sProfileID(pCurNumber))(vGroupID)(l).Amount) = ' ||
										  sopergroupredrates(sprofileid(pcurno)) (vgroupid)(l)
										  .amount);
									addsetuplog('UnpaidAmnt=' || ssdbalancedd(pcurno));
									addsetuplog('RedTermAmount=' ||
												sopergroupredrates(sprofileid(pcurno)) (vgroupid)(l)
												.amount);
								
								ELSE
									error.raiseerror('Unknown reduced term <' ||
													 sopergroupredrates(sprofileid(pcurno))
													 (vgroupid)(l).terms || '>!');
								
							END CASE;
						
							IF vuseredrate
							THEN
							
								vreducedrateid := sopergroupredrates(sprofileid(pcurno)) (vgroupid)(l)
												 .rateid;
							
								IF vprevprevstatementdate IS NULL
								THEN
									FOR pp IN REVERSE 1 .. vstcyclearray.count
									LOOP
										IF vstcyclearray(pp)
										 .nextstatementdate = getcurrentcycle().statementdate
										THEN
											vprevprevstatementdate := vstcyclearray(pp)
																	  .statementdate;
											EXIT;
										END IF;
									END LOOP;
									s.say(cmethodname ||
										  '       Previous cycle beginning date (vPrevPrevStatementDate) = ' ||
										  htools.d2s(vprevprevstatementdate));
								END IF;
								s.say(cmethodname || '       - info: Reduced term is satisfied');
							
								EXIT;
							ELSE
								s.say(cmethodname ||
									  '       - info: Reduced term is NOT satisfied');
							END IF;
						
						END LOOP reduced_rates;
					
						t.var('Final UseRedRate', htools.b2s(vuseredrate));
					
						s.say(cmethodname || '  ++  ');
						s.say(cmethodname || '');
					
						s.say(cmethodname ||
							  '  ++  WHETHER UNBILLED TRANSACTIONS SHOULD BE SELECTED FOR INTEREST CHARGING (supposed that grace period term is NOT satisfied) ++ ');
						s.say(cmethodname ||
							  '       If should be selected (vGrpParams(custom_contractprofiles.cPG_UnBillInc)) = ' ||
							  vgrpparams(custom_contractprofiles.cpg_unbillinc) ||
							  ', [1 - YES, 0 - NO]');
					
						IF (vgrpparams(custom_contractprofiles.cpg_usegrace) = '0')
						   OR ((vgrpparams(custom_contractprofiles.cpg_unbillinc) = '1') AND
						   (NOT vuseredrate))
						THEN
							vpostenddate := getcurrentcycle().nextstatementdate;
						ELSE
							vpostenddate := getcurrentcycle().statementdate;
						END IF;
						s.say(cmethodname ||
							  '       The date up to which transaction is selected for interest calculation (vPostEndDate) = ' ||
							  htools.d2s(vpostenddate));
						addsetuplog('TrnDateIncluded=' || to_char(vpostenddate, 'DDMMYYYY'));
						s.say(cmethodname || '  ++ ');
						s.say(cmethodname || '');
					
						s.say(cmethodname ||
							  '  ++  WHETHER INTEREST SHOULD BE CHARGED FOR PERIOD UP TO CURRENT STATEMENT DATE (actual for group using grace period) ++ ');
						s.say(cmethodname ||
							  '       If should be charged (vGrpParams(custom_contractprofiles.cPG_TillCurSD)) = ' ||
							  vgrpparams(custom_contractprofiles.cpg_tillcursd) ||
							  ', [1 - YES, 0 - NO]');
					
						IF vgrpparams(custom_contractprofiles.cpg_tillcursd) = '1'
						THEN
							vchargeenddate := getcurrentcycle().nextstatementdate;
						ELSE
							s.say(cmethodname ||
								  '       - info: either parameter is switched off or the group is not used grace period, therefore "charging end date" is chosen according to "grace" value paramter');
							vchargeenddate := vpostenddate;
						END IF;
						s.say(cmethodname ||
							  '       The date up to which interest should be charged (vChargeEndDate) = ' ||
							  htools.d2s(vchargeenddate));
						addsetuplog('ChargeTo=' || to_char(vchargeenddate, 'DDMMYYYY'));
						s.say(cmethodname || '  ++  ');
						s.say(cmethodname || '');
					
						s.say(cmethodname ||
							  '  ++  INTEREST CALCULATION PROCESS (transaction handling) ++ ');
						s.say(cmethodname ||
							  '         Interest charge mode according to current contract state (sBlockParam.State.ChargeInt) = ' ||
							  contractstatereference.getdescr_interestcharge(sblockparam.state.chargeint) || ' (' ||
							  sblockparam.state.chargeint || ')');
					
						IF sblockparam.state.chargeint = contractstatereference.cintdontcharge
						THEN
						
							s.say(cmethodname ||
								  '         Accorrding to current contract state - Interest Should NOT be charged');
						
							setgroupintenddate(sdepaccount(pcurno).accountno
											  ,vgroupid
											  ,vpostenddate
											  ,vchargeenddate);
						
						ELSE
						
							s.say(cmethodname || '  ++  GETTING OTHER GROUP PARAMETERS ++ ');
							vprcvalue   := 0;
							vdaysinyear := coalesce(vgrpparams(custom_contractprofiles.cpg_daysinyear)
												   ,contracttools.daysinyear(vchargeenddate));
							s.say(cmethodname || '       > Days in year (vDaysInYear) = ' ||
								  vdaysinyear);
							s.say(cmethodname ||
								  '       > Base of interest calculation (vGrpParams(custom_contractprofiles.cPG_ChargeOnB)) = ' ||
								  vgrpparams(custom_contractprofiles.cpg_chargeonb) ||
								  ', [1 - Full balance, 2 - Remaining balance]');
						
							addsetuplog('YearDays=' || vdaysinyear);
							addsetuplog('ChargeOn=' ||
										vgrpparams(custom_contractprofiles.cpg_chargeonb));
						
							vprcdatechoice := vgrpparams(custom_contractprofiles.cpg_crdprcdate);
							vprctype       := vgrpparams(custom_contractprofiles.cpg_crdprctype);
							vprcperiodfrom := vgrpparams(custom_contractprofiles.cpg_crdprcprdt);
							s.say(cmethodname ||
								  '       > Interest calculation rate choosing: Date (vPrcDateChoice) = ' ||
								  vprcdatechoice ||
								  ', [1 - Use current business date, 2 - Use transaction date, 3 - Use rate history]');
							s.say(cmethodname ||
								  '       > Interest calculation rate choosing: Amount (vPrcType) = ' ||
								  vprctype ||
								  ', [1 - Remaining balance, 2 - Discrete remaining balance, 3 - Transaction amount]');
							s.say(cmethodname ||
								  '       > Interest calculation rate choosing: Period from (vPrcPeriodFrom) = ' ||
								  vprcperiodfrom ||
								  ', [1 - Contract creation date, 2 - Transaction date]');
						
							vusebaserate := NOT vuseredrate;
						
							IF vusebaserate
							THEN
								addsetuplog('Rate=REGULAR');
								vgroupprcid := vgrpparams(custom_contractprofiles.cpg_crdprchist);
								s.say(cmethodname ||
									  '       > Chosen rate type for interest calculation = REGULAR');
								s.say(cmethodname ||
									  '       > Chosen rate ID for interest calculation (vGroupPrcID) = ' ||
									  vgroupprcid);
							ELSE
								addsetuplog('Rate=REDUCED');
								vgroupprcid := vreducedrateid;
								s.say(cmethodname ||
									  '       > Chosen rate type for interest calculation = REDUCED; NOTE! The rate type can be chosen on transaction level');
								s.say(cmethodname ||
									  '       > Chosen rate ID for interest calculation (vGroupPrcID = vReducedRateId) = ' ||
									  vgroupprcid);
							END IF;
						
							IF vprcperiodfrom = 1
							THEN
								vperiod := getperiod(sdepaccount(pcurno).createdate);
								s.say(cmethodname ||
									  '       > Contract creation date (sDepAccount(pCurNumber).CreateDate) = ' ||
									  htools.d2s(sdepaccount(pcurno).createdate));
								s.say(cmethodname ||
									  '       > Number of cycles that passed from contract creation date (vPeriod) = ' ||
									  vperiod);
							END IF;
						
							addsetuplog('RateId=' || vgroupprcid);
							addsetuplog('RateType=' || vprctype);
							addsetuplog('RatePrdt=' || vprcperiodfrom);
							addsetuplog('RateDate=' || vprcdatechoice);
						
							s.say(cmethodname ||
								  '       > Promotional rate ID (vGrpParams(custom_contractprofiles.cPG_ProPrcHist)) = ' ||
								  vgrpparams(custom_contractprofiles.cpg_proprchist));
							s.say(cmethodname ||
								  '       > Preferential rate ID (vGrpParams(custom_contractprofiles.cPG_PrePrcHist)) = ' ||
								  vgrpparams(custom_contractprofiles.cpg_preprchist));
							s.say(cmethodname ||
								  '       > Don''t charge interest on paid amount till due date (vGrpParams(custom_contractprofiles.cPG_ChargePaid)) = ' ||
								  vgrpparams(custom_contractprofiles.cpg_chargepaid) ||
								  ', [0 - NO (i.e. charge interest), 1 - YES (i.e. don''t charge)]');
							s.say(cmethodname ||
								  '       > On first billing cycle only (!!!used ONLY with parameter "do not charge interest on paid amount till due date")   (vGrpParams(custom_contractprofiles.cPG_OnlyFirst)) = ' ||
								  vgrpparams(custom_contractprofiles.cpg_onlyfirst) ||
								  ', [0 - NO (for all cycles), 1 - YES (first cycle only)]');
							s.say(cmethodname || '  ++  ');
						
							addsetuplog('PromRateId=' ||
										vgrpparams(custom_contractprofiles.cpg_proprchist));
							addsetuplog('PrefRateId=' ||
										vgrpparams(custom_contractprofiles.cpg_preprchist));
							addsetuplog('RepayDate=' || sprofile(sprofileid(pcurno))
										(custom_contractprofiles.cp_repaydate));
							addsetuplog('ChargeOnPaid=' || service.iif(vgrpparams(custom_contractprofiles.cpg_chargepaid) = '1'
																	  ,'1'
																	  ,'2'));
							addsetuplog('Only1=' || service.iif(vgrpparams(custom_contractprofiles.cpg_onlyfirst) = '1'
															   ,'1'
															   ,'2'));
							s.say('');
							s.say(cmethodname ||
								  '         Preferential rate validity \in cycles\ (vGrpParams(custom_contractprofiles.cPG_PreUse) = ' ||
								  vgrpparams(custom_contractprofiles.cpg_preuse));
							s.say(cmethodname ||
								  '         Preferential Rate Id (vGrpParams(custom_contractprofiles.cPG_PrePrcHist)) = ' ||
								  vgrpparams(custom_contractprofiles.cpg_preprchist));
							s.say(cmethodname ||
								  '         Contract creation date (ContractTypeSchema.sContractRow.CreateDate) = ' ||
								  htools.d2s(contracttypeschema.scontractrow.createdate));
							addsetuplog('PrefRateUsageStarts=' ||
										vgrpparams(custom_contractprofiles.cpg_preprcusagestarts));
						
							vprefrateusagemode := cprefrate_donotuse;
						
							IF (vgrpparams(custom_contractprofiles.cpg_preprchist) <> -1)
							   AND
							   referencecalendar.isselectedday(contracttypeschema.scontractrow.createdate
															  ,vgrpparams(custom_contractprofiles.cpg_precalid))
							THEN
							
								s.say(cmethodname ||
									  '         Preferential rate usage starts from (vGrpParams(custom_contractprofiles.cPG_PrePrcUsageStarts) = ' ||
									  vgrpparams(custom_contractprofiles.cpg_preprcusagestarts) ||
									  ', [1 - Contract creation date, 2 - transaction date]');
								s.say(cmethodname ||
									  '         Cycles number between contr. creation date and oper. date  = ' ||
									  getcyclesnumber(contracttypeschema.scontractrow.createdate
													 ,coperdate));
							
								CASE nvl(vgrpparams(custom_contractprofiles.cpg_preprcusagestarts)
									,custom_contractprofiles.cprefrateuse_contrcreationdate)
								
									WHEN custom_contractprofiles.cprefrateuse_contrcreationdate THEN
									
										IF prefrateshouldbeapplied(contracttypeschema.scontractrow.createdate
																  ,vgrpparams)
										THEN
											vprefrateusagemode := cprefrate_forcontract;
										END IF;
									
									WHEN custom_contractprofiles.cprefrateuse_trandate THEN
									
										vprefrateusagemode := cprefrate_fortrxn;
									
									ELSE
										error.raiseerror('Unknown "Usage period starts from parameter value " <' ||
														 nvl(vgrpparams(custom_contractprofiles.cpg_preprcusagestarts)
															,custom_contractprofiles.cprefrateuse_contrcreationdate) || '>!');
								END CASE;
							
							END IF;
						
							t.var('vPrefRateUsageMode', vprefrateusagemode);
						
							<<all_group_trxns>>
							FOR j IN curtrxnlist(sdepaccount(pcurno).accountno
												,vgroupid
												,vpostenddate)
							LOOP
							
								vprcid    := vgroupprcid;
								vratetype := service.iif(vusebaserate, crate_regular, crate_reduced);
							
								s.say(cmethodname || '         Transaction attributes: recNo = ' ||
									  j.recno || ', TranDate = ' || htools.d2s(j.trandate) ||
									  ', PostDate = ' || htools.d2s(j.postdate) || ', Amount = ' ||
									  j.amount || ', Paid amount = ' || j.paidamount);
							
								IF vusebaserate
								THEN
								
									IF vgrpparams(custom_contractprofiles.cpg_proprchist) <> -1
									THEN
									
										CASE vgrpparams(custom_contractprofiles.cpg_proaddcond)
										
											WHEN custom_contractprofiles.cproplsql_off THEN
												vusepromo := referencecalendar.isselectedday(j.trandate
																							,vgrpparams(custom_contractprofiles.cpg_procalid));
											
											WHEN custom_contractprofiles.cproplsql_and THEN
												vusepromo := referencecalendar.isselectedday(j.trandate
																							,vgrpparams(custom_contractprofiles.cpg_procalid)) AND
															 promoblockresult(vgrpparams(custom_contractprofiles.cpg_proplsql)
																			 ,j.docno);
											
											WHEN custom_contractprofiles.cproplsql_or THEN
												vusepromo := referencecalendar.isselectedday(j.trandate
																							,vgrpparams(custom_contractprofiles.cpg_procalid)) OR
															 promoblockresult(vgrpparams(custom_contractprofiles.cpg_proplsql)
																			 ,j.docno);
											
											ELSE
												error.raiseerror('Internal error: unsupported PL/SQL block use mode: ' ||
																 vgrpparams(custom_contractprofiles.cpg_proaddcond) || '!');
										END CASE;
									
										IF vusepromo
										THEN
											vprcid    := vgrpparams(custom_contractprofiles.cpg_proprchist);
											vratetype := crate_promotional;
											addlog('PromRateID', vprcid);
											s.say(cmethodname ||
												  '         - info: (promotional rate analyzing): Promotional rate is used');
										END IF;
									
									END IF;
								
								ELSIF vreducedtermusage =
									  custom_contractprofiles.cgraceperusage_prevcycleonly
								THEN
								
									s.say(cmethodname ||
										  '         - info: ("Apply reduced term for previous cycle only" analyzing): Reduced rate is used');
								
									IF j.postdate <= vprevprevstatementdate
									THEN
										s.say(cmethodname || '         Posting date ' ||
											  htools.d2s(j.postdate) ||
											  ' is less or equal to previous cycle beginning date ' ||
											  htools.d2s(vprevprevstatementdate) ||
											  ', therefore REGULAR rate is chosen');
										vprcid    := vgrpparams(custom_contractprofiles.cpg_crdprchist);
										vratetype := crate_regular;
										s.say(cmethodname ||
											  '         - info: ("Apply reduced term for previous cycle only" analyzing): Regular rate is used');
										addlog('Rate', 'REGULAR');
									ELSE
										addlog('Rate', 'GROUP RATE');
									END IF;
								
								END IF;
							
								s.say(cmethodname || '         Final Interest rate ID (vPrcID) = ' ||
									  vprcid);
								addlog('TranRateId', vprcid);
							
								IF vprcid = -1
								THEN
									s.say(cmethodname ||
										  '         - info: Final interest rate is "Don''t charge"');
								ELSE
								
									loadtrxnrepayments(j.recno
													  ,sprofile(sprofileid(pcurno))
													   (custom_contractprofiles.cp_repaydate)
													  ,vatranche);
									FOR i IN 1 .. vatranche.count
									LOOP
										s.say(cmethodname || '         vaTranche(' || i ||
											  ').RecNo=' || vatranche(i).docno || ' Amount=' || vatranche(i)
											  .value || ' opDate = ' || vatranche(i).opdate ||
											  ' entCode = ' || vatranche(i).entcode);
									END LOOP;
								
									varemain := sch_prc.tranche2remain(- (j.amount - j.paidamount)
																	  ,vatranche
																	  ,TRUE
																	  ,greatest(j.intstartdate
																			   ,j.intenddate + 1)
																	  ,coperdate + 1
																	  ,TRUE
																	  ,TRUE);
									FOR i IN 1 .. varemain.count
									LOOP
										s.say(cmethodname || '         vaRemain(' || i ||
											  ').OpDate=' || varemain(i).opdate || ' vaRemain(' || i ||
											  ').Remain=' || varemain(i).remain);
									END LOOP;
								
									IF vgrpparams(custom_contractprofiles.cpg_chargeonb) = 1
									THEN
										sch_prc.changeremain(varemain
															,sch_prc.crm_rpl
															,pbaseamount => j.amount);
										FOR i IN 1 .. varemain.count
										LOOP
											s.say(cmethodname ||
												  '         "CHANGED vaRemain: " - vaRemain(' || i ||
												  ').OpDate=' || varemain(i).opdate ||
												  ' vaRemain(' || i || ').Remain=' || varemain(i)
												  .remain);
										END LOOP;
									END IF;
								
									IF vgrpparams(custom_contractprofiles.cpg_chargepaid) = '1'
									THEN
										IF vgrpparams(custom_contractprofiles.cpg_onlyfirst) <> '1'
										   OR ((getpreviouscycle().statementdate IS NULL) OR
											   (j.postdate BETWEEN getpreviouscycle()
											   .statementdate + 1 AND getpreviouscycle()
											   .nextstatementdate))
										THEN
											vduedateamount := sch_prc.changeremain(varemain
																				  ,sch_prc.crm_last
																				  ,penddate => least(getcurrentcycle()
																									 .duedate
																									,coperdate));
											s.say(cmethodname || '         DontChargeOnPaid=TRUE');
											s.say(cmethodname || '         DDAmount= ' ||
												  vduedateamount);
											FOR i IN 1 .. varemain.count
											LOOP
												s.say(cmethodname ||
													  '         "CHANGED vaRemain: " - vaRemain(' || i ||
													  ').OpDate=' || varemain(i).opdate ||
													  ' vaRemain(' || i || ').Remain=' || varemain(i)
													  .remain);
											END LOOP;
											addlog('DontChargeOnPaid', 'TRUE');
											addlog('DDAmount', vduedateamount);
										END IF;
									END IF;
								
									vfixprcdate := CASE
													vgrpparams(custom_contractprofiles.cpg_crdprcdate)
													   WHEN custom_contractprofiles.cdate_current THEN
														coperdate
													   WHEN custom_contractprofiles.cdate_transaction THEN
														j.trandate
													   WHEN custom_contractprofiles.cdate_cardcreation THEN
														getlastcardcreationdate
													   ELSE
														NULL
												   END;
								
									CASE vgrpparams(custom_contractprofiles.cpg_crdprctype)
									
										WHEN custom_contractprofiles.camount_max THEN
											vfixamount  := NULL;
											vamountmode := sch_prc.cam_remain;
										
										WHEN custom_contractprofiles.camount_discrete THEN
											vfixamount  := NULL;
											vamountmode := sch_prc.cam_discrete;
										
										ELSE
											vfixamount  := j.amount;
											vamountmode := sch_prc.cam_remain;
									END CASE;
								
									vfixperiod := CASE
												   vgrpparams(custom_contractprofiles.cpg_crdprcprdt)
													  WHEN 1 THEN
													   vperiod
													  ELSE
													   getperiod(j.trandate)
												  END;
								
									s.say(cmethodname || '         vFixPrcDate=' ||
										  htools.d2s(vfixprcdate) || ' vFixAmount=' || vfixamount ||
										  ' vAmountMode=' || vamountmode || ' vFixPeriod=' ||
										  vfixperiod || ', vPrcID = ' || vprcid);
								
									sch_prc.mergerate(varemain
													 ,sch_prc.loadrate(vprcid)
													 ,vfixprcdate
													 ,sch_prc.cmoderpl
													 ,vfixperiod
													 ,vfixamount
													 ,pamountmode => vamountmode);
									FOR k IN 1 .. varemain.count
									LOOP
										s.say(cmethodname || '         ' || k || ': OpDate=' || varemain(k)
											  .opdate);
										s.say(cmethodname || '         ' || k || ': Remain=' || varemain(k)
											  .remain);
										s.say(cmethodname || '         ' || k || ': Rate=' || varemain(k).rate);
										s.say(cmethodname || '         ' || k || ': Lucre=' || varemain(k)
											  .lucre);
										IF varemain(k).asubremain.exists(1)
										THEN
											FOR kk IN 1 .. varemain(k).asubremain.count
											LOOP
												s.say(k || ': ASubRemain(' || kk || ')=' || varemain(k)
													  .asubremain(kk));
												IF varemain(k).asubrate.exists(kk)
												THEN
													s.say(k || ': ASubRate(' || kk || ')=' || varemain(k)
														  .asubrate(kk));
												END IF;
												IF varemain(k).asubrc_remain.exists(kk)
												THEN
													s.say(k || ': ASubRC_Remain(' || kk || ')=' || varemain(k)
														  .asubrc_remain(kk));
												END IF;
												IF varemain(k).asubrc_amin.exists(kk)
												THEN
													s.say(k || ': ASubRC_AMin(' || kk || ')=' || varemain(k)
														  .asubrc_amin(kk));
												END IF;
												IF varemain(k).asubrc_amax.exists(kk)
												THEN
													s.say(k || ': ASubRC_AMax(' || kk || ')=' || varemain(k)
														  .asubrc_amax(kk));
												END IF;
											END LOOP;
										END IF;
									END LOOP;
								
									IF vusebaserate
									   AND ((vprefrateusagemode = cprefrate_forcontract) OR
									   ((vprefrateusagemode = cprefrate_fortrxn) AND
									   prefrateshouldbeapplied(j.trandate, vgrpparams)))
									THEN
									
										vratetype := crate_preferential;
									
										sch_prc.mergerate(varemain
														 ,sch_prc.loadrate(vgrpparams(custom_contractprofiles.cpg_preprchist))
														 ,coperdate
														 ,sch_prc.cmodeaddwochange
														 ,pamountmode => vamountmode);
										s.say(cmethodname ||
											  '         After merging with preferential rate:');
										FOR k IN 1 .. varemain.count
										LOOP
											s.say(cmethodname || '         ' || k || ': OpDate=' || varemain(k)
												  .opdate);
											s.say(cmethodname || '         ' || k || ': Remain=' || varemain(k)
												  .remain);
											s.say(cmethodname || '         ' || k || ': Rate=' || varemain(k).rate);
											s.say(cmethodname || '         ' || k || ': Lucre=' || varemain(k)
												  .lucre);
											IF varemain(k).asubremain.exists(1)
											THEN
												FOR kk IN 1 .. varemain(k).asubremain.count
												LOOP
													s.say(cmethodname || '         ' || k ||
														  ': ASubRemain(' || kk || ')=' || varemain(k)
														  .asubremain(kk));
													IF varemain(k).asubrate.exists(kk)
													THEN
														s.say(k || ': ASubRate(' || kk || ')=' || varemain(k)
															  .asubrate(kk));
													END IF;
													IF varemain(k).asubrc_remain.exists(kk)
													THEN
														s.say(k || ': ASubRC_Remain(' || kk || ')=' || varemain(k)
															  .asubrc_remain(kk));
													END IF;
													IF varemain(k).asubrc_amin.exists(kk)
													THEN
														s.say(k || ': ASubRC_AMin(' || kk || ')=' || varemain(k)
															  .asubrc_amin(kk));
													END IF;
													IF varemain(k).asubrc_amax.exists(kk)
													THEN
														s.say(k || ': ASubRC_AMax(' || kk || ')=' || varemain(k)
															  .asubrc_amax(kk));
													END IF;
												END LOOP;
											END IF;
										END LOOP;
									END IF;
								
									vprcstep := sch_prc.calc(varemain
															,greatest(j.intstartdate
																	 ,j.intenddate + 1)
															,vchargeenddate + 1
															,pdaysinyear => vdaysinyear);
									s.say(cmethodname || '         vPrcStep = ' || vprcstep);
									s.say(cmethodname || '         vaRemain.Count = ' ||
										  varemain.count);
								
									FOR i IN 1 .. varemain.count
									LOOP
										s.say(cmethodname || '         vaRemain(' || i ||
											  ').OpDate=' || htools.d2s(varemain(i).opdate) ||
											  ' j.IntStartDate=' || htools.d2s(j.intstartdate) ||
											  ' j.IntEndDate + 1=' || htools.d2s(j.intenddate + 1) ||
											  ' vChargeEndDate=' || htools.d2s(vchargeenddate));
										IF (varemain(i)
										   .opdate >= greatest(j.intstartdate, j.intenddate + 1))
										   AND (varemain(i).opdate <= vchargeenddate)
										THEN
											CASE vgrpparams(custom_contractprofiles.cpg_crdprctype)
												WHEN 1 THEN
													addlog('RateSelect', 'REMAIN');
													savelog(vgroupid
														   ,j.recno
														   ,j.intstartdate
														   ,j.intenddate
														   ,varemain      (i).opdate
														   ,j.amount
														   ,varemain      (i).remain
														   ,varemain      (i).rate
														   ,varemain      (i + 1).opdate       - varemain(i)
															.opdate);
												WHEN 2 THEN
													FOR k IN 1 .. varemain(i).asubrc_remain.count
													LOOP
														addlog('RateSelect', 'DISCRETE');
														IF varemain(i).asubrc_amin(k) IS NOT NULL
														THEN
															addlog('FromRemain'
																  ,varemain(i).asubrc_amin(k));
														END IF;
														IF varemain(i).asubrc_amax(k) IS NOT NULL
														THEN
															addlog('ToRemain'
																  ,varemain(i).asubrc_amax(k));
														END IF;
														savelog(vgroupid
															   ,j.recno
															   ,j.intstartdate
															   ,j.intenddate
															   ,varemain      (i).opdate
															   ,j.amount
															   ,varemain      (i).asubremain(k)
															   ,varemain      (i).asubrate(k)
															   ,varemain      (i + 1).opdate       - varemain(i)
																.opdate);
													END LOOP;
												ELSE
													addlog('RateSelect', 'TRAN');
													savelog(vgroupid
														   ,j.recno
														   ,j.intstartdate
														   ,j.intenddate
														   ,varemain      (i).opdate
														   ,j.amount
														   ,varemain      (i).remain
														   ,varemain      (i).rate
														   ,varemain      (i + 1).opdate       - varemain(i)
															.opdate);
											END CASE;
										END IF;
									END LOOP;
								
									vprcvalue := vprcvalue + vprcstep;
								
									IF (sprofile(sprofileid(pcurno))
										(custom_contractprofiles.cp_divintbyrates) = '1')
									THEN
										vainterest(vratetype) := vainterest(vratetype) + vprcstep;
									END IF;
								
									s.say(cmethodname || '         PrcStep=' || vprcstep);
									s.say(cmethodname || '         PrcValue=' || vprcvalue);
								
								END IF;
							
								settrxnintenddate(j, vchargeenddate);
							
								cleartranlog;
							
							END LOOP all_group_trxns;
						
							s.say(cmethodname || '         End PrcValue=' || vprcvalue);
						
							IF vprcvalue > 0
							THEN
							
								IF sprofile(sprofileid(pcurno))
								 (custom_contractprofiles.cp_chargetype) = '1'
								THEN
								
									IF (sprofile(sprofileid(pcurno))
										(custom_contractprofiles.cp_divintbyrates) = '1')
									THEN
										chargeinterestbyarray(pcurno
															 ,vgroupid
															 ,vainterest
															 ,vfullremark);
									
									ELSE
										makeinterestentry(pcurno, vgroupid, vprcvalue, vfullremark);
									END IF;
								
								ELSE
									vtotalinterest := vtotalinterest + vprcvalue;
								END IF;
							
							END IF;
						
						END IF;
					
						s.say(cmethodname || '  ++  ');
					
					END IF;
				
					savesetuplog(vgroupid);
				
				END LOOP operations_groups;
			
				IF vtotalinterest > 0
				THEN
				
					IF (sprofile(sprofileid(pcurno))
						(custom_contractprofiles.cp_divintbyrates) = '1')
					THEN
						chargeinterestbyarray(pcurno, 0, vainterest, vfullremark);
					
					ELSE
						makeinterestentry(pcurno, 0, vtotalinterest, vfullremark);
					END IF;
				
				END IF;
			
				saveprofilelog;
			
			WHEN 2 THEN
			
				IF sblockparam.state.chargeint <> contractstatereference.cintdontcharge
				THEN
				
					addsetuplog('IntChrgType=' || sprofile(sprofileid(pcurno))
								(custom_contractprofiles.cp_intbyremainchrgtype));
				
					CASE
					 sprofile(sprofileid(pcurno)) (custom_contractprofiles.cp_intbyremainchrgtype)
					
						WHEN 1 THEN
							NULL;
						
						WHEN 2 THEN
						
							vdummypha := custom_overdueparameterscalculation.getoverdueparameters(sdepaccount(pcurno)
																								  .accountno
																								 ,pcurno
																								 ,NULL
																								 ,sdelparam.overdueint
																								 ,voverdueparameters);
						
							addsetuplog('Remain=' || voverdueparameters.unpaidsdamountonddate);
						
							IF voverdueparameters.unpaidsdamountonddate > 0
							THEN
							
								vprcid := custom_contractprofiles.cr_intbyremainrate;
							
								FOR i IN 1 .. sprofilerates(sprofileid(pcurno))(vprcid).count
								LOOP
									EXIT WHEN sprofilerates(sprofileid(pcurno))(vprcid)(i).pdate > coperdate;
									vdate := sprofilerates(sprofileid(pcurno)) (vprcid)(i).pdate;
								END LOOP;
							
								contracttools.raiseif(vdate IS NULL
													 ,'Interest rate on date <' ||
													  htools.d2s(coperdate) || '> is not set!');
							
								addsetuplog('RateId=' || sprofilerates(sprofileid(pcurno))
											(vprcid)(1).pid);
							
								FOR i IN 1 .. sprofilerates(sprofileid(pcurno))(vprcid).count
								LOOP
									IF sprofilerates(sprofileid(pcurno)) (vprcid)(i).pdate = vdate
									THEN
										varates(varates.count + 1) := sprofilerates(sprofileid(pcurno))
																	  (vprcid) (i);
									END IF;
								END LOOP;
							
								contracttools.raiseif(varates(varates.count).prow = 0
													 ,'Interest calculation on tiers requires rate with at least one positive amount!');
							
								vremain := voverdueparameters.unpaidsdamountonddate;
							
								FOR i IN 1 .. varates.count
								LOOP
								
									vindex := i;
								
									IF i = varates.count
									THEN
										vinterval := varates(i).prow;
									ELSE
										vinterval := varates(i + 1).prow - varates(i).prow;
									END IF;
								
									EXIT WHEN(vremain < vinterval) OR(i = varates.count);
								
									vtotalinterest := vtotalinterest + varates(i).pvalue;
									vremain        := greatest(vremain - vinterval, 0);
								
									savelogbytiers(i, vinterval, varates(i).pvalue, 1);
								
								END LOOP;
							
								s.say('FinalRemain = ' || vremain);
							
								IF vremain > 0
								THEN
									vfinalquantity := ceil(vremain / vinterval);
									vtotalinterest := vtotalinterest +
													  (vfinalquantity * varates(vindex).pvalue);
								
									savelogbytiers(vindex
												  ,vinterval
												  ,varates(vindex).pvalue
												  ,vfinalquantity);
								END IF;
							
								s.say('TotalInterest = ' || vtotalinterest);
							
								IF vtotalinterest > 0
								THEN
									makeinterestentry(pcurno, 0, vtotalinterest, vfullremark);
								END IF;
							
								savesetuplog(0);
								saveprofilelog;
							
							END IF;
						
						ELSE
							error.raiseerror('Unknown interest charge type <' ||
											 sprofile(sprofileid(pcurno))
											 (custom_contractprofiles.cp_intbyremainchrgtype) || '>!');
					END CASE;
				
				END IF;
			
			ELSE
				error.raiseerror('Unknown interest charge mode <' || sprofile(sprofileid(pcurno))
								 (custom_contractprofiles.cp_intchrgmode) || '>!');
		END CASE;
	
		IF sinttoinston(pcurno)
		   AND (vatrxnstoinst.count > 0)
		THEN
			moveinteresttoinstallment(pcurno, vtrxnstoinstamount, vatrxnstoinst);
		END IF;
	
		dotransactionsrepayment(pcurno);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END interestcharge;

	FUNCTION fillremainarray
	(
		paccount   IN contracttools.taccountrecord
	   ,pstartdate IN DATE
	   ,penddate   IN DATE
	) RETURN contracttools.typeprcarray IS
		cmethodname CONSTANT typemethodname := cpackagename || '.FillRemainArray';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vresult contracttools.typeprcarray;
		vcount  NUMBER;
	
		CURSOR curentries IS
			SELECT opdate
				  ,SUM(VALUE) VALUE
			FROM   (SELECT b.opdate
						  ,-a.value VALUE
					FROM   tentry    a
						  ,tdocument b
					WHERE  a.branch = cbranch
					AND    a.debitaccount = paccount.accountno
					AND    b.branch = a.branch
					AND    b.docno = a.docno
					AND    b.opdate >= pstartdate + 1
					AND    b.opdate <= penddate
					AND    b.newdocno IS NULL
					UNION ALL
					SELECT b.opdate
						  ,a.value
					FROM   tentry    a
						  ,tdocument b
					WHERE  a.branch = cbranch
					AND    a.creditaccount = paccount.accountno
					AND    b.branch = a.branch
					AND    b.docno = a.docno
					AND    b.opdate >= pstartdate + 1
					AND    b.opdate <= penddate
					AND    b.newdocno IS NULL)
			GROUP  BY opdate
			ORDER  BY opdate;
	
	BEGIN
		t.enter(cmethodname);
	
		vcount := 1;
		vresult(1).premain := contracttools.get_bod_remain(paccount.accountno
														  ,pstartdate + 1
														  ,FALSE
														  ,pcheckemptyaccno => FALSE);
		vresult(1).pdate := pstartdate;
		FOR i IN curentries
		LOOP
			vcount := vcount + 1;
			t.var('vCount', vcount);
			IF (contracttools.getyear(i.opdate) <> contracttools.getyear(vresult(vcount - 1).pdate))
			   AND ((i.opdate) <> trunc(i.opdate, 'year'))
			THEN
				vresult(vcount).pdate := trunc(i.opdate, 'year');
				vresult(vcount).premain := vresult(vcount - 1).premain;
				vcount := vcount + 1;
			END IF;
			vresult(vcount).pdate := i.opdate;
			vresult(vcount).premain := vresult(vcount - 1).premain + i.value;
		END LOOP;
		IF contracttools.getyear(vresult(vcount).pdate) <> contracttools.getyear(penddate)
		THEN
			vcount := vcount + 1;
			vresult(vcount).pdate := trunc(penddate, 'year');
			vresult(vcount).premain := vresult(vcount - 1).premain;
		END IF;
		FOR i IN 1 .. vcount
		LOOP
			vresult(i).premain := abs(vresult(i).premain);
			s.say(cmethodname || ' -> Date=' || vresult(i).pdate || ' Remain =' || vresult(i)
				  .premain);
		END LOOP;
	
		t.leave(cmethodname);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END fillremainarray;

	PROCEDURE createstatementpackrow(pcontractprevioussd IN DATE) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.CreateStatementPackRow';
		coperdate   CONSTANT DATE := seance.getoperdate;
		vitem statementmanualrt.tmanuallogitemrec;
	BEGIN
		t.enter(cmethodname, pcontractprevioussd);
	
		IF nvl(sstatementpackno, 0) = 0
		THEN
			spacket.datestart       := sstatstartdate;
			spacket.dateend         := coperdate;
			spacket.taxid           := 0;
			spacket.statementgrp    := statementrt.statement_contract;
			spacket.statementtype   := sactparam(cctp_stmttype);
			spacket.foldercode      := sactparam(cctp_stmtfolder);
			spacket.useclientfolder := 0;
			spacket.lngcode         := NULL;
			s.say(cmethodname || ' -> DateStart =' || spacket.datestart);
			s.say(cmethodname || ' -> DateEnd =' || spacket.dateend);
			sstatementpackno := statementmanualrt.createmanualpacket(spacket);
		END IF;
		s.say(cmethodname || ' -> StatementPackNo =' || sstatementpackno);
		IF sstatementpackno IS NULL
		THEN
			error.raiseerror('Error creating statement packet!');
		END IF;
		IF hascorporatecontract
		THEN
			contractparams.savedate(contractparams.ccontract
								   ,getcorpcontractnumber
								   ,'Statement_Start'
								   ,sstatstartdate);
			contractparams.savedate(contractparams.ccontract
								   ,getcorpcontractnumber
								   ,'Statement_End'
								   ,coperdate);
		END IF;
		vitem.contractno := scontractno;
		vitem.datestart  := nvl(pcontractprevioussd + 1, contracttypeschema.scontractrow.createdate);
		vitem.dateend    := coperdate;
		s.say(cmethodname ||
			  '    Statement generation beginning date for the contract (vItem.DateStart) = ' ||
			  htools.d2s(vitem.datestart) ||
			  ', Statement generation end date for the contract (vItem.DateEnd) = ' ||
			  htools.d2s(vitem.dateend));
	
		IF NOT statementmanualrt.additemtomanualpacket(sstatementpackno, vitem)
		THEN
			error.raiseerror('Error adding contract to statement packet!');
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END createstatementpackrow;

	PROCEDURE setaccountsstatus
	(
		poperation IN PLS_INTEGER
	   ,pdoonline  IN BOOLEAN
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SetAccountsStatus';
	
		vdorollback        BOOLEAN := poperation = cadjusting;
		vlocallysavingflag BOOLEAN := FALSE;
		vsavedstatus       typeaccountstatus;
		vcurrstatus        typeaccountstatus;
		vstatuschangemode  NUMBER;
	
	BEGIN
		t.enter(cmethodname, poperation);
	
		vstatuschangemode := sacparam(cp_chaccstatus);
		t.var('vStatusChangeMode', vstatuschangemode);
	
		IF vstatuschangemode <> 1
		THEN
		
			FOR i IN 1 .. 2
			LOOP
			
				IF ifcurrencyisusedintype(i, scontracttype, scontractno)
				THEN
				
					vcurrstatus := sdepaccount(i).acct_stat;
					s.say(cmethodname || 'Account number (sDepAccount(' || i || ').AccountNo) =' || sdepaccount(i)
						  .accountno || ' Current Account status in TWCMS (vCurrStatus)=' ||
						  vcurrstatus);
				
					vsavedstatus := contractparams.loadchar(contractparams.ccontract
														   ,scontractno
														   ,'Acc_Status_' || i
														   ,FALSE);
					t.var('vSavedStatus', vsavedstatus);
				
					IF vsavedstatus IS NULL
					THEN
						savecontractparam('Acc_Status_' || i, vcurrstatus, vdorollback);
						vsavedstatus := vcurrstatus;
					END IF;
				
					t.var('sBlockParam.State.AccBlock', sblockparam.state.accblock);
				
					IF sblockparam.state.accblock <> vcurrstatus
					THEN
					
						IF (vstatuschangemode = 2)
						   OR ((vstatuschangemode = 3) AND (vsavedstatus = vcurrstatus))
						   OR ((vstatuschangemode = 4) AND
						   ((vcurrstatus = referenceacct_stat.stat_open) OR
						   (vsavedstatus = vcurrstatus)))
						THEN
						
							IF vdorollback
							THEN
								contractrbstd.setaccacct_stat(sdepaccount(i)
															 ,sblockparam.state.accblock);
							ELSIF contracttools.setaccacct_stat(sdepaccount(i)
															   ,sblockparam.state.accblock) <> 0
							THEN
								error.raisewhenerr;
							END IF;
						
							savecontractparam('Acc_Status_' || i
											 ,sblockparam.state.accblock
											 ,vdorollback);
						
							IF pdoonline
							THEN
								BEGIN
									remoteonline.setaccountstatus(sdepaccount(i).accountno
																 ,sblockparam.state.accblock);
								EXCEPTION
									WHEN OTHERS THEN
										htools.showmessage('Warning'
														  , 'Error when changing account <' || sdepaccount(i)
														   .accountno || '> status in TWO:~' ||
															remoteonline.geterrortext(remoteonline.geterrorcode) ||
															'~Changes saved locally');
										vlocallysavingflag := TRUE;
										err.seterror(0, cmethodname);
								END;
							END IF;
						
							IF poperation = csetcontrstate
							THEN
								a4mlog.cleanparamlist;
								a4mlog.addparamrec('AccountStatus'
												  ,vcurrstatus
												  ,sblockparam.state.accblock);
								a4mlog.addparamrec('LocalChange', htools.b2s(vlocallysavingflag));
								a4mlog.addparamrec('Operation', getoperationdescr(poperation));
								a4mlog.logobject(object.gettype(contract.object_name)
												,scontractno
												,'Change Account Status from "' ||
												 referenceacct_stat.getname(vcurrstatus) ||
												 '" to "' ||
												 referenceacct_stat.getname(sblockparam.state.accblock) ||
												 service.iif(vlocallysavingflag, ' (LOCALLY)', '')
												,a4mlog.act_change
												,a4mlog.putparamlist
												,powner => getclientid);
							END IF;
						
						END IF;
					END IF;
				END IF;
			END LOOP;
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END setaccountsstatus;

	PROCEDURE dotransactionsrepayment
	(
		pcurno         IN NUMBER
	   ,pmigrationmode IN BOOLEAN := FALSE
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.DoTransactionsRepayment';
		vacredittrxns typetrxnarray;
		vadebittrxns  typetrxnarray;
		vusedtrxn     typetrxnrec;
	BEGIN
		t.enter(cmethodname);
	
		vacredittrxns := getcredittrxns(pcurno);
	
		FOR i IN 1 .. vacredittrxns.count
		LOOP
		
			IF contracttools.notequal(vacredittrxns(i).trantype, vusedtrxn.trantype)
			   OR ((vacredittrxns(i).trantype = ctrxntype_debitrev) AND
				   contracttools.notequal(vacredittrxns(i).groupid, vusedtrxn.groupid))
			   OR (pmigrationmode AND (vacredittrxns(i).postdate <> vusedtrxn.postdate))
			THEN
			
				vadebittrxns := getdebittrxns(pcurno, vacredittrxns(i), pmigrationmode);
			
				vusedtrxn := vacredittrxns(i);
			
			END IF;
		
			FOR j IN 1 .. vadebittrxns.count
			LOOP
				dorepayment(pcurno, vadebittrxns(j), vacredittrxns(i));
			
				EXIT WHEN vacredittrxns(i).paidfull = 1;
			END LOOP;
		
		END LOOP;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dotransactionsrepayment;

	PROCEDURE processinstallmenttrxns
	(
		pcurno             IN NUMBER
	   ,pinstcontractno    IN typecontractno
	   ,ploanno            IN NUMBER
	   ,poinstaccount      IN OUT NOCOPY contracttools.taccountrecord
	   ,pamount            IN NUMBER
	   ,poatrxnstotransfer IN OUT typetrxnarray
	   ,pchargecommisson   IN BOOLEAN
	   ,pskiploancheck     IN BOOLEAN
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ProcessInstallmentTrxns';
	
		vinstfeeaccount contracttools.taccountrecord;
		vinsttrxn       typetrxnrec;
		ventryno        typeentryno;
		vfeebyinst      NUMBER;
		vfeebyrcm       NUMBER;
		vfeemode        NUMBER;
	
	BEGIN
		t.enter(cmethodname);
	
		vinsttrxn := doentry(pcurno
							,poinstaccount
							,sdepaccount(pcurno)
							,sdepaccount(pcurno).currencyno
							,pamount
							,'INSTALLMENT_ON'
							,'InstlmtOn');
	
		ventryno := sentryno;
	
		FOR i IN 1 .. poatrxnstotransfer.count
		LOOP
		
			IF pskiploancheck
			   OR (poatrxnstotransfer(i).loanno = ploanno)
			THEN
				dorepayment(pcurno, poatrxnstotransfer(i), vinsttrxn);
			END IF;
		
		END LOOP;
	
		dofutureinterestentry(ploanno);
	
		commitloan(ploanno, ventryno);
	
		changeusedlimits(pcurno, pamount, NULL, NULL, TRUE, TRUE);
	
		IF pchargecommisson
		THEN
		
			vfeebyinst := gettransferfeeparams(pinstcontractno
											  ,ploanno
											  ,sprecision(pcurno)
											  ,vfeemode
											  ,pamount
											  ,vinstfeeaccount.accountno);
		
			IF vfeemode = cnofee
			THEN
				t.note(cmethodname, 'No installment fee will be charged');
			ELSE
			
				IF vfeemode IN (cinstfee, crcminstfee)
				THEN
					contracttools.loadcontractaccountbyaccno(vinstfeeaccount.accountno
															,vinstfeeaccount
															,c_doexception);
					doentry(pcurno
						   ,sdepaccount(pcurno)
						   ,vinstfeeaccount
						   ,sdepaccount(pcurno).currencyno
						   ,vfeebyinst
						   ,'INSTALLMENT_ON_FEE'
						   ,'InstOnFee'
						   ,'Installment fee by installment settings');
				END IF;
			
				IF vfeemode IN (crcmfee, crcminstfee)
				THEN
					vfeebyrcm := contractcommission.getcommission(sactparamccy(pcurno)
																  (cctp_installmentonfee)
																 ,contracttypeschema.scontractrow.createdate
																 ,seance.getoperdate
																 ,pamount
																 ,sprecision(pcurno));
					doentry(pcurno
						   ,sdepaccount(pcurno)
						   ,sabaccounts(pcurno) (cb_instonfeeacc)
						   ,sdepaccount(pcurno).currencyno
						   ,vfeebyrcm
						   ,'INSTALLMENT_ON_FEE'
						   ,'InstOnFee'
						   ,'Installment fee by RCM settings');
				END IF;
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END processinstallmenttrxns;

	PROCEDURE appendnewtransactions
	(
		pcurno             IN NUMBER
	   ,pmovetoinstallment IN BOOLEAN := FALSE
	   ,pmigrationmode     IN BOOLEAN := FALSE
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.AppendNewTransactions';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		valinkedcontracts contractlink.typecontractarray;
		vatrxnstotransfer typetrxnarray;
		vanewtrxns        typetrxnarray;
		vcredittrxn       typetrxnrec;
		vdebittrxn        typetrxnrec;
		vloanno           NUMBER;
		vsum              NUMBER;
	
		PROCEDURE getnewtransactions
		(
			paccountno IN typeaccountno
		   ,plastdocno IN NUMBER
		   ,oanewtrxns OUT NOCOPY typetrxnarray
		) IS
			cmethodname CONSTANT typemethodname := appendnewtransactions.cmethodname ||
												   '.GetNewTransactions';
		BEGIN
			t.enter(cmethodname, paccountno);
		
			SELECT /*+ ORDERED USE_NL(aaa a e p v) */
			 aaa.branch
			,scontractno
			,paccountno
			,NULL
			,NULL
			,aaa.groupid
			,NULL
			,least(trunc(aaa.valuedate), trunc(aaa.opdate))
			,trunc(aaa.opdate)
			,aaa.value
			,0
			,0
			,NULL
			,NULL
			,NULL
			,NULL
			,aaa.docno
			,aaa.no
			,coalesce(a.pan, e.pan, p.pan, v.pan) AS pan
			,coalesce(a.mbr, e.mbr, p.mbr, v.mbr) AS mbr
			,aaa.entcode
			,NULL
			,aaa.grouptype
			,coalesce(a.trancode, e.code, p.trancode, v.trancode) AS trancode
			,coalesce(a.enttype, e.enttype, p.enttype, v.enttype) AS enttype
			,aaa.parentdocno
			,NULL
			,aaa.childdocno
			,NULL
			,NULL
			,NULL
			,NULL
			,NULL
			,NULL
			,NULL
			,NULL BULK COLLECT
			INTO   oanewtrxns
			FROM   (SELECT /*+ ORDERED USE_NL(aa c d) INDEX (c ICENTRYGRPLIST_ENTCODE) */
					 aa.branch
					,aa.docno
					,aa.no
					,aa.opdate
					,aa.valuedate
					,aa.entcode
					,aa.value
					,nvl(d.cashadvance, ctrxngrp_other) grouptype
					,nvl(c.groupid, 0) groupid
					,aa.parentdocno
					,aa.childdocno
					,aa.debitaccount
					FROM   (SELECT /*+ ORDERED USE_NL(a b) INDEX(a IENTRY_DEBITACCOUNT) INDEX (b IDOCUMENTS_DOCNO) */
							 a.branch
							,a.docno
							,a.no
							,b.opdate       opdate
							,a.valuedate
							,a.debitentcode entcode
							,-a.value       VALUE
							,b.parentdocno
							,b.childdocno
							,a.debitaccount
							FROM   tentry a
							JOIN   tdocument b
							ON     (b.branch = a.branch)
							AND    (b.docno = a.docno)
							WHERE  a.branch = cbranch
							AND    a.debitaccount = paccountno
							AND    a.docno > plastdocno
							AND    a.value > 0
							AND    b.newdocno IS NULL
							UNION ALL
							SELECT /*+ ORDERED USE_NL(a b) INDEX(a IENTRY_CREDITACCOUNT) INDEX (b IDOCUMENTS_DOCNO) */
							 a.branch
							,a.docno
							,a.no
							,b.opdate       opdate
							,a.valuedate
							,a.debitentcode entcode
							,a.value        VALUE
							,b.parentdocno
							,b.childdocno
							,a.debitaccount
							FROM   tentry a
							JOIN   tdocument b
							ON     (b.branch = a.branch)
							AND    (b.docno = a.docno)
							WHERE  a.branch = cbranch
							AND    a.creditaccount = paccountno
							AND    a.docno > plastdocno
							AND    a.value > 0
							AND    b.newdocno IS NULL) aa
					LEFT   JOIN tcontractentrygrouplist c
					ON     (c.branch = aa.branch)
					AND    (c.entcode = aa.entcode)
					LEFT   JOIN tcontractentrygroup d
					ON     (d.branch = c.branch)
					AND    (d.groupid = c.groupid)) aaa
			LEFT   JOIN tatmext a
			ON     (a.branch = aaa.branch)
			AND    (a.docno = aaa.docno)
			LEFT   JOIN texcommon e
			ON     (e.branch = aaa.branch)
			AND    (e.docno = aaa.docno)
			LEFT   JOIN tposcheque p
			ON     (p.branch = aaa.branch)
			AND    (p.docno = aaa.docno)
			LEFT   JOIN tvoiceslip v
			ON     (v.branch = aaa.branch)
			AND    (v.docno = aaa.docno)
			ORDER  BY opdate
					 ,docno
					 ,no;
		
			t.leave(cmethodname, oanewtrxns.count);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END getnewtransactions;
	
		PROCEDURE autotransfertoinstallment
		(
			painstallmentcontracts IN contractlink.typecontractarray
		   ,panewtrxns             IN OUT NOCOPY typetrxnarray
		) IS
			cmethodname CONSTANT typemethodname := appendnewtransactions.cmethodname ||
												   '.AutoTransferToInstallment';
			vinstaccount contracttools.taccountrecord;
		BEGIN
			t.enter(cmethodname, painstallmentcontracts.count);
		
			FOR i IN 1 .. painstallmentcontracts.count
			LOOP
				autocreateinstallment(painstallmentcontracts(i).cno, panewtrxns);
			END LOOP;
		
			FOR i IN 1 .. panewtrxns.count
			LOOP
			
				IF panewtrxns(i).instcontractno IS NOT NULL
				THEN
				
					IF contracttools.notequal(vinstaccount.accountno, panewtrxns(i).instaccountno)
					THEN
						contracttools.loadcontractaccountbyaccno(panewtrxns(i).instaccountno
																,vinstaccount
																,c_doexception);
					END IF;
				
					startnewinstallment(pcurno
									   ,panewtrxns(i).instcontractno
									   ,cim_auto
									   ,panewtrxns(i).loanno
									   ,panewtrxns(i).insttotalsum
									   ,panewtrxns(i).docno
									   ,panewtrxns(i).entryno
									   ,panewtrxns(i).recno);
				
					processinstallmenttrxns(pcurno
										   ,panewtrxns(i).instcontractno
										   ,panewtrxns(i).loanno
										   ,vinstaccount
										   ,panewtrxns(i).insttotalsum
										   ,panewtrxns
										   ,(nvl(sactparamccy(pcurno) (cctp_instonfeecalc), 0) = 1)
										   ,FALSE);
				
				END IF;
			
			END LOOP;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END autotransfertoinstallment;
	
		PROCEDURE manualtransfertoinstallment
		(
			painstallmentcontracts IN contractlink.typecontractarray
		   ,poatrxnstotransfer     IN OUT NOCOPY typetrxnarray
		) IS
			cmethodname CONSTANT typemethodname := appendnewtransactions.cmethodname ||
												   '.ManualTransferToInstallment';
			coperdate   CONSTANT DATE := seance.getoperdate;
		
			vinstaccount      contracttools.taccountrecord;
			vcurrcontractno   typecontractno;
			vchargecommission BOOLEAN;
		
			CURSOR manualloans(painstallmentcontracts IN contractlink.typecontractarray) IS
				SELECT instcontractno
					  ,loanno
					  ,SUM(amount) AS insttotalsum
				FROM   tcontracttrxninstallment
				WHERE  branch = cbranch
				AND    contractno = scontractno
				AND    accountno = sdepaccount(pcurno).accountno
				AND    instcontractno IN (SELECT cno FROM TABLE(painstallmentcontracts))
				AND    packno = 0
				AND    createtype = cim_manual
				AND    processed = 0
				GROUP  BY instcontractno
						 ,loanno
				ORDER  BY instcontractno;
		
		BEGIN
			t.enter(cmethodname, painstallmentcontracts.count);
		
			FOR i IN manualloans(painstallmentcontracts)
			LOOP
			
				IF contracttools.notequal(vcurrcontractno, i.instcontractno)
				THEN
				
					contracttools.loadcontractaccountbyaccno(getinstallmentaccount(i.instcontractno)
															,vinstaccount
															,c_doexception);
				
					vchargecommission := nvl(sactparamccy(pcurno) (cctp_instonfeecalc), 0) = 1;
				
					vcurrcontractno := i.instcontractno;
				
				END IF;
			
				processinstallmenttrxns(pcurno
									   ,i.instcontractno
									   ,i.loanno
									   ,vinstaccount
									   ,i.insttotalsum
									   ,poatrxnstotransfer
									   ,vchargecommission
									   ,FALSE);
			
			END LOOP;
		
			FORALL i IN 1 .. poatrxnstotransfer.count
				UPDATE tcontracttrxninstallment
				SET    packno        = spackno
					  ,processed     = 1
					  ,processeddate = coperdate
				WHERE  branch = poatrxnstotransfer(i).branch
				AND    contractno = poatrxnstotransfer(i).contractno
				AND    accountno = poatrxnstotransfer(i).accountno
				AND    docno = poatrxnstotransfer(i).docno
				AND    entryno = poatrxnstotransfer(i).entryno;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END manualtransfertoinstallment;
	
		PROCEDURE interesttransfertoinstallment(pcurno IN NUMBER) IS
			cmethodname CONSTANT typemethodname := appendnewtransactions.cmethodname ||
												   '.InterestTransferToInstallment';
		
			vinstallmentcontract apitypes.typecontractrecord;
			vinstallmentaccount  contracttools.taccountrecord;
			vatrxnstotransfer    typetrxnarray;
			vloanno              NUMBER;
			vfromdate            DATE;
			vtodate              DATE;
		
			CURSOR documents2installment
			(
				pfromdate IN DATE
			   ,ptodate   IN DATE
			) IS
				SELECT docno
					  ,SUM(amount) - SUM(paidamount) AS amount
				FROM   tcontracttrxnlist l
				JOIN   treferenceentry re
				ON     re.branch = l.branch
				AND    l.debitentcode = re.code
				WHERE  l.branch = cbranch
				AND    l.accountno = sdepaccount(pcurno).accountno
				AND    l.trantype = ctrxntype_debit
				AND    l.paidfull = 0
				AND    l.postdate BETWEEN nvl(pfromdate, postdate) AND nvl(ptodate, postdate)
				AND    re.ident LIKE 'CHARGE_INTEREST_GROUP_%'
				GROUP  BY docno
				ORDER  BY docno;
		
		BEGIN
			t.enter(cmethodname, pcurno);
		
			IF (sactparamccy(pcurno) (cctp_inttoinston) = 1)
			   AND (sacparamccy(pcurno) (cp_inttoinston) = 1)
			THEN
			
				vfromdate := to_date(sactparamccy(pcurno) (cctp_inttoinstfrom)
									,contractparams.cparam_date_format);
				vtodate   := to_date(sactparamccy(pcurno) (cctp_inttoinstto)
									,contractparams.cparam_date_format);
			
				FOR i IN documents2installment(vfromdate, vtodate)
				LOOP
				
					IF vinstallmentcontract.no IS NULL
					THEN
						getinstallmentcontract(pcurno
											  ,sactparamccy(pcurno) (cctp_inttoinstct)
											  ,TRUE
											  ,vinstallmentcontract
											  ,vinstallmentaccount);
					END IF;
				
					vloanno := createloanforamount(vinstallmentcontract.no, i.amount);
				
					SELECT l.*
						  ,NULL
						  ,NULL
						  ,NULL
						  ,NULL
						  ,NULL
						  ,NULL
						  ,NULL
						  ,NULL
						  ,NULL
						  ,NULL
						  ,NULL
						  ,NULL
						  ,NULL
						  ,NULL BULK COLLECT
					INTO   vatrxnstotransfer
					FROM   tcontracttrxnlist l
					JOIN   treferenceentry re
					ON     re.branch = l.branch
					AND    l.debitentcode = re.code
					WHERE  l.branch = cbranch
					AND    l.accountno = sdepaccount(pcurno).accountno
					AND    l.trantype = ctrxntype_debit
					AND    l.paidfull = 0
					AND    l.postdate BETWEEN nvl(vfromdate, postdate) AND nvl(vtodate, postdate)
					AND    l.docno = i.docno
					AND    re.ident LIKE 'CHARGE_INTEREST_GROUP_%'
					ORDER  BY docno
							 ,entryno;
				
					FOR j IN 1 .. vatrxnstotransfer.count
					LOOP
						startnewinstallment(pcurno
										   ,vinstallmentcontract.no
										   ,cim_auto
										   ,vloanno
										   ,i.amount
										   ,vatrxnstotransfer      (j).docno
										   ,vatrxnstotransfer      (j).entryno
										   ,vatrxnstotransfer      (j).recno);
					END LOOP;
				
					processinstallmenttrxns(pcurno
										   ,vinstallmentcontract.no
										   ,vloanno
										   ,vinstallmentaccount
										   ,i.amount
										   ,vatrxnstotransfer
										   ,nvl(sactparamccy(pcurno) (cctp_instonfeecalc), 0) = 1
										   ,TRUE);
				
				END LOOP;
			
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END interesttransfertoinstallment;
	
	BEGIN
		t.enter(cmethodname, pcurno);
	
		getnewtransactions(sdepaccount(pcurno).accountno
						  ,sacparamccy(pcurno) (cp_lastdocno)
						  ,vanewtrxns);
	
		FOR i IN 1 .. vanewtrxns.count
		LOOP
			buildtransaction(pcurno, vanewtrxns(i), NOT pmigrationmode);
			savetrxntolist(pcurno, vanewtrxns(i), NOT pmigrationmode);
		END LOOP;
	
		IF (pmovetoinstallment OR susereversalent)
		   AND (contractlink.getlinkno(scontractno
									  ,contractlink.cmain
									  ,valinkedcontracts
									  ,cinstlinkname
									  ,sdepaccount(pcurno).currencyno) > 0)
		THEN
		
			SELECT l.*
				  ,NULL
				  ,NULL
				  ,NULL
				  ,NULL
				  ,NULL
				  ,NULL
				  ,NULL
				  ,NULL
				  ,NULL
				  ,NULL
				  ,NULL
				  ,NULL
				  ,i.loanno
				  ,NULL BULK COLLECT
			INTO   vatrxnstotransfer
			FROM   tcontracttrxninstallment i
			JOIN   tcontracttrxnlist l
			ON     l.branch = i.branch
			AND    l.contractno = i.contractno
			AND    l.accountno = i.accountno
			AND    l.docno = i.docno
			AND    l.entryno = i.entryno
			WHERE  i.branch = cbranch
			AND    i.contractno = scontractno
			AND    i.accountno = sdepaccount(pcurno).accountno
			AND    i.instcontractno IN (SELECT cno FROM TABLE(valinkedcontracts))
			AND    i.packno = 0
			AND    i.createtype = cim_manual
			AND    i.processed = 0
			ORDER  BY l.packno
					 ,l.recno;
		
		END IF;
	
		IF susereversalent
		THEN
		
			FOR i IN 1 .. vanewtrxns.count
			LOOP
			
				IF vanewtrxns(i).parentdocno IS NOT NULL
				THEN
				
					vloanno := getinstallmentloanno(vanewtrxns(i).parentdocno
												   ,vanewtrxns(i).parententryno);
				
					IF vloanno > 0
					THEN
					
						vsum := reverseinstallment(pcurno, vloanno, vanewtrxns(i).amount);
					
						IF vsum > 0
						THEN
						
							vdebittrxn := addtrxnfromentry(pcurno
														  ,sdepaccount(pcurno).accountno
														  ,-vsum
														  ,'REV_REPAYMENT');
						
							dorepayment(pcurno, vdebittrxn, vanewtrxns(i));
						
						END IF;
					
					ELSE
					
						IF vanewtrxns(i).trantype IN (ctrxntype_debit, ctrxntype_creditrev)
						THEN
						
							vcredittrxn := gettrxn(sdepaccount(pcurno).accountno
												  ,vanewtrxns (i).parentdocno
												  ,vanewtrxns (i).parententryno);
							vdebittrxn  := vanewtrxns(i);
						
						ELSE
						
							vdebittrxn  := gettrxn(sdepaccount(pcurno).accountno
												  ,vanewtrxns (i).parentdocno
												  ,vanewtrxns (i).parententryno);
							vcredittrxn := vanewtrxns(i);
						
							FOR j IN 1 .. vatrxnstotransfer.count
							LOOP
								IF (vatrxnstotransfer(j).packno = vdebittrxn.packno)
								   AND (vatrxnstotransfer(j).recno = vdebittrxn.recno)
								THEN
									error.raiseerror('Entry ' || vdebittrxn.docno || '/' ||
													 vdebittrxn.entryno ||
													 ' was reversed and cannot be transferred to installment (tranche ' || vatrxnstotransfer(j)
													 .loanno || ')!');
								END IF;
							END LOOP;
						
						END IF;
					
						dorepayment(pcurno, vdebittrxn, vcredittrxn);
					
					END IF;
				
				END IF;
			
			END LOOP;
		
		END IF;
	
		IF pmovetoinstallment
		THEN
		
			autotransfertoinstallment(valinkedcontracts, vanewtrxns);
		
			manualtransfertoinstallment(valinkedcontracts, vatrxnstotransfer);
		
			interesttransfertoinstallment(pcurno);
		
		END IF;
	
		dotransactionsrepayment(pcurno, pmigrationmode);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END appendnewtransactions;

	FUNCTION getpaymentamount
	(
		paccountno      IN VARCHAR
	   ,pstdate         IN DATE
	   ,pdate           IN DATE
	   ,preverseenddate IN DATE
	) RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetPaymentAmount (internal)';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		TYPE typerepaymrow IS RECORD(
			 amount   NUMBER
			,postdate DATE);
		TYPE typerepaymarray IS TABLE OF typerepaymrow INDEX BY PLS_INTEGER;
		vpaid    NUMBER;
		vapaid   typerepaymarray;
		vreverse NUMBER;
		vdelta   NUMBER;
	BEGIN
		s.say(cmethodname || '  pStDate = ' || htools.d2s(pstdate) || ', pDate = ' ||
			  htools.d2s(pdate));
		SELECT amount
			  ,postdate BULK COLLECT
		INTO   vapaid
		FROM   (SELECT a.amount
					  ,a.postdate
					  ,a.recno
				FROM   tcontracttrxnlist a
				WHERE  a.branch = cbranch
				AND    a.accountno = paccountno
				AND    a.trantype = ctrxntype_repayment
				AND    a.postdate BETWEEN pstdate + 1 AND pdate
				UNION ALL
				SELECT -a.amount
					  ,a.postdate
					  ,a.recno
				FROM   tcontracttrxnlist a
				WHERE  a.branch = cbranch
				AND    a.accountno = paccountno
				AND    a.trantype = ctrxntype_creditrev
				AND    a.postdate BETWEEN pstdate + 1 AND pdate)
		ORDER  BY postdate
				 ,recno;
		vpaid := 0;
		s.say(cmethodname || ' vaPaid.count=' || vapaid.count, 1);
		IF vapaid.count > 0
		THEN
			FOR i IN REVERSE 1 .. vapaid.count
			LOOP
				s.say(cmethodname || ' -> i=' || i || ' vaPaid(i)=' || vapaid(i).amount, 1);
				IF vapaid(i).amount < 0
					AND i > 1
				THEN
					vreverse := vapaid(i).amount;
					FOR j IN REVERSE 1 .. i - 1
					LOOP
						s.say(cmethodname || ' -> j=' || j || ' vaPaid(j)=' || vapaid(j).amount, 1);
						IF vapaid(j).amount > 0
							AND (vapaid(i).postdate > preverseenddate AND vapaid(j)
								 .postdate > preverseenddate OR vapaid(i)
								 .postdate <= preverseenddate AND vapaid(j)
								 .postdate <= preverseenddate)
						THEN
							s.say(cmethodname || ' -> vaPaid(' || j || ')=' || vapaid(j).amount, 1);
							vdelta := least(vapaid(j).amount, abs(vreverse));
							s.say(cmethodname || ' -> vDelta=' || vdelta, 1);
							s.say(cmethodname || ' -> vReverse=' || vreverse, 1);
							vapaid(j).amount := vapaid(j).amount - vdelta;
							vreverse := vreverse + vdelta;
						END IF;
						s.say(cmethodname || ' 2 -> vaPaid(' || j || ')=' || vapaid(j).amount, 1);
						s.say(cmethodname || ' 2 -> vReverse=' || vreverse, 1);
						IF vreverse = 0
						THEN
							EXIT;
						END IF;
					END LOOP;
				END IF;
			END LOOP;
			FOR i IN 1 .. vapaid.count
			LOOP
				s.say(cmethodname || ' -> vaPaid(' || i || ')=' || vapaid(i).amount, 1);
				IF vapaid(i).amount > 0
				THEN
					vpaid := vpaid + vapaid(i).amount;
					s.say(cmethodname || ' -> vPaid=' || vpaid, 1);
				END IF;
			END LOOP;
		END IF;
	
		s.say(cmethodname || ' return ' || vpaid, 1);
		RETURN vpaid;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION getpaymentamount
	(
		paccountno IN VARCHAR
	   ,pstartdate IN DATE
	   ,penddate   IN DATE
	) RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetPaymentAmount';
	BEGIN
		s.say(cmethodname || ': pAccountNo=' || paccountno || ' pStartDate=' ||
			  htools.d2s(pstartdate) || ' pEndDate=' || htools.d2s(penddate));
		RETURN getpaymentamount(paccountno, pstartdate, penddate, penddate);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getpaymentamount;

	FUNCTION calcminpaymentgroup
	(
		pcurno IN NUMBER
	   ,plog   IN OUT NOCOPY VARCHAR
	) RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.CalcMinPaymentGroup';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		varrbase  types.arrnum;
		varrvalue types.arrnum;
		vtotal    NUMBER := 0;
		vvalue    NUMBER;
	BEGIN
		s.say(cmethodname || ' -> Start', 1);
	
		vvalue := sdepaccount(pcurno).overdraft * smpgroupsettings(smpprofileid(pcurno))(custom_contractprofiles.cclgroup)
				  .prcvalue / 100;
		addlog(plog
			  , 'GroupVal=CL@' || sdepaccount(pcurno).overdraft || '@' ||
				smpgroupsettings(smpprofileid(pcurno))(custom_contractprofiles.cclgroup)
			   .prcvalue || '@' || vvalue);
		vtotal := vtotal + vvalue;
		s.say(cmethodname || ' -> CL %=' || vvalue, 1);
		FOR i IN (SELECT groupid
						,amount
						,paidamount
						,postdate
				  FROM   tcontracttrxnlist
				  WHERE  branch = cbranch
				  AND    accountno = sdepaccount(pcurno).accountno
				  AND    trantype IN (ctrxntype_debit, ctrxntype_creditrev)
				  AND    paidfull = 0)
		LOOP
			s.say(cmethodname || ' -> Tran Unpaid=' || (i.amount - i.paidamount) || ' GroupId=' ||
				  i.groupid || ' PostDate=' || i.postdate
				 ,1);
			IF NOT (smpgroupsettings(smpprofileid(pcurno))(i.groupid)
				.curonly AND i.postdate <= nvl(getcurrentcycle().statementdate, i.postdate - 1))
			THEN
				vvalue := round((i.amount - i.paidamount) * smpgroupsettings(smpprofileid(pcurno))(i.groupid)
								.prcvalue / 100
							   ,sprecision(pcurno));
				IF NOT varrvalue.exists(i.groupid)
				THEN
					varrvalue(i.groupid) := 0;
					varrbase(i.groupid) := 0;
				END IF;
				varrvalue(i.groupid) := varrvalue(i.groupid) + vvalue;
				varrbase(i.groupid) := varrbase(i.groupid) + (i.amount - i.paidamount);
				vtotal := vtotal + vvalue;
			END IF;
		END LOOP;
		IF varrvalue.count > 0
		THEN
			vvalue := varrvalue.first;
		
			FOR i IN 1 .. varrvalue.count
			LOOP
			
				s.say(cmethodname || ' -> Group=' || vvalue || ' MP Amount=' || varrvalue(vvalue)
					 ,1);
				addlog(plog
					  , 'GroupVal=' || vvalue || '@' || varrbase(vvalue) || '@' ||
						smpgroupsettings(smpprofileid(pcurno))(vvalue)
					   .prcvalue || '@' || varrvalue(vvalue));
				IF vvalue <> varrvalue.last
				THEN
					vvalue := varrvalue.next(vvalue);
				END IF;
			END LOOP;
		END IF;
		s.say(cmethodname || ' -> End', 1);
		RETURN vtotal;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION getallowedoverlimit(pcurno IN NUMBER) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetAllowedOverLimit';
		vacclimitsetup     typeobjectlimitsettings;
		vactualcreditlimit NUMBER;
		vresult            NUMBER := 0;
	BEGIN
		t.enter(cmethodname, pcurno);
	
		t.var('sBlockParam.State.UseAllowedOL', sblockparam.state.useallowedol);
	
		IF sblockparam.state.useallowedol = 1
		THEN
		
			t.var('saCParamCcy(pCurNo)(cP_AccOLType)', sacparamccy(pcurno) (cp_accoltype));
		
			IF sacparamccy(pcurno) (cp_accoltype) <> clmtnotdefined
			THEN
			
				vacclimitsetup := getobjectlimitssetup(scontractno, pcurno);
			
				vactualcreditlimit := service.iif(vacclimitsetup.tempcredlimit.active
												 ,vacclimitsetup.tempcredlimit.amount
												 ,vacclimitsetup.credlimit.amount);
				t.var('Actual credit limit', vactualcreditlimit);
			
				vresult := contracttypelimits.calclimitvalue(sacparamccy(pcurno) (cp_accoltype)
															,vactualcreditlimit
															,sacparamccy(pcurno) (cp_accolprc)
															,sacparamccy(pcurno) (cp_accolamount)
															,sprecision(pcurno));
			
			END IF;
		
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getallowedoverlimit;

	FUNCTION overlimitcalc(pcurno IN NUMBER) RETURN typelimitrecord IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.OverLimitCalc';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		CURSOR curtrxnlist IS
			SELECT *
			FROM   tcontracttrxnlist
			WHERE  branch = cbranch
			AND    accountno = sdepaccount(pcurno).accountno
			AND    trantype <= 2
			AND    paidfull = 0
			ORDER  BY trandate;
	
		vothcur    NUMBER;
		vunpaid1   NUMBER := 0;
		vunpaid2   NUMBER := 0;
		vuselimit1 NUMBER := 0;
		vuselimit2 NUMBER := 0;
		vovramnt1  NUMBER := 0;
		vovramnt2  NUMBER := 0;
	
		vovrlimit1 NUMBER := 0;
		vovrlimit2 NUMBER := 0;
		vovrlimit3 NUMBER := 0;
		vcalclimit typelimitrecord;
	BEGIN
		s.say(cmethodname || ' -> ' || pcurno, 1);
		vothcur := service.iif(pcurno = 1, 2, 1);
	
		FOR i IN curtrxnlist
		LOOP
		
			vunpaid1 := i.amount - i.paidamount;
		
			vovramnt1 := greatest(least(vuselimit1, sdepaccount(pcurno).overdraft) + vunpaid1 - sdepaccount(pcurno)
								  .overdraft
								 ,0);
		
			vovrlimit1 := vovrlimit1 + vovramnt1;
		
			vunpaid2 := vovramnt1 * i.rate;
		
			vovramnt2 := greatest(least(vuselimit2, snotusedlimit(vothcur)) + vunpaid2 -
								  snotusedlimit(vothcur)
								 ,0);
		
			vovrlimit2 := vovrlimit2 + vunpaid2;
			IF vunpaid2 <> 0
			THEN
			
				vovrlimit3 := vovrlimit3 + (vovramnt1 * vovramnt2 / vunpaid2);
			END IF;
		
			s.say(cmethodname || ' -> UnPaid=' || vunpaid1 || '(' || vunpaid2 || ') UseLimit=' ||
				  vuselimit1 || '(' || vuselimit2 || ') OvrAmnt=' || vovramnt1 || '(' || vovramnt2 ||
				  ') OvrLimit=' || vovrlimit1 || '(' || vovrlimit2 || ')(' || vovrlimit3 || ')'
				 ,1);
		
			vuselimit1 := vuselimit1 + vunpaid1;
			vuselimit2 := vuselimit2 + vunpaid2;
		END LOOP;
		vovrlimit1 := round(vovrlimit1, sprecision(pcurno));
		s.say(cmethodname || ' vOthCur=' || vothcur, 1);
		s.say(cmethodname || ' sPrecision(vOthCur)=' || sprecision(vothcur), 1);
		vovrlimit2 := round(vovrlimit2, sprecision(vothcur));
		vovrlimit3 := round(vovrlimit3, sprecision(pcurno));
	
		snotusedlimit(vothcur) := greatest(snotusedlimit(vothcur) - vovrlimit2, 0);
	
		vcalclimit.cur1overlimit        := vovrlimit1;
		vcalclimit.cur2overlimit        := vovrlimit2;
		vcalclimit.cur1aggroverlimit    := vovrlimit3;
		vcalclimit.cur1allowedoverlimit := getallowedoverlimit(pcurno);
	
		s.say(cmethodname || ' -> Cur1OverLimit=' || vcalclimit.cur1overlimit || ' Cur2OverLimit=' ||
			  vcalclimit.cur2overlimit || ' Cur1AggrOverLimit=' || vcalclimit.cur1aggroverlimit ||
			  ' Cur1AllowedOverLimit=' || vcalclimit.cur1allowedoverlimit
			 ,1);
	
		s.say(cmethodname || ' -> End', 1);
		RETURN vcalclimit;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END overlimitcalc;

	FUNCTION calcallowedoverdue
	(
		pmp        IN NUMBER
	   ,pparams    IN types.arrstr1000
	   ,pprecision IN NUMBER
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CalcAllowedOverDue';
		vresult NUMBER;
	BEGIN
		t.enter(cmethodname);
	
		vresult := round(pmp * pparams(custom_contractprofiles.cp_ovdallowprc) / 100, pprecision);
		s.say(cmethodname || ': SD MP Amnt=' || pmp || ' Allow Amnt=' ||
			  pparams(custom_contractprofiles.cp_ovdallowamt) || ' Allow Prc=' ||
			  pparams(custom_contractprofiles.cp_ovdallowprc) || ' Prc Amount=' || vresult ||
			  ' CalcType=' || pparams(custom_contractprofiles.cp_ovdallow));
	
		CASE pparams(custom_contractprofiles.cp_ovdallow)
			WHEN 2 THEN
				vresult := vresult + pparams(custom_contractprofiles.cp_ovdallowamt);
			WHEN 3 THEN
				vresult := greatest(vresult, pparams(custom_contractprofiles.cp_ovdallowamt));
			ELSE
				vresult := least(vresult, pparams(custom_contractprofiles.cp_ovdallowamt));
		END CASE;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END calcallowedoverdue;

	PROCEDURE rollbacktrxnlist(ppackno IN NUMBER) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.RollBackTrxnList';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vcontractno      typecontractno;
		vmanualinstcount NUMBER;
	BEGIN
		s.say(cmethodname || ' -> PackNo=' || ppackno, 1);
		BEGIN
			SELECT contractno
			INTO   vcontractno
			FROM   tcontracttrxnlist
			WHERE  branch = cbranch
			AND    packno = ppackno
			AND    rownum < 2;
		EXCEPTION
			WHEN OTHERS THEN
				NULL;
		END;
		IF vcontractno IS NOT NULL
		   AND contracttypeschema.scontractrow.no <> vcontractno
		THEN
			error.raiseerror('Can''t rollback PackNo ' || ppackno ||
							 ' as it belongs to another contract (' || vcontractno ||
							 ') while the rollback operation is executed for the contract ' ||
							 contracttypeschema.scontractrow.no);
		END IF;
		INSERT INTO tcontracttrxnrollbacklog
		VALUES
			(cbranch
			,contracttypeschema.scontractrow.no
			,ppackno
			,SYSDATE
			,seance.getoperdate
			,clerk.getclerkid);
	
		UPDATE tcontracttrxninstallment
		SET    paid = 0
		WHERE  loanno IN (SELECT loanno
						  FROM   tcontractrpmntinstallment
						  WHERE  branch = cbranch
						  AND    contractno = contracttypeschema.scontractrow.no
						  AND    packno = ppackno
						  AND    paid = 1);
	
		SELECT COUNT(*)
		INTO   vmanualinstcount
		FROM   tcontracttrxninstallment ct
		JOIN   tcontracttrxnlist c
		ON     c.branch = ct.branch
		AND    c.contractno = ct.contractno
		AND    c.recno = ct.recno
		AND    c.packno = ppackno
		WHERE  ct.branch = cbranch
		AND    ct.contractno = contracttypeschema.scontractrow.no
		AND    ct.packno = 0
		AND    ct.createtype = cim_manual;
		IF vmanualinstcount > 0
		THEN
			error.raiseerror('Operation impossible because ' || vmanualinstcount ||
							 ' transaction(s) has been already transferred to installments!');
		END IF;
	
		FOR i IN (SELECT *
				  FROM   tcontractrpmntinstallment
				  WHERE  branch = cbranch
				  AND    contractno = contracttypeschema.scontractrow.no
				  AND    packno = ppackno)
		LOOP
			undoloanrepayment(i.loanno, ppackno);
		END LOOP;
		DELETE FROM tcontractrpmntinstallment
		WHERE  branch = cbranch
		AND    contractno = contracttypeschema.scontractrow.no
		AND    packno = ppackno;
	
		FOR i IN (SELECT *
				  FROM   tcontracttrxninstallment
				  WHERE  branch = cbranch
				  AND    contractno = contracttypeschema.scontractrow.no
				  AND    packno = ppackno
				  AND    createtype = 2)
		LOOP
			undocommitloan(i.loanno);
		END LOOP;
		UPDATE tcontracttrxninstallment
		SET    processed     = 0
			  ,processeddate = NULL
			  ,packno        = 0
		WHERE  branch = cbranch
		AND    contractno = contracttypeschema.scontractrow.no
		AND    packno = ppackno
		AND    createtype = 2;
	
		FOR i IN (SELECT *
				  FROM   tcontracttrxninstallment
				  WHERE  branch = cbranch
				  AND    contractno = contracttypeschema.scontractrow.no
				  AND    packno = ppackno
				  AND    createtype = 1)
		LOOP
			undocommitloan(i.loanno);
		END LOOP;
		UPDATE tcontracttrxninstallment
		SET    recno         = 0
			  ,docno         = 0
			  ,entryno       = 0
			  ,processed     = 0
			  ,processeddate = NULL
			  ,packno        = 0
		WHERE  branch = cbranch
		AND    contractno = contracttypeschema.scontractrow.no
		AND    packno = ppackno
		AND    createtype = 1;
	
		FOR i IN (SELECT loanno
				  FROM   tcontracttrxninstallment
				  WHERE  branch = cbranch
				  AND    contractno = contracttypeschema.scontractrow.no
				  AND    packno = ppackno
				  AND    createtype = 3
				  GROUP  BY loanno)
		LOOP
			undocommitloan(i.loanno);
			rollbackloan(i.loanno);
		END LOOP;
		DELETE FROM tcontracttrxninstallment
		WHERE  branch = cbranch
		AND    contractno = contracttypeschema.scontractrow.no
		AND    packno = ppackno
		AND    createtype = 3;
	
		FOR i IN (SELECT *
				  FROM   tcontracttrxnrollback
				  WHERE  branch = cbranch
				  AND    packno = ppackno)
		LOOP
		
			FOR itrxn IN (SELECT contractno
								,packno
								,recno
								,amount
								,paidamount
								,paidfull
								,intenddate
								,paidfulldate
								,offbalance
						  FROM   tcontracttrxnlist
						  WHERE  branch = cbranch
						  AND    recno = i.recno)
			LOOP
				IF itrxn.contractno <> contracttypeschema.scontractrow.no
				THEN
					error.raiseerror('Can''t rollback PackNo ' || ppackno || ': ' || itrxn.packno || '-' ||
									 itrxn.recno || ' belongs to another contract (' ||
									 itrxn.contractno || ')');
				END IF;
			
			END LOOP;
			s.say(cmethodname || ' -> RecNo =' || i.recno, 1);
			UPDATE tcontracttrxnlist
			SET    amount       = i.amount
				  ,paidamount   = i.paidamount
				  ,paidfull     = i.paidfull
				  ,intenddate   = i.intenddate
				  ,paidfulldate = i.paidfulldate
				  ,offbalance   = i.offbalance
			WHERE  branch = cbranch
			AND    recno = i.recno
			AND    contractno = contracttypeschema.scontractrow.no;
		END LOOP;
	
		DELETE FROM tcontracttrxnrollback
		WHERE  branch = cbranch
		AND    packno = ppackno;
		DELETE FROM tcontracttrxnrepayment
		WHERE  branch = cbranch
		AND    packno = ppackno;
		DELETE FROM tcontracttrxnlist
		WHERE  branch = cbranch
		AND    packno = ppackno;
		DELETE FROM tcontractinterestprofilelog
		WHERE  branch = cbranch
		AND    packno = ppackno;
		DELETE FROM tcontractinterestsetuplog
		WHERE  branch = cbranch
		AND    packno = ppackno;
		DELETE FROM tcontractinterestlog
		WHERE  branch = cbranch
		AND    packno = ppackno;
		DELETE FROM tcontractminpaymentlog
		WHERE  branch = cbranch
		AND    packno = ppackno;
		DELETE FROM tcontractstatehistory
		WHERE  branch = cbranch
		AND    packno = ppackno;
		DELETE FROM tinterestandmp_profhistory
		WHERE  contractno = scontractno
		AND    packno = ppackno
		AND    branch = cbranch;
	
		s.say(cmethodname || ' -> End', 1);
	EXCEPTION
		WHEN OTHERS THEN
			s.say(cmethodname || ': excep = ' || SQLERRM, 1);
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION getamnthistory
	(
		pcurno   IN NUMBER
	   ,penddate DATE := NULL
	) RETURN typeamnthistoryarray IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetAmntHistory';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		venddate DATE := coalesce(penddate, seance.getoperdate);
		vcount   NUMBER := 0;
		varr     typeamnthistoryarray;
		vamount  NUMBER := 0;
	BEGIN
		s.say(cmethodname || '   --<< BEGIN', 1);
		s.say(cmethodname || '    - INPUT PARAMETERS: pCurNo = ' || pcurno || ', pEndDate = ' ||
			  htools.d2s(venddate));
		IF sovdaccount(pcurno).accountno IS NULL
		THEN
			RETURN varr;
		END IF;
		FOR i IN (SELECT opdate
						,SUM(VALUE) VALUE
				  FROM   (SELECT b.opdate
								,a.value VALUE
						  FROM   tentry    a
								,tdocument b
						  WHERE  a.branch = cbranch
						  AND    a.debitaccount = sovdaccount(pcurno).accountno
						  AND    b.branch = a.branch
						  AND    b.docno = a.docno
						  AND    b.newdocno IS NULL
						  AND    b.opdate <= venddate
						  UNION ALL
						  SELECT b.opdate
								,-a.value
						  FROM   tentry    a
								,tdocument b
						  WHERE  a.branch = cbranch
						  AND    a.creditaccount = sovdaccount(pcurno).accountno
						  AND    b.branch = a.branch
						  AND    b.docno = a.docno
						  AND    b.newdocno IS NULL
						  AND    b.opdate <= venddate)
				  GROUP  BY opdate
				  ORDER  BY opdate)
		LOOP
			vamount := vamount + i.value;
			vcount := vcount + 1;
			varr(vcount).operdate := i.opdate;
			varr(vcount).amount := i.value;
			varr(vcount).balance := vamount;
		END LOOP;
		s.say(cmethodname || '   -->> END', 1);
		RETURN varr;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION shieldpromoperiodactive(pcurno IN NUMBER) RETURN BOOLEAN IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.ShieldPromoPeriodActive';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vcycles NUMBER;
	BEGIN
		SELECT COUNT(*)
		INTO   vcycles
		FROM   tcontractstcycle
		WHERE  branch = cbranch
		AND    contractno = scontractno
		AND    statementdate IS NOT NULL;
		t.var('vCycles', vcycles);
		t.var('saCTParamCcy(pCurNo)(cCTP_ProShieldCycles)'
			 ,sactparamccy(pcurno) (cctp_proshieldcycles));
		RETURN vcycles < sactparamccy(pcurno)(cctp_proshieldcycles) OR referencecalendar.isselectedday(seance.getoperdate
																									  ,sactparamccy(pcurno)
																									   (cctp_proshieldclnd));
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION setstate RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SetState';
		vlastregistredstate contractstatereference.typeregisteredstaterow;
		vdialog             NUMBER;
	BEGIN
		t.enter(cmethodname);
	
		vdialog := dialog.new('Set Contract State', 0, 0, 60, 1, pextid => cmethodname);
		dialog.bevel(vdialog, 1, 1, 59, 3, dialog.bevel_frame);
	
		vlastregistredstate := contractstatereference.getlastregisteredstate(scontractno);
	
		dialog.hiddenchar(vdialog, 'LastStateCode', vlastregistredstate.statecode);
	
		dialog.inputchar(vdialog
						,'Descr'
						,17
						,3
						,40
						,'Description of contract state reason'
						,100
						,'Description:');
		dialog.setenable(vdialog, 'Descr', FALSE);
	
		IF vlastregistredstate.stickmode = contractstatereference.cdontstick
		THEN
			contractstatereference.dropbox_state_create(vdialog
													   ,'State'
													   ,17
													   ,2
													   ,20
													   ,'State:'
													   ,'Contract State'
													   ,'AUTO~Auto determination'
													   ,dialog.cmconfirm
													   ,contractstatereference.c_stateauto);
		
		ELSIF vlastregistredstate.stickmode = contractstatereference.cstickmanual
		THEN
			contractstatereference.dropbox_state_create(vdialog
													   ,'State'
													   ,17
													   ,2
													   ,20
													   ,'State:'
													   ,'Contract State'
													   ,'AUTO~Auto determination'
													   ,dialog.cmconfirm
													   ,vlastregistredstate.statecode);
			dialog.putchar(vdialog, 'Descr', vlastregistredstate.comments);
		
		ELSIF vlastregistredstate.stickmode IN
			  (contractstatereference.cstick
			  ,contractstatereference.cstickbelow
			  ,contractstatereference.cstickabove)
		THEN
			contractstatereference.dropbox_state_create(vdialog
													   ,'State'
													   ,17
													   ,2
													   ,20
													   ,'State:'
													   ,'Contract State'
													   ,'AUTO~Auto determination'
													   ,dialog.cmconfirm
													   ,vlastregistredstate.statecode);
			dialog.putchar(vdialog
						  ,'Descr'
						  ,coalesce(vlastregistredstate.comments
								   ,getdescrforstickmode(vlastregistredstate.stickmode)));
		ELSE
			error.raiseerror('Error: unknown stick mode <' || vlastregistredstate.stickmode || '>!');
		END IF;
	
		dialog.button(vdialog, 'Ok', 18, 5, 12, 'OK', dialog.cmok, 0, 'Save and exit dialog');
		dialog.button(vdialog
					 ,'Cancel'
					 ,32
					 ,5
					 ,12
					 ,'Cancel'
					 ,dialog.cmcancel
					 ,0
					 ,'Cancel data saving and exit dialog');
		dialog.setdefault(vdialog, 'Ok');
	
		dialog.setdialogvalid(vdialog, cpackagename || '.SetStateProc');
	
		t.leave(cmethodname);
		RETURN vdialog;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END setstate;

	PROCEDURE setstateproc
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR
	   ,pcmd      IN NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SetStateProc';
	
		vlastregistredstatecode contractstatereference.typestatecode;
		vnewstate               contractstatereference.typestaterow;
		vchangedintwo           BOOLEAN := FALSE;
		vconnected              BOOLEAN := FALSE;
	
	BEGIN
		t.enter(cmethodname);
	
		IF pwhat = dialog.wtdialogvalid
		THEN
		
			IF pcmd = dialog.cmconfirm
			THEN
				IF upper(pitemname) = upper('State')
				THEN
					dialog.setenable(pdialog, 'Descr', TRUE);
					dialog.putchar(pdialog, 'Descr', NULL);
				END IF;
				dialog.goitem(pdialog, 'Descr');
			
			ELSIF pcmd = dialog.cmok
			THEN
				BEGIN
					SAVEPOINT spbegin;
				
					vlastregistredstatecode := dialog.getchar(pdialog, 'LastStateCode');
					vnewstate.statecode     := contractstatereference.dropbox_state_getvalue(pdialog
																							,'State');
				
					IF vnewstate.statecode <> vlastregistredstatecode
					THEN
					
						IF vnewstate.statecode = contractstatereference.c_stateauto
						THEN
							contractstatereference.resetcontractstate(scontractno, getpackno);
						ELSE
							contractstatereference.setcontractstate(scontractno
																   ,getpackno
																   ,vnewstate.statecode
																   ,dialog.getchar(pdialog
																				  ,'Descr'));
						END IF;
					
						a4mlog.cleanparamlist;
						a4mlog.addparamrec('CntrSt', vlastregistredstatecode, vnewstate.statecode);
						a4mlog.addparamrec('Desc', dialog.getchar(pdialog, 'Descr'));
						a4mlog.logobject(object.gettype(contract.object_name)
										,scontractno
										,'Change contract state from <' || vlastregistredstatecode ||
										 '> to <' || vnewstate.statecode || '>'
										,a4mlog.act_change
										,a4mlog.putparamlist
										,powner => getclientid);
					
						IF htools.ask('Attention'
									 ,'Do you want to change cards/accounts status at once?')
						THEN
						
							getcontractdata;
						
							IF vnewstate.statecode = contractstatereference.c_stateauto
							THEN
								vnewstate := sblockparam.state;
							
							ELSE
								vnewstate := contractstatereference.getstate(vnewstate.statecode);
							END IF;
						
							BEGIN
							
								remoteonline.logon;
								vconnected := TRUE;
								remoteonline.begintransaction;
							
								setcardsstatusintwo(vnewstate.cardsign
												   ,vnewstate.cardblock
												   ,csetcontrstate);
							
								vchangedintwo := TRUE;
							EXCEPTION
								WHEN OTHERS THEN
								
									IF vconnected
									THEN
										remoteonline.rollbacktransaction;
									END IF;
									htools.showmessage('Warning'
													  ,'Error when changing card(s) status in TWO:~~' ||
													   error.gettext ||
													   '.~~Changes will be saved locally!');
									error.clear;
							END;
						
							setcardsstatusintwcms(vnewstate.cardsign
												 ,vnewstate.cardblock
												 ,vnewstate.reissueban
												 ,csetcontrstate
												 ,c_norollback
												 ,TRUE
												 ,vchangedintwo);
						
							setaccountsstatus(csetcontrstate, vchangedintwo);
						
							IF vchangedintwo
							THEN
								remoteonline.committransaction;
								remoteonline.logoff;
							END IF;
						
						END IF;
					
					END IF;
				
					COMMIT;
				
				EXCEPTION
					WHEN OTHERS THEN
						ROLLBACK TO spbegin;
						IF vconnected
						THEN
							remoteonline.rollbacktransaction;
							remoteonline.logoff;
						END IF;
						err.seterror(SQLCODE, cmethodname);
						service.sayerr(pdialog, 'Error');
						dialog.goitem(pdialog, 'Cancel');
						RETURN;
				END;
			END IF;
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			error.show(pwhere => cmethodname);
			dialog.goitem(pdialog, 'Cancel');
	END setstateproc;

	FUNCTION dlg_contractparams_create RETURN NUMBER IS
		cmethodname  CONSTANT typemethodname := cpackagename || '.Dlg_ContractParams_Create';
		chandlername CONSTANT typemethodname := cpackagename || '.Dlg_ContractParams_Handler';
	
		cdialogwidth  CONSTANT NUMBER := 70;
		cdialogheight CONSTANT NUMBER := 14;
	
		vdialog  NUMBER;
		vpage    NUMBER;
		vsubpage NUMBER;
	
		PROCEDURE disableifnoright
		(
			pdialog    IN NUMBER
		   ,pright     IN VARCHAR2
		   ,paitemlist IN tblchar100
		) IS
			cmethodname CONSTANT typemethodname := dlg_contractparams_create.cmethodname ||
												   '.DisableIfNoRight';
		BEGIN
			t.enter(cmethodname, pright);
		
			IF NOT checkright('SET_PARAM', pright)
			THEN
				dlg_tools.setenabled(pdialog, paitemlist, FALSE);
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END disableifnoright;
	
	BEGIN
		t.enter(cmethodname);
	
		vdialog := dialog.new(contractdlg.makedialogcaption(scontractno
														   ,contractdlg.c_cap_conparams)
							 ,0
							 ,0
							 ,cdialogwidth
							 ,cdialogwidth
							 ,pextid => cmethodname);
	
		dialog.pagelist(vdialog, 'PAGER', 1, 1, cdialogwidth - 1, cdialogheight - 4);
	
		vpage := dialog.page(vdialog, 'PAGER', 'Common');
	
		dialog.bevel(vpage
					,1
					,1
					,68
					,3
					,dialog.bevel_frame
					,pcaption => 'Card and account statuses at delinquency');
		dlg_tools.makedroplist(vpage
							  ,'CardLock'
							  ,27
							  ,2
							  ,35
							  ,35
							  ,'Change card status:'
							  ,'Change card status at delinquency');
		dialog.listaddrecord(vpage, 'CardLock', ccrdstatset_default || '~By default');
		dialog.listaddrecord(vpage, 'CardLock', ccrdstatset_never || '~Never');
		dialog.listaddrecord(vpage
							,'CardLock'
							,ccrdstatset_open || '~Always, if current status is "Opened"');
		dialog.listaddrecord(vpage
							,'CardLock'
							,ccrdstatset_auto || '~If it was not changed manually');
		contractparams.loaddialogfieldnumber(vpage
											,'CardLock'
											,contractparams.ccontract
											,pdefaultvalue => 0);
	
		dlg_tools.makedroplist(vpage
							  ,'ChangeAccStatus'
							  ,27
							  ,3
							  ,35
							  ,35
							  ,'Change account status:'
							  ,'Change account status at delinquency');
		dialog.listaddrecord(vpage, 'ChangeAccStatus', '0~By default');
		dialog.listaddrecord(vpage, 'ChangeAccStatus', '1~Never');
		dialog.listaddrecord(vpage, 'ChangeAccStatus', '2~Always');
		dialog.listaddrecord(vpage, 'ChangeAccStatus', '3~If it was not changed manually');
		dialog.listaddrecord(vpage, 'ChangeAccStatus', '4~Always, if current status is "Opened"');
		contractparams.loaddialogfieldnumber(vpage
											,'ChangeAccStatus'
											,contractparams.ccontract
											,pdefaultvalue => 0);
	
		dialog.bevel(vpage
					,1
					,4
					,68
					,2
					,dialog.bevel_frame
					,pcaption => 'No-overdue period calculation settings');
		dlg_tools.makedroplist(vpage
							  ,'ZeroMPCycles'
							  ,27
							  ,5
							  ,20
							  ,20
							  ,'Cycles with MP = 0:'
							  ,'Cycles with MP = 0');
		dialog.listaddrecord(vpage, 'ZeroMPCycles', '0~By default');
		dialog.listaddrecord(vpage, 'ZeroMPCycles', cmp0_count || '~Count');
		dialog.listaddrecord(vpage, 'ZeroMPCycles', cmp0_dontcount || '~Don''t count');
		dialog.listaddrecord(vpage, 'ZeroMPCycles', cmp0_restart || '~Restart counting');
		contractparams.loaddialogfieldnumber(vpage
											,'ZeroMPCycles'
											,contractparams.ccontract
											,pdefaultvalue => 0);
	
		IF nvl(contractparams.loadnumber(contractparams.ccontracttype
										,scontracttype
										,'PeriodType'
										,FALSE)
			  ,1) IN (contractdelinqsetup.covdday, contractdelinqsetup.covdfirstday)
		THEN
			dialog.setenable(vdialog, 'ZeroMPCycles', FALSE);
		ELSE
			dialog.setenable(vdialog, 'ZeroMPCycles', TRUE);
		END IF;
	
		dialog.bevel(vpage, 1, 6, 68, 2, dialog.bevel_frame, pcaption => 'Billing cycle calendar');
		contractcalendar.makeitem(vpage
								 ,'BillCycleCalendar'
								 ,27
								 ,7
								 ,35
								 ,'Name:'
								 ,'Billing cycles calendar');
		contractcalendar.fillitem(vpage, 'BillCycleCalendar');
		contractparams.loaddialogfieldnumber(vpage
											,'BillCycleCalendar'
											,contractparams.ccontract
											,pdefaultvalue => -1);
	
		vpage := dialog.page(vdialog, 'PAGER', 'Delinquency States');
	
		dialog.bevel(vpage
					,1
					,1
					,68
					,3
					,dialog.bevel_frame
					,pcaption => 'Overdue period calculation mode');
		dlg_tools.makedroplist(vpage
							  ,'OvdPeriodCalcMode'
							  ,27
							  ,2
							  ,26
							  ,26
							  ,'Calculation mode:'
							  ,'Overdue period calculation mode');
		dialog.listaddrecord(vpage, 'OvdPeriodCalcMode', '~By default', dialog.cmconfirm);
		dialog.listaddrecord(vpage
							,'OvdPeriodCalcMode'
							,covdcalc_normal || '~Standard'
							,dialog.cmconfirm);
		dialog.listaddrecord(vpage
							,'OvdPeriodCalcMode'
							,covdcalc_frzwithrep || '~Freeze (consider payments)'
							,dialog.cmconfirm);
		dialog.listaddrecord(vpage
							,'OvdPeriodCalcMode'
							,covdcalc_frzworep || '~Freeze (ignore payments)'
							,dialog.cmconfirm);
		contractparams.loaddialogfieldnumber(vpage
											,'OvdPeriodCalcMode'
											,contractparams.ccontract
											,pdefaultvalue => NULL);
	
		dlg_tools.element_datefromto_create(vpage
										   ,'OvdPeriodDates'
										   ,27
										   ,3
										   ,'Period from:'
										   ,'Calculation mode period start date'
										   ,'To:'
										   ,'Calculation mode period end date'
										   ,TRUE);
		dlg_tools.element_datefromto_load(vpage
										 ,'OvdPeriodDates'
										 ,contractparams.ccontract
										 ,scontractno
										 ,'OvdPeriodDateFrom'
										 ,'OvdPeriodDateTo');
	
		dlg_contractparams_handler(dialog.wt_dialogvalid
								  ,vpage
								  ,upper('OvdPeriodCalcMode')
								  ,dialog.cmconfirm);
	
		vpage := dialog.page(vdialog, 'PAGER', 'Profiles');
	
		dialog.pagelist(vpage, 'PROF_PAGER', 1, 1, 67, 8);
	
		FOR i IN 1 .. 2
		LOOP
		
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			THEN
			
				vsubpage := dialog.page(vpage
									   ,'PROF_PAGER'
									   ,referencecurrency.getabbreviation(sdepaccount(i).currencyno) ||
										' Currency');
			
				dialog.bevel(vsubpage
							,1
							,1
							,66
							,6
							,dialog.bevel_frame
							,pcaption => 'Interest and Fees Calculation Profile');
				custom_contractprofiles.makeitem(vsubpage
												,'Profile' || slabel(i)
												,12
												,2
												,50
												,'Profile:'
												,'Interest and Fees Calculation Profile');
				custom_contractprofiles.fillitem(vsubpage
												,'Profile' || slabel(i)
												,sdepaccount(i).currencyno
												,'Default Profile');
				contractparams.loaddialogfieldnumber(vsubpage
													,'Profile' || slabel(i)
													,contractparams.ccontract
													,NULL
													,NULL
													,0);
			
				dialog.inputcheck(vsubpage
								 ,'FixProfile' || slabel(i)
								 ,12
								 ,3
								 ,50
								 ,'Use this profile regardless of delinquency state'
								 ,'Use this profile regardless of delinquency state');
				contractparams.loaddialogbool(vsubpage
											 ,'FixProfile' || slabel(i)
											 ,contractparams.ccontract);
			
				dialog.bevel(vsubpage
							,1
							,4
							,66
							,1
							,dialog.bevel_top
							,pcaption => 'Minimum Payment Calculation Profile');
				custom_contractprofiles.makeitem(vsubpage
												,'MPProfile' || slabel(i)
												,12
												,5
												,50
												,'Profile:'
												,'Minimum Payment Calculation Profile');
				custom_contractprofiles.fillitem(vsubpage
												,'MPProfile' || slabel(i)
												,NULL
												,'Default Profile'
												,TRUE);
				contractparams.loaddialogfieldnumber(vsubpage
													,'MPProfile' || slabel(i)
													,contractparams.ccontract
													,NULL
													,NULL
													,0);
			
				dialog.inputcheck(vsubpage
								 ,'FixMPProfile' || slabel(i)
								 ,12
								 ,6
								 ,50
								 ,'Use this profile regardless of delinquency state'
								 ,'Use this profile regardless of delinquency state');
				contractparams.loaddialogbool(vsubpage
											 ,'FixMPProfile' || slabel(i)
											 ,contractparams.ccontract);
			
			END IF;
		
		END LOOP;
	
		vpage := dialog.page(vdialog, 'PAGER', 'DAF Generation');
	
		dialog.bevel(vpage, 1, 1, 68, 2, dialog.bevel_frame);
		dlg_tools.makedroplist(vpage
							  ,'GenDAF'
							  ,38
							  ,2
							  ,20
							  ,20
							  ,'Generate DAF by this contract:'
							  ,'Generate DAF by this contract');
		dialog.listaddrecord(vpage, 'GenDAF', cdaf_default || '~By default');
		dialog.listaddrecord(vpage, 'GenDAF', cdaf_generate || '~Generate');
		dialog.listaddrecord(vpage, 'GenDAF', cdaf_skip || '~Don''t generate');
		contractparams.loaddialogfieldnumber(vpage
											,'GenDAF'
											,contractparams.ccontract
											,pdefaultvalue => cdaf_default);
	
		dialog.pagelist(vpage, 'DAF_PAGER', 1, 4, 67, 5);
		FOR i IN 1 .. 2
		LOOP
			IF ifcurrencyisusedintype(i, scontracttype, contracttypeschema.scontractrow.no)
			THEN
				vsubpage := dialog.page(vpage
									   ,'DAF_PAGER'
									   ,referencecurrency.getabbreviation(sdepaccount(i).currencyno) ||
										' Currency');
				dialog.bevel(vsubpage
							,1
							,1
							,66
							,3
							,dialog.bevel_frame
							,pcaption => 'Direct Debit Amount Calculation');
				contractddreference.makeitem(vsubpage
											,'DAFProfile' || slabel(i)
											,12
											,2
											,40
											,'Profile:');
				contractddreference.loaddialogvalue(vsubpage
												   ,'DAFProfile' || slabel(i)
												   ,contractddreference.ccontract
												   ,scontractno);
			END IF;
		END LOOP;
	
		vpage := dialog.page(vdialog, 'PAGER', 'Limits');
	
		dialog.pagelist(vpage, 'LIMITPAGER', 1, 1, 67, 8);
	
		FOR i IN 1 .. 2
		LOOP
		
			IF ifcurrencyisusedintype(i, scontracttype, contracttypeschema.scontractrow.no)
			THEN
			
				vsubpage := dialog.page(vpage
									   ,'LIMITPAGER'
									   ,referencecurrency.getabbreviation(sdepaccount(i).currencyno) ||
										' Currency');
			
				dialog.bevel(vsubpage
							,1
							,1
							,66
							,6
							,dialog.bevel_frame
							,pcaption => 'Allowed Overlimit');
				dlg_tools.makedroplist(vsubpage
									  ,'AccOverLimitType' || slabel(i)
									  ,22
									  ,2
									  ,40
									  ,40
									  ,'Calculate as:'
									  ,'Account Allowed Overlimit calculation type');
				dialog.listaddrecord(vsubpage
									,'AccOverLimitType' || slabel(i)
									,'-1~By default'
									,dialog.cmconfirm);
				dialog.listaddrecord(vsubpage
									,'AccOverLimitType' || slabel(i)
									,clmtnotdefined || '~Not used'
									,dialog.cmconfirm);
				dialog.listaddrecord(vsubpage
									,'AccOverLimitType' || slabel(i)
									,clmttotal || '~Total of'
									,dialog.cmconfirm);
				dialog.listaddrecord(vsubpage
									,'AccOverLimitType' || slabel(i)
									,clmtmax || '~Maximum between'
									,dialog.cmconfirm);
				dialog.listaddrecord(vsubpage
									,'AccOverLimitType' || slabel(i)
									,clmtmin || '~Minimum between'
									,dialog.cmconfirm);
			
				dialog.inputmoney(vsubpage
								 ,'AccOverLimitAmount' || slabel(i)
								 ,22
								 ,3
								 ,'Account Allowed Overlimit flat amount value'
								 ,'Flat amount:');
				dialog.inputmoney(vsubpage
								 ,'AccOverLimitPrc' || slabel(i)
								 ,22
								 ,4
								 ,'Account Allowed Overlimit percentage from Account Credit Limit'
								 ,'Percentage value:');
			
				IF contractparams.loaddialogfieldnumber(vsubpage
													   ,'AccOverLimitType' || slabel(i)
													   ,contractparams.ccontract
													   ,pdefaultvalue => -1) IN
				   (clmttotal, clmtmax, clmtmin)
				THEN
					contractparams.loaddialognumber(vsubpage
												   ,'AccOverLimitAmount' || slabel(i)
												   ,contractparams.ccontract);
					contractparams.loaddialognumber(vsubpage
												   ,'AccOverLimitPrc' || slabel(i)
												   ,contractparams.ccontract);
				END IF;
			
				dlg_contractparams_handler(dialog.wt_dialogvalid
										  ,vdialog
										  ,upper('AccOverLimitType') || slabel(i)
										  ,dialog.cmconfirm);
			
			END IF;
		
		END LOOP;
	
		IF slinkschemasinst.count > 0
		THEN
		
			vpage := dialog.page(vdialog, 'PAGER', 'Installment');
		
			dialog.pagelist(vpage, 'INSTPAGER', 1, 1, 67, 4);
		
			FOR i IN 1 .. 2
			LOOP
			
				IF ifcurrencyisusedintype(i, scontracttype, scontractno)
				THEN
				
					vsubpage := dialog.page(vpage
										   ,'INSTPAGER'
										   ,referencecurrency.getabbreviation(sdepaccount(i)
																			  .currencyno) ||
											' Currency');
				
					dialog.bevel(vsubpage
								,1
								,1
								,66
								,2
								,dialog.bevel_frame
								,pcaption => 'Interest Transfer to Installment');
				
					dlg_tools.makedroplist(vsubpage
										  ,'IntToInstOn' || slabel(i)
										  ,26
										  ,2
										  ,12
										  ,12
										  ,'Do interest transfer:'
										  ,'Whether it is necessary to transfer charged interest to installment');
					dialog.listaddrecord(vsubpage, 'IntToInstOn' || slabel(i), '0~No');
					dialog.listaddrecord(vsubpage, 'IntToInstOn' || slabel(i), '1~Yes');
					contractparams.loaddialogfieldnumber(vsubpage
														,'IntToInstOn' || slabel(i)
														,contractparams.ccontract
														,scontractno
														,pdefaultvalue => 0);
					dialog.setenable(vsubpage
									,'IntToInstOn' || slabel(i)
									,sactparamccy(i) (cctp_inttoinston) = 1);
				
				END IF;
			
			END LOOP;
		
		END IF;
	
		vpage := dialog.page(vdialog, 'PAGER', 'Credit Shield');
	
		dialog.bevel(vpage, 1, 1, 68, 2, dialog.bevel_frame);
		dlg_tools.makedroplist(vpage
							  ,'UseShield'
							  ,30
							  ,2
							  ,20
							  ,20
							  ,'Premium charging:'
							  ,'Credit Shield Premium charging');
		dialog.listaddrecord(vpage, 'UseShield', ccs_default || '~By default');
		dialog.listaddrecord(vpage, 'UseShield', ccs_charge || '~Charge');
		dialog.listaddrecord(vpage, 'UseShield', ccs_nocharge || '~Don''t charge');
		contractparams.loaddialogfieldnumber(vpage
											,'UseShield'
											,contractparams.ccontract
											,pdefaultvalue => ccs_default);
	
		vpage := dialog.page(vdialog, 'PAGER', 'Customers Accounts');
	
		dialog.pagelist(vpage, 'ACCPAGER', 1, 1, 67, 8);
	
		FOR i IN 1 .. 2
		LOOP
		
			IF ifcurrencyisusedintype(i, scontracttype, contracttypeschema.scontractrow.no)
			THEN
			
				vsubpage := dialog.page(vpage
									   ,'ACCPAGER'
									   ,referencecurrency.getabbreviation(sdepaccount(i).currencyno) ||
										' Currency');
			
				dialog.bevel(vsubpage
							,1
							,1
							,66
							,6
							,dialog.bevel_frame
							,pcaption => 'Account for positive balance transfer');
				dialog.inputchar(vsubpage
								,'Account' || slabel(i)
								,29
								,2
								,20
								,'Account for positive balance transfer'
								,NULL
								,'Account number:');
				dialog.setitemcommand(vdialog, 'Account' || slabel(i), ccmd_findaccount);
				contractparams.loaddialogchar(vsubpage
											 ,'Account' || slabel(i)
											 ,contractparams.ccontract);
			
				dialog.bevel(vsubpage
							,1
							,3
							,66
							,1
							,dialog.bevel_top
							,pcaption => 'Autorepayment account');
				dialog.inputchar(vsubpage
								,'PayAccount' || slabel(i)
								,29
								,4
								,20
								,'Account for automatic repayment'
								,NULL
								,'Account number:');
				dialog.setitemcommand(vdialog, 'PayAccount' || slabel(i), ccmd_findaccount);
				contractparams.loaddialogchar(vsubpage
											 ,'PayAccount' || slabel(i)
											 ,contractparams.ccontract);
			
				dlg_tools.makedroplist(vsubpage
									  ,'PayAmount' || slabel(i)
									  ,29
									  ,5
									  ,20
									  ,20
									  ,'Repayment amount:'
									  ,'Amount for automatic repayment');
				dialog.listaddrecord(vsubpage
									,'PayAmount' || slabel(i)
									,cautopay_mponod || '~Minimum payment');
				dialog.listaddrecord(vsubpage
									,'PayAmount' || slabel(i)
									,cautopay_debtonsd || '~SD indebtedness');
				dialog.listaddrecord(vsubpage
									,'PayAmount' || slabel(i)
									,cautopay_debtonod || '~Current indebtedness');
				contractparams.loaddialogfieldnumber(vsubpage
													,'PayAmount' || slabel(i)
													,contractparams.ccontract
													,pdefaultvalue => 1);
			
			END IF;
		
		END LOOP;
	
		disableifnoright(vdialog
						,'COMMON_PG'
						,tblchar100('CardLock', 'ChangeAccStatus', 'ZeroMPCycles'));
		disableifnoright(vdialog, 'BIL_C_CLDR', tblchar100('BillCycleCalendar'));
		disableifnoright(vdialog, 'DELINQENCY_PG', tblchar100('OvdPeriodCalcMode'));
		IF NOT checkright('SET_PARAM', 'DELINQENCY_PG')
		THEN
			dlg_tools.element_datefromto_enable(vdialog, 'OvdPeriodDates', FALSE, FALSE);
		END IF;
		disableifnoright(vdialog, 'DAF_GEN_PG', tblchar100('GenDAF'));
		disableifnoright(vdialog, 'CRD_SHIELD_PG', tblchar100('UseShield'));
	
		FOR i IN 1 .. 2
		LOOP
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			THEN
				disableifnoright(vdialog
								,'PROFILES_PG'
								,tblchar100('Profile' || slabel(i)
										   ,'FixProfile' || slabel(i)
										   ,'MPProfile' || slabel(i)
										   ,'FixMPProfile' || slabel(i)));
				disableifnoright(vdialog, 'DAF_GEN_PG', tblchar100('DAFProfile' || slabel(i)));
				disableifnoright(vdialog
								,'LIMITS_PG'
								,tblchar100('AccOverLimitType' || slabel(i)
										   ,'AccOverLimitAmount' || slabel(i)
										   ,'AccOverLimitPrc' || slabel(i)));
				IF slinkschemasinst.count > 0
				THEN
					disableifnoright(vdialog
									,'INSTALLMENT_PG'
									,tblchar100('IntToInstOn' || slabel(i)));
				END IF;
				disableifnoright(vdialog
								,'CUSTMRS_ACC_PG'
								,tblchar100('Account' || slabel(i)
										   ,'PayAccount' || slabel(i)
										   ,'PayAmount' || slabel(i)));
			END IF;
		END LOOP;
	
		dlg_tools.startbuttondrawing(cdialogwidth, 2);
		dlg_tools.drawbutton(vdialog
							,cbtn_ok
							,'OK'
							,'Save changes and exit dialog'
							,cdialogheight - 2
							,dialog.cmok
							,pdefault => TRUE);
		dlg_tools.drawbutton(vdialog
							,cbtn_cancel
							,'Cancel'
							,'Cancel changes and exit dialog'
							,cdialogheight - 2
							,dialog.cmcancel);
	
		dialog.setdialogvalid(vdialog, chandlername);
	
		t.leave(cmethodname);
		RETURN vdialog;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_contractparams_create;

	FUNCTION dlg_contractparams_getdata
	(
		pdialog          IN NUMBER
	   ,ocalendarchanged OUT BOOLEAN
	   ,oneedchangesd    OUT BOOLEAN
	   ,onewsd           OUT DATE
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_ContractParams_GetData';
		vwarning    VARCHAR2(200);
		vcalendarid NUMBER;
	BEGIN
		t.enter(cmethodname, pdialog);
	
		vcalendarid := dialog.getcurrentrecordnumber(pdialog, 'BillCycleCalendar', 'ItemId');
	
		ocalendarchanged := vcalendarid <> sacparam(cp_billcyclecalendar);
	
		IF ocalendarchanged
		THEN
		
			onewsd := getnewnextsd(CASE vcalendarid
									   WHEN -1 THEN
										sactparam(cctp_calendarid)
									   ELSE
										vcalendarid
								   END);
		
			oneedchangesd := needchangenextsd(onewsd, csetcontractparams, vwarning);
		
		END IF;
	
		IF vwarning IS NOT NULL
		THEN
			dlg_tools.rundlg_yesno(pdialog, 'Warning', vwarning, 'BillCycleCalendar');
		END IF;
	
		t.leave(cmethodname, htools.b2s(TRUE));
		RETURN TRUE;
	EXCEPTION
		WHEN dlg_tools.validate_error THEN
			t.leave(cmethodname, htools.b2s(FALSE));
			RETURN FALSE;
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_contractparams_getdata;

	PROCEDURE dlg_contractparams_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER := 0
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_ContractParams_Handler';
		vcalendarchanged BOOLEAN;
		vneedchangesd    BOOLEAN;
		vitemend         VARCHAR2(50);
		vvalue           NUMBER;
		vnewsd           DATE;
	BEGIN
		t.enter(cmethodname
			   ,'Dialog = ' || pdialog || ', What = ' || pwhat || ', ItemName = ' || pitemname ||
				', Cmd = ' || pcmd);
	
		IF pwhat = dialog.wt_dialogvalid
		THEN
		
			CASE pcmd
			
				WHEN ccmd_findaccount THEN
					dlg_tools.rundlg_selectaccount(pdialog
												  ,pitemname
												  ,finderselectaccount.acpersone
												  ,contracttypeschema.scontractrow.idclient);
				
				WHEN dialog.cmconfirm THEN
				
					IF pitemname = upper('OvdPeriodCalcMode')
					THEN
					
						vvalue := nvl(dlg_tools.getdroplistvalue(pdialog
																,pitemname
																,pprohibitnull => FALSE)
									 ,covdcalc_normal);
					
						dlg_tools.element_datefromto_enable(pdialog
														   ,'OvdPeriodDates'
														   ,vvalue IN
															(covdcalc_frzwithrep
														   ,covdcalc_frzworep)
														   ,vvalue IN
															(covdcalc_frzwithrep
														   ,covdcalc_frzworep));
					
					ELSE
					
						vitemend := REPLACE(pitemname, upper('AccOverLimitType'));
					
						IF vitemend IN ('DOM', 'INT')
						THEN
							dlg_tools.setvisible(pdialog
												,tblchar100('ACCOVERLIMITAMOUNT' || vitemend
														   ,'ACCOVERLIMITPRC' || vitemend)
												,dlg_tools.getdroplistvalue(pdialog, pitemname) IN
												 (clmttotal, clmtmax, clmtmin));
						END IF;
					
					END IF;
				
					dialog.cancelclose(pdialog);
				
				WHEN dialog.cmok THEN
				
					IF dlg_contractparams_getdata(pdialog, vcalendarchanged, vneedchangesd, vnewsd)
					THEN
					
						BEGIN
						
							SAVEPOINT sp_saveparams;
						
							contractparams.savedialogfieldnumber(pdialog
																,'CardLock'
																,contractparams.ccontract
																,pwhitelog                => TRUE
																,pparamname               => 'Change card status at violation');
							contractparams.savedialogfieldnumber(pdialog
																,'ChangeAccStatus'
																,contractparams.ccontract
																,pwhitelog                => TRUE
																,pparamname               => 'Change account status at violation');
							contractparams.savedialogfieldnumber(pdialog
																,'ZeroMPCycles'
																,contractparams.ccontract
																,pwhitelog                => TRUE
																,pparamname               => 'Change no-overdue period calculation settings');
							contractparams.savedialogfieldnumber(pdialog
																,'UseShield'
																,contractparams.ccontract
																,pwhitelog                => TRUE
																,pparamname               => 'Credit Shield premium charging');
							contractparams.savedialogfieldnumber(pdialog
																,'GenDAF'
																,contractparams.ccontract
																,pwhitelog                => TRUE
																,pparamname               => 'Generate DAF for contract');
						
							IF vcalendarchanged
							THEN
							
								contractparams.savedialogfieldnumber(pdialog
																	,'BillCycleCalendar'
																	,contractparams.ccontract
																	,pwhitelog                => TRUE
																	,pparamname               => 'Calendar for contract');
							
								IF vneedchangesd
								THEN
									updatenextsd(vnewsd, csetcontractparams);
								END IF;
							
							END IF;
						
							CASE
							 contractparams.savedialogfieldnumber(pdialog
																 ,'OvdPeriodCalcMode'
																 ,contractparams.ccontract
																 ,scontractno
																 ,TRUE
																 ,pwhitelog                => TRUE
																 ,pparamname               => 'Overdue period calculation mode')
								WHEN covdcalc_normal THEN
									nullifyparams(tblchar100('OvdPeriodDateFrom'
															,'OvdPeriodDateTo')
												 ,contractparams.ccontract
												 ,scontractno
												 ,NULL
												 ,TRUE);
								WHEN covdcalc_frzwithrep THEN
									dlg_tools.element_datefromto_save(pdialog
																	 ,'OvdPeriodDates'
																	 ,contractparams.ccontract
																	 ,scontractno
																	 ,'OvdPeriodDateFrom'
																	 ,'OvdPeriodDateTo');
								WHEN covdcalc_frzworep THEN
									dlg_tools.element_datefromto_save(pdialog
																	 ,'OvdPeriodDates'
																	 ,contractparams.ccontract
																	 ,scontractno
																	 ,'OvdPeriodDateFrom'
																	 ,'OvdPeriodDateTo');
								
								ELSE
									nullifyparams(tblchar100('OvdPeriodDateFrom'
															,'OvdPeriodDateTo')
												 ,contractparams.ccontract
												 ,scontractno
												 ,NULL
												 ,TRUE);
							END CASE;
						
							FOR i IN 1 .. 2
							LOOP
							
								IF ifcurrencyisusedintype(i
														 ,scontracttype
														 ,contracttypeschema.scontractrow.no)
								THEN
									contractparams.savedialogfieldnumber(pdialog
																		,'Profile' || slabel(i)
																		,contractparams.ccontract
																		,pwhitelog => TRUE
																		,pparamname => 'Interest and Fees Calculation Profile for ' ||
																					   sfulllabel(i));
									contractparams.savedialogbool(pdialog
																 ,'FixProfile' || slabel(i)
																 ,contractparams.ccontract
																 ,pwhitelog => TRUE
																 ,pparamname => 'Use Interest and Fees profile regardless of delinquency state for ' ||
																				sfulllabel(i));
									contractparams.savedialogfieldnumber(pdialog
																		,'MPProfile' || slabel(i)
																		,contractparams.ccontract
																		,pwhitelog => TRUE
																		,pparamname => 'Minimum Payment Calculation Profile for ' ||
																					   sfulllabel(i));
									contractparams.savedialogbool(pdialog
																 ,'FixMPProfile' || slabel(i)
																 ,contractparams.ccontract
																 ,pwhitelog => TRUE
																 ,pparamname => 'Use Minimum Payment profile regardless of delinquency state for ' ||
																				sfulllabel(i));
									contractddreference.savedialogvalue(pdialog
																	   ,'DAFProfile' || slabel(i)
																	   ,contractddreference.ccontract
																	   ,scontractno
																	   ,FALSE
																	   ,'Direct Debit Calculation Profile for ' ||
																		sfulllabel(i));
									IF contractparams.savedialogfieldnumber(pdialog
																		   ,'AccOverLimitType' ||
																			slabel(i)
																		   ,contractparams.ccontract
																		   ,pwhitelog => TRUE
																		   ,pparamname => 'Account Overlimit Type for ' ||
																						  sfulllabel(i)) > 0
									THEN
										contractparams.savedialognumber(pdialog
																	   ,'AccOverLimitAmount' ||
																		slabel(i)
																	   ,contractparams.ccontract
																	   ,pwhitelog => TRUE
																	   ,pparamname => 'Account Overlimit flat amount for ' ||
																					  sfulllabel(i));
										contractparams.savedialognumber(pdialog
																	   ,'AccOverLimitPrc' ||
																		slabel(i)
																	   ,contractparams.ccontract
																	   ,pwhitelog => TRUE
																	   ,pparamname => 'Account Overlimit percentage for ' ||
																					  sfulllabel(i));
									ELSE
										nullifyparams(tblchar100('AccOverLimitAmount'
																,'AccOverLimitPrc')
													 ,contractparams.ccontract
													 ,scontractno
													 ,slabel(i)
													 ,TRUE);
									END IF;
									IF slinkschemasinst.count > 0
									THEN
										contractparams.savedialogfieldnumber(pdialog
																			,'IntToInstOn' ||
																			 slabel(i)
																			,contractparams.ccontract
																			,scontractno
																			,pwhitelog => TRUE
																			,pparamname => 'Interest Transfer to Installment ' ||
																						   sfulllabel(i));
									END IF;
									contractparams.savedialogaccount(pdialog
																	,'Account' || slabel(i)
																	,contractparams.ccontract
																	,pisnull => TRUE
																	,pwhitelog => TRUE
																	,pparamname => 'Account for Positive Balance Transfer for ' ||
																				   sfulllabel(i));
									contractparams.savedialogaccount(pdialog
																	,'PayAccount' || slabel(i)
																	,contractparams.ccontract
																	,pisnull => TRUE
																	,pwhitelog => TRUE
																	,pparamname => 'Account for automatic repayment ' ||
																				   sfulllabel(i));
									contractparams.savedialogfieldnumber(pdialog
																		,'PayAmount' || slabel(i)
																		,contractparams.ccontract
																		,pwhitelog => TRUE
																		,pparamname => 'Automatic repayment amount ' ||
																					   sfulllabel(i));
								END IF;
							
							END LOOP;
						
						EXCEPTION
							WHEN dlg_tools.validate_error THEN
								ROLLBACK TO sp_saveparams;
							WHEN contractparams.accountnotexists THEN
								ROLLBACK TO sp_saveparams;
								htools.showmessage('Error', 'Incorrect account number!');
							WHEN contractparams.valuenotexists THEN
								ROLLBACK TO sp_saveparams;
								htools.showmessage('Error', 'A value is required!');
							WHEN contractparams.incorrectvalue THEN
								ROLLBACK TO sp_saveparams;
								htools.showmessage('Error', 'Incorrect value!');
							WHEN OTHERS THEN
								ROLLBACK TO sp_saveparams;
								RAISE;
						END;
					
					END IF;
				
				ELSE
					NULL;
				
			END CASE;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_contractparams_handler;

	FUNCTION chargeaccumint RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.ChargeAccumInt';
		vdialog NUMBER;
		vy      NUMBER := 1;
	BEGIN
		vdialog := dialog.new('Charge Accumulated Interest', 0, 0, 52, 7, pextid => cmethodname);
		dialog.setdialogpre(vdialog, cpackagename || '.ChargeAccumIntProc');
		dialog.setdialogvalid(vdialog, cpackagename || '.ChargeAccumIntProc');
		FOR i IN 1 .. 2
		LOOP
			IF ifcurrencyisusedintype(i
									 ,contracttypeschema.scontractrow.type
									 ,contracttypeschema.scontractrow.no)
			THEN
				dialog.bevel(vdialog, 1, vy, 51, 3, dialog.bevel_frame, TRUE, sfulllabel(i));
				vy := vy + 1;
				dialog.textlabel(vdialog, 'Lab' || slabel(i), 35, vy, 15, 'Amount to move:');
				vy := vy + 1;
				dialog.inputmoney(vdialog
								 ,'InterestAccum' || slabel(i)
								 ,18
								 ,vy
								 ,'Amount of accumulated interest'
								 ,'Interest (' || getcurrencyabbr(i) || '):');
				dialog.setenable(vdialog, 'InterestAccum' || slabel(i), FALSE);
				dialog.inputmoney(vdialog
								 ,'InterestCharge' || slabel(i)
								 ,35
								 ,vy
								 ,'Amount to move to card account');
				vy := vy + 1;
			END IF;
		END LOOP;
		vy := vy + 1;
	
		dialog.button(vdialog, 'Ok', 13, vy, 12, 'OK', dialog.cmok, 0, 'Save and exit dialog');
		dialog.setdefault(vdialog, 'Ok');
		dialog.button(vdialog
					 ,'Cancel'
					 ,28
					 ,vy
					 ,12
					 ,'Cancel'
					 ,dialog.cmcancel
					 ,0
					 ,'Cancel data saving and exit dialog');
	
		RETURN vdialog;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END chargeaccumint;

	PROCEDURE moveinterest
	(
		pcurno IN NUMBER
	   ,pvalue IN NUMBER
	) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.MoveInterest';
		vvalue NUMBER := pvalue;
	BEGIN
		IF vvalue > 0
		THEN
			vvalue := least(vvalue, abs(sintaccount(pcurno).remain));
			IF vvalue > 0
			THEN
				doentry(pcurno
					   ,sdepaccount(pcurno)
					   ,sintaccount(pcurno)
					   ,sdepaccount(pcurno).currencyno
					   ,vvalue
					   ,'CHARGE_INTEREST_GROUP_0'
					   ,'Crd%_0'
					   ,getfullremark(pcurno, 'TransFullRemark')
					   ,pdotrxn => FALSE);
			END IF;
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END moveinterest;

	PROCEDURE chargeaccumintproc
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR
	   ,pcmd      IN NUMBER
	) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.ChargeAccumIntProc';
		vamount         NUMBER;
		vret            NUMBER;
		vinterestcharge types.arrnum;
	
		FUNCTION checkerror
		(
			pcurnumber    IN NUMBER
		   ,pdebtitem     IN VARCHAR
		   ,ptransferitem IN VARCHAR
		   ,ovalue        OUT NUMBER
		) RETURN BOOLEAN IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.CheckError';
			vvalue NUMBER;
			vret   NUMBER;
		BEGIN
			vvalue := dialog.getnumber(pdialog, ptransferitem || slabel(pcurnumber));
			vret   := dialog.getnumber(pdialog, pdebtitem || slabel(pcurnumber));
			s.say(cmethodname || ' Item=' || pdebtitem || ' vValue=' || vvalue || ' vRet=' || vret
				 ,1);
			IF vvalue IS NULL
			   OR vvalue < 0
			   OR vvalue > vret
			THEN
				dialog.goitem(pdialog, ptransferitem || slabel(pcurnumber));
				dialog.sethothint(pdialog, 'Incorrect value');
				ovalue := vvalue;
				RETURN FALSE;
			END IF;
			ovalue := vvalue;
			RETURN TRUE;
		END;
	
	BEGIN
		CASE pwhat
			WHEN dialog.wtdialogpre THEN
				FOR i IN 1 .. 2
				LOOP
					IF ifcurrencyisusedintype(i
											 ,contracttypeschema.scontractrow.type
											 ,contracttypeschema.scontractrow.no)
					THEN
						vamount := abs(sintaccount(i).remain);
						dialog.putnumber(pdialog, 'InterestAccum' || slabel(i), vamount);
						dialog.putnumber(pdialog, 'InterestCharge' || slabel(i), vamount);
						dialog.setenable(pdialog, 'InterestCharge' || slabel(i), vamount <> 0);
					END IF;
				END LOOP;
			WHEN dialog.wtdialogvalid THEN
				FOR i IN 1 .. 2
				LOOP
					IF ifcurrencyisusedintype(i
											 ,contracttypeschema.scontractrow.type
											 ,contracttypeschema.scontractrow.no)
					THEN
						IF NOT checkerror(i, 'InterestAccum', 'InterestCharge', vinterestcharge(i))
						THEN
							RETURN;
						END IF;
					END IF;
				END LOOP;
			
				startnewdocument;
			
				FOR i IN 1 .. 2
				LOOP
					IF ifcurrencyisusedintype(i
											 ,contracttypeschema.scontractrow.type
											 ,contracttypeschema.scontractrow.no)
					THEN
						moveinterest(i, vinterestcharge(i));
					END IF;
				END LOOP;
				IF sdocno IS NOT NULL
				THEN
					htools.message('Attention', 'Interest is moved to the card account');
				END IF;
			ELSE
				NULL;
		END CASE;
	EXCEPTION
		WHEN OTHERS THEN
			error.show(pwhere => cmethodname);
			dialog.goitem(pdialog, 'Cancel');
	END;

	FUNCTION calcgst
	(
		pcurno      IN NUMBER
	   ,pvalue      IN NUMBER
	   ,pentryident IN typeentryident
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CalcGST';
		vresult NUMBER := 0;
	BEGIN
		t.enter(cmethodname
			   ,'CurNo = ' || pcurno || ', Value = ' || pvalue || ', EntryIdent = ' || pentryident);
	
		IF (sactparamccy(pcurno) (cctp_gst_profileid) IS NOT NULL)
		   AND
		   goodsservicestax.hastaxforentry(sactparamccy(pcurno) (cctp_gst_profileid), pentryident)
		THEN
			vresult := goodsservicestax.calctax(sactparamccy(pcurno) (cctp_gst_profileid)
											   ,pentryident
											   ,pvalue
											   ,sprecision(pcurno));
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END calcgst;

	PROCEDURE chargegst
	(
		pcurno IN NUMBER
	   ,pvalue IN NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ChargeGST';
		vprofile goodsservicestax.typeprofilerecord;
		vaccount contracttools.taccountrecord;
	BEGIN
		t.enter(cmethodname, pvalue);
	
		IF sactparamccy(pcurno) (cctp_gst_profileid) IS NOT NULL
		THEN
		
			vprofile := goodsservicestax.getprofile(sactparamccy(pcurno) (cctp_gst_profileid));
		
			IF (pvalue > 0)
			   OR (vprofile.zeroentry = 1)
			THEN
			
				contracttools.loadcontractaccountbyaccno(vprofile.account, vaccount, c_doexception);
			
				doentry(pcurno
					   ,sdepaccount(pcurno)
					   ,vaccount
					   ,sdepaccount(pcurno).currencyno
					   ,pvalue
					   ,vprofile.entryident
					   ,'GST');
			
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END chargegst;

	PROCEDURE saveovdfeecalclog(poovdfeecalclog IN OUT NOCOPY typeovdfeecalclog) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SaveOvdFeeCalcLog';
	BEGIN
		t.enter(cmethodname);
	
		IF poovdfeecalclog.hasinfo
		THEN
		
			poovdfeecalclog.profilesettings.packno := getpackno;
		
			INSERT INTO toverduefeecalclogmain VALUES poovdfeecalclog.profilesettings;
			INSERT INTO tregpromologcalcsetings VALUES poovdfeecalclog.regularcalcdata;
			INSERT INTO tregpromologcalcsetings VALUES poovdfeecalclog.promocalcdata;
		
			FORALL i IN 1 .. poovdfeecalclog.intcalcdetails.count
				INSERT INTO toverduefeeinterestcalcdetails
				VALUES poovdfeecalclog.intcalcdetails
					(i);
		
			contractrb.setlabel(crl_ovdfeelogsaved);
			contractrb.setnvalue('PackNo', poovdfeecalclog.profilesettings.packno);
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END saveovdfeecalclog;

	PROCEDURE calcovdfee
	(
		pcurno          IN NUMBER
	   ,ofeevalue       OUT NUMBER
	   ,ogst            OUT NUMBER
	   ,poovdfeecalclog IN OUT NOCOPY typeovdfeecalclog
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CalcOvdFee';
		coperdate   CONSTANT DATE := seance.getoperdate;
	
		vneedcalculate  BOOLEAN := TRUE;
		vallowedoverdue NUMBER := 0;
		vprofile        types.arrstr1000;
		vlastovdfeedate DATE;
		vminovdamount   NUMBER;
		vmaxovdamount   NUMBER;
		vovdfeebase     NUMBER;
		vresult         NUMBER := 0;
		vsdamount       NUMBER;
		vfamount        NUMBER;
		vftype          NUMBER;
		vfprc           NUMBER;
	
		PROCEDURE addprofileparam
		(
			poovdfeecalclog IN OUT NOCOPY typeovdfeecalclog
		   ,pparam          IN VARCHAR2
		   ,pvalue          IN VARCHAR2
		) IS
		BEGIN
			poovdfeecalclog.profilesettings.calcinfo := poovdfeecalclog.profilesettings.calcinfo ||
														pparam || '=' || pvalue || ';';
		END addprofileparam;
	
		PROCEDURE addcalcinfo
		(
			pocalcdata IN OUT NOCOPY typeovdfeecalcdata
		   ,pparam     IN VARCHAR2
		   ,pvalue     IN VARCHAR2
		) IS
		BEGIN
			pocalcdata.calcinfo := pocalcdata.calcinfo || pparam || '=' || pvalue || ';';
		END addcalcinfo;
	
		PROCEDURE setlog_profileparams
		(
			pcurno          IN NUMBER
		   ,poovdfeecalclog IN OUT NOCOPY typeovdfeecalclog
		) IS
			cmethodname CONSTANT typemethodname := calcovdfee.cmethodname ||
												   '.SetLog_ProfileParams';
		BEGIN
			t.enter(cmethodname, pcurno);
		
			poovdfeecalclog.profilesettings.overduefeelogid := seqforlogging.nextval;
			poovdfeecalclog.profilesettings.branch          := seance.getbranch;
			poovdfeecalclog.profilesettings.contractno      := scontractno;
			poovdfeecalclog.profilesettings.currencynumber  := pcurno;
			poovdfeecalclog.profilesettings.accountno       := sdepaccount(pcurno).accountno;
			poovdfeecalclog.profilesettings.operdate        := coperdate;
			poovdfeecalclog.profilesettings.profileid       := sprofileid(pcurno);
			poovdfeecalclog.profilesettings.lastupdatedate  := SYSDATE;
		
			addprofileparam(poovdfeecalclog
						   ,'AllowType'
						   ,vprofile(custom_contractprofiles.cp_ovdallow));
			addprofileparam(poovdfeecalclog
						   ,'AllowFlatAmnt'
						   ,vprofile(custom_contractprofiles.cp_ovdallowamt));
			addprofileparam(poovdfeecalclog
						   ,'AllowPrc'
						   ,vprofile(custom_contractprofiles.cp_ovdallowprc));
			addprofileparam(poovdfeecalclog
						   ,'ChargeDate'
						   ,vprofile(custom_contractprofiles.cp_ovdfeedate));
			addprofileparam(poovdfeecalclog, 'Precision', sprecision(pcurno));
			addprofileparam(poovdfeecalclog, 'StateCode', sblockparam.state.statecode);
			addprofileparam(poovdfeecalclog
						   ,'StateChargeFee'
						   ,nvl(sblockparam.state.chargeovdfee, 0));
			addprofileparam(poovdfeecalclog, 'OverdueAmountOnDD', sminpaymentdd(pcurno));
		
			poovdfeecalclog.regularcalcdata.regpromocalcset_id := seqforlogging.nextval;
			poovdfeecalclog.regularcalcdata.overduefeelogid    := poovdfeecalclog.profilesettings.overduefeelogid;
			poovdfeecalclog.regularcalcdata.feetype            := 'REGULAR';
			poovdfeecalclog.regularcalcdata.feetypeusage       := 0;
			poovdfeecalclog.regularcalcdata.lastupdatedate     := SYSDATE;
		
			addcalcinfo(poovdfeecalclog.regularcalcdata
					   ,'ChargeType'
					   ,vprofile(custom_contractprofiles.cp_ovdfeetype));
			addcalcinfo(poovdfeecalclog.regularcalcdata
					   ,'Base'
					   ,vprofile(custom_contractprofiles.cp_ovdfeebase));
			addcalcinfo(poovdfeecalclog.regularcalcdata
					   ,'FlatAmount'
					   ,vprofile(custom_contractprofiles.cp_ovdfeeamt));
			addcalcinfo(poovdfeecalclog.regularcalcdata
					   ,'Prc'
					   ,vprofile(custom_contractprofiles.cp_ovdfeeprc));
			addcalcinfo(poovdfeecalclog.regularcalcdata
					   ,'YearDays'
					   ,vprofile(custom_contractprofiles.cp_ovdfeedaysinyear));
			addcalcinfo(poovdfeecalclog.regularcalcdata
					   ,'Min'
					   ,vprofile(custom_contractprofiles.cp_ovdfeeminamount));
			addcalcinfo(poovdfeecalclog.regularcalcdata
					   ,'Max'
					   ,vprofile(custom_contractprofiles.cp_ovdfeemaxamount));
			IF sprofilerates(sprofileid(pcurno))(custom_contractprofiles.cp_ovdfeeinterestrat)
			.exists(1)
			THEN
				addcalcinfo(poovdfeecalclog.regularcalcdata
						   ,'Rate'
						   ,sprofilerates(sprofileid(pcurno))
							(custom_contractprofiles.cp_ovdfeeinterestrat)(1).pid);
			ELSE
				addcalcinfo(poovdfeecalclog.regularcalcdata, 'Rate', NULL);
			END IF;
		
			poovdfeecalclog.promocalcdata.regpromocalcset_id := seqforlogging.nextval;
			poovdfeecalclog.promocalcdata.overduefeelogid    := poovdfeecalclog.profilesettings.overduefeelogid;
			poovdfeecalclog.promocalcdata.feetype            := 'PROMOTIONAL';
			poovdfeecalclog.promocalcdata.feetypeusage       := 0;
			poovdfeecalclog.promocalcdata.lastupdatedate     := SYSDATE;
		
			addcalcinfo(poovdfeecalclog.promocalcdata
					   ,'ChargeType'
					   ,vprofile(custom_contractprofiles.cp_redovdfeetype));
			addcalcinfo(poovdfeecalclog.promocalcdata
					   ,'Base'
					   ,vprofile(custom_contractprofiles.cp_redovdfeebase));
			addcalcinfo(poovdfeecalclog.promocalcdata
					   ,'FlatAmount'
					   ,vprofile(custom_contractprofiles.cp_redovdfeeamt));
			addcalcinfo(poovdfeecalclog.promocalcdata
					   ,'Prc'
					   ,vprofile(custom_contractprofiles.cp_redovdfeeprc));
			addcalcinfo(poovdfeecalclog.promocalcdata
					   ,'YearDays'
					   ,vprofile(custom_contractprofiles.cp_redovdfeedaysinyear));
			addcalcinfo(poovdfeecalclog.promocalcdata
					   ,'Min'
					   ,vprofile(custom_contractprofiles.cp_redovdfeeminamount));
			addcalcinfo(poovdfeecalclog.promocalcdata
					   ,'Max'
					   ,vprofile(custom_contractprofiles.cp_redovdfeemaxamount));
			addcalcinfo(poovdfeecalclog.promocalcdata
					   ,'Clnd'
					   ,vprofile(custom_contractprofiles.cp_redovdfeeperiod));
			IF sprofilerates(sprofileid(pcurno))(custom_contractprofiles.cp_redovdfeeinterestrat)
			.exists(1)
			THEN
				addcalcinfo(poovdfeecalclog.promocalcdata
						   ,'Rate'
						   ,sprofilerates(sprofileid(pcurno))
							(custom_contractprofiles.cp_redovdfeeinterestrat)(1).pid);
			ELSE
				addcalcinfo(poovdfeecalclog.promocalcdata, 'Rate', NULL);
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END setlog_profileparams;
	
		FUNCTION getoverdueinterest
		(
			pcontractno     IN typecontractno
		   ,pdate           IN DATE
		   ,paccountno      IN typeaccountno
		   ,pcurno          IN NUMBER
		   ,poovdfeecalclog IN OUT NOCOPY typeovdfeecalclog
		   ,pcalcpromoint   IN BOOLEAN
		) RETURN NUMBER IS
			cmethodname CONSTANT typemethodname := calcovdfee.cmethodname || '.GetOverdueInterest';
		
			voverdueremainsarray custom_overdueparameterscalculation.typeoverdueremainsarray;
			varemain             sch_prc.tarrremain;
			vrate                sch_prc.trecrate;
			vdaysinyear          NUMBER;
			vresult              NUMBER;
			vperiod              NUMBER;
			vsetid               NUMBER;
		
		BEGIN
			t.enter(cmethodname
				   ,'pContractNo = ' || pcontractno || ', pDate = ' || htools.d2s(pdate) ||
					', pAccountNo = ' || paccountno || ', pCurNo = ' || pcurno ||
					', pCalcPromoInt = ' || service.iif(pcalcpromoint, 'PROMOTIONAL', 'REGULAR'));
		
			varemain.delete;
			voverdueremainsarray := custom_overdueparameterscalculation.getoverdueremains(scontractno
																						 ,coperdate
																						 ,paccountno
																						 ,pcurno);
			FOR i IN 1 .. voverdueremainsarray.count
			LOOP
				varemain(i).opdate := voverdueremainsarray(i).operdate;
				varemain(i).remain := voverdueremainsarray(i).overdueamount;
			END LOOP;
			vperiod := trunc(months_between(coperdate, sdepaccount(pcurno).createdate));
			t.var('Period (number of month) passed from account creation date', vperiod);
		
			IF pcalcpromoint
			THEN
				t.var('Interest rate ID (promotional)'
					 ,sprofilerates(sprofileid(pcurno))
					  (custom_contractprofiles.cp_redovdfeeinterestrat)(1).pid);
				vrate       := sch_prc.loadrate(sprofilerates(sprofileid(pcurno))
												(custom_contractprofiles.cp_redovdfeeinterestrat)(1).pid);
				vdaysinyear := vprofile(custom_contractprofiles.cp_redovdfeedaysinyear);
				vsetid      := poovdfeecalclog.promocalcdata.regpromocalcset_id;
			
			ELSE
				t.var('Interest rate ID (regular)'
					 ,sprofilerates(sprofileid(pcurno))
					  (custom_contractprofiles.cp_ovdfeeinterestrat)(1).pid);
				vrate       := sch_prc.loadrate(sprofilerates(sprofileid(pcurno))
												(custom_contractprofiles.cp_ovdfeeinterestrat)(1).pid);
				vdaysinyear := vprofile(custom_contractprofiles.cp_ovdfeedaysinyear);
				vsetid      := poovdfeecalclog.regularcalcdata.regpromocalcset_id;
			END IF;
		
			t.var('vDaysInYear', vdaysinyear);
			sch_prc.mergedate(varemain
							 ,sch_prc.getnydate(sdepaccount(pcurno).createdate, coperdate));
			sch_prc.mergerate(varemain, vrate, NULL, sch_prc.cmoderpl, vperiod);
			vresult := round(sch_prc.calc(varemain, pdaysinyear => vdaysinyear), sprecision(pcurno));
		
			poovdfeecalclog.intcalcdetails.delete;
			FOR i IN 1 .. varemain.count - 1
			LOOP
				s.say(cmethodname || '           ===>>> remain = ' || varemain(i).remain ||
					  ', opDate = ' || varemain(i).opdate || ', Rate = ' || varemain(i).rate);
				poovdfeecalclog.intcalcdetails(i).ovdintercalcdtl := seqforlogging.nextval;
				poovdfeecalclog.intcalcdetails(i).regpromocalcset_id := vsetid;
				poovdfeecalclog.intcalcdetails(i).baseamount := varemain(i).remain;
				poovdfeecalclog.intcalcdetails(i).interestrate := varemain(i).rate;
				poovdfeecalclog.intcalcdetails(i).datefrom := varemain(i).opdate;
				poovdfeecalclog.intcalcdetails(i).dateto := varemain(i + 1).opdate;
				poovdfeecalclog.intcalcdetails(i).daysinyear := coalesce(vdaysinyear
																		,contracttools.daysinyear(varemain(i)
																								  .opdate));
				poovdfeecalclog.intcalcdetails(i).lastupdatedate := SYSDATE;
			END LOOP;
		
			t.leave(cmethodname, vresult);
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END getoverdueinterest;
	
		FUNCTION minmaxamount
		(
			pminamount IN NUMBER
		   ,pmaxamount IN NUMBER
		   ,pvalue     IN NUMBER
		) RETURN NUMBER IS
			cmethodname CONSTANT typemethodname := calcovdfee.cmethodname || '.MinMaxAmount';
		BEGIN
			s.say(cmethodname || ' pMinOvdAmount: ' || pminamount || ' pMaxOvdAmount: ' ||
				  pmaxamount || ' pValue: ' || pvalue);
		
			IF (pminamount IS NOT NULL)
			   AND (pvalue < pminamount)
			THEN
				RETURN pminamount;
			END IF;
		
			IF (pmaxamount IS NOT NULL)
			   AND (pmaxamount > 0)
			   AND (pvalue > pmaxamount)
			THEN
				RETURN pmaxamount;
			END IF;
		
			RETURN pvalue;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END minmaxamount;
	
	BEGIN
		t.enter(cmethodname, pcurno);
	
		s.say(cmethodname || '      Interest and fees calculation profile (sProfileID(' || pcurno ||
			  ')) = ' || sprofileid(pcurno));
		IF sprofile.exists(sprofileid(pcurno))
		THEN
			s.say(cmethodname ||
				  '      - info: Settings for Interest and fees calculation profile (sProfileID(' ||
				  pcurno || ')) = ' || sprofileid(pcurno) || ' were found');
		ELSE
			s.say(cmethodname ||
				  '      - info: Settings for Interest and fees calculation profile (sProfileID(' ||
				  pcurno || ')) = ' || sprofileid(pcurno) || ' were NOT found');
		END IF;
	
		vprofile := sprofile(sprofileid(pcurno));
	
		s.say(cmethodname || '      OVERDUE CALCULATION PROFILE''s <' || sprofileid(pcurno) ||
			  '> SETTINGS ');
		s.say(cmethodname || '       Overdue fee charge type (sProfile(sProfileID(' || pcurno ||
			  '))(custom_contractprofiles.cP_OvdFeeType)) = ' ||
			  vprofile(custom_contractprofiles.cp_ovdfeetype) ||
			  ', [ 1- Not used, 2-as total of, 3-as maximum between, 4-as minimum between]');
		s.say(cmethodname || '         Flat amount (sProfile(sProfileID(' || pcurno ||
			  '))(custom_contractprofiles.cP_OvdFeeAmt)) = ' ||
			  vprofile(custom_contractprofiles.cp_ovdfeeamt));
		s.say(cmethodname || '         Percentage (sProfile(sProfileID(' || pcurno ||
			  '))(custom_contractprofiles.cP_OvdFeePrc)) = ' ||
			  vprofile(custom_contractprofiles.cp_ovdfeeprc));
		s.say(cmethodname || '         When fee should be charged (sProfile(sProfileID(' || pcurno ||
			  '))(custom_contractprofiles.cP_OvdFeeDate)) = ' ||
			  vprofile(custom_contractprofiles.cp_ovdfeedate) ||
			  ', [1-Statement date, 2 - Due Date]');
		s.say(cmethodname || '         Overdue fee caclulation base (sProfile(sProfileID(' ||
			  pcurno || '))(custom_contractprofiles.cP_OvdFeeBase)) =' ||
			  vprofile(custom_contractprofiles.cp_ovdfeebase) ||
			  ', 1-Unpaid MP On Due Date, 2-Statement Date Amount');
		s.say(cmethodname || '         Days in year for overdue calculation (sProfile(sProfileID(' ||
			  pcurno || '))(custom_contractprofiles.cP_OvdFeeDaysInYear)) =' ||
			  vprofile(custom_contractprofiles.cp_ovdfeedaysinyear));
	
		s.say(cmethodname || '       Promotional overdue fee charge type (sProfile(sProfileID(' ||
			  pcurno || '))(custom_contractprofiles.cP_RedOvdFeeType)) = ' ||
			  vprofile(custom_contractprofiles.cp_redovdfeetype) ||
			  ', [ 1- Not used, 2-as total of, 3-as maximum between, 4-as minimum between]');
		s.say(cmethodname || '         Flat amount (sProfile(sProfileID(' || pcurno ||
			  '))(custom_contractprofiles.cP_RedOvdFeeAmt)) = ' ||
			  vprofile(custom_contractprofiles.cp_redovdfeeamt));
		s.say(cmethodname || '         Percentage (sProfile(sProfileID(' || pcurno ||
			  '))(custom_contractprofiles.cP_RedOvdFeePrc)) = ' ||
			  vprofile(custom_contractprofiles.cp_redovdfeeprc));
		s.say(cmethodname || '         Promotional calendar id (sProfile(sProfileID(' || pcurno ||
			  '))(custom_contractprofiles.cP_RedOvdFeePeriod)) = ' ||
			  vprofile(custom_contractprofiles.cp_redovdfeeperiod));
		s.say(cmethodname || '         Overdue fee caclulation base (sProfile(sProfileID(' ||
			  pcurno || '))(custom_contractprofiles.cP_RedOvdFeeBase)) =' ||
			  vprofile(custom_contractprofiles.cp_redovdfeebase) ||
			  ', 1-Unpaid MP On Due Date, 2-Statement Date Amount');
	
		setlog_profileparams(pcurno, poovdfeecalclog);
	
		IF sblockparam.state.chargeovdfee IN
		   (contractstatereference.covdfeecharge, contractstatereference.covdfeeoffbalance)
		THEN
		
			IF vprofile(custom_contractprofiles.cp_ovdfeetype) > 1
			THEN
			
				vlastovdfeedate               := contractparams.loaddate(contractparams.ccontract
																		,scontractno
																		,'Last_Overdue_Fee_' ||
																		 pcurno
																		,FALSE);
				poovdfeecalclog.lastfeecharge := vlastovdfeedate;
				addprofileparam(poovdfeecalclog, 'LastOvdFeeSD', vlastovdfeedate);
			
				t.var('StatementDate', getcurrentcycle().statementdate);
				t.var('vLastOvdFeeDate', vlastovdfeedate);
				IF (getcurrentcycle().statementdate IS NOT NULL)
				   AND ((vlastovdfeedate IS NULL) OR
				   (vlastovdfeedate < getcurrentcycle().statementdate))
				THEN
				
					t.var('Overdue amount on due date', sminpaymentdd(pcurno));
					IF sminpaymentdd(pcurno) > 0
					THEN
					
						IF vprofile(custom_contractprofiles.cp_ovdallow) > 1
						THEN
							vallowedoverdue := calcallowedoverdue(getcurrentmp(pcurno)
																 ,vprofile
																 ,sprecision(pcurno));
						END IF;
					
						addprofileparam(poovdfeecalclog, 'AlwbOvdValue', vallowedoverdue);
					
						IF sminpaymentdd(pcurno) > vallowedoverdue
						THEN
						
							IF (vprofile(custom_contractprofiles.cp_redovdfeetype) > 1)
							   AND
							   referencecalendar.isselectedday(coperdate
															  ,vprofile(custom_contractprofiles.cp_redovdfeeperiod))
							THEN
								s.say(cmethodname ||
									  '       - info: Promotional settings are going to be used');
								poovdfeecalclog.promocalcdata.feetypeusage := 1;
								vftype                                     := vprofile(custom_contractprofiles.cp_redovdfeetype);
							
								IF vftype = custom_contractprofiles.covdfeecalctype_asinterest
								THEN
									vresult        := getoverdueinterest(scontractno
																		,coperdate
																		,sdepaccount(pcurno)
																		 .accountno
																		,pcurno
																		,poovdfeecalclog
																		,TRUE);
									vneedcalculate := FALSE;
								ELSE
									vfamount      := vprofile(custom_contractprofiles.cp_redovdfeeamt);
									vfprc         := vprofile(custom_contractprofiles.cp_redovdfeeprc);
									vovdfeebase   := nvl(vprofile(custom_contractprofiles.cp_redovdfeebase)
														,1);
									vminovdamount := vprofile(custom_contractprofiles.cp_redovdfeeminamount);
									vmaxovdamount := vprofile(custom_contractprofiles.cp_redovdfeemaxamount);
								END IF;
							ELSE
								s.say(cmethodname ||
									  '       - info: Regular settings are going to be used');
								poovdfeecalclog.regularcalcdata.feetypeusage := 1;
								vftype                                       := vprofile(custom_contractprofiles.cp_ovdfeetype);
							
								IF vftype = custom_contractprofiles.covdfeecalctype_asinterest
								THEN
									vresult        := getoverdueinterest(scontractno
																		,coperdate
																		,sdepaccount(pcurno)
																		 .accountno
																		,pcurno
																		,poovdfeecalclog
																		,FALSE);
									vneedcalculate := FALSE;
								ELSE
									vfamount      := vprofile(custom_contractprofiles.cp_ovdfeeamt);
									vfprc         := vprofile(custom_contractprofiles.cp_ovdfeeprc);
									vovdfeebase   := nvl(vprofile(custom_contractprofiles.cp_ovdfeebase)
														,1);
									vminovdamount := vprofile(custom_contractprofiles.cp_ovdfeeminamount);
									vmaxovdamount := vprofile(custom_contractprofiles.cp_ovdfeemaxamount);
								END IF;
							END IF;
						
							IF vneedcalculate
							THEN
							
								IF vovdfeebase = 1
								THEN
									s.say(cmethodname ||
										  '       - info: Overdue Fee Is Based On Unpaid MP Amount '
										 ,1);
									addprofileparam(poovdfeecalclog
												   ,'AmountBase'
												   ,sminpaymentdd(pcurno));
									vresult := round(sminpaymentdd(pcurno) * vfprc / 100
													,sprecision(pcurno));
								ELSE
									s.say(cmethodname ||
										  '      - info: Overdue Fee Is Based On SD Amount '
										 ,1);
									s.say(cmethodname ||
										  '      Statement Date which amount is base  for OvdFee calculation  (StatementDate) = ' ||
										  htools.d2s(getcurrentcycle().statementdate));
									vsdamount := nvl(custom_overdueparameterscalculation.getlastpassedcycleinfo(sdepaccount(pcurno).accountno, pcurno, getcurrentcycle().statementdate + 1)
													 .sdamount
													,0);
								
									addprofileparam(poovdfeecalclog, 'SDAmount', vsdamount);
									addprofileparam(poovdfeecalclog, 'AmountBase', abs(vsdamount));
								
									s.say(cmethodname || '      SD Amount (vSDAmount)) = ' ||
										  vsdamount
										 ,1);
									vresult := round(abs(vsdamount) * vfprc / 100
													,sprecision(pcurno));
								END IF;
							
								IF vftype = custom_contractprofiles.covdfeecalctype_astotal
								THEN
									vresult := vresult + vfamount;
								ELSIF vftype = custom_contractprofiles.covdfeecalctype_asmax
								THEN
									vresult := greatest(vresult, vfamount);
								ELSIF vftype = custom_contractprofiles.covdfeecalctype_asmin
								THEN
									vresult := least(vresult, vfamount);
								END IF;
								s.say(cmethodname || '      OverdueFee (vResult) =' || vresult, 1);
							
								vresult := minmaxamount(vminovdamount, vmaxovdamount, vresult);
							
							END IF;
						
						END IF;
					
						IF poovdfeecalclog.regularcalcdata.feetypeusage = 1
						THEN
							addcalcinfo(poovdfeecalclog.regularcalcdata, 'OvdFinalVal', vresult);
						ELSIF poovdfeecalclog.promocalcdata.feetypeusage = 1
						THEN
							addcalcinfo(poovdfeecalclog.promocalcdata, 'OvdFinalVal', vresult);
						END IF;
					
					END IF;
				
				END IF;
			
			END IF;
		
		END IF;
	
		ofeevalue := vresult;
		ogst      := calcgst(pcurno, ofeevalue, 'OVERDUE_FEE_ON');
	
		poovdfeecalclog.hasinfo := TRUE;
	
		t.leave(cmethodname, ofeevalue);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END calcovdfee;

	PROCEDURE chargeovdfee
	(
		pcurno          IN NUMBER
	   ,pfeevalue       IN NUMBER
	   ,pgst            IN NUMBER
	   ,poovdfeecalclog IN OUT NOCOPY typeovdfeecalclog
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ChargeOvdFee';
		vfullremark typefullremark;
	BEGIN
		t.enter(cmethodname, pcurno);
	
		IF pfeevalue > 0
		THEN
		
			vfullremark := getfullremark(pcurno, 'TransFullRemarkOF');
		
			poovdfeecalclog.profilesettings.calcinfo := poovdfeecalclog.profilesettings.calcinfo ||
														'EntryRemark=' || vfullremark || ';';
		
			CASE sblockparam.state.chargeovdfee
				WHEN contractstatereference.covdfeecharge THEN
					doentry(pcurno
						   ,sdepaccount(pcurno)
						   ,sabaccounts(pcurno) (cb_incaccodf)
						   ,sdepaccount(pcurno).currencyno
						   ,pfeevalue
						   ,'OVERDUE_FEE_ON'
						   ,'OvdFee'
						   ,vfullremark);
				WHEN contractstatereference.covdfeeoffbalance THEN
					doentry(pcurno
						   ,sdepaccount(pcurno)
						   ,sabaccounts(pcurno) (cb_incaccodfoffbal)
						   ,sdepaccount(pcurno).currencyno
						   ,pfeevalue
						   ,'OVERDUE_FEE_ON'
						   ,'OvdFee'
						   ,vfullremark);
				ELSE
					error.raiseerror('Overdue fee can not be charged according to current delinquency state setting: ' ||
									 contractstatereference.getdescr_overduefee(sblockparam.state.chargeovdfee));
			END CASE;
		
			chargegst(pcurno, pgst);
		
		END IF;
	
		contractrbstd.changecontractparam(scontractno
										 ,'Last_Overdue_Fee_' || pcurno
										 ,to_char(getcurrentcycle().statementdate
												 ,contractparams.cparam_date_format));
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END chargeovdfee;

	PROCEDURE calcovlfee
	(
		pcurno    IN NUMBER
	   ,ofeevalue OUT NUMBER
	   ,ogst      OUT NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CalcOvlFee';
		coperdate   CONSTANT DATE := seance.getoperdate;
	
		vprchistarray     referenceprchistory.typeprcarray;
		vprcarray         contracttools.typeprcarray;
		vlimitexceed      BOOLEAN := FALSE;
		vallowedoverlimit NUMBER;
		vdaysinyear       NUMBER;
		vovlfee           NUMBER := 0;
		vprcvalue         NUMBER;
		vusered           BOOLEAN;
		vprcstep          NUMBER;
		vfamount          NUMBER;
		vperiod           NUMBER;
		vfyear            NUMBER;
		vftype            NUMBER;
		vfprc             NUMBER;
	
	BEGIN
		t.enter(cmethodname, pcurno);
	
		IF snowstatementdate
		   AND (sovdaccount(pcurno).accountno IS NOT NULL)
		   AND (sblockparam.state.chargeovlfee = 1)
		   AND (sprofile(sprofileid(pcurno)) (custom_contractprofiles.cp_ovrlmttype) > 1)
		THEN
		
			IF (sprofile(sprofileid(pcurno)) (custom_contractprofiles.cp_ovrignorecorp) = '1')
			   OR (NOT hascorporatecontract)
			   OR wasoverdraft(getcorpcontractnumber
							  ,sdepaccount(pcurno).currencyno
							  ,nvl(getcurrentcycle().statementdate, sdepaccount(pcurno).createdate)
							  ,coperdate - 1)
			THEN
			
				vusered := sprofile(sprofileid(pcurno))
						   (custom_contractprofiles.cp_redovrlmttype) > 1 AND
						   referencecalendar.isselectedday(coperdate
														  ,sprofile(sprofileid(pcurno))
														   (custom_contractprofiles.cp_redovrlmtperiod));
				IF vusered
				THEN
					vftype   := sprofile(sprofileid(pcurno))
								(custom_contractprofiles.cp_redovrlmttype);
					vfprc    := sprofile(sprofileid(pcurno))
								(custom_contractprofiles.cp_redovrlmtprc);
					vfamount := sprofile(sprofileid(pcurno))
								(custom_contractprofiles.cp_redovrlmtamt);
					vfyear   := sprofile(sprofileid(pcurno))
								(custom_contractprofiles.cp_redovrlmtyear);
				ELSE
					vftype   := sprofile(sprofileid(pcurno))
								(custom_contractprofiles.cp_ovrlmttype);
					vfprc    := sprofile(sprofileid(pcurno)) (custom_contractprofiles.cp_ovrlmtprc);
					vfamount := sprofile(sprofileid(pcurno))
								(custom_contractprofiles.cp_ovrlmtamount);
					vfyear   := sprofile(sprofileid(pcurno))
								(custom_contractprofiles.cp_ovrlmtyear);
				END IF;
			
				vprcarray := fillremainarray(sovdaccount(pcurno)
											,nvl(getcurrentcycle().statementdate
												,sdepaccount    (pcurno).createdate - 1) + 1
											,coperdate);
			
				IF vprcarray(vprcarray.count).pdate <> coperdate
				THEN
					vprcarray(vprcarray.count + 1).pdate := coperdate;
				END IF;
			
				vprcarray(vprcarray.count).premain := abs(sovdaccount(pcurno).remain);
			
				vallowedoverlimit := round(sprofile(sprofileid(pcurno)) (custom_contractprofiles.cp_ovrlmtallowprc) * sdepaccount(pcurno)
										   .overdraft / 100
										  ,sprecision(pcurno));
				t.var('Allow OverLimit Prc', vallowedoverlimit);
			
				vallowedoverlimit := service.iif(sprofile(sprofileid(pcurno))
												 (custom_contractprofiles.cp_ovrlmtallow) = 1
												,greatest(sprofile(sprofileid(pcurno))
														  (custom_contractprofiles.cp_ovrlmtallowamt)
														 ,vallowedoverlimit)
												,least(sprofile(sprofileid(pcurno))
													   (custom_contractprofiles.cp_ovrlmtallowamt)
													  ,vallowedoverlimit));
				t.var('Allow OverLimit Value', vallowedoverlimit);
			
				IF sprofile(sprofileid(pcurno)) (custom_contractprofiles.cp_ovrlmtterms) = 1
				THEN
					FOR i IN 1 .. vprcarray.count
					LOOP
						t.var('OverLimit Value', vprcarray(i).premain);
						vlimitexceed := vprcarray(i).premain > vallowedoverlimit;
						EXIT WHEN vlimitexceed;
					END LOOP;
				
				ELSE
					t.var('sOvdAccount(pCurNo).Remain', sovdaccount(pcurno).remain);
					vlimitexceed := abs(sovdaccount(pcurno).remain) > vallowedoverlimit;
				END IF;
				t.var('Limit Exceed', htools.b2s(vlimitexceed));
			
				IF vlimitexceed
				THEN
					IF vftype = 2
					THEN
						IF vusered
						THEN
							vprchistarray := sprofilerates(sprofileid(pcurno))
											 (custom_contractprofiles.cr_redovrprchist);
						ELSE
							vprchistarray := sprofilerates(sprofileid(pcurno))
											 (custom_contractprofiles.cr_ovrprchist);
						END IF;
						vperiod := trunc(months_between(coperdate, sdepaccount(pcurno).createdate));
						vprcarray(1).ppercent := referenceprchistory.getpercentvalue(vprchistarray
																					,coperdate
																					,vperiod
																					,vprcarray(1)
																					 .premain);
						FOR j IN 2 .. vprcarray.count
						LOOP
							vprcarray(j).ppercent := referenceprchistory.getpercentvalue(vprchistarray
																						,coperdate
																						,vperiod
																						,vprcarray(j)
																						 .premain);
							vprcarray(j - 1).pdays := vprcarray(j).pdate - vprcarray(j - 1).pdate;
							s.say(cmethodname || ' -> Date = ' || vprcarray(j - 1).pdate ||
								  ' Remain = ' || vprcarray(j - 1).premain || ' Days = ' || vprcarray(j - 1)
								  .pdays || ' Percent = ' || vprcarray(j - 1).ppercent);
						END LOOP;
						vprcarray.delete(vprcarray.count);
						vprcvalue := 0;
						FOR j IN 1 .. vprcarray.count
						LOOP
							vdaysinyear := coalesce(vfyear
												   ,contracttools.daysinyear(vprcarray(j).pdate));
							t.var('DaysInYear', vdaysinyear);
							vprcstep := vprcarray(j).premain * vprcarray(j).ppercent * vprcarray(j)
										.pdays / (vdaysinyear * 100);
							s.say(cmethodname || ' -> ' || j || ' PrcStep=' || vprcstep);
							vprcvalue := vprcvalue + vprcstep;
						END LOOP;
						vprcvalue := round(vprcvalue, sprecision(pcurno));
						t.var('CalcPrc', vprcvalue);
						vovlfee := vprcvalue;
					ELSE
						IF sprofile(sprofileid(pcurno))
						 (custom_contractprofiles.cp_ovrlmtbased) = 1
						THEN
							s.say(cmethodname || ' -> Limit Exceed within cycle');
							vovlfee := 0;
							FOR j IN 1 .. vprcarray.count
							LOOP
								IF vprcarray(j).premain > vovlfee
								THEN
									vovlfee := vprcarray(j).premain;
								END IF;
							END LOOP;
						ELSE
							s.say(cmethodname || ' -> Limit Exceed on SD');
							vovlfee := vprcarray(vprcarray.count).premain;
						END IF;
					
						t.var('Max Limit Exceed', vovlfee);
						vovlfee := round(vfprc * vovlfee / 100, sprecision(pcurno));
						t.var('OverLimit Fee Prc Value', vovlfee);
						t.var('OverLimit Fee Flat Amount Value', vfamount);
						IF vftype = 3
						THEN
							vovlfee := vovlfee + vfamount;
						ELSIF vftype = 4
						THEN
							vovlfee := greatest(vovlfee, vfamount);
						ELSIF vftype = 5
						THEN
							vovlfee := least(vovlfee, vfamount);
						END IF;
					END IF;
				END IF;
			
			END IF;
		
		END IF;
	
		ofeevalue := vovlfee;
		ogst      := calcgst(pcurno, ofeevalue, 'OVERLIMIT_FEE_ON');
	
		t.leave(cmethodname, ofeevalue);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END calcovlfee;

	PROCEDURE chargeovlfee
	(
		pcurno    IN NUMBER
	   ,pfeevalue IN NUMBER
	   ,pgst      IN NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ChargeOvlFee';
	BEGIN
		t.enter(cmethodname, pcurno);
	
		IF pfeevalue > 0
		THEN
		
			doentry(pcurno
				   ,sdepaccount(pcurno)
				   ,sabaccounts(pcurno) (cb_incaccolf)
				   ,sdepaccount(pcurno).currencyno
				   ,pfeevalue
				   ,'OVERLIMIT_FEE_ON'
				   ,'OvrLmtFee'
				   ,getfullremark(pcurno, 'TransFullRemarkOLF'));
		
			chargegst(pcurno, pgst);
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END chargeovlfee;

	PROCEDURE chargeovlfee(pcurno IN NUMBER) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ChargeOvlFee';
		vfeevalue NUMBER;
		vgst      NUMBER;
	BEGIN
		t.enter(cmethodname, pcurno);
	
		calcovlfee(pcurno, vfeevalue, vgst);
	
		chargeovlfee(pcurno, vfeevalue, vgst);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END chargeovlfee;

	FUNCTION getusedinstlimit
	(
		pcurno    IN NUMBER
	   ,poalimits IN OUT NOCOPY types.arrnum
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetUsedInstLimit';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vnoarray       contractlink.typecontractarray;
		vuselimittype  NUMBER;
		vstatementdate DATE;
		vrecno         NUMBER;
	
		PROCEDURE reportresult
		(
			plimits     IN types.arrnum
		   ,pcalctype   IN PLS_INTEGER
		   ,pvaluedescr IN VARCHAR2
		) IS
			cmethodname CONSTANT typemethodname := getusedinstlimit.cmethodname || '.ReportResult';
		BEGIN
			IF plimits.exists(pcalctype)
			THEN
				t.var(pvaluedescr, plimits(pcalctype));
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END reportresult;
	
	BEGIN
		t.enter(cmethodname, pcurno);
	
		vuselimittype := nvl(contractparams.loadnumber(contractparams.ccontracttype
													  ,scontracttype
													  ,'InstDepend'
													  ,FALSE)
							,cinstusedlimit);
	
		poalimits(vuselimittype) := 0;
	
		IF (poalimits.count > 1)
		   OR (NOT poalimits.exists(cinstnotdepend))
		THEN
		
			IF (slinkschemasinst.count > 0)
			   AND (nvl(contractparams.loadnumber(contractparams.ccontracttype
												 ,scontracttype
												 ,'USEINST'
												 ,FALSE)
					   ,0) = 1)
			THEN
			
				IF contractlink.getlinkno(scontractno
										 ,contractlink.cmain
										 ,vnoarray
										 ,cinstlinkname
										 ,sdepaccount(pcurno).currencyno) > 0
				THEN
				
					IF poalimits.exists(cinstregpayment)
					THEN
						SELECT MAX(recno)
						INTO   vrecno
						FROM   tcontractstcycle
						WHERE  branch = cbranch
						AND    contractno = scontractno;
						SELECT nextstatementdate
						INTO   vstatementdate
						FROM   tcontractstcycle
						WHERE  branch = cbranch
						AND    recno = vrecno;
					END IF;
				
					IF poalimits.exists(cinstusedlimitandinterest)
					THEN
						poalimits(cinstusedlimit) := 0;
					END IF;
				
					FOR i IN 1 .. vnoarray.count
					LOOP
					
						IF poalimits.exists(cinstregpayment)
						THEN
							poalimits(cinstregpayment) := poalimits(cinstregpayment) +
														  getinstallmentrepaymentamount(vnoarray(i).cno
																					   ,vstatementdate);
						END IF;
					
						IF poalimits.exists(cinstusedlimit)
						THEN
							poalimits(cinstusedlimit) := poalimits(cinstusedlimit) +
														 getusedinstallmentlimit(vnoarray(i).cno);
						END IF;
					
						IF poalimits.exists(cinstusedlimitandinterest)
						THEN
							poalimits(cinstusedlimitandinterest) := poalimits(cinstusedlimitandinterest) +
																	getinstallmentunpaidinterest(vnoarray(i).cno);
						END IF;
					
					END LOOP;
				
					IF poalimits.exists(cinstusedlimitandinterest)
					THEN
						poalimits(cinstusedlimitandinterest) := poalimits(cinstusedlimitandinterest) +
																poalimits(cinstusedlimit);
					END IF;
				
				END IF;
			
			END IF;
		
			reportresult(poalimits
						,cinstregpayment
						,'Repayment amount on SD (' || htools.d2s(vstatementdate) || ')');
			reportresult(poalimits, cinstusedlimit, 'Installment total unpaid amount');
			reportresult(poalimits
						,cinstusedlimitandinterest
						,'Installment total unpaid amount + Interest');
		
		END IF;
	
		t.leave(cmethodname, poalimits(vuselimittype));
		RETURN poalimits(vuselimittype);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getusedinstlimit;

	FUNCTION getusedinstlimit(pcurno IN NUMBER) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetUsedInstLimit';
		vdummy types.arrnum;
	BEGIN
		RETURN getusedinstlimit(pcurno, vdummy);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getusedinstlimit;

	FUNCTION getalllimitsvalue RETURN typealllimitarray IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetAllLimitsValue';
	
		vcontractobjects typecontractobjects;
	
		vestablishedlimits typelimitvaluerecord;
		vusedlimits        typelimitvaluerecord;
		vavailablelimits   typelimitvaluerecord;
		vusedinstallment   NUMBER;
	
		vcurno        NUMBER;
		vmaincurno    NUMBER;
		vsecondcurno  NUMBER;
		vpan_mbr      VARCHAR2(50);
		vconvertedsum NUMBER;
	
		TYPE typearrholdlistbycurno IS TABLE OF apitypes.typeextractholdlist INDEX BY PLS_INTEGER;
		vaholdlistbycurno typearrholdlistbycurno;
	
		vusedcreditlimit NUMBER;
	
		vresult typealllimitarray;
	
		FUNCTION correctusedlimit
		(
			plimitkind    IN NUMBER
		   ,pcurno        IN NUMBER
		   ,ppan          IN typepan
		   ,pmbr          IN typembr
		   ,pcurrentvalue IN NUMBER
		   ,pholdslist    IN apitypes.typeextractholdlist
		) RETURN NUMBER IS
			cmethodname  CONSTANT typemethodname := getalllimitsvalue.cmethodname ||
													'.CorrectUsedLimit';
			ciscredlimit CONSTANT BOOLEAN := plimitkind = clk_creditlimit;
			cisaccount   CONSTANT BOOLEAN := ppan IS NULL;
			vresult NUMBER := 0;
		BEGIN
			t.enter(cmethodname
				   ,'pLimitKind = ' || plimitkind || ', pCurrentValue = ' || pcurrentvalue);
		
			IF (cisaccount AND ciscredlimit)
			   OR
			   (gettypelimitperiod(plimitkind, vcurno, ppan, pmbr) IN
			   (referencelimit.periodtype_reset_in_refresh, contracttypelimits.periodtype_at_sd))
			THEN
			
				vresult := pcurrentvalue;
			
				IF ifcurrencyisusedintype(pcurno, scontracttype, scontractno)
				THEN
				
					FOR i IN 1 .. pholdslist.count
					LOOP
					
						IF cisaccount
						   OR ((ppan = pholdslist(i).pan) AND (pmbr = pholdslist(i).mbr))
						THEN
						
							IF (ciscredlimit OR (custom_contractprofiles.getgrouptypebyentryident(referenceextractoperation.getentident(pholdslist(i)
																																		.device
																																	   ,pholdslist(i)
																																		.entcode)) =
							   ctrxngrp_cash))
							THEN
								vresult := vresult + pholdslist(i).value;
							END IF;
						
						END IF;
					
					END LOOP;
				
				END IF;
			
			END IF;
		
			t.leave(cmethodname, vresult);
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END correctusedlimit;
	
	BEGIN
		t.enter(cmethodname);
	
		getcontractobjects(vcontractobjects);
	
		FOR i IN 1 .. 2
		LOOP
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			THEN
				vaholdlistbycurno(i) := extracthold.getholdlist(sdepaccount(i).accountno
															   ,extract.hold_debit
															   ,extracthold.chsactual);
			END IF;
		END LOOP;
	
		FOR i IN 1 .. vcontractobjects.count
		LOOP
		
			IF ifcurrencyisusedintype(vcontractobjects(i).curno, scontracttype, scontractno)
			THEN
			
				vcurno := vcontractobjects(i).curno;
			
				vestablishedlimits := getcalclimitsvalue(vcurno
														,scontractno
														,vcontractobjects(i).pan
														,vcontractobjects(i).mbr);
			
				vestablishedlimits.credlimit := nvl(vestablishedlimits.credlimit, 0);
				vestablishedlimits.cashlimit := nvl(vestablishedlimits.cashlimit, 0);
			
				IF vcontractobjects(i).pan IS NULL
				THEN
					vusedcreditlimit := abs(least(sdepaccount(vcurno).remain, 0));
				ELSE
					vusedcreditlimit := vcontractobjects(i).usedcredlimit;
				END IF;
			
				vusedlimits.credlimit := correctusedlimit(clk_creditlimit
														 ,vcurno
														 ,vcontractobjects(i).pan
														 ,vcontractobjects(i).mbr
														 ,vusedcreditlimit
														 ,vaholdlistbycurno(vcurno));
				vusedlimits.cashlimit := correctusedlimit(clk_cashlimit
														 ,vcurno
														 ,vcontractobjects(i).pan
														 ,vcontractobjects(i).mbr
														 ,vcontractobjects(i).usedcashlimit
														 ,vaholdlistbycurno(vcurno));
			
				IF vcontractobjects(i).pan IS NULL
				THEN
					vusedinstallment := getusedinstlimit(vcurno);
				ELSE
					vusedinstallment := 0;
				END IF;
			
				vavailablelimits.credlimit := greatest(nvl(vestablishedlimits.credlimit, 0) -
													   nvl(vusedlimits.credlimit, 0) -
													   nvl(vusedinstallment, 0)
													  ,0);
				vavailablelimits.cashlimit := greatest(nvl(vestablishedlimits.cashlimit, 0) -
													   nvl(vusedlimits.cashlimit, 0)
													  ,0);
			
				vpan_mbr := TRIM(vcontractobjects(i).pan || '-' || vcontractobjects(i).mbr);
			
				vresult(vcurno)(vpan_mbr).estabcreditlimit := nvl(vestablishedlimits.credlimit, 0);
				vresult(vcurno)(vpan_mbr).estabcashlimit := nvl(vestablishedlimits.cashlimit, 0);
				vresult(vcurno)(vpan_mbr).usedcredlimit := nvl(vusedlimits.credlimit, 0);
				vresult(vcurno)(vpan_mbr).usedcashlimit := nvl(vusedlimits.cashlimit, 0);
				vresult(vcurno)(vpan_mbr).usedinstallment := nvl(vusedinstallment, 0);
				vresult(vcurno)(vpan_mbr).availcreditlimit := nvl(vavailablelimits.credlimit, 0);
				vresult(vcurno)(vpan_mbr).availcashlimit := nvl(vavailablelimits.cashlimit, 0);
			
				t.var('vCurNo', vcurno);
				t.var('Card', masktodebug(vcontractobjects(i).pan, vcontractobjects(i).mbr));
				t.var('vEstablishedLimits.CredLimit', vestablishedlimits.credlimit);
				t.var('vEstablishedLimits.CashLimit', vestablishedlimits.cashlimit);
				t.var('vUsedLimits.CredLimit', vusedlimits.credlimit);
				t.var('vUsedLimits.CashLimit', vusedlimits.cashlimit);
				t.var('vUsedInstallment', vusedinstallment);
				t.var('vAllowableLimits.CredLimit', vavailablelimits.credlimit);
				t.var('vAllowableLimits.CashLimit', vavailablelimits.cashlimit);
			
			END IF;
		
		END LOOP;
	
		IF getlimittype_int(scontractno) = caggregate
		THEN
		
			vmaincurno   := service.iif(scardcount1 > 0, 1, 2);
			vsecondcurno := getvaluebycurno(vmaincurno, 2, 1);
		
			t.var('vMainCurNo', vmaincurno);
			t.var('vSecondCurNo', vsecondcurno);
		
			FOR i IN 1 .. vcontractobjects.count
			LOOP
			
				vcurno   := vcontractobjects(i).curno;
				vpan_mbr := TRIM(vcontractobjects(i).pan || '-' || vcontractobjects(i).mbr);
			
				t.var('vCurNo', vcurno);
				t.var('Card', masktodebug(vcontractobjects(i).pan, vcontractobjects(i).mbr));
			
				IF NOT vresult.exists(vsecondcurno)
				THEN
					s.say(cmethodname ||
						  '            - info: Minor currency limit information is not found');
					vresult(vsecondcurno)(vpan_mbr) := NULL;
				ELSIF NOT vresult(vsecondcurno).exists(vpan_mbr)
				THEN
					s.say(cmethodname ||
						  '            - info: Information for PAN_MBR is not found for minor currency');
					vresult(vsecondcurno)(vpan_mbr) := NULL;
				END IF;
			
				IF vmaincurno = vcontractobjects(i).curno
				THEN
				
					vconvertedsum := contracttools.getsumincurrency(nvl(vresult(vsecondcurno)(vpan_mbr)
																		.estabcreditlimit
																	   ,0)
																   ,sdepaccount(vsecondcurno)
																	.currencyno
																   ,sdepaccount(vmaincurno)
																	.currencyno
																   ,sactparam(cctp_exchangerate));
					vresult(vmaincurno)(vpan_mbr).estabcreditlimitaggr := vresult(vmaincurno)(vpan_mbr)
																		 .estabcreditlimit +
																		  greatest(vconvertedsum, 0);
					vresult(vsecondcurno)(vpan_mbr).estabcreditlimitaggr := NULL;
				
					vconvertedsum := contracttools.getsumincurrency(nvl(vresult(vsecondcurno)(vpan_mbr)
																		.estabcashlimit
																	   ,0)
																   ,sdepaccount(vsecondcurno)
																	.currencyno
																   ,sdepaccount(vmaincurno)
																	.currencyno
																   ,sactparam(cctp_exchangerate));
					vresult(vmaincurno)(vpan_mbr).estabcashlimitaggr := vresult(vmaincurno)(vpan_mbr)
																	   .estabcashlimit +
																		greatest(vconvertedsum, 0);
					vresult(vsecondcurno)(vpan_mbr).estabcashlimitaggr := NULL;
				
					vconvertedsum := contracttools.getsumincurrency(nvl(vresult(vsecondcurno)(vpan_mbr)
																		.usedcredlimit
																	   ,0)
																   ,sdepaccount(vsecondcurno)
																	.currencyno
																   ,sdepaccount(vmaincurno)
																	.currencyno
																   ,sactparam(cctp_exchangerate));
					vresult(vmaincurno)(vpan_mbr).usedcredlimitaggr := vresult(vmaincurno)(vpan_mbr)
																	  .usedcredlimit +
																	   greatest(vconvertedsum, 0);
					vresult(vsecondcurno)(vpan_mbr).usedcredlimitaggr := NULL;
				
					vconvertedsum := contracttools.getsumincurrency(nvl(vresult(vsecondcurno)(vpan_mbr)
																		.usedcashlimit
																	   ,0)
																   ,sdepaccount(vsecondcurno)
																	.currencyno
																   ,sdepaccount(vmaincurno)
																	.currencyno
																   ,sactparam(cctp_exchangerate));
					vresult(vmaincurno)(vpan_mbr).usedcashlimitaggr := vresult(vmaincurno)(vpan_mbr)
																	  .usedcashlimit +
																	   greatest(vconvertedsum, 0);
					vresult(vsecondcurno)(vpan_mbr).usedcashlimitaggr := NULL;
				
					vresult(vmaincurno)(vpan_mbr).availcreditlimitaggr := greatest(vresult(vmaincurno)(vpan_mbr)
																				   .estabcreditlimitaggr -
																				   vresult(vmaincurno)(vpan_mbr)
																				   .usedcredlimitaggr
																				  ,0);
					vresult(vsecondcurno)(vpan_mbr).availcreditlimitaggr := NULL;
				
					vresult(vmaincurno)(vpan_mbr).availcashlimitaggr := greatest(vresult(vmaincurno)(vpan_mbr)
																				 .estabcashlimitaggr -
																				 vresult(vmaincurno)(vpan_mbr)
																				 .usedcashlimitaggr
																				,0);
					vresult(vsecondcurno)(vpan_mbr).availcashlimitaggr := NULL;
				
					t.var('EstabCreditLimitAggr'
						 ,vresult(vmaincurno)(vpan_mbr).estabcreditlimitaggr);
					t.var('EstabCashLimitAggr', vresult(vmaincurno)(vpan_mbr).estabcashlimitaggr);
					t.var('UsedCredLimitAggr', vresult(vmaincurno)(vpan_mbr).usedcredlimitaggr);
					t.var('UsedCashLimitAggr', vresult(vmaincurno)(vpan_mbr).usedcashlimitaggr);
					t.var('AvailCreditLimitAggr'
						 ,vresult(vmaincurno)(vpan_mbr).availcreditlimitaggr);
					t.var('AvailCashLimitAggr', vresult(vmaincurno)(vpan_mbr).availcashlimitaggr);
				
				END IF;
			
			END LOOP;
		
		END IF;
	
		t.leave(cmethodname);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getalllimitsvalue;

	FUNCTION getalllimitsvalue(pcontractno IN typecontractno) RETURN typealllimitarray IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetAllLimitsValue';
	BEGIN
		initcontract(pcontractno);
		RETURN getalllimitsvalue;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getalllimitsvalue;

	PROCEDURE updateobjectlimitsintwcms
	(
		pcurno       IN NUMBER
	   ,ppan         IN typepan
	   ,pmbr         IN typembr
	   ,poperation   IN PLS_INTEGER
	   ,plocalchange IN BOOLEAN := TRUE
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UpdateObjectLimitsInTWCMS';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vasavedlimitslist referencelimit.tlimitarray;
		vanewlimitslist   referencelimit.tlimitarray;
		vanewlimitsdata   typecontractcalculatedlimits;
		valimitarray      contracttypelimits.typelimitarray;
		vobjectlimits     typealllimitrec;
		vhasnewtrxns      types.arrbool;
		vneedupdate       BOOLEAN;
	
		FUNCTION converttosparse(plimitarray IN referencelimit.tlimitarray)
			RETURN referencelimit.tlimitarray IS
			cmethodname CONSTANT typemethodname := updateobjectlimitsintwcms.cmethodname ||
												   '.ConvertToSparse';
			vresult referencelimit.tlimitarray;
		BEGIN
			FOR i IN 1 .. plimitarray.count
			LOOP
				vresult(plimitarray(i).limitid) := plimitarray(i);
			END LOOP;
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END converttosparse;
	
		FUNCTION converttoordered(plimitarray IN referencelimit.tlimitarray)
			RETURN referencelimit.tlimitarray IS
			cmethodname CONSTANT typemethodname := updateobjectlimitsintwcms.cmethodname ||
												   '.ConvertToOrdered';
			vresult  referencelimit.tlimitarray;
			vlimitid NUMBER;
		BEGIN
			vlimitid := plimitarray.first;
			WHILE vlimitid IS NOT NULL
			LOOP
				vresult(vresult.count + 1) := plimitarray(vlimitid);
				vlimitid := plimitarray.next(vlimitid);
			END LOOP;
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END converttoordered;
	
		PROCEDURE setnewlimitparams
		(
			plimitsettings    IN contracttypelimits.typelimitrecord
		   ,paccountno        IN typeaccountno
		   ,ppan              IN typepan
		   ,pmbr              IN typembr
		   ,pestablishedlimit IN NUMBER
		   ,pusedlimit        IN NUMBER
		   ,oneedupdate       IN OUT BOOLEAN
		) IS
			cmethodname CONSTANT typemethodname := updateobjectlimitsintwcms.cmethodname ||
												   '.SetNewLimitParams';
			climitid    CONSTANT PLS_INTEGER := plimitsettings.limitid;
		BEGIN
			t.enter(cmethodname);
		
			IF plimitsettings.periodtype IN
			   (referencelimit.periodtype_none
			   ,referencelimit.periodtype_week
			   ,referencelimit.periodtype_month
			   ,referencelimit.periodtype_year)
			THEN
				vanewlimitslist(climitid).periodtype := plimitsettings.periodtype;
				vanewlimitslist(climitid).period := referencelimit.getlimitperiod(plimitsettings.periodtype
																				 ,plimitsettings.periodvalue
																				 ,0
																				 ,0);
			
			ELSIF plimitsettings.periodtype IN
				  (referencelimit.periodtype_reset_in_refresh, contracttypelimits.periodtype_at_sd)
			THEN
				vanewlimitslist(climitid).periodtype := referencelimit.periodtype_reset_in_refresh;
			ELSE
				error.raiseerror('Internal error: unsupported period type <' ||
								 plimitsettings.periodtype || '>!');
			END IF;
		
			vanewlimitslist(climitid).limitid := climitid;
			vanewlimitslist(climitid).limitstatus := referencelimit.stat_object;
			vanewlimitslist(climitid).maxvalue := pestablishedlimit;
		
			vanewlimitsdata(climitid).branch := cbranch;
			vanewlimitsdata(climitid).contractno := scontractno;
			vanewlimitsdata(climitid).accountno := paccountno;
			vanewlimitsdata(climitid).pan := ppan;
			vanewlimitsdata(climitid).mbr := pmbr;
			vanewlimitsdata(climitid).currencyno := pcurno;
			vanewlimitsdata(climitid).limitid := climitid;
			vanewlimitsdata(climitid).limitkind := plimitsettings.limitkind;
			vanewlimitsdata(climitid).objecttype := plimitsettings.objecttype;
			vanewlimitsdata(climitid).ownership := plimitsettings.ownership;
			vanewlimitsdata(climitid).establimit := pestablishedlimit;
			vanewlimitsdata(climitid).usedlimit := pusedlimit;
		
			IF NOT oneedupdate
			THEN
				oneedupdate := (NOT vasavedlimitslist.exists(climitid)) OR
							   contracttools.notequal(vasavedlimitslist(climitid).periodtype
													 ,vanewlimitslist  (climitid).periodtype) OR
							   contracttools.notequal(vasavedlimitslist(climitid).period
													 ,vanewlimitslist  (climitid).period) OR
							   contracttools.notequal(vasavedlimitslist(climitid).maxvalue
													 ,vanewlimitslist  (climitid).maxvalue);
			END IF;
		
			t.leave(cmethodname, htools.b2s(oneedupdate));
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END setnewlimitparams;
	
		PROCEDURE savelimits
		(
			poanewlimitslist IN OUT NOCOPY referencelimit.tlimitarray
		   ,panewlimitsdata  IN typecontractcalculatedlimits
		   ,pobjecttype      IN PLS_INTEGER
		   ,paccountno       IN typeaccountno
		   ,ppan             IN typepan
		   ,pmbr             IN typembr
		   ,pneedupdate      IN OUT BOOLEAN
		) IS
			cmethodname CONSTANT typemethodname := updateobjectlimitsintwcms.cmethodname ||
												   '.SaveLimits';
			vasavedlimitsids types.arrnum;
			vatemp           types.arrnum;
			vlimitid         NUMBER;
		BEGIN
			t.enter(cmethodname);
		
			SELECT limitid BULK COLLECT
			INTO   vatemp
			FROM   tcontractcalculatedlimits
			WHERE  branch = cbranch
			AND    contractno = scontractno
			AND    accountno = paccountno
			AND    ((ppan IS NULL) OR (pan = ppan))
			AND    ((pmbr IS NULL) OR (mbr = pmbr))
			AND    currencyno = pcurno
			AND    objecttype = pobjecttype;
		
			FOR i IN 1 .. vatemp.count
			LOOP
				vasavedlimitsids(vatemp(i)) := vatemp(i);
			END LOOP;
		
			vlimitid := poanewlimitslist.first;
			WHILE vlimitid IS NOT NULL
			LOOP
			
				IF vasavedlimitsids.exists(vlimitid)
				   AND (NOT panewlimitsdata.exists(vlimitid))
				THEN
					poanewlimitslist.delete(vlimitid);
					pneedupdate := TRUE;
				END IF;
			
				vlimitid := poanewlimitslist.next(vlimitid);
			END LOOP;
		
			IF pneedupdate
			THEN
			
				CASE pobjecttype
					WHEN referencelimit.objtype_account THEN
						referencelimit.saveaccountlimits(sdepaccount(pcurno).accountno
														,converttoordered(poanewlimitslist));
					WHEN referencelimit.objtype_acc2card THEN
						referencelimit.saveacc2cardlimits(ppan
														 ,pmbr
														 ,sdepaccount(pcurno).accountno
														 ,converttoordered(poanewlimitslist));
					ELSE
						error.raiseerror('Unsupported object type <' || pobjecttype || '>!');
				END CASE;
				error.raisewhenerr;
			
			END IF;
		
			IF pneedupdate
			   OR ((panewlimitsdata.count > 0) AND (vasavedlimitsids.count = 0))
			THEN
			
				IF vasavedlimitsids.count > 0
				THEN
				
					DELETE FROM tcontractcalculatedlimits
					WHERE  branch = cbranch
					AND    contractno = scontractno
					AND    accountno = paccountno
					AND    ((ppan IS NULL) OR (pan = ppan))
					AND    ((pmbr IS NULL) OR (mbr = pmbr))
					AND    currencyno = pcurno
					AND    objecttype = pobjecttype;
				
				END IF;
			
				FORALL i IN INDICES OF panewlimitsdata
					INSERT INTO tcontractcalculatedlimits VALUES panewlimitsdata (i);
			
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END savelimits;
	
		PROCEDURE logobjectlimitschange
		(
			pobjectlimits IN typealllimitrec
		   ,paccountno    IN typeaccountno
		   ,ppan          IN typepan := NULL
		   ,pmbr          IN typembr := NULL
		) IS
			cmethodname CONSTANT typemethodname := updateobjectlimitsintwcms.cmethodname ||
												   '.LogObjectLimitsChange';
		
			vaddkey typehistaddkey;
		
			PROCEDURE loglimitchange
			(
				pnewvalue        IN NUMBER
			   ,pkey             IN typehistkey
			   ,paddkey          IN typehistaddkey
			   ,pparamnameforlog IN VARCHAR2
			   ,pparamdescr      IN VARCHAR2
			) IS
				cmethodname CONSTANT typemethodname := logobjectlimitschange.cmethodname ||
													   '.LogLimitChange';
				voldvalue NUMBER;
			BEGIN
				t.enter(cmethodname);
			
				voldvalue := nvl(contractparams.readlasthistoryvalue(scontractno, pkey, paddkey), 0);
			
				IF contracttools.notequal(voldvalue, pnewvalue)
				THEN
				
					contractparams.writehistory(scontractno
											   ,shistpackno
											   ,pkey
											   ,paddkey
											   ,pnewvalue
											   ,'Value of ' || pparamdescr ||
												' changed by operation "' ||
												getoperationdescr(poperation) || '"');
				
					a4mlog.cleanparamlist;
				
					a4mlog.addparamrec(pparamnameforlog, voldvalue, pnewvalue);
					a4mlog.addparamrec('LocalChange', htools.b2s(plocalchange));
					a4mlog.addparamrec('AccountNo', paccountno);
				
					IF ppan IS NOT NULL
					THEN
						a4mlog.addparamrec(contract.clogparam_pan, ppan);
						a4mlog.addparamrec('MBR', pmbr);
					END IF;
				
					a4mlog.logobject(object.gettype(contract.object_name)
									,scontractno
									,service.iif(ppan IS NULL, 'Account ', 'Account-card link ') ||
									 pparamdescr || ' value changed from ' ||
									 formatmoneywithabbr(voldvalue, pcurno) || ' to ' ||
									 formatmoneywithabbr(pnewvalue, pcurno) || ' by operation "' ||
									 getoperationdescr(poperation) || '" ' ||
									 service.iif(plocalchange, '(TWCMS only)', '(TWO and TWCMS)')
									,a4mlog.act_change
									,a4mlog.putparamlist
									,powner => getclientid);
				
				END IF;
			
				t.leave(cmethodname);
			EXCEPTION
				WHEN OTHERS THEN
					t.exc(cmethodname);
					error.save(cmethodname);
					RAISE;
			END loglimitchange;
		
		BEGIN
			t.enter(cmethodname);
		
			IF ppan IS NULL
			THEN
				vaddkey := getvaluebycurno(pcurno, 'DOM:', 'INT:') || 'ACCOUNT';
			ELSE
				vaddkey := getvaluebycurno(pcurno, 'DOM:', 'INT:') || ppan || '-' || pmbr;
			END IF;
		
			loglimitchange(pobjectlimits.estabcreditlimit
						  ,'CREDIT_LIMIT'
						  ,vaddkey
						  ,'CreditLimit'
						  ,'credit limit');
			loglimitchange(pobjectlimits.estabcashlimit
						  ,'CASH_LIMIT'
						  ,vaddkey
						  ,'CashLimitVal'
						  ,'cash limit');
			loglimitchange(pobjectlimits.usedcredlimit
						  ,'USED_CREDIT_LIMIT'
						  ,vaddkey
						  ,'UsedCredLimitVal'
						  ,'used credit limit');
			loglimitchange(pobjectlimits.usedcashlimit
						  ,'USED_CASH_LIMIT'
						  ,vaddkey
						  ,'UsedCashLimitVal'
						  ,'used cash limit');
			loglimitchange(pobjectlimits.usedinstallment
						  ,'USED_INSTALLMENT'
						  ,vaddkey
						  ,'UsedInstallmentVal'
						  ,'used installment');
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END logobjectlimitschange;
	
	BEGIN
		t.enter(cmethodname);
	
		scontrattrcalcflag.delete;
	
		slimittype := getlimittype_int(scontractno);
	
		vobjectlimits := getcontrattr_alllimits(scontractno, pcurno, ppan, pmbr);
	
		FOR i IN 1 .. 2
		LOOP
			vhasnewtrxns(i) := slastdocno.exists(i) AND
							   (slastdocno(i) <> nvl(contractparams.loadnumber(contractparams.ccontract
																			  ,scontractno
																			  ,'LastDocNo_' || i
																			  ,FALSE)
													,0));
		END LOOP;
	
		IF ppan IS NULL
		THEN
		
			s.say('Processing account ' || sdepaccount(pcurno).accountno);
		
			vneedupdate := vhasnewtrxns(pcurno);
		
			vasavedlimitslist := converttosparse(referencelimit.getaccountlimits(sdepaccount(pcurno)
																				 .accountno));
		
			vanewlimitslist := vasavedlimitslist;
		
			IF sdepaccount(pcurno).overdraft <> vobjectlimits.estabcreditlimit
			THEN
			
				IF poperation IN (ccontractcreation, cadjusting, cbatchparamchange)
				THEN
					addcreditlimittorollback(pcurno);
				END IF;
			
				contracttools.setoverdraft(sdepaccount(pcurno), vobjectlimits.estabcreditlimit);
			
			END IF;
		
			IF (slimittype <> caggregate)
			   OR (vobjectlimits.availcashlimitaggr IS NOT NULL)
			THEN
				setnewlimitparams(gettypelimitsetup(clk_cashlimit, pcurno)
								 ,sdepaccount(pcurno).accountno
								 ,NULL
								 ,NULL
								 ,nvl(vobjectlimits.availcashlimitaggr
									 ,vobjectlimits.availcashlimit)
								 ,nvl(vobjectlimits.usedcashlimitaggr, vobjectlimits.usedcashlimit)
								 ,vneedupdate);
			END IF;
		
			valimitarray := contracttypelimits.getlimitssettings(scontracttype
																,clk_addlimit
																,referencelimit.objtype_account
																,cco_primary
																,pcurno);
		
			FOR i IN 1 .. valimitarray.count
			LOOP
				setnewlimitparams(valimitarray(i)
								 ,sdepaccount(pcurno).accountno
								 ,NULL
								 ,NULL
								 ,contracttypelimits.calclimitvalue(valimitarray(i)
																   ,vobjectlimits.estabcreditlimit
																   ,sprecision(pcurno))
								 ,0
								 ,vneedupdate);
			END LOOP;
		
			savelimits(vanewlimitslist
					  ,vanewlimitsdata
					  ,referencelimit.objtype_account
					  ,sdepaccount(pcurno).accountno
					  ,NULL
					  ,NULL
					  ,vneedupdate);
		
			logobjectlimitschange(vobjectlimits, sdepaccount(pcurno).accountno);
		
		ELSE
		
			IF card.existaccountcardlink(ppan, pmbr, sdepaccount(pcurno).accountno)
			THEN
			
				vneedupdate := vhasnewtrxns(1) OR vhasnewtrxns(2);
			
				vasavedlimitslist := converttosparse(referencelimit.getacc2cardlimits(ppan
																					 ,pmbr
																					 ,sdepaccount(pcurno)
																					  .accountno));
			
				vanewlimitslist := vasavedlimitslist;
			
				setnewlimitparams(gettypelimitsetup(clk_creditlimit, pcurno, ppan, pmbr)
								 ,sdepaccount(pcurno).accountno
								 ,ppan
								 ,pmbr
								 ,nvl(vobjectlimits.availcreditlimitaggr
									 ,vobjectlimits.availcreditlimit)
								 ,nvl(vobjectlimits.usedcredlimitaggr, vobjectlimits.usedcredlimit)
								 ,vneedupdate);
			
				setnewlimitparams(gettypelimitsetup(clk_cashlimit, pcurno, ppan, pmbr)
								 ,sdepaccount(pcurno).accountno
								 ,ppan
								 ,pmbr
								 ,nvl(vobjectlimits.availcashlimitaggr
									 ,vobjectlimits.availcashlimit)
								 ,nvl(vobjectlimits.usedcashlimitaggr, vobjectlimits.usedcashlimit)
								 ,vneedupdate);
			
				savelimits(vanewlimitslist
						  ,vanewlimitsdata
						  ,referencelimit.objtype_acc2card
						  ,sdepaccount(pcurno).accountno
						  ,ppan
						  ,pmbr
						  ,vneedupdate);
			
				logobjectlimitschange(vobjectlimits, sdepaccount(pcurno).accountno, ppan, pmbr);
			
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END updateobjectlimitsintwcms;

	PROCEDURE updateallobjectslimitsintwcms
	(
		poperation   IN PLS_INTEGER
	   ,plocalchange IN BOOLEAN := TRUE
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UpdateAllObjectsLimitsInTWCMS';
		vcontractobjects typecontractobjects;
	BEGIN
		t.enter(cmethodname);
	
		contracttools.checkvalue_exists(scontractno, 'Contract number');
	
		getcontractobjects(vcontractobjects);
	
		FOR i IN 1 .. vcontractobjects.count
		LOOP
			updateobjectlimitsintwcms(vcontractobjects(i).curno
									 ,vcontractobjects(i).pan
									 ,vcontractobjects(i).mbr
									 ,poperation
									 ,plocalchange);
		END LOOP;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END updateallobjectslimitsintwcms;

	FUNCTION dlg_setobjectlimits_create
	(
		pcurno IN NUMBER
	   ,ppan   IN typepan := NULL
	   ,pmbr   IN typembr := NULL
	) RETURN NUMBER IS
		cmethodname  CONSTANT typemethodname := cpackagename || '.Dlg_SetObjectLimits_Create';
		chandlername CONSTANT typemethodname := cpackagename || '.Dlg_SetObjectLimits_Handler';
		cisaccount   CONSTANT BOOLEAN := ppan IS NULL;
	
		c_dialogwidth  CONSTANT NUMBER := 68;
		c_dialogheight CONSTANT NUMBER := 18;
	
		vcaption VARCHAR(50);
		vdialog  NUMBER;
		vpage    NUMBER;
	
		PROCEDURE createlimittypelist
		(
			pdialog    IN NUMBER
		   ,pitemname  IN typeitemname
		   ,px         IN NUMBER
		   ,py         IN NUMBER
		   ,plen       IN NUMBER
		   ,pcaption   IN VARCHAR2
		   ,phint      IN VARCHAR2
		   ,ptypeslist IN tblnumber
		) IS
			cmethodname CONSTANT typemethodname := dlg_setobjectlimits_create.cmethodname ||
												   '.CreateLimitTypeList';
		BEGIN
			dialog.inputchar(pdialog, pitemname, px, py, plen, phint, NULL, pcaption);
			dialog.listaddfield(pdialog, pitemname, 'ItemID', 'N', 1, 0);
			dialog.listaddfield(pdialog, pitemname, 'ItemName', 'C', 35, 1);
			dialog.setreadonly(pdialog, pitemname, TRUE);
			FOR i IN 1 .. ptypeslist.count
			LOOP
				dialog.listaddrecord(pdialog
									,pitemname
									,ptypeslist(i) || '~' || calimitcalcmethods(ptypeslist(i) + 1)
									,dialog.cmconfirm);
			END LOOP;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END createlimittypelist;
	
	BEGIN
		t.enter(cmethodname);
	
		IF cisaccount
		THEN
			vcaption := 'Account limit in ';
		ELSE
			vcaption := 'Card ' || masktodialog(ppan, pmbr) || ' limit in ';
		END IF;
	
		vdialog := dialog.new(vcaption ||
							  referencecurrency.getabbreviation(sdepaccount(pcurno).currencyno)
							 ,0
							 ,0
							 ,c_dialogwidth
							 ,c_dialogheight
							 ,pextid => cmethodname);
	
		dialog.hiddennumber(vdialog, citem_currency, pcurno);
		dialog.hiddenchar(vdialog, citem_pan, ppan);
		dialog.hiddennumber(vdialog, citem_mbr, pmbr);
	
		dialog.pagelist(vdialog, 'PAGER', 1, 1, 67, 12);
	
		vpage := dialog.page(vdialog, 'PAGER', 'Permanent limit');
	
		dialog.bevel(vpage, 1, 1, 66, 4, dialog.bevel_frame, TRUE, 'Credit limit setup');
		IF cisaccount
		THEN
			dialog.inputmoney(vpage, 'Limit', 27, 2, 'Value of limit', 'Limit value:');
		ELSE
			createlimittypelist(vpage
							   ,'CredLimitType'
							   ,27
							   ,2
							   ,35
							   ,'Limit calculation type:'
							   ,'Credit limit calculation type'
							   ,tblnumber(clmtastype, clmtnotdefined, clmttotal, clmtmax, clmtmin));
			dialog.inputmoney(vpage
							 ,'CredLimitAmount'
							 ,27
							 ,3
							 ,'Credit Limit flat amount value'
							 ,'Flat amount:');
			dialog.inputmoney(vpage
							 ,'CredLimitPrc'
							 ,27
							 ,4
							 ,'Credit Limit percentage value from Initial Limit value'
							 ,'Percentage value:');
		END IF;
	
		dialog.bevel(vpage, 1, 5, 66, 4, dialog.bevel_frame, TRUE, 'Cash limit setup');
		createlimittypelist(vpage
						   ,'CashLimitType'
						   ,27
						   ,6
						   ,35
						   ,'Limit calculation type:'
						   ,'Cash limit calculation type'
						   ,tblnumber(clmtastype, clmtnotdefined, clmttotal, clmtmax, clmtmin));
		dialog.inputmoney(vpage
						 ,'CashLimitAmount'
						 ,27
						 ,7
						 ,'Cash limit flat amount value'
						 ,'Flat amount:');
		dialog.inputmoney(vpage
						 ,'CashLimitPrc'
						 ,27
						 ,8
						 ,'Cash limit percentage value from initial limit value'
						 ,'Percentage value:');
	
		vpage := dialog.page(vdialog, 'PAGER', 'Temporary limit');
	
		dialog.bevel(vpage, 1, 1, 66, 5, dialog.bevel_frame, TRUE, 'Credit limit setup');
		IF cisaccount
		THEN
			createlimittypelist(vpage
							   ,'TempCredLimitType'
							   ,27
							   ,2
							   ,35
							   ,'Limit calculation type:'
							   ,'Temporary credit limit calculation type'
							   ,tblnumber(clmtnotused, clmtdefined));
			dialog.inputmoney(vpage
							 ,'TempCredLimitAmount'
							 ,27
							 ,3
							 ,'Value of limit'
							 ,'Limit value:');
			dlg_tools.element_datefromto_create(vpage
											   ,'TempCredLimitDate'
											   ,27
											   ,4
											   ,'Valid from:'
											   ,'Temporary credit limit activation date'
											   ,'Valid to:'
											   ,'Temporary credit limit expiration date'
											   ,TRUE
											   ,6);
		ELSE
			createlimittypelist(vpage
							   ,'TempCredLimitType'
							   ,27
							   ,2
							   ,35
							   ,'Limit calculation type:'
							   ,'Temporary credit limit calculation type'
							   ,tblnumber(clmtnotused, clmttotal, clmtmax, clmtmin));
			dialog.inputmoney(vpage
							 ,'TempCredLimitAmount'
							 ,27
							 ,3
							 ,'Temporary credit limit flat amount value'
							 ,'Flat amount:');
			dialog.inputmoney(vpage
							 ,'TempCredLimitPrc'
							 ,27
							 ,4
							 ,'Temporary credit limit percentage value from initial limit value'
							 ,'Percentage value:');
			dialog.inputdate(vpage
							,'TempCredLimitDate'
							,27
							,5
							,'Temporary credit limit expiration date'
							,'Valid to:');
		END IF;
		dialog.hiddenbool(vpage, 'TempCredLimitActive', NULL);
	
		dialog.bevel(vpage, 1, 6, 66, 5, dialog.bevel_frame, TRUE, 'Cash limit setup');
		createlimittypelist(vpage
						   ,'TempCashLimitType'
						   ,27
						   ,7
						   ,35
						   ,'Limit calculation type:'
						   ,'Temporary cash limit calculation type'
						   ,tblnumber(clmtnotused, clmttotal, clmtmax, clmtmin));
		dialog.inputmoney(vpage
						 ,'TempCashLimitAmount'
						 ,27
						 ,8
						 ,'Temporary cash limit flat amount value'
						 ,'Flat amount:');
		dialog.inputmoney(vpage
						 ,'TempCashLimitPrc'
						 ,27
						 ,9
						 ,'Temporary cash limit percentage value from initial limit value'
						 ,'Percentage value:');
		IF cisaccount
		THEN
			dlg_tools.element_datefromto_create(vpage
											   ,'TempCashLimitDate'
											   ,27
											   ,10
											   ,'Valid from:'
											   ,'Temporary cash limit activation date'
											   ,'Valid to:'
											   ,'Temporary cash limit expiration date'
											   ,TRUE
											   ,6);
		ELSE
			dialog.inputdate(vpage
							,'TempCashLimitDate'
							,27
							,10
							,'Temporary cash limit expiration date'
							,'Valid to:');
		END IF;
		dialog.hiddenbool(vpage, 'TempCashLimitActive', NULL);
	
		vpage := dialog.page(vdialog, 'PAGER', 'Used Limit');
		IF NOT cisaccount
		THEN
			dialog.bevel(vpage, 1, 1, 66, 2, dialog.bevel_frame, TRUE, 'Used credit limit');
			dialog.inputmoney(vpage
							 ,'UsedCredLimit'
							 ,27
							 ,2
							 ,'Used limit value'
							 ,'Used limit value:');
		END IF;
		dialog.bevel(vpage, 1, 3, 66, 2, dialog.bevel_frame, TRUE, 'Cash limit');
		dialog.inputmoney(vpage, 'UsedCashLimit', 27, 4, 'Used limit value', 'Used limit value:');
	
		dialog.inputcheck(vdialog
						 ,'DoOnline'
						 ,3
						 ,c_dialogheight - 4
						 ,21
						 ,'Set this checkbox to instantly aplly the changes to TWO'
						 ,'Apply changes online');
		dialog.putbool(vdialog, 'DoOnline', TRUE);
	
		dlg_tools.startbuttondrawing(c_dialogwidth, 2);
		dlg_tools.drawbutton(vdialog
							,cbtn_ok
							,'OK'
							,'Save changes and exit dialog'
							,c_dialogheight - 2
							,dialog.cmok
							,pdefault => TRUE);
		dlg_tools.drawbutton(vdialog
							,cbtn_cancel
							,'Cancel'
							,'Cancel changes and exit dialog'
							,c_dialogheight - 2
							,dialog.cmcancel);
	
		dialog.setdialogpre(vdialog, chandlername);
		dialog.setdialogvalid(vdialog, chandlername);
	
		t.leave(cmethodname);
		RETURN vdialog;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			dialog.destroy(vdialog);
			error.save(cmethodname);
			RAISE;
	END dlg_setobjectlimits_create;

	FUNCTION dlg_setobjectlimits_validate
	(
		pdialog           IN NUMBER
	   ,olimitsetuprecord IN OUT NOCOPY typeobjectlimitsettings
	   ,odoonline         OUT BOOLEAN
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_SetObjectLimits_Validate';
	
		PROCEDURE getlimitparams
		(
			pdialog        IN NUMBER
		   ,pitemprefix    IN typeitemname
		   ,olimitsettings OUT NOCOPY typelimitsettings
		   ,pistemplimit   IN BOOLEAN := FALSE
		) IS
			cmethodname CONSTANT typemethodname := dlg_setobjectlimits_validate.cmethodname ||
												   '.GetLimitParams';
		BEGIN
			t.enter(cmethodname, pitemprefix);
		
			olimitsettings.calcmethod := dlg_tools.getnumberfromlist(pdialog
																	,pitemprefix || 'Type'
																	,'ItemId'
																	,'Limit calculation type');
		
			IF olimitsettings.calcmethod IN (clmttotal, clmtmax, clmtmin, clmtdefined)
			THEN
			
				IF olimitsettings.calcmethod = clmtdefined
				THEN
				
					olimitsettings.amount := dlg_tools.getnumber(pdialog
																,pitemprefix || 'Amount'
																,'Limit value'
																,dlg_tools.cnum_nonnegative);
				
				ELSE
				
					olimitsettings.amount := dlg_tools.getnumber(pdialog
																,pitemprefix || 'Amount'
																,'Flat amount'
																,dlg_tools.cnum_nonnegative
																,pwhatisnull => 0);
				
					olimitsettings.percent := dlg_tools.getnumber(pdialog
																 ,pitemprefix || 'Prc'
																 ,'Percentage value'
																 ,dlg_tools.cnum_nonnegative
																 ,pwhatisnull => 0);
				
				END IF;
			
				IF pistemplimit
				THEN
				
					IF olimitsetuprecord.pan IS NOT NULL
					THEN
						olimitsettings.validto := dlg_tools.getdate(pdialog
																   ,pitemprefix || 'Date'
																   ,'Valid to'
																   ,dlg_tools.cdate_nodayoff);
					
					ELSE
						dlg_tools.element_datefromto_getvalue(pdialog
															 ,pitemprefix || 'Date'
															 ,olimitsettings.validfrom
															 ,olimitsettings.validto
															 ,dlg_tools.cdate_dayoffnow
															 ,ptodatecheckmode => dlg_tools.cdate_nodayoff);
					END IF;
				
					olimitsettings.active := dialog.getbool(pdialog, pitemprefix || 'Active');
				
				END IF;
			
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END getlimitparams;
	
	BEGIN
		t.enter(cmethodname);
	
		olimitsetuprecord.curno := dialog.getnumber(pdialog, citem_currency);
		olimitsetuprecord.pan   := dialog.getchar(pdialog, citem_pan);
		olimitsetuprecord.mbr   := dialog.getnumber(pdialog, citem_mbr);
	
		IF olimitsetuprecord.pan IS NOT NULL
		THEN
			getlimitparams(pdialog, 'CredLimit', olimitsetuprecord.credlimit);
		ELSE
			olimitsetuprecord.credlimit.amount     := dlg_tools.getnumber(pdialog
																		 ,'Limit'
																		 ,'Limit value'
																		 ,dlg_tools.cnum_nonnegative);
			olimitsetuprecord.credlimit.calcmethod := clmtdefined;
		END IF;
	
		getlimitparams(pdialog, 'CashLimit', olimitsetuprecord.cashlimit);
	
		getlimitparams(pdialog, 'TempCredLimit', olimitsetuprecord.tempcredlimit, TRUE);
	
		getlimitparams(pdialog, 'TempCashLimit', olimitsetuprecord.tempcashlimit, TRUE);
	
		IF olimitsetuprecord.pan IS NOT NULL
		THEN
			olimitsetuprecord.usedcredlimit.amount := dlg_tools.getnumber(pdialog
																		 ,'UsedCredLimit'
																		 ,'Used credit limit'
																		 ,dlg_tools.cnum_nonnegative
																		 ,pwhatisnull => 0);
		END IF;
	
		olimitsetuprecord.usedcashlimit.amount := dlg_tools.getnumber(pdialog
																	 ,'UsedCashLimit'
																	 ,'Used cash limit'
																	 ,dlg_tools.cnum_nonnegative
																	 ,pwhatisnull => 0);
	
		odoonline := dialog.getbool(pdialog, 'DoOnline');
	
		t.leave(cmethodname, htools.b2s(TRUE));
		RETURN TRUE;
	EXCEPTION
		WHEN dlg_tools.validate_error THEN
			t.leave(cmethodname, htools.b2s(FALSE));
			RETURN FALSE;
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_setobjectlimits_validate;

	PROCEDURE closetwo
	(
		oconnected  IN OUT BOOLEAN
	   ,psuccessful IN BOOLEAN
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CloseTWO';
	BEGIN
		t.enter(cmethodname
			   ,'Connected = ' || htools.b2s(oconnected) || ', Successful = ' ||
				htools.b2s(psuccessful));
	
		IF oconnected
		THEN
		
			IF psuccessful
			THEN
				remoteonline.committransaction;
			ELSE
				remoteonline.rollbacktransaction;
			END IF;
		
			remoteonline.logoff;
		
			oconnected := FALSE;
		
		END IF;
	
		t.leave(cmethodname, htools.b2s(oconnected));
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END closetwo;

	PROCEDURE dlg_setobjectlimits_save
	(
		ponewlimitsetup IN OUT NOCOPY typeobjectlimitsettings
	   ,poperation      IN PLS_INTEGER
	   ,pdoonline       IN BOOLEAN
	   ,pcheckscoring   IN BOOLEAN
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_SetObjectLimits_Save';
		ciscard     CONSTANT BOOLEAN := ponewlimitsetup.pan IS NOT NULL;
		cisaccount  CONSTANT BOOLEAN := NOT ciscard;
	
		voldcardlimits   typecardlimitvaluearray;
		vcardlist        apitypes.typecardlist;
		voldlimitsvalue  typelimitvaluerecord;
		vprocessoffline  BOOLEAN := TRUE;
		vonlineerrortext VARCHAR2(32767);
		vconnected       BOOLEAN := FALSE;
		vlimittype       NUMBER;
		vlimitsum        NUMBER;
		vdelta           NUMBER := 0;
		vcurno           NUMBER;
	
		voldlimitsetup typeobjectlimitsettings;
	
		vcredlimitchanged     BOOLEAN;
		vcashlimitchanged     BOOLEAN;
		vtempcredlimitchanged BOOLEAN;
		vtempcashlimitchanged BOOLEAN;
	
		vlimitsettingschanged BOOLEAN;
		vusedlimitschanged    BOOLEAN;
	
		vfimicomment VARCHAR2(100) := NULL;
	
		FUNCTION islimitsettingschanged
		(
			poldsettings IN typelimitsettings
		   ,pnewsettings IN typelimitsettings
		) RETURN BOOLEAN IS
			cmethodname CONSTANT typemethodname := dlg_setobjectlimits_save.cmethodname ||
												   '.IsLimitSettingsChanged';
			vresult BOOLEAN;
		BEGIN
			t.enter(cmethodname);
		
			vresult := contracttools.notequal(poldsettings.calcmethod, pnewsettings.calcmethod) OR
					   contracttools.notequal(poldsettings.amount, pnewsettings.amount) OR
					   contracttools.notequal(poldsettings.percent, pnewsettings.percent) OR
					   contracttools.notequal(poldsettings.validfrom, pnewsettings.validfrom) OR
					   contracttools.notequal(poldsettings.validto, pnewsettings.validto) OR
					   contracttools.notequal(poldsettings.active, pnewsettings.active);
		
			t.leave(cmethodname, htools.b2s(vresult));
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END islimitsettingschanged;
	
		PROCEDURE processlimit
		(
			ptypelimitsetup IN contracttypelimits.typelimitrecord
		   ,poldvalue       IN NUMBER
		   ,pnewvalue       IN NUMBER
		   ,poalimitarray   IN OUT NOCOPY apitypes.limit_array
		) IS
			cmethodname CONSTANT typemethodname := dlg_setobjectlimits_save.cmethodname ||
												   '.ProcessLimit';
			vfound BOOLEAN := FALSE;
			vindex PLS_INTEGER;
			vdelta NUMBER;
		BEGIN
			t.enter(cmethodname, 'OldValue = ' || poldvalue || ', NewValue = ' || pnewvalue);
		
			IF poldvalue <> pnewvalue
			THEN
			
				vdelta := pnewvalue - poldvalue;
			
				FOR i IN 1 .. poalimitarray.count
				LOOP
					IF poalimitarray(i).limitid = ptypelimitsetup.limitid
					THEN
						poalimitarray(i).maxvalue := greatest(poalimitarray(i).maxvalue + vdelta, 0);
						vfound := TRUE;
						EXIT;
					END IF;
				END LOOP;
			
				IF NOT vfound
				THEN
				
					vindex := poalimitarray.count + 1;
					poalimitarray(vindex).limitid := ptypelimitsetup.limitid;
					poalimitarray(vindex).maxvalue := pnewvalue;
					poalimitarray(vindex).curvalue := pnewvalue;
				
					IF ptypelimitsetup.periodtype IN
					   (referencelimit.periodtype_none
					   ,referencelimit.periodtype_week
					   ,referencelimit.periodtype_month
					   ,referencelimit.periodtype_year)
					THEN
						poalimitarray(vindex).periodtype := ptypelimitsetup.periodtype;
						poalimitarray(vindex).period := referencelimit.getlimitperiod(ptypelimitsetup.periodtype
																					 ,ptypelimitsetup.periodvalue
																					 ,0
																					 ,0);
					
					ELSIF ptypelimitsetup.periodtype IN
						  (referencelimit.periodtype_reset_in_refresh
						  ,contracttypelimits.periodtype_at_sd)
					THEN
						poalimitarray(vindex).periodtype := referencelimit.periodtype_reset_in_refresh;
					ELSE
						error.raiseerror('Internal error: unsupported period type <' ||
										 ptypelimitsetup.periodtype || '>!');
					END IF;
				
				END IF;
			
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END processlimit;
	
		PROCEDURE updatecard2acclimit
		(
			pcurno     IN NUMBER
		   ,plimittype IN PLS_INTEGER
		   ,poldlimit  IN typelimitvaluerecord
		   ,ppan       IN typepan
		   ,pmbr       IN typembr
		) IS
			cmethodname CONSTANT typemethodname := dlg_setobjectlimits_save.cmethodname ||
												   '.UpdateCard2AccLimit';
			vnewlimit typelimitvaluerecord;
			vlimitarr apitypes.limit_array;
			vcurno    NUMBER;
		BEGIN
			t.enter(cmethodname, pcurno);
		
			vnewlimit := getobjectlimits(pcurno, plimittype, ppan, pmbr);
		
			IF (poldlimit.credlimit <> vnewlimit.credlimit)
			   OR (poldlimit.cashlimit <> vnewlimit.cashlimit)
			THEN
			
				vcurno := CASE plimittype
							  WHEN caggregate THEN
							   getaggrlimitcurno
							  ELSE
							   pcurno
						  END;
			
				remoteonline.getacc2cardlimits(ppan
											  ,pmbr
											  ,sdepaccount(vcurno).accountno
											  ,plimitarr   => vlimitarr);
			
				processlimit(gettypelimitsetup(clk_creditlimit, pcurno, ppan, pmbr)
							,poldlimit.credlimit
							,vnewlimit.credlimit
							,vlimitarr);
				processlimit(gettypelimitsetup(clk_cashlimit, pcurno, ppan, pmbr)
							,poldlimit.cashlimit
							,vnewlimit.cashlimit
							,vlimitarr);
			
				remoteonline.setacc2cardlimits(ppan
											  ,pmbr
											  ,sdepaccount(vcurno).accountno
											  ,vlimitarr);
			
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END updatecard2acclimit;
	
		PROCEDURE updateacctlimits
		(
			pcurno     IN NUMBER
		   ,plimittype IN PLS_INTEGER
		   ,poldlimit  IN typelimitvaluerecord
		) IS
			cmethodname CONSTANT typemethodname := dlg_setobjectlimits_save.cmethodname ||
												   '.UpdateAcctLimits';
			vlimitarr apitypes.limit_array;
			vnewlimit typelimitvaluerecord;
			vcurno    NUMBER;
		BEGIN
			t.enter(cmethodname, pcurno);
		
			vnewlimit := getobjectlimits(pcurno, plimittype);
		
			t.var('Old cash limit', poldlimit.cashlimit);
			t.var('New cash limit', vnewlimit.cashlimit);
		
			IF vnewlimit.cashlimit <> poldlimit.cashlimit
			THEN
			
				vcurno := CASE plimittype
							  WHEN caggregate THEN
							   getaggrlimitcurno
							  ELSE
							   pcurno
						  END;
			
				remoteonline.getacctlimits(sdepaccount(vcurno).accountno, plimitarr => vlimitarr);
			
				processlimit(gettypelimitsetup(clk_cashlimit, pcurno)
							,poldlimit.cashlimit
							,vnewlimit.cashlimit
							,vlimitarr);
			
				remoteonline.setaccountlimits(sdepaccount(vcurno).accountno, vlimitarr);
			
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END updateacctlimits;
	
	BEGIN
		t.enter(cmethodname);
	
		SAVEPOINT sp_savelimits;
	
		IF poperation = csetcredlimit
		THEN
			startnewdocument;
		END IF;
	
		voldlimitsetup := getobjectlimitssetup(scontractno
											  ,ponewlimitsetup.curno
											  ,ponewlimitsetup.pan
											  ,ponewlimitsetup.mbr);
	
		processobjecttemplimits(voldlimitsetup, ponewlimitsetup, poperation);
	
		vcredlimitchanged     := islimitsettingschanged(voldlimitsetup.credlimit
													   ,ponewlimitsetup.credlimit);
		vcashlimitchanged     := islimitsettingschanged(voldlimitsetup.cashlimit
													   ,ponewlimitsetup.cashlimit);
		vtempcredlimitchanged := islimitsettingschanged(voldlimitsetup.tempcredlimit
													   ,ponewlimitsetup.tempcredlimit);
		vtempcashlimitchanged := islimitsettingschanged(voldlimitsetup.tempcashlimit
													   ,ponewlimitsetup.tempcashlimit);
	
		vlimitsettingschanged := vcredlimitchanged OR vcashlimitchanged OR vtempcredlimitchanged OR
								 vtempcashlimitchanged;
		vusedlimitschanged    := contracttools.notequal(voldlimitsetup.usedcredlimit.amount
													   ,ponewlimitsetup.usedcredlimit.amount) OR
								 contracttools.notequal(voldlimitsetup.usedcashlimit.amount
													   ,ponewlimitsetup.usedcashlimit.amount);
	
		IF vlimitsettingschanged
		   OR vusedlimitschanged
		THEN
		
			vlimittype := getlimittype_int(scontractno);
		
			IF vlimitsettingschanged
			THEN
			
				IF cisaccount
				THEN
				
					voldlimitsvalue := getobjectlimits(ponewlimitsetup.curno, vlimittype);
				
					vcardlist := contract.getcardlist(scontractno);
				
					FOR i IN 1 .. vcardlist.count
					LOOP
						voldcardlimits(vcardlist(i).pan || vcardlist(i).mbr) := getobjectlimits(ponewlimitsetup.curno
																							   ,vlimittype
																							   ,vcardlist            (i).pan
																							   ,vcardlist            (i).mbr);
					END LOOP;
				
				ELSE
					voldlimitsvalue := getobjectlimits(ponewlimitsetup.curno
													  ,vlimittype
													  ,ponewlimitsetup.pan
													  ,ponewlimitsetup.mbr);
				END IF;
			
			END IF;
		
			dml_limitsetup_updaterecord(ponewlimitsetup, poperation, FALSE, pcheckscoring);
		
			IF cisaccount
			THEN
			
				vlimitsum := sdepaccount(ponewlimitsetup.curno).overdraft;
			
				IF vcredlimitchanged
				   OR (vtempcredlimitchanged AND
				   (ponewlimitsetup.tempcredlimit.calcmethod = clmtnotused))
				THEN
				
					vlimitsum := ponewlimitsetup.credlimit.amount;
				
					vfimicomment := 'CRD_LIMIT=' || ponewlimitsetup.credlimit.amount || ';';
				
					IF vtempcredlimitchanged
					   AND (ponewlimitsetup.tempcredlimit.calcmethod = clmtnotused)
					THEN
						vfimicomment := vfimicomment || 'TEMP_CRD_LIMIT=OFF';
					END IF;
				
				END IF;
			
				IF vtempcredlimitchanged
				   AND (ponewlimitsetup.tempcredlimit.calcmethod = clmtdefined)
				THEN
				
					IF ponewlimitsetup.tempcredlimit.validfrom <= seance.getoperdate
					THEN
						vlimitsum := ponewlimitsetup.tempcredlimit.amount;
					END IF;
				
					vfimicomment := vfimicomment || 'TEMP_CRD_LIMIT=ON@' ||
									ponewlimitsetup.tempcredlimit.amount || '@' ||
									htools.d2s(ponewlimitsetup.tempcredlimit.validfrom) || '@' ||
									htools.d2s(ponewlimitsetup.tempcredlimit.validto);
				
				END IF;
			
				vdelta := vlimitsum - sdepaccount(ponewlimitsetup.curno).overdraft;
			
				IF vlimittype = caggregate
				THEN
				
					vcurno := getaggrlimitcurno;
				
					vdelta := sign(vdelta) *
							  contracttools.getsumincurrency(abs(vdelta)
															,sdepaccount(ponewlimitsetup.curno)
															 .currencyno
															,sdepaccount(vcurno).currencyno
															,sactparam(cctp_exchangerate));
				
				ELSE
					vcurno := ponewlimitsetup.curno;
				END IF;
			
			END IF;
		
			IF pdoonline
			   AND vlimitsettingschanged
			   AND (vlimittype <> cnotdefined)
			THEN
			
				BEGIN
				
					remoteonline.logon;
					vconnected := TRUE;
					remoteonline.begintransaction;
				
					IF ciscard
					THEN
					
						updatecard2acclimit(ponewlimitsetup.curno
										   ,vlimittype
										   ,voldlimitsvalue
										   ,ponewlimitsetup.pan
										   ,ponewlimitsetup.mbr);
					
					ELSE
					
						IF vfimicomment IS NOT NULL
						THEN
						
							IF vdelta > 0
							THEN
								remoteonline.accountcredit(sdepaccount (vcurno).accountno
														  ,vdelta
														  ,pfimicomment => vfimicomment);
							ELSE
								remoteonline.accountdebit(sdepaccount (vcurno).accountno
														 ,-vdelta
														 ,pfimicomment => vfimicomment);
							END IF;
						END IF;
					
						updateacctlimits(vcurno, vlimittype, voldlimitsvalue);
					
						FOR i IN 1 .. vcardlist.count
						LOOP
						
							IF vcardlist(i).pcstat <> referencecrd_stat.card_closed
							THEN
								updatecard2acclimit(ponewlimitsetup.curno
												   ,vlimittype
												   ,voldcardlimits(vcardlist(i)
																   .pan || vcardlist(i).mbr)
												   ,vcardlist(i).pan
												   ,vcardlist(i).mbr);
							END IF;
						END LOOP;
					
					END IF;
				
				EXCEPTION
					WHEN OTHERS THEN
					
						closetwo(vconnected, FALSE);
					
						vonlineerrortext := error.gettext;
					
						error.clear;
				END;
			
				IF vonlineerrortext IS NOT NULL
				THEN
				
					IF poperation = csetcredlimit
					THEN
						vprocessoffline := htools.ask('Warning'
													 ,'Error when changing limits in TWO:~~' ||
													  vonlineerrortext ||
													  '.~~Save changes in TWCMS only?');
					
					ELSE
						error.raiseerror(vonlineerrortext);
					END IF;
				
				END IF;
			
			END IF;
		
			IF vprocessoffline
			THEN
				BEGIN
				
					updateobjectlimitsintwcms(ponewlimitsetup.curno
											 ,ponewlimitsetup.pan
											 ,ponewlimitsetup.mbr
											 ,poperation
											 ,NOT pdoonline OR (vonlineerrortext IS NOT NULL));
				
					IF cisaccount
					THEN
						chargelimitchangefee(ponewlimitsetup.curno
											,cctp_lcf_acccredlmtprofileid
											,voldlimitsetup.credlimit.amount
											,ponewlimitsetup.credlimit.amount
											,poperation);
					END IF;
				
					closetwo(vconnected, TRUE);
				
					IF poperation = csetcredlimit
					THEN
						COMMIT;
					END IF;
				
				EXCEPTION
					WHEN OTHERS THEN
						t.exc(cmethodname, 'TWCMSUpdate');
					
						closetwo(vconnected, FALSE);
					
						RAISE;
				END;
			
			ELSE
				RAISE exccancelledbyuser;
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			ROLLBACK TO sp_savelimits;
			RAISE;
	END dlg_setobjectlimits_save;

	PROCEDURE dlg_setobjectlimits_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_SetObjectLimits_Handler';
	
		vnewlimitsetup typeobjectlimitsettings;
		vdoonline      BOOLEAN;
	
		PROCEDURE switchlimitfields(pitemname IN typeitemname) IS
			cmethodname CONSTANT typemethodname := dlg_setobjectlimits_handler.cmethodname ||
												   '.SwitchLimitFields';
			vitemname typeitemname := REPLACE(pitemname, 'TYPE');
			vneedshow BOOLEAN;
		BEGIN
		
			vneedshow := dialog.getcurrentrecordnumber(pdialog, pitemname, 'ItemId')
						 NOT IN (clmtnotused, clmtnotdefined, clmtastype);
		
			dialog.setvisible(pdialog, vitemname || 'Amount', vneedshow);
		
			IF dialog.existsitembyname(pdialog, vitemname || 'Prc')
			THEN
				dialog.setvisible(pdialog, vitemname || 'Prc', vneedshow);
			END IF;
		
			IF (dialog.getchar(pdialog, citem_pan) IS NULL)
			   AND dialog.existsitembyname(pdialog, vitemname || 'DateFrom')
			THEN
				dlg_tools.element_datefromto_setvisible(pdialog, vitemname || 'Date', vneedshow);
			
			ELSIF dialog.existsitembyname(pdialog, vitemname || 'Date')
			THEN
				dialog.setvisible(pdialog, vitemname || 'Date', vneedshow);
			END IF;
		
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END switchlimitfields;
	
		PROCEDURE putlimitparams
		(
			pdialog        IN NUMBER
		   ,pitemprefix    IN typeitemname
		   ,plimitsettings IN typelimitsettings
		   ,pistemplimit   IN BOOLEAN := FALSE
		) IS
			cmethodname CONSTANT typemethodname := dlg_setobjectlimits_handler.cmethodname ||
												   '.PutLimitParams';
		BEGIN
			t.enter(cmethodname, pitemprefix);
		
			dialog.setcurrecbyvalue(pdialog
								   ,pitemprefix || 'Type'
								   ,'ItemID'
								   ,plimitsettings.calcmethod);
		
			dialog.putnumber(pdialog, pitemprefix || 'Amount', plimitsettings.amount);
		
			IF dialog.existsitembyname(pdialog, pitemprefix || 'Prc')
			THEN
				dialog.putnumber(pdialog, pitemprefix || 'Prc', plimitsettings.percent);
			END IF;
		
			IF pistemplimit
			THEN
			
				IF dialog.getchar(pdialog, citem_pan) IS NULL
				THEN
				
					dlg_tools.element_datefromto_setvalue(pdialog
														 ,pitemprefix || 'Date'
														 ,coalesce(plimitsettings.validfrom
																  ,seance.getoperdate)
														 ,plimitsettings.validto);
				
					IF plimitsettings.active
					THEN
						dlg_tools.element_datefromto_enable(pdialog
														   ,pitemprefix || 'Date'
														   ,FALSE
														   ,TRUE);
					END IF;
				
					dialog.putbool(pdialog, pitemprefix || 'Active', plimitsettings.active);
				
				ELSE
					dialog.putdate(pdialog, pitemprefix || 'Date', plimitsettings.validto);
				END IF;
			
			END IF;
		
			switchlimitfields(pitemprefix || 'TYPE');
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END putlimitparams;
	
		PROCEDURE initdialog(pdialog IN NUMBER) IS
			cmethodname CONSTANT typemethodname := dlg_setobjectlimits_handler.cmethodname ||
												   '.InitDialog';
			vcurrentlimitsetup typeobjectlimitsettings;
		BEGIN
			t.enter(cmethodname);
		
			vcurrentlimitsetup := getobjectlimitssetup(scontractno
													  ,dialog.getnumber(pdialog, citem_currency)
													  ,dialog.getchar(pdialog, citem_pan)
													  ,dialog.getnumber(pdialog, citem_mbr));
		
			IF vcurrentlimitsetup.pan IS NULL
			THEN
				dialog.putnumber(pdialog, 'Limit', vcurrentlimitsetup.credlimit.amount);
			ELSE
				putlimitparams(pdialog, 'CredLimit', vcurrentlimitsetup.credlimit);
			END IF;
		
			putlimitparams(pdialog, 'CashLimit', vcurrentlimitsetup.cashlimit);
		
			putlimitparams(pdialog, 'TempCredLimit', vcurrentlimitsetup.tempcredlimit, TRUE);
		
			putlimitparams(pdialog, 'TempCashLimit', vcurrentlimitsetup.tempcashlimit, TRUE);
		
			IF vcurrentlimitsetup.pan IS NOT NULL
			THEN
				dialog.putnumber(pdialog, 'UsedCredLimit', vcurrentlimitsetup.usedcredlimit.amount);
			END IF;
		
			dialog.putnumber(pdialog, 'UsedCashLimit', vcurrentlimitsetup.usedcashlimit.amount);
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.show('Error initializing object limits dialog!', cmethodname);
				dialog.abort(pdialog);
		END initdialog;
	
	BEGIN
		t.enter(cmethodname
			   ,'What = ' || pwhat || ', Dialog = ' || pdialog || ', ItemName = ' || pitemname ||
				', Cmd = ' || pcmd);
	
		CASE pwhat
		
			WHEN dialog.wt_dialogpre THEN
				initdialog(pdialog);
			
			WHEN dialog.wtdialogvalid THEN
			
				CASE pcmd
				
					WHEN dialog.cmconfirm THEN
						switchlimitfields(pitemname);
						dialog.cancelclose(pdialog);
					
					WHEN dialog.cmok THEN
					
						IF dlg_setobjectlimits_validate(pdialog, vnewlimitsetup, vdoonline)
						THEN
							BEGIN
							
								getcontractdata;
							
								checkifobjectlimitcanbeset(vnewlimitsetup, csetcredlimit, pdialog);
							
								dlg_setobjectlimits_save(vnewlimitsetup
														,csetcredlimit
														,vdoonline
														,TRUE);
							
								updateallobjectslimitsintwcms(csetcredlimit, NOT vdoonline);
							EXCEPTION
							
								WHEN exccancelledbyuser THEN
									dialog.cancelclose(pdialog);
								
								WHEN OTHERS THEN
									dialog.cancelclose(pdialog);
									error.save(cmethodname);
									htools.showmessage('Error', error.getusertext);
									error.clear;
							END;
						END IF;
					
					ELSE
						NULL;
				END CASE;
			
			ELSE
				NULL;
		END CASE;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_setobjectlimits_handler;

	FUNCTION dlg_managelimits_create RETURN NUMBER IS
		cmethodname  CONSTANT typemethodname := cpackagename || '.Dlg_ManageLimits_Create';
		chandlername CONSTANT typemethodname := cpackagename || '.Dlg_ManageLimits_Handler';
	
		cdialogwidth  CONSTANT NUMBER := 80;
		cdialogheight CONSTANT NUMBER := 22;
	
		cpagewidth  CONSTANT NUMBER := cdialogwidth - 1;
		cpageheight CONSTANT NUMBER := 19;
	
		cmaxheight CONSTANT NUMBER := 18;
	
		vdialog NUMBER;
		vpage   NUMBER;
	
	BEGIN
		t.enter(cmethodname);
	
		vdialog := dialog.new(contractdlg.makedialogcaption(scontractno
														   ,contractdlg.c_cap_consetlimit)
							 ,0
							 ,0
							 ,cdialogwidth
							 ,cdialogheight
							 ,pextid => cmethodname);
		dialog.pagelist(vdialog, 'PAGER', 1, 1, cpagewidth, cpageheight);
	
		FOR i IN 1 .. 2
		LOOP
		
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			THEN
			
				vpage := dialog.page(vdialog
									,'PAGER'
									,referencecurrency.getabbreviation(sdepaccount(i).currencyno) ||
									 ' currency');
			
				dlg_tools.drawnestedbevel(vpage
										 ,1
										 ,1
										 ,cpagewidth - 1
										 ,cmaxheight
										 ,upper('Account limits'));
			
				dlg_tools.drawindicator_money(vpage
											 ,'AccCredLimit' || i
											 ,17
											 ,2
											 ,15
											 ,'Credit limit:'
											 ,'Value of credit limit'
											 ,sprecision(i));
				dlg_tools.drawindicator_money(vpage
											 ,'AccUsedCredLimit' || i
											 ,17
											 ,3
											 ,15
											 ,'Used:'
											 ,'Value of used credit limit'
											 ,sprecision(i));
				dlg_tools.drawindicator_date(vpage
											,'AccCredValidFrom' || i
											,49
											,2
											,'Valid from:'
											,'Temporary credit limit activation date');
				dlg_tools.drawindicator_date(vpage
											,'AccCredValidTo' || i
											,49
											,3
											,'Valid to:'
											,'Temporary credit limit expiration date');
			
				dialog.bevel(vpage, 1, 4, 60, 1, dialog.bevel_box);
			
				dlg_tools.drawindicator_money(vpage
											 ,'AccCashLimit' || i
											 ,17
											 ,5
											 ,15
											 ,'Cash limit:'
											 ,'Value of cash limit'
											 ,sprecision(i));
				dlg_tools.drawindicator_money(vpage
											 ,'AccUsedCashLimit' || i
											 ,17
											 ,6
											 ,15
											 ,'Used:'
											 ,'Value of used cash limit'
											 ,sprecision(i));
				dlg_tools.drawindicator_date(vpage
											,'AccCashValidFrom' || i
											,49
											,5
											,'Valid from:'
											,'Temporary cash limit activation date');
				dlg_tools.drawindicator_date(vpage
											,'AccCashValidTo' || i
											,49
											,6
											,'Valid to:'
											,'Temporary cash limit expiration date');
			
				dialog.bevel(vpage, 60, 1, 1, 6, dialog.bevel_frame);
			
				dialog.button(vpage
							 ,cbtn_setlimit || i
							 ,63
							 ,4
							 ,12
							 ,'Change'
							 ,0
							 ,0
							 ,'Press this button to change account limits');
				dialog.setitempost(vpage, cbtn_setlimit || i, chandlername);
			
				dlg_tools.drawnestedbevel(vpage
										 ,1
										 ,7
										 ,cpagewidth - 1
										 ,cmaxheight
										 ,upper('Card-account limits'));
			
				dialog.list(vpage, clist_cards || i, 3, 9, 72, 5, 'List of contract cards', TRUE);
				dialog.setcaption(vpage, clist_cards || i, 'PAN~MBR~Cardholder name');
				dialog.listaddfield(vpage, clist_cards || i, 'PAN', 'C', 20, 0);
				dialog.listaddfield(vpage, clist_cards || i, 'PAN_Mask', 'C', 20, 1);
				dialog.listaddfield(vpage, clist_cards || i, 'MBR', 'C', 3, 1);
				dialog.listaddfield(vpage, clist_cards || i, 'Client', 'C', 40, 1);
				dialog.setitemchange(vpage, clist_cards || i, chandlername);
				dialog.setitempost(vpage, clist_cards || i, chandlername);
			
				dlg_tools.drawindicator_money(vpage
											 ,'CardCredLimit' || i
											 ,17
											 ,16
											 ,15
											 ,'Credit limit:'
											 ,'Value of credit limit'
											 ,sprecision(i));
				dlg_tools.drawindicator_date(vpage
											,'CardCredValidDate' || i
											,44
											,16
											,'Valid to:'
											,'Temporary credit limit expiration date');
				dlg_tools.drawindicator_money(vpage
											 ,'CardUsedCredLimit' || i
											 ,62
											 ,16
											 ,15
											 ,'Used:'
											 ,'Value of used credit limit'
											 ,sprecision(i));
				dlg_tools.drawindicator_money(vpage
											 ,'CardCashLimit' || i
											 ,17
											 ,17
											 ,15
											 ,'Cash limit:'
											 ,'Value of cash limit'
											 ,sprecision(i));
				dlg_tools.drawindicator_date(vpage
											,'CardCashValidDate' || i
											,44
											,17
											,'Valid to:'
											,'Temporary cash limit expiration date');
				dlg_tools.drawindicator_money(vpage
											 ,'CardUsedCashLimit' || i
											 ,62
											 ,17
											 ,15
											 ,'Used:'
											 ,'Value of used cash limit'
											 ,sprecision(i));
			
			END IF;
		
		END LOOP;
	
		dialog.button(vdialog, cbtn_ok, 35, 21, 12, 'Exit', dialog.cmok, 0, 'Exit dialog');
		dialog.setdefault(vdialog, cbtn_ok);
	
		dialog.setdialogpre(vdialog, chandlername);
	
		t.leave(cmethodname);
		RETURN vdialog;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			dialog.destroy(vdialog);
			error.save(cmethodname);
			RAISE;
	END dlg_managelimits_create;

	PROCEDURE dlg_managelimits_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_ManageLimits_Handler';
	
		vobjectlimitsetup typeobjectlimitsettings;
		vlimitvalue       typelimitvaluerecord;
		vcurno            NUMBER := NULL;
	
		PROCEDURE refreshaccountinfo(pcurno IN NUMBER) IS
			cmethodname CONSTANT typemethodname := dlg_managelimits_handler.cmethodname ||
												   '.RefreshAccountInfo';
		BEGIN
			t.enter(cmethodname, pcurno);
		
			vobjectlimitsetup := getobjectlimitssetup(scontractno, pcurno);
			vlimitvalue       := calcobjectlimits(pcurno);
		
			dialog.putnumber(pdialog, 'AccCredLimit' || pcurno, vlimitvalue.credlimit);
			dialog.putnumber(pdialog
							,'AccUsedCredLimit' || pcurno
							,abs(least(sdepaccount(pcurno).remain, 0)));
		
			dialog.putdate(pdialog
						  ,'AccCredValidFrom' || pcurno
						  ,service.iif(vobjectlimitsetup.tempcredlimit.active
									  ,vobjectlimitsetup.tempcredlimit.validfrom
									  ,NULL));
			dialog.putdate(pdialog
						  ,'AccCredValidTo' || pcurno
						  ,service.iif(vobjectlimitsetup.tempcredlimit.active
									  ,vobjectlimitsetup.tempcredlimit.validto
									  ,NULL));
		
			dialog.putnumber(pdialog, 'AccCashLimit' || pcurno, vlimitvalue.cashlimit);
			dialog.putnumber(pdialog
							,'AccUsedCashLimit' || pcurno
							,vobjectlimitsetup.usedcashlimit.amount);
		
			dialog.putdate(pdialog
						  ,'AccCashValidFrom' || pcurno
						  ,service.iif(vobjectlimitsetup.tempcashlimit.active
									  ,vobjectlimitsetup.tempcashlimit.validfrom
									  ,NULL));
			dialog.putdate(pdialog
						  ,'AccCashValidTo' || pcurno
						  ,service.iif(vobjectlimitsetup.tempcashlimit.active
									  ,vobjectlimitsetup.tempcashlimit.validto
									  ,NULL));
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END refreshaccountinfo;
	
		PROCEDURE refreshcardinfo
		(
			pcurno IN NUMBER
		   ,ppan   IN typepan
		   ,pmbr   IN typembr
		) IS
			cmethodname CONSTANT typemethodname := dlg_managelimits_handler.cmethodname ||
												   '.RefreshCardInfo';
		BEGIN
			t.enter(cmethodname);
		
			IF pcurno IS NULL
			THEN
			
				vlimitvalue := getobjectlimits(pcurno, getlimittype_int(scontractno), ppan, pmbr);
			
			ELSE
			
				vobjectlimitsetup := getobjectlimitssetup(scontractno, pcurno, ppan, pmbr);
				vlimitvalue       := calcobjectlimits(pcurno, ppan, pmbr);
			
				dialog.putdate(pdialog
							  ,'CardCredValidDate' || pcurno
							  ,vobjectlimitsetup.tempcredlimit.validto);
				dialog.putdate(pdialog
							  ,'CardCashValidDate' || pcurno
							  ,vobjectlimitsetup.tempcashlimit.validto);
				dialog.putnumber(pdialog
								,'CardUsedCredLimit' || pcurno
								,vobjectlimitsetup.usedcredlimit.amount);
				dialog.putnumber(pdialog
								,'CardUsedCashLimit' || pcurno
								,vobjectlimitsetup.usedcashlimit.amount);
			
			END IF;
		
			dialog.putnumber(pdialog, 'CardCredLimit' || pcurno, vlimitvalue.credlimit);
			dialog.putnumber(pdialog, 'CardCashLimit' || pcurno, vlimitvalue.cashlimit);
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END refreshcardinfo;
	
		PROCEDURE initdialog(pdialog IN NUMBER) IS
			cmethodname CONSTANT typemethodname := dlg_managelimits_handler.cmethodname ||
												   '.InitDialog';
			vcardlist apitypes.typecardlist;
		BEGIN
			t.enter(cmethodname);
		
			vcardlist := contract.getcardlist(scontractno
											 ,pclientid4sorting => contract.getidclient(scontractno));
		
			FOR i IN 1 .. 2
			LOOP
				IF ifcurrencyisusedintype(i, scontracttype, scontractno)
				THEN
				
					refreshaccountinfo(i);
				
					FOR j IN 1 .. vcardlist.count
					LOOP
						dialog.listaddrecord(pdialog
											,clist_cards || i
											,vcardlist(j)
											 .pan || '~' || card.getmaskedpan(vcardlist(j).pan) || '~' || vcardlist(j).mbr || '~' || clientpersone.getpersonerecord(vcardlist(j).idclient).fio);
					END LOOP;
				
					IF vcardlist.exists(1)
					THEN
						refreshcardinfo(i, vcardlist(1).pan, vcardlist(1).mbr);
					END IF;
				END IF;
			END LOOP;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.show('Error initializing limits management dialog!', cmethodname);
				dialog.abort(pdialog);
		END initdialog;
	
		PROCEDURE runobjectlimitsdialog
		(
			pcurno     IN NUMBER
		   ,pisaccount IN BOOLEAN
		) IS
			cmethodname CONSTANT typemethodname := dlg_managelimits_handler.cmethodname ||
												   '.RunObjectLimitsDialog';
			vdialog NUMBER;
			vpan    typepan;
			vmbr    typembr;
		BEGIN
			t.enter(cmethodname);
		
			getcontractdata;
		
			vpan := dialog.getcurrentrecordchar(pdialog, clist_cards || pcurno, 'PAN');
			vmbr := dialog.getcurrentrecordchar(pdialog, clist_cards || pcurno, 'MBR');
		
			IF pisaccount
			THEN
				vdialog := dlg_setobjectlimits_create(pcurno);
			ELSE
				vdialog := dlg_setobjectlimits_create(pcurno, vpan, vmbr);
			END IF;
		
			IF dialog.exec(vdialog) = dialog.cmok
			THEN
			
				IF pisaccount
				THEN
					refreshaccountinfo(pcurno);
				END IF;
			
				IF vpan IS NOT NULL
				THEN
					refreshcardinfo(pcurno, vpan, vmbr);
				END IF;
			
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				dialog.destroy(vdialog);
				error.save(cmethodname);
				RAISE;
		END runobjectlimitsdialog;
	
	BEGIN
		t.enter(cmethodname
			   ,'What = ' || pwhat || ', Dialog = ' || pdialog || ', ItemName = ' || pitemname ||
				', Cmd = ' || pcmd);
	
		IF substr(pitemname, -1) IN ('1', '2')
		THEN
			vcurno := substr(pitemname, -1);
		END IF;
	
		CASE pwhat
		
			WHEN dialog.wt_dialogpre THEN
			
				initdialog(pdialog);
			
			WHEN dialog.wt_itempost THEN
			
				CASE pitemname
				
					WHEN cbtn_setlimit || vcurno THEN
						runobjectlimitsdialog(vcurno, TRUE);
					
					WHEN clist_cards || vcurno THEN
						runobjectlimitsdialog(vcurno, FALSE);
					
					ELSE
						NULL;
				END CASE;
			
			WHEN dialog.wt_itemchange THEN
				IF pitemname = clist_cards || vcurno
				THEN
					refreshcardinfo(vcurno
								   ,dialog.getcurrentrecordchar(pdialog
															   ,clist_cards || vcurno
															   ,'PAN')
								   ,dialog.getcurrentrecordchar(pdialog
															   ,clist_cards || vcurno
															   ,'MBR'));
				END IF;
			
			ELSE
				NULL;
		END CASE;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_managelimits_handler;

	FUNCTION getinstallmentrepaymentsum
	(
		pcurno IN NUMBER
	   ,precno IN NUMBER
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetInstallmentRepaymentSum';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		valinkedcontracts contractlink.typecontractarray;
		vatypes           tblnumber := tblnumber();
		vresult           NUMBER := 0;
	
	BEGIN
		t.enter(cmethodname, 'CurNo = ' || pcurno || ', RecNo = ' || precno);
	
		IF sactparam(cctp_useinst) = '1'
		THEN
		
			IF sactparam(cctp_instaddpay) = '1'
			THEN
				vatypes.extend(1);
				vatypes(vatypes.count) := cinstrep2mep;
			END IF;
		
			IF sactparam(cctp_instaddacc) = '1'
			THEN
				vatypes.extend(1);
				vatypes(vatypes.count) := cinstacc2mep;
			END IF;
		
			IF sactparam(cctp_instaddint) = '1'
			THEN
				vatypes.extend(1);
				vatypes(vatypes.count) := cinstint2mep;
			END IF;
		
			IF vatypes.count > 0
			THEN
			
				IF contractlink.getlinkno(scontractno
										 ,contractlink.cmain
										 ,valinkedcontracts
										 ,cinstlinkname
										 ,sdepaccount(pcurno).currencyno) > 0
				THEN
				
					SELECT greatest(nvl(SUM(ri.amount), 0) - nvl(SUM(ctl.paidamount), 0), 0)
					INTO   vresult
					FROM   tcontractrpmntinstallment ri
					JOIN   tcontracttrxnlist ctl
					ON     ctl.branch = ri.branch
					AND    ctl.docno = ri.docno
					AND    ctl.entryno = CASE ri.includemp
							   WHEN cinstint2mep THEN
								ri.intentryno
							   ELSE
								ri.payentryno
						   END
					WHERE  ri.branch = cbranch
					AND    ri.contractno = scontractno
					AND    ri.strecno = precno
					AND    ri.includemp MEMBER OF
					 vatypes
					AND    ri.loanno IN
						   (SELECT loanno
							 FROM   tcontracttrxninstallment
							 WHERE  branch = cbranch
							 AND    instcontractno IN (SELECT cno FROM TABLE(valinkedcontracts)));
				
				END IF;
			
			END IF;
		
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getinstallmentrepaymentsum;

	FUNCTION getduedate
	(
		pcontractno    IN typecontractno
	   ,pstatementdate IN DATE
	) RETURN DATE IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetDueDate';
		vstatementdate DATE;
		vresult        DATE := NULL;
	BEGIN
		t.enter(cmethodname, pstatementdate);
	
		vstatementdate := nvl(pstatementdate, getcurrentstdate(pcontractno));
		IF vstatementdate IS NOT NULL
		THEN
			vresult := contractcalendar.getpaymentduedate(getcalendarid(pcontractno)
														 ,vstatementdate);
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getduedate;

	FUNCTION getminpayment
	(
		pcontractno    IN VARCHAR
	   ,paccountno     IN VARCHAR
	   ,pstatementdate IN DATE
	) RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetMinPayment';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vcontracttype typecontracttype;
	
		vret NUMBER;
		CURSOR c1 IS
			SELECT recno
				  ,statementdate
			FROM   tcontractstcycle
			WHERE  branch = cbranch
			AND    contractno = pcontractno
			AND    statementdate <= pstatementdate
			ORDER  BY statementdate DESC;
	BEGIN
		FOR i IN c1
		LOOP
			vret := i.recno;
			s.say(cmethodname || ' -> Last Statement Date=' || i.statementdate);
			EXIT;
		END LOOP;
		IF vret IS NULL
		THEN
			RETURN NULL;
		END IF;
	
		vcontracttype := contract.gettype(pcontractno);
		contracttools.loadcontractaccount(contracttypeitems.getitemcode(vcontracttype
																	   ,'ItemDeposit' || slabel(1))
										 ,sdepaccount(1)
										 ,pcontractno);
		contracttools.loadcontractaccount(contracttypeitems.getitemcode(vcontracttype
																	   ,'ItemDeposit' || slabel(2))
										 ,sdepaccount(2)
										 ,pcontractno);
		IF sdepaccount(1).accountno = paccountno
			AND ifcurrencyisusedintype(1, vcontracttype, pcontractno)
		THEN
			SELECT minpayment
			INTO   vret
			FROM   tcontractstminpaymentdata
			WHERE  branch = cbranch
			AND    screcno = vret
			AND    currencynumber = 1;
		ELSIF sdepaccount(2).accountno = paccountno
			   AND ifcurrencyisusedintype(2, vcontracttype, pcontractno)
		THEN
			SELECT minpayment
			INTO   vret
			FROM   tcontractstminpaymentdata
			WHERE  branch = cbranch
			AND    screcno = vret
			AND    currencynumber = 2;
		ELSE
			RETURN NULL;
		END IF;
		RETURN vret;
	EXCEPTION
		WHEN no_data_found THEN
			RETURN NULL;
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getminpayment;

	FUNCTION getunpaidminpayment
	(
		pcontractno    IN typecontractno
	   ,paccountno     IN typeaccountno
	   ,pstatementdate IN DATE
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetUnpaidMinPayment';
		vdueamount NUMBER;
	BEGIN
		t.enter(cmethodname, paccountno);
	
		getdueamount(paccountno, pstatementdate, vdueamount, sdummynum);
	
		vdueamount := -vdueamount;
	
		t.leave(cmethodname, vdueamount);
		RETURN vdueamount;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getunpaidminpayment;

	FUNCTION getnextstatementdate
	(
		pcontractno    IN typecontractno
	   ,pstatementdate IN DATE
	   ,pdoexception   IN BOOLEAN := TRUE
	) RETURN DATE IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetNextStatementDate';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vresult DATE := NULL;
	BEGIN
		t.enter(cmethodname, pstatementdate);
	
		FOR i IN (SELECT nextstatementdate
				  FROM   tcontractstcycle
				  WHERE  branch = cbranch
				  AND    contractno = pcontractno
				  AND    nextstatementdate > pstatementdate
				  ORDER  BY nextstatementdate)
		LOOP
			vresult := i.nextstatementdate;
			EXIT;
		END LOOP;
	
		IF (vresult IS NULL)
		   AND pdoexception
		THEN
			error.raiseerror('Statement date not found for contract <' || pcontractno ||
							 '> since <' || htools.d2s(pstatementdate) || '>!');
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getnextstatementdate;

	FUNCTION getoverlimitperiod
	(
		pcontractno IN VARCHAR
	   ,paccountno  IN VARCHAR
	   ,pdate       IN DATE := NULL
	) RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetOverLimitPeriod';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		coperdate   CONSTANT DATE := seance.getoperdate;
		vdate      DATE;
		vcycles    NUMBER;
		vaccountno VARCHAR(20);
		vaccount   taccount%ROWTYPE;
	BEGIN
		scontractno := pcontractno;
	
		vaccountno := sch_rev_api.getoverlimitaccno(cbranch, paccountno);
		IF vaccountno IS NULL
		THEN
			RETURN 0;
		END IF;
		contracttools.loadcontractaccountbyaccno(vaccountno, vaccount, c_doexception);
		vdate := contracttools.getfirstnotnullremaindate(vaccountno
														,vaccount.createdate
														,nvl(pdate, coperdate));
	
		IF vdate IS NULL
		THEN
			RETURN 0;
		END IF;
	
		SELECT COUNT(*)
		INTO   vcycles
		FROM   tcontractstcycle
		WHERE  branch = cbranch
		AND    contractno = pcontractno
		AND    statementdate BETWEEN vdate AND nvl(pdate, coperdate);
		vcycles := greatest(vcycles - 1, 0);
		RETURN vcycles;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION getoverdueperiod
	(
		pcontractno IN typecontractno
	   ,paccountno  IN typeaccountno
	   ,pdate       IN DATE := NULL
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetOverduePeriod';
		cenddate    CONSTANT DATE := coalesce(pdate, seance.getoperdate);
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vresult    NUMBER := 0;
		vstartdate DATE;
	BEGIN
		t.enter(cmethodname, paccountno);
	
		initcontract(pcontractno);
	
		vstartdate := sdeldate(getcurnobyaccountno(paccountno));
	
		IF vstartdate IS NOT NULL
		THEN
		
			SELECT COUNT(*)
			INTO   vresult
			FROM   tcontractstcycle
			WHERE  branch = cbranch
			AND    contractno = pcontractno
			AND    statementdate BETWEEN vstartdate AND cenddate;
		
			vresult := greatest(vresult - 1, 0);
		
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getoverdueperiod;

	FUNCTION getoverduehistory
	(
		pcontractno IN typecontractno
	   ,pcurno      IN NUMBER
	) RETURN typepaidhistarray IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetOverdueHistory';
	BEGIN
		scontractno                          := pcontractno;
		scontracttype                        := contract.gettype(scontractno);
		contracttypeschema.scontractrow.no   := pcontractno;
		contracttypeschema.scontractrow.type := scontracttype;
		readsetupscheme(FALSE);
		getcontractdata;
		RETURN spaidhistarray(pcurno);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	PROCEDURE getoverdueinfo
	(
		paccountno     IN VARCHAR2
	   ,pcurnumber     IN NUMBER
	   ,pdate          IN DATE
	   ,ooverduedate   OUT DATE
	   ,ooverdueamount OUT NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetOverdueInfo';
		voverdueparameters custom_overdueparameterscalculation.typeoverdueparamsrecord;
	BEGIN
		t.enter(cmethodname);
	
		vdummypha      := custom_overdueparameterscalculation.getoverdueparameters(paccountno
																				  ,pcurnumber
																				  ,pdate
																				  ,sdelparam.overdueint
																				  ,voverdueparameters);
		ooverduedate   := voverdueparameters.overduedate;
		ooverdueamount := abs(voverdueparameters.overdueamount);
	
		t.outpar('oOverdueDate', ooverduedate);
		t.outpar('oOverdueAmount', ooverdueamount);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getoverdueinfo;

	PROCEDURE getoverduedate
	(
		paccountno     IN VARCHAR2
	   ,pcurnumber     IN NUMBER
	   ,pdate          IN DATE
	   ,ooverduedate   OUT DATE
	   ,ooverdueamount OUT NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetOverdueDate';
	BEGIN
		t.enter(cmethodname, paccountno);
	
		scontractno                          := contract.getcontractnobyaccno(paccountno);
		scontracttype                        := contract.gettype(scontractno);
		contracttypeschema.scontractrow.no   := scontractno;
		contracttypeschema.scontractrow.type := scontracttype;
		readsetupscheme(FALSE);
		getcontractdata(TRUE);
	
		getoverdueinfo(paccountno, pcurnumber, pdate, ooverduedate, ooverdueamount);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getoverduedate;

	PROCEDURE getdueamount
	(
		paccountno     IN VARCHAR
	   ,pdate          IN DATE
	   ,odueamount     OUT NUMBER
	   ,ooverdueamount OUT NUMBER
	) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetDueAmount';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		voverdueparameters custom_overdueparameterscalculation.typeoverdueparamsrecord;
		vcontracttype      typecontracttype;
		vcontractno        typecontractno;
		vcurno             NUMBER;
	
	BEGIN
		s.say(cmethodname || '    --<< BEGIN ', 1);
		s.say(cmethodname || '      - INPUT PARAMETERS:  pAccountNo = ' || paccountno ||
			  ', pDate = ' || htools.d2s(pdate));
		s.say(cmethodname, 1);
	
		vcurno := getcurrencynumberbyaccount(paccountno);
	
		SELECT a.no
		INTO   vcontractno
		FROM   tcontractitem a
		WHERE  a.branch = cbranch
		AND    a.key = paccountno;
		s.say(cmethodname || '      vContractNo = ' || vcontractno, 1);
	
		vcontracttype := contract.gettype(vcontractno);
		s.say(cmethodname || '      vContractType = ' || vcontracttype, 1);
	
		sdelparam.overdueint := contractparams.loadnumber(contractparams.ccontracttype
														 ,vcontracttype
														 ,'PERIODTYPE'
														 ,FALSE);
		s.say(cmethodname || '      sDelParam.OverdueInt = ' || sdelparam.overdueint, 1);
	
		spaidhistarray(vcurno) := custom_overdueparameterscalculation.getoverdueparameters(paccountno           => paccountno
																						  ,pcurrencynumber      => vcurno
																						  ,pdate                => pdate
																						  ,pconsideroverduefrom => sdelparam.overdueint
																						  ,ooverdueparameters   => voverdueparameters);
	
		odueamount     := -voverdueparameters.dueamount;
		ooverdueamount := -voverdueparameters.overdueamount;
		s.say(cmethodname || '      oDueAmount = ' || odueamount || ', oOverDueAmount = ' ||
			  ooverdueamount
			 ,1);
	
		s.say(cmethodname || '    -->> END ', 1);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getdueamount;

	PROCEDURE getcardlimitvalue
	(
		pcontractno    IN typecontractno
	   ,paccountno     IN typeaccountno
	   ,ppan           IN typepan
	   ,pmbr           IN typembr
	   ,ocredlimit     OUT NUMBER
	   ,ocashlimit     OUT NUMBER
	   ,ousedcredlimit OUT NUMBER
	   ,ousedcashlimit OUT NUMBER
	   ,pconsiderpb    IN BOOLEAN := FALSE
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCardLimitValue';
		vobjectlimitsetup typeobjectlimitsettings;
		vobjectlimit      typelimitvaluerecord;
		vcurno            NUMBER;
	BEGIN
		t.enter(cmethodname
			   ,'ContractNo = ' || pcontractno || ' AccountNo = ' || paccountno || ' Card = ' ||
				masktodebug(ppan, pmbr));
	
		initcontract(pcontractno);
	
		vcurno := getcurnobyaccountno(paccountno);
		t.var('vCurNo', vcurno);
	
		sprecision(vcurno) := referencecurrency.getprecision(sdepaccount(vcurno).currencyno);
	
		vobjectlimitsetup := getobjectlimitssetup(pcontractno, vcurno, ppan, pmbr);
		vobjectlimit      := calcobjectlimits(vcurno, ppan, pmbr, pconsiderpb);
	
		ocredlimit := vobjectlimit.credlimit;
		ocashlimit := vobjectlimit.cashlimit;
	
		IF ppan IS NULL
		THEN
			ousedcredlimit := abs(least(sdepaccount(vcurno).remain, 0));
		ELSE
			ousedcredlimit := vobjectlimitsetup.usedcredlimit.amount;
		END IF;
	
		ousedcashlimit := vobjectlimitsetup.usedcashlimit.amount;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcardlimitvalue;

	PROCEDURE getavailablelimit
	(
		pcontractno IN VARCHAR
	   ,olimitdom   OUT NUMBER
	   ,olimitint   OUT NUMBER
	) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetAvailableLimit';
		voverlimit typelimitarray;
		vacc1      NUMBER;
		vacc2      NUMBER;
	BEGIN
		scontractno   := pcontractno;
		scontracttype := contract.gettype(scontractno);
		contracttools.loadcontractaccount(contracttypeitems.getitemcode(scontracttype
																	   ,'ItemDeposit' || slabel(1))
										 ,sdepaccount(1)
										 ,scontractno);
		contracttools.loadcontractaccount(contracttypeitems.getitemcode(scontracttype
																	   ,'ItemDeposit' || slabel(2))
										 ,sdepaccount(2)
										 ,scontractno);
		sactparam(cctp_exchangerate) := contractparams.loadnumber(contractparams.ccontracttype
																 ,scontracttype
																 ,'ExchangeRate'
																 ,FALSE);
		IF getlimittype_int(scontractno) = caggregate
		THEN
			sprecision(1) := referencecurrency.getprecision(sdepaccount(1).currencyno);
			sprecision(2) := referencecurrency.getprecision(sdepaccount(2).currencyno);
			snotusedlimit(1) := greatest(sdepaccount(1).overdraft + sdepaccount(1).remain, 0);
			snotusedlimit(2) := greatest(sdepaccount(2).overdraft + sdepaccount(2).remain, 0);
			voverlimit(1) := overlimitcalc(1);
			voverlimit(2) := overlimitcalc(2);
		
			IF scardcount1 > 0
			THEN
				vacc1 := 1;
				vacc2 := 2;
			ELSE
				vacc1 := 2;
				vacc2 := 1;
			END IF;
			snotusedlimit(vacc1) := snotusedlimit(vacc1) +
									contracttools.getsumincurrency(snotusedlimit(vacc2)
																  ,sdepaccount(vacc2).currencyno
																  ,sdepaccount(vacc1).currencyno
																  ,sactparam(cctp_exchangerate));
		
			snotusedlimit(vacc2) := 0;
		
			olimitdom := snotusedlimit(1);
			olimitint := snotusedlimit(2);
		ELSE
			IF ifcurrencyisusedintype(1, scontracttype, scontractno)
			THEN
				olimitdom := sdepaccount(1).overdraft + sdepaccount(1).remain;
			ELSE
				olimitdom := 0;
			END IF;
			IF ifcurrencyisusedintype(2, scontracttype, scontractno)
			THEN
				olimitint := sdepaccount(2).overdraft + sdepaccount(2).remain;
			ELSE
				olimitint := 0;
			END IF;
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	PROCEDURE getcreditlastpayment
	(
		pcontractno IN VARCHAR
	   ,pcurrencyno IN NUMBER
	   ,odate       OUT DATE
	   ,oamount     OUT NUMBER
	) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetCreditLastPayment';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vcontracttype NUMBER;
		vdepaccount   contracttools.typeaccarray;
		vaccountno    VARCHAR(20);
		vdate         DATE;
		vamount       NUMBER;
		vmaxdate      DATE;
		vmaxamount    NUMBER := 0;
	
		PROCEDURE getpaydata(paccountno IN typeaccountno) IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetCreditLastPayment.GetPayData';
		BEGIN
			vdate   := NULL;
			vamount := 0;
			FOR i IN (SELECT a.amount
							,a.postdate
					  FROM   tcontracttrxnlist a
					  WHERE  a.branch = cbranch
					  AND    a.accountno = paccountno
					  AND    a.trantype = ctrxntype_repayment
					  ORDER  BY a.postdate DESC)
			LOOP
				vdate   := i.postdate;
				vamount := i.amount;
				EXIT;
			END LOOP;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END;
	BEGIN
		s.say(cmethodname || ' -> ContractNo =' || pcontractno);
		s.say(cmethodname || ' -> CurrencyNo =' || pcurrencyno);
		vcontracttype := contract.gettype(pcontractno);
		contracttools.loadcontractaccount(contracttypeitems.getitemcode(vcontracttype
																	   ,'ItemDeposit' || slabel(1))
										 ,vdepaccount(1)
										 ,pcontractno);
		contracttools.loadcontractaccount(contracttypeitems.getitemcode(vcontracttype
																	   ,'ItemDeposit' || slabel(2))
										 ,vdepaccount(2)
										 ,pcontractno);
		IF vdepaccount(1).accountno IS NOT NULL
			AND vdepaccount(1).currencyno = pcurrencyno
		THEN
			vaccountno := vdepaccount(1).accountno;
		ELSIF vdepaccount(2).accountno IS NOT NULL
			   AND vdepaccount(2).currencyno = pcurrencyno
		THEN
			vaccountno := vdepaccount(2).accountno;
		ELSE
			error.raiseerror('Cannot find account for currency <' || pcurrencyno || '>!');
		END IF;
		getpaydata(vaccountno);
		IF vdate IS NOT NULL
		THEN
			vmaxdate   := vdate;
			vmaxamount := vamount;
		END IF;
		odate   := vmaxdate;
		oamount := vmaxamount;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getcreditlastpayment;

	FUNCTION getdafvalue
	(
		pcontractno IN typecontractno
	   ,paccountno  IN typeaccountno
	   ,pdate       IN DATE
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetDAFValue';
		vdummy DATE;
	BEGIN
		RETURN getdafvalue(pcontractno, paccountno, pdate, sdummynum, vdummy);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getdafvalue;

	FUNCTION getdafvalue
	(
		pcontractno          IN typecontractno
	   ,paccountno           IN typeaccountno
	   ,pdate                IN DATE
	   ,osdbalance           OUT NUMBER
	   ,osd                  OUT DATE
	   ,pifneededroundresult BOOLEAN := TRUE
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetDAFValue';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vcontracttype  NUMBER;
		vdepaccount    contracttools.typeaccarray;
		vcur           NUMBER;
		vdafbasedon    NUMBER;
		vdafmethod     NUMBER;
		vdafamount     NUMBER;
		vdafprc        NUMBER;
		vusepayment    BOOLEAN;
		vrestrictmp    BOOLEAN;
		vnoarray       contractlink.typecontractarray;
		vlinkno        VARCHAR(25);
		vlinktype      NUMBER;
		vremainst      NUMBER;
		vminpayment    NUMBER;
		vrecno         NUMBER;
		vstatementdate DATE;
		vduedate       DATE;
		vbaseamount    NUMBER;
		vdueamount     NUMBER;
		vpaid          NUMBER;
		vlabel         types.arrstr20;
	
		vprofile   NUMBER;
		vstrec     tcontractstcycle%ROWTYPE;
		vparams    tcontractddreference%ROWTYPE;
		vgendaf    NUMBER;
		vdafgen4ct BOOLEAN;
	
		voverdueamountonpdate NUMBER;
		vdueamountonpdate     NUMBER;
	
		vrepaymentamounts custom_overdueparameterscalculation.type_repaym_unpaid_amnts_rec;
	BEGIN
	
		custom_overdueparameterscalculation.clearcache;
	
		vlabel(1) := 'EGP';
		vlabel(2) := 'USD';
		vdafgen4ct := nvl(contractparams.loadbool(contractparams.ccontracttype
												 ,contract.gettype(pcontractno)
												 ,'DAFGen4CType'
												 ,FALSE)
						 ,FALSE);
		vgendaf := nvl(contractparams.loadnumber(contractparams.ccontract
												,pcontractno
												,'GenDAF'
												,FALSE)
					  ,0);
	
		IF (vgendaf = cdaf_skip)
		   OR ((vgendaf = cdaf_default) AND (NOT vdafgen4ct))
		THEN
			RETURN NULL;
		END IF;
	
		SELECT nvl(MAX(recno), 0)
		INTO   vrecno
		FROM   tcontractstcycle
		WHERE  branch = cbranch
		AND    contractno = pcontractno
		AND    statementdate <= pdate;
		s.say(cmethodname || ' ->  RecNo=' || vrecno);
		IF vrecno = 0
		THEN
			RETURN 0;
		END IF;
		vcontracttype := contract.gettype(pcontractno);
		contracttools.loadcontractaccount(contracttypeitems.getitemcode(vcontracttype
																	   ,'ItemDeposit' || slabel(1))
										 ,vdepaccount(1)
										 ,pcontractno);
		contracttools.loadcontractaccount(contracttypeitems.getitemcode(vcontracttype
																	   ,'ItemDeposit' || slabel(2))
										 ,vdepaccount(2)
										 ,pcontractno);
		IF paccountno = vdepaccount(2).accountno
		THEN
			vcur := 2;
		ELSE
			vcur := 1;
		END IF;
		s.say(cmethodname || ' -> Cur=' || vcur);
		vlinkno := NULL;
		IF contractlink.getlinkno(pcontractno, contractlink.clink, vnoarray) > 0
		THEN
			vlinkno := vnoarray(1).cno;
		END IF;
		s.say(cmethodname || ' -> LinkNo=' || vlinkno);
	
		vprofile := contractddreference.loadvalue(contractddreference.ccontract
												 ,pcontractno
												 ,'DAFProfile' || slabel(vcur)
												 ,FALSE);
		IF vprofile IS NULL
		THEN
			IF NOT contractparams.loadbool(contractparams.ccontracttype, vcontracttype, 'CorpMode')
			THEN
				s.say(cmethodname || ' Use customer contract type personal settings');
				vprofile := contractddreference.loadvalue(contractddreference.ccontracttype
														 ,vcontracttype
														 ,'DAFProfile' || slabel(vcur)
														 ,FALSE);
			ELSE
				s.say(cmethodname || ' Use corporate settings');
				IF vlinkno IS NULL
				THEN
					error.raiseerror('Contract <' || pcontractno ||
									 '> must be linked to corporate contract');
				END IF;
				vlinktype := contract.gettype(vlinkno);
				s.say(cmethodname || ' -> LinkType =' || vlinktype);
				vprofile := contractddreference.loadvalue(contractddreference.ccontract
														 ,vlinkno
														 ,'DAFProfile' || vlabel(vcur)
														 ,FALSE);
				IF vprofile IS NULL
				THEN
					s.say(cmethodname || ' Use corporate contract type personal settings');
					vprofile := contractddreference.loadvalue(contractddreference.ccontracttype
															 ,vlinktype
															 ,'DAFProfile' || vlabel(vcur)
															 ,FALSE);
				ELSE
					s.say(cmethodname || ' Use corporate contract personal settings');
				END IF;
			END IF;
		ELSE
			s.say(cmethodname || ' Use customer contract personal settings');
		END IF;
		s.say(cmethodname || ' -> Profile' || vprofile);
		IF vprofile IS NULL
		THEN
			error.raiseerror('Direct Debit calculation profile is not defined for contract <' ||
							 pcontractno || '>');
		END IF;
	
		SELECT *
		INTO   vstrec
		FROM   tcontractstcycle
		WHERE  branch = cbranch
		AND    recno = vrecno;
		vstatementdate := vstrec.statementdate;
		vduedate       := vstrec.duedate;
		osd            := vstatementdate;
		s.say(cmethodname || ' ->  StatementDate(1)=' || vstatementdate);
		s.say(cmethodname || ' ->  DueDate(1)=' || vduedate);
	
		scontractddrecord.contractno        := pcontractno;
		scontractddrecord.statementdate     := vstrec.statementdate;
		scontractddrecord.duedate           := vstrec.duedate;
		scontractddrecord.duedatepass       := vstrec.lastduedate IS NOT NULL;
		scontractddrecord.nextstatementdate := vstrec.nextstatementdate;
		scontractddrecord.accountno         := paccountno;
		scontractddrecord.dafdate           := getdafgendate(pcontractno);
	
		vremainst                   := nvl(custom_overdueparameterscalculation.getlastpassedcycleinfo(paccountno, getcurrencynumberbyaccount(paccountno), vstatementdate + 1)
										   .sdamount
										  ,0);
		vremainst                   := abs(least(vremainst, 0));
		scontractddrecord.sdbalance := vremainst;
	
		vparams := contractddreference.getsettings(vprofile);
	
		vdafbasedon := vparams.ddbasedon;
		vdafmethod  := vparams.ddmethod;
		vdafamount  := vparams.ddamount;
		vdafprc     := vparams.ddprc;
		vusepayment := htools.i2b(vparams.ddusepayment);
		vrestrictmp := htools.i2b(vparams.ddrestrictmp);
	
		IF (vdafbasedon = 3)
		   AND (vduedate > pdate)
		THEN
			s.say(cmethodname || ' ->  Find Last Cycle');
			SELECT statementdate
				  ,duedate
				  ,recno
			INTO   vstatementdate
				  ,vduedate
				  ,vrecno
			FROM   tcontractstcycle
			WHERE  branch = cbranch
			AND    contractno = pcontractno
			AND    nextstatementdate = vstatementdate;
			s.say(cmethodname || ' ->  RecNo(2)=' || vrecno);
			s.say(cmethodname || ' ->  StatementDate(2)=' || vstatementdate);
			s.say(cmethodname || ' ->  DueDate(2)=' || vduedate);
			IF vstatementdate IS NULL
			THEN
				RETURN 0;
			END IF;
			vusepayment := TRUE;
		END IF;
		s.say(cmethodname || ' 1 =');
	
		osdbalance := vremainst;
		SELECT minpayment
		INTO   vminpayment
		FROM   tcontractstminpaymentdata
		WHERE  branch = cbranch
		AND    screcno = vrecno
		AND    currencynumber = vcur;
	
		IF vdafbasedon = 1
		THEN
			vrepaymentamounts := custom_overdueparameterscalculation.getrepaymentamounts(paccountno
																						,vcur
																						,pdate
																						,vstatementdate + 1);
			vbaseamount       := vremainst - vrepaymentamounts.revdebitoverplus;
		ELSE
			vbaseamount := vminpayment;
		END IF;
	
		s.say(cmethodname || ' 2 =');
		s.say(cmethodname || ' -> RemainSt =' || vremainst || ' MinPayment=' || vminpayment ||
			  ' StatementDate=' || vstatementdate);
		s.say(cmethodname || ' -> DAFBasedOn =' || vdafbasedon || ' DAFMethod=' || vdafmethod ||
			  ' DAFPrc=' || vdafprc || ' DAFAmount=' || vdafamount);
		s.say(cmethodname || ' -> BaseAmount(1) =' || vbaseamount);
		s.say(cmethodname || ' -> Currency  =' || vdepaccount(vcur).currencyno);
		s.say(cmethodname || ' -> Precision =' ||
			  referencecurrency.getprecision(vdepaccount(vcur).currencyno));
	
		IF pifneededroundresult
		THEN
			vbaseamount := round(vbaseamount * vdafprc / 100
								,referencecurrency.getprecision(vdepaccount(vcur).currencyno));
		ELSE
			vbaseamount := vbaseamount * vdafprc / 100;
		END IF;
		s.say(cmethodname || ' -> BaseAmount(2) =' || vbaseamount);
	
		IF vdafmethod = 1
		THEN
			vbaseamount := vbaseamount + vdafamount;
		ELSIF vdafmethod = 2
		THEN
			vbaseamount := greatest(vbaseamount, vdafamount);
		ELSE
			vbaseamount := least(vbaseamount, vdafamount);
		END IF;
		s.say(cmethodname || ' -> BaseAmount(3) =' || vbaseamount);
	
		vbaseamount := least(vbaseamount, vremainst);
		s.say(cmethodname || ' -> BaseAmount(4) =' || vbaseamount);
	
		IF vusepayment
		THEN
		
			s.say(cmethodname || ' -> Consider payment');
		
			IF vdafbasedon IN (2, 3)
			THEN
				getdueamount(paccountno, pdate, vdueamountonpdate, voverdueamountonpdate);
			END IF;
		
			IF vdafbasedon = 1
			THEN
				vpaid := vrepaymentamounts.paid;
			ELSIF vdafbasedon = 2
			THEN
				vpaid := vminpayment - abs(vdueamountonpdate);
			ELSIF vdafbasedon = 3
			THEN
				vpaid := vminpayment - abs(voverdueamountonpdate);
			END IF;
			s.say(cmethodname || ' -> vMinPayment = ' || vminpayment || ', vDueAmountOnPDate = ' ||
				  vdueamountonpdate || ', vOverdueAmountOnPDate = ' || voverdueamountonpdate ||
				  ', vPaid = ' || vpaid);
		
			vbaseamount := greatest(vbaseamount - greatest(vpaid, 0), 0);
		
		END IF;
	
		IF vrestrictmp
		THEN
			s.say(cmethodname || ' -> Restrict by MP');
			IF vusepayment
			THEN
				getdueamount(paccountno, pdate, vdueamount, sdummynum);
				t.var('vDueAmount', abs(vdueamount));
				vbaseamount := greatest(vbaseamount, abs(vdueamount));
			ELSE
				vbaseamount := greatest(vbaseamount, vminpayment);
			END IF;
		END IF;
	
		s.say(cmethodname || ' -> BaseAmount(5) =' || vbaseamount);
	
		IF pifneededroundresult
		THEN
			vbaseamount := round(vbaseamount
								,referencecurrency.getprecision(vdepaccount(vcur).currencyno));
		END IF;
	
		s.say(cmethodname || ' -> BaseAmount(6) =' || vbaseamount);
		RETURN vbaseamount;
	EXCEPTION
		WHEN contractparams.valuenotexists THEN
			error.saveraise(cmethodname
						   ,error.errorconst
						   ,'DAF generation settings are not defined!');
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getdafvalue;

	FUNCTION getcontractstinfo RETURN typecontractcyclerecord IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetContractStInfo';
	BEGIN
		RETURN scontractddrecord;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getcontractstinfo;

	FUNCTION getdafsettings
	(
		pcontractno IN typecontractno
	   ,paccountno  IN typeaccountno
	) RETURN typedafsetrecord IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetDAFSettings';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vcontracttype NUMBER;
		vdepaccount   contracttools.typeaccarray;
		vcur          NUMBER;
		vnoarray      contractlink.typecontractarray;
		vlinkno       VARCHAR(25);
		vlinktype     NUMBER;
		vlabel        types.arrstr20;
		vdafrec       typedafsetrecord;
		vprofile      NUMBER;
		vparams       tcontractddreference%ROWTYPE;
		vstrec        tcontractstcycle%ROWTYPE;
	BEGIN
		vlabel(1) := 'EGP';
		vlabel(2) := 'USD';
	
		vcontracttype := contract.gettype(pcontractno);
		contracttools.loadcontractaccount(contracttypeitems.getitemcode(vcontracttype
																	   ,'ItemDeposit' || slabel(1))
										 ,vdepaccount(1)
										 ,pcontractno);
		contracttools.loadcontractaccount(contracttypeitems.getitemcode(vcontracttype
																	   ,'ItemDeposit' || slabel(2))
										 ,vdepaccount(2)
										 ,pcontractno);
		IF paccountno = vdepaccount(2).accountno
		THEN
			vcur := 2;
		ELSE
			vcur := 1;
		END IF;
		s.say(cmethodname || ' -> Cur=' || vcur);
		vlinkno := NULL;
		IF contractlink.getlinkno(pcontractno, contractlink.clink, vnoarray) > 0
		THEN
			vlinkno := vnoarray(1).cno;
		END IF;
		s.say(cmethodname || ' -> LinkNo=' || vlinkno);
		CASE
		 nvl(contractparams.loadnumber(contractparams.ccontract, pcontractno, 'GenDAF', FALSE), 0)
			WHEN cdaf_default THEN
				vdafrec.generate := nvl(contractparams.loadbool(contractparams.ccontracttype
															   ,vcontracttype
															   ,'DAFGen4CType'
															   ,FALSE)
									   ,FALSE);
			WHEN cdaf_generate THEN
				vdafrec.generate := TRUE;
			WHEN cdaf_skip THEN
				vdafrec.generate := FALSE;
			ELSE
				error.raiseerror('Unknown DAF generation mode in contract settings!');
		END CASE;
	
		vprofile := contractddreference.loadvalue(contractddreference.ccontract
												 ,pcontractno
												 ,'DAFProfile' || slabel(vcur)
												 ,FALSE);
		IF vprofile IS NULL
		THEN
			IF NOT contractparams.loadbool(contractparams.ccontracttype, vcontracttype, 'CorpMode')
			THEN
				s.say(cmethodname || ' Use customer contract type personal settings');
				vprofile := contractddreference.loadvalue(contractddreference.ccontracttype
														 ,vcontracttype
														 ,'DAFProfile' || slabel(vcur)
														 ,FALSE);
			ELSE
				s.say(cmethodname || ' Use corporate settings');
				IF vlinkno IS NULL
				THEN
					error.raiseerror('Contract <' || pcontractno ||
									 '> must be linked to corporate contract');
				END IF;
				vlinktype := contract.gettype(vlinkno);
				s.say(cmethodname || ' -> LinkType =' || vlinktype);
				vprofile := contractddreference.loadvalue(contractddreference.ccontract
														 ,vlinkno
														 ,'DAFProfile' || vlabel(vcur)
														 ,FALSE);
				IF vprofile IS NULL
				THEN
					s.say(cmethodname || ' Use corporate contract type personal settings');
					vprofile := contractddreference.loadvalue(contractddreference.ccontracttype
															 ,vlinktype
															 ,'DAFProfile' || vlabel(vcur)
															 ,FALSE);
				ELSE
					s.say(cmethodname || ' Use corporate contract personal settings');
				END IF;
			END IF;
		ELSE
			s.say(cmethodname || ' Use customer contract personal settings');
		END IF;
	
		s.say(cmethodname || ' -> Profile' || vprofile);
		IF vprofile IS NULL
		THEN
			error.raiseerror('Direct Debit calculation profile is not defined for contract <' ||
							 pcontractno || '>');
		END IF;
	
		SELECT *
		INTO   vstrec
		FROM   tcontractstcycle
		WHERE  branch = cbranch
		AND    statementdate IS NOT NULL
		AND    rownum < 2
		ORDER  BY statementdate DESC;
		scontractddrecord.contractno        := pcontractno;
		scontractddrecord.statementdate     := vstrec.statementdate;
		scontractddrecord.duedate           := vstrec.duedate;
		scontractddrecord.duedatepass       := vstrec.lastduedate IS NOT NULL;
		scontractddrecord.nextstatementdate := vstrec.nextstatementdate;
	
		vparams := contractddreference.getsettings(vprofile);
	
		vdafrec.basedon    := vparams.ddbasedon;
		vdafrec.method     := vparams.ddmethod;
		vdafrec.amount     := vparams.ddamount;
		vdafrec.prc        := vparams.ddprc;
		vdafrec.usepayment := htools.i2b(vparams.ddusepayment);
		vdafrec.restrictmp := htools.i2b(vparams.ddrestrictmp);
	
		RETURN vdafrec;
	EXCEPTION
		WHEN contractparams.valuenotexists THEN
			error.saveraise(cmethodname
						   ,error.errorconst
						   ,'DAF generation settings are not defined');
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getdafsettings;

	FUNCTION checkvalue_exists
	(
		pvalue     IN DATE
	   ,pvaluename IN VARCHAR2
	) RETURN DATE IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CheckValue_Exists';
	BEGIN
		contracttools.checkvalue_exists(pvalue, pvaluename);
		RETURN pvalue;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END checkvalue_exists;

	FUNCTION getdebitentryamount
	(
		pcontractno    IN typecontractno
	   ,paccountno     IN typeaccountno
	   ,pstatementdate IN DATE
	   ,pstartdate     DATE := NULL
	   ,penddate       DATE := NULL
	   ,pident         IN VARCHAR2 := NULL
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetDebitEntryAmount';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vcycle     typebillingcycle;
		vstartdate DATE;
		venddate   DATE;
		vresult    NUMBER;
	
	BEGIN
		t.enter(cmethodname
			   ,'pContractNo = ' || pcontractno || ', pAccountNo = ' || paccountno ||
				', pStatementDate = ' || htools.d2s(pstatementdate) || ', pStartDate = ' ||
				htools.d2s(pstartdate) || ', pEndDate = ' || htools.d2s(penddate) || ', pIdent = ' ||
				pident);
	
		contracttools.checkvalue_exists(pcontractno, 'Contract number');
		contracttools.checkvalue_exists(paccountno, 'Account number');
	
		scontractno := pcontractno;
	
		IF nvl(pstartdate, penddate) IS NULL
		THEN
		
			contracttools.checkvalue_exists(pstatementdate, 'Statement date');
		
			IF NOT int_getcyclebydate(pstatementdate, vcycle)
			THEN
				t.leave(cmethodname, 0);
				RETURN 0;
			END IF;
		
			venddate := vcycle.nextstatementdate;
			IF vcycle.statementdate IS NULL
			THEN
				vstartdate := venddate - 1000;
			ELSE
				vstartdate := vcycle.statementdate + 1;
			END IF;
		
		ELSE
			vstartdate := checkvalue_exists(pstartdate, 'Period start date');
			venddate   := checkvalue_exists(penddate, 'Period end date');
		END IF;
	
		t.var('vStartDate', vstartdate);
		t.var('vEndDate', venddate);
	
		SELECT nvl(SUM(a.value), 0)
		INTO   vresult
		FROM   tentry          a
			  ,tdocument       b
			  ,treferenceentry e
		WHERE  a.branch = cbranch
		AND    a.debitaccount = paccountno
		AND    b.branch = a.branch
		AND    b.docno = a.docno
		AND    b.opdate BETWEEN vstartdate AND venddate
		AND    b.newdocno IS NULL
		AND    e.branch = a.branch
		AND    e.code = a.debitentcode
		AND    e.ident = nvl(pident, e.ident)
		AND    (e.ident IN ('OVERDUE_FEE_ON', 'OVERLIMIT_FEE_ON') OR
			  e.ident LIKE 'CHARGE_INTEREST_GROUP_%');
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getdebitentryamount;

	FUNCTION getlpfeeamount
	(
		pcontractno IN typecontractno
	   ,paccountno  IN typeaccountno
	   ,pdate       IN DATE
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetLPFeeAmount';
	BEGIN
		RETURN getdebitentryamount(pcontractno, paccountno, pdate, pident => 'OVERDUE_FEE_ON');
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getlpfeeamount;

	FUNCTION getolfeeamount
	(
		pcontractno IN typecontractno
	   ,paccountno  IN typeaccountno
	   ,pdate       IN DATE
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetOLFeeAmount';
	BEGIN
		RETURN getdebitentryamount(pcontractno, paccountno, pdate, pident => 'OVERLIMIT_FEE_ON');
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getolfeeamount;

	FUNCTION getinterestamount
	(
		pcontractno IN typecontractno
	   ,paccountno  IN typeaccountno
	   ,pgroup      IN NUMBER
	   ,pdate       IN DATE
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetInterestAmount';
	BEGIN
		RETURN getdebitentryamount(pcontractno
								  ,paccountno
								  ,pdate
								  ,pident => 'CHARGE_INTEREST_GROUP_' || pgroup);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getinterestamount;

	FUNCTION getolamount
	(
		pcontractno IN typecontractno
	   ,paccountno  IN typeaccountno
	   ,pdate       IN DATE
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetOLAmount';
		vcycle  typebillingcycle;
		vresult NUMBER := 0;
	BEGIN
		scontractno := pcontractno;
		IF int_getcyclebydate(pdate, vcycle)
		THEN
			vresult := abs(contracttools.get_eod_remain(paccountno, vcycle.nextstatementdate));
		END IF;
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getolamount;

	FUNCTION getminpaymenthistory(pcontractno IN typecontractno) RETURN typeminpayhistarray IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetMinPaymentHistory';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		varesult typeminpayhistarray;
		vcount   NUMBER := 0;
		vdate    DATE;
	BEGIN
		FOR i IN (SELECT a.statementdate
						,b.minpayment
						,b.currencynumber
				  FROM   tcontractstcycle          a
						,tcontractstminpaymentdata b
				  WHERE  a.branch = cbranch
				  AND    a.contractno = pcontractno
				  AND    b.branch = a.branch
				  AND    b.screcno = a.recno
				  ORDER  BY a.statementdate)
		LOOP
			IF i.statementdate IS NOT NULL
			THEN
				IF vdate IS NULL
				   OR vdate <> i.statementdate
				THEN
					vcount := vcount + 1;
					vdate  := i.statementdate;
				END IF;
				varesult(vcount).statementdate := i.statementdate;
				IF i.currencynumber = 1
				THEN
					varesult(vcount).amountdom := i.minpayment;
				ELSE
					varesult(vcount).amountint := i.minpayment;
				END IF;
			END IF;
		END LOOP;
		RETURN varesult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getminpaymenthistory;

	PROCEDURE getinterestamount
	(
		pcontractno           IN VARCHAR
	   ,oaprcarraydom         OUT NOCOPY typeprcchargearray
	   ,oaprcarrayint         OUT NOCOPY typeprcchargearray
	   ,oaovdfeeamount        OUT NOCOPY typenumber
	   ,oaovlfeeamount        OUT NOCOPY typenumber
	   ,osavedinterestcalclog OUT NOCOPY typeparsedinterestlog_tab
	   ,puserdefinedoperdate  IN DATE := NULL
	) IS
		cmethodname     CONSTANT VARCHAR2(80) := cpackagename || '.GetInterestAmount';
		cbranch         CONSTANT NUMBER := custom_seance.getbranch;
		cactualoperdate CONSTANT DATE := custom_seance.getoperdate;
		vcloseinfoarray typecloseinfoarray;
	BEGIN
		custom_seance.settempoperdate(nvl(puserdefinedoperdate, cactualoperdate));
	
		custom_s.say(cmethodname || ', OperDate = ' || htools.d2s(custom_seance.getoperdate) ||
					 ', cActualOperDate = ' || htools.d2s(cactualoperdate));
	
		IF custom_contracttypeschema.scontractrow.no IS NULL
		   OR pcontractno <> custom_contracttypeschema.scontractrow.no
		THEN
			SELECT *
			INTO   contracttypeschema.scontractrow
			FROM   tcontract
			WHERE  branch = cbranch
			AND    no = pcontractno;
			scontractno   := custom_contracttypeschema.scontractrow.no;
			scontracttype := custom_contracttypeschema.scontractrow.type;
			scontractstat := contract.getstatus(contracttypeschema.scontractrow.no);
			IF contract.checkstatus(scontractstat, contract.stat_close)
			THEN
				error.raiseerror('Contract is closed');
			END IF;
		END IF;
		readsetupscheme(FALSE);
		getcontractdata;
	
		vcloseinfoarray := calccontractforclose(TRUE);
	
		oaprcarraydom := sprcchargedom;
		oaprcarrayint := sprcchargeint;
	
		FOR i IN 1 .. 2
		LOOP
			IF vcloseinfoarray.exists(i)
			THEN
			
				oaovdfeeamount(i) := vcloseinfoarray(i).overduefee;
			
				oaovlfeeamount(i) := vcloseinfoarray(i).overlimitfee;
			END IF;
		END LOOP;
	
		osavedinterestcalclog := ssavedinterestcalclog;
	
		custom_seance.settempoperdate(cactualoperdate);
	
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			custom_seance.settempoperdate(cactualoperdate);
			RAISE;
	END getinterestamount;

	FUNCTION getcreditlimit
	(
		pcontractno IN VARCHAR
	   ,pcurrencyno IN NUMBER := NULL
	) RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetCreditLimit';
	BEGIN
		contracttools.loadcontractaccount(contracttypeitems.getitemcode(contract.gettype(pcontractno)
																	   ,'ItemDeposit' || slabel(1))
										 ,sdepaccount(1)
										 ,pcontractno);
		contracttools.loadcontractaccount(contracttypeitems.getitemcode(contract.gettype(pcontractno)
																	   ,'ItemDeposit' || slabel(2))
										 ,sdepaccount(2)
										 ,pcontractno);
		IF pcurrencyno IS NULL
		   OR pcurrencyno = nvl(sdepaccount(1).currencyno, 0)
		THEN
			RETURN sdepaccount(1).overdraft;
		END IF;
		IF pcurrencyno = nvl(sdepaccount(2).currencyno, 0)
		THEN
			RETURN sdepaccount(2).overdraft;
		END IF;
		error.saveraise(cmethodname
					   ,error.errorconst
					   ,'Incorrect currency number (' || pcurrencyno || ') for contract ' ||
						pcontractno);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION getstdatelist
	(
		pcontractno IN typecontractno
	   ,pstartdate  IN DATE
	   ,pposition   IN PLS_INTEGER
	   ,pcount      IN PLS_INTEGER
	) RETURN types.arrdate IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetStDateList';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vcalendarid  tcontractcalendar.calendarid%TYPE;
		vacontractsd tbldate := tbldate();
		vacalendarsd tbldate := tbldate();
		vresult      types.arrdate;
		vnextdd      DATE;
		vnextsd      DATE;
	
	BEGIN
		t.enter(cmethodname, pstartdate);
	
		SELECT nextstatementdate BULK COLLECT
		INTO   vacontractsd
		FROM   tcontractstcycle
		WHERE  branch = cbranch
		AND    contractno = pcontractno
		AND    nextstatementdate > pstartdate
		ORDER  BY nextstatementdate;
	
		t.var('Number of cycles in tContractStCycle', vacontractsd.count);
	
		vcalendarid := getcalendarid(pcontractno);
	
		IF vacontractsd.count > 0
		THEN
			t.note(cmethodname, 'Statement dates from tContractStCycle:');
			FOR i IN 1 .. vacontractsd.count
			LOOP
				t.var('vaContractSD(' || i || ')', vacontractsd(i));
			END LOOP;
			vnextdd := contractcalendar.getpaymentduedate(vcalendarid
														 ,vacontractsd(vacontractsd.count));
			vnextsd := contractcalendar.getnextstatementdate(vcalendarid, vnextdd);
			t.var('Found next DD', vnextdd);
			t.var('Found next SD', vnextsd);
		END IF;
	
		vnextsd := coalesce(vnextsd, contract.getcontractrecord(pcontractno).createdate);
	
		SELECT DAY BULK COLLECT
		INTO   vacalendarsd
		FROM   tcontractcalendar
		WHERE  branch = cbranch
		AND    calendarid = vcalendarid
		AND    sd = 1
		AND    DAY >= vnextsd
		AND    DAY > pstartdate
		ORDER  BY DAY;
	
		t.var('Number of cycles in calendar', vacalendarsd.count);
		IF vacalendarsd.count = 0
		THEN
			error.raiseerror('There are no statement dates in calendar <' || vcalendarid ||
							 '> after ' || htools.d2s(vnextsd));
		ELSE
			t.note(cmethodname, 'Statement Dates added from new calendar:');
			FOR i IN 1 .. vacalendarsd.count
			LOOP
				t.var('vaCalendarSD(' || i || ')', vacalendarsd(i));
				vacontractsd.extend;
				vacontractsd(vacontractsd.count) := vacalendarsd(i);
			END LOOP;
		END IF;
	
		SELECT * BULK COLLECT
		INTO   vresult
		FROM   (SELECT * FROM TABLE(vacontractsd) ORDER BY 1)
		WHERE  rownum <= pcount + pposition
		
		MINUS
		
		SELECT * FROM (SELECT * FROM TABLE(vacontractsd) ORDER BY 1) WHERE rownum <= pposition;
	
		t.var('vResult.count', vresult.count);
	
		s.say(cmethodname || ' Final SD array:');
		FOR i IN 1 .. vresult.count
		LOOP
			t.var('vResult(' || i || ')', vresult(i));
		END LOOP;
	
		IF vresult.count < pcount
		THEN
			error.raiseerror('The number of statement dates for customer contract <' ||
							 pcontractno || '> is less than the number of cycles requested (' ||
							 pcount || ')!');
		END IF;
		vresult(0) := pstartdate;
	
		t.leave(cmethodname);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getstdatelist;

	FUNCTION getcontractstate(pcontractno IN typecontractno) RETURN contractstatereference.typestateid IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetContractState';
		vcontracttype typecontracttype;
	BEGIN
		t.enter(cmethodname);
	
		scontractno                          := pcontractno;
		vcontracttype                        := contract.gettype(scontractno);
		contracttypeschema.scontractrow.type := vcontracttype;
		contracttypeschema.scontractrow.no   := pcontractno;
		IF nvl(scontracttype, 0) <> vcontracttype
		THEN
			scontracttype := vcontracttype;
			readsetupscheme(FALSE);
		END IF;
		getcontractdata;
	
		t.leave(cmethodname, sblockparam.stateid);
		RETURN sblockparam.stateid;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcontractstate;

	FUNCTION getstcyclelist
	(
		pcontractno IN typecontractno
	   ,pstartdate  DATE := NULL
	   ,penddate    DATE := NULL
	) RETURN typestcyclearray IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetStCycleList';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vresult typestcyclearray;
	BEGIN
		FOR i IN (SELECT *
				  FROM   tcontractstcycle
				  WHERE  branch = cbranch
				  AND    contractno = pcontractno
				  AND    statementdate IS NOT NULL
				  ORDER  BY statementdate)
		LOOP
			IF i.statementdate >= nvl(pstartdate, i.statementdate)
			   AND i.statementdate <= nvl(penddate, i.statementdate)
			THEN
				vresult(vresult.count + 1).statementdate := i.statementdate;
				vresult(vresult.count).nextstatementdate := i.nextstatementdate;
				vresult(vresult.count).duedate := i.duedate;
			END IF;
		END LOOP;
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getstcyclelist;

	FUNCTION getstcyclefulllist
	(
		pcontractno IN VARCHAR
	   ,pstartdate  DATE := NULL
	   ,penddate    DATE := NULL
	) RETURN typestcyclefullinfoarray IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetStCycleFullList';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vstcarr typestcyclefullinfoarray;
		vcount  NUMBER := 0;
	
		FUNCTION getcurrentmp
		(
			precno    IN NUMBER
		   ,pcurrency IN NUMBER
		) RETURN NUMBER IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename ||
												 '.GetStCycleFullList.GetMinPayment';
			vminpayment NUMBER;
		BEGIN
			s.say(cmethodname || ' RecNo=' || precno || ' Ccy=' || pcurrency, 1);
			SELECT minpayment
			INTO   vminpayment
			FROM   tcontractstminpaymentdata
			WHERE  branch = cbranch
			AND    screcno = precno
			AND    currencynumber = pcurrency;
			RETURN vminpayment;
		EXCEPTION
			WHEN no_data_found THEN
				RETURN 0;
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END;
	BEGIN
		s.say(cmethodname || ' start', 1);
		FOR i IN (SELECT *
				  FROM   tcontractstcycle
				  WHERE  branch = cbranch
				  AND    contractno = pcontractno
				  AND    statementdate IS NOT NULL
				  ORDER  BY statementdate)
		LOOP
			IF i.statementdate >= nvl(pstartdate, i.statementdate)
			   AND i.statementdate <= nvl(penddate, i.statementdate)
			THEN
				vcount := vcount + 1;
				vstcarr(vcount).statementdate := i.statementdate;
				vstcarr(vcount).duedate := i.duedate;
				vstcarr(vcount).duedatepass := i.lastduedate IS NOT NULL;
				vstcarr(vcount).nextstatementdate := i.nextstatementdate;
				vstcarr(vcount).minpaymentdom := getcurrentmp(i.recno, 1);
				vstcarr(vcount).minpaymentint := getcurrentmp(i.recno, 2);
			END IF;
		END LOOP;
		s.say(cmethodname || ' end', 1);
		RETURN vstcarr;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION getcontractinterestsetuplog
	(
		pcontractno    IN typecontractno
	   ,pcurno         IN NUMBER
	   ,pstatementdate IN DATE
	) RETURN typecontractintsetuplogarray IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetContractInterestSetupLog';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vresult typecontractintsetuplogarray;
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		SELECT l.groupid
			  ,eg.groupname
			  ,l.calcinfo BULK COLLECT
		INTO   vresult
		FROM   tcontractinterestsetuplog l
		JOIN   tcontractentrygroup eg
		ON     eg.branch = l.branch
		AND    eg.groupid = l.groupid
		WHERE  l.branch = cbranch
		AND    l.contractno = pcontractno
		AND    l.currencynumber = pcurno
		AND    l.statementdate = pstatementdate
		ORDER  BY l.groupid;
	
		t.leave(cmethodname, vresult.count);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcontractinterestsetuplog;

	FUNCTION getprevstdate(pcontractno IN typecontractno) RETURN DATE IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetPrevStDate';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vstatementdate DATE;
		vcurstdate     DATE;
	BEGIN
		vcurstdate := getcurrentstdate(pcontractno);
		IF vcurstdate IS NULL
		THEN
			RETURN NULL;
		END IF;
		SELECT statementdate
		INTO   vstatementdate
		FROM   tcontractstcycle
		WHERE  branch = cbranch
		AND    contractno = pcontractno
		AND    nextstatementdate = vcurstdate;
		RETURN vstatementdate;
	EXCEPTION
		WHEN no_data_found THEN
			RETURN NULL;
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION getcurrentstdate(pcontractno IN typecontractno) RETURN DATE IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetCurrentStDate';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vresult DATE;
	BEGIN
		SELECT MAX(statementdate)
		INTO   vresult
		FROM   tcontractstcycle
		WHERE  branch = cbranch
		AND    contractno = pcontractno
		AND    statementdate IS NOT NULL;
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getcurrentstdate;

	FUNCTION getnextstdate(pcontractno IN typecontractno) RETURN DATE IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetNextStDate';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vresult DATE;
	BEGIN
		SELECT MAX(nextstatementdate)
		INTO   vresult
		FROM   tcontractstcycle
		WHERE  branch = cbranch
		AND    contractno = pcontractno;
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getnextstdate;

	FUNCTION getprintedduedate
	(
		pcontractno    IN typecontractno
	   ,pstatementdate IN DATE
	) RETURN DATE IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetPrintedDueDate';
		vstatementdate DATE;
		vresult        DATE := NULL;
	BEGIN
		t.enter(cmethodname, pstatementdate);
	
		vstatementdate := nvl(pstatementdate, getcurrentstdate(pcontractno));
		IF vstatementdate IS NOT NULL
		THEN
			vresult := contractcalendar.getprintedduedate(getcalendarid(pcontractno)
														 ,vstatementdate);
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getprintedduedate;

	FUNCTION getdafgendate(pcontractno IN typecontractno) RETURN DATE IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetDAFGenDate';
		vstatementdate DATE;
		vresult        DATE := NULL;
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		vstatementdate := getcurrentstdate(pcontractno);
		IF vstatementdate IS NOT NULL
		THEN
			vresult := contractcalendar.getdafdate(getcalendarid(pcontractno), vstatementdate);
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getdafgendate;

	PROCEDURE setispromoperiodforplsql(pispromo IN BOOLEAN) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.SetIsPromoPeriodForPLSQL';
	BEGIN
		splsql_ispromoperiod := pispromo;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	PROCEDURE setvaluesforplsql
	(
		pshieldvalue         IN NUMBER
	   ,pdiscountshieldvalue IN NUMBER
	   ,pdepaccountbalance   IN NUMBER
	   ,poverlimit           IN NUMBER
	   ,punpaidmp            IN NUMBER
	   ,poverduemp           IN NUMBER
	   ,psdbalanceod         IN NUMBER
	   ,psdbalancedd         IN NUMBER
	   ,pstateid             IN contractstatereference.typestateid
	) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.SetValuesForPLSQL';
	BEGIN
		splsql_shieldvalue         := pshieldvalue;
		splsql_discountshieldvalue := pdiscountshieldvalue;
		splsql_depaccountbalance   := pdepaccountbalance;
		splsql_overlimit           := poverlimit;
		splsql_minpaymentod        := punpaidmp;
		splsql_minpaymentdd        := poverduemp;
		splsql_sdbalanceod         := psdbalanceod;
		splsql_sdbalancedd         := psdbalancedd;
		splsql_delinqstateid       := pstateid;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END setvaluesforplsql;

	FUNCTION getdiscountshieldfromplsql RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetDiscountShieldFromPLSQL';
	BEGIN
		RETURN splsql_discountshieldvalue;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	PROCEDURE plsql_setdiscountshield(pdiscountvalue IN NUMBER) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.PLSQL_SetDiscountShield';
	BEGIN
		splsql_discountshieldvalue := pdiscountvalue;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION plsql_ispromoperiod RETURN BOOLEAN IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.PLSQL_IsPromoPeriod';
	BEGIN
		RETURN splsql_ispromoperiod;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION plsql_getshieldvalue RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.PLSQL_GetShieldValue';
	BEGIN
		RETURN splsql_shieldvalue;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION plsql_getdiscountshieldvalue RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.PLSQL_GetDiscountShieldValue';
	BEGIN
		RETURN splsql_discountshieldvalue;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION plsql_getbalance RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.PLSQL_GetBalance';
	BEGIN
		RETURN splsql_depaccountbalance;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION plsql_getoverlimit RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.PLSQL_GetOverlimit';
	BEGIN
		RETURN splsql_overlimit;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION plsql_getunpaidmp RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.PLSQL_GetUnPaidMP';
	BEGIN
		RETURN splsql_minpaymentod;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION plsql_getoverduemp RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.PLSQL_GetOverdueMP';
	BEGIN
		RETURN splsql_minpaymentdd;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION plsql_getsdbalanceod RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.PLSQL_GetSDBalanceOD';
	BEGIN
		RETURN splsql_sdbalanceod;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION plsql_getsdbalancedd RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.PLSQL_GetSDBalanceDD';
	BEGIN
		RETURN splsql_sdbalancedd;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION plsql_getdelinqstateid RETURN contractstatereference.typestateid IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.PLSQL_GetDelinqStateId';
	BEGIN
		RETURN splsql_delinqstateid;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	PROCEDURE savechecktrxnlisterr
	(
		paccountno   IN typeaccountno
	   ,pcurno       IN NUMBER
	   ,ptranamount  IN NUMBER
	   ,pentryamount IN NUMBER
	) IS
		PRAGMA AUTONOMOUS_TRANSACTION;
		cmethodname CONSTANT typemethodname := cpackagename || '.SaveCheckTrxnListErr';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		coperdate   CONSTANT DATE := seance.getoperdate;
	BEGIN
		INSERT INTO tcontracttrxnerrors
		VALUES
			(cbranch
			,scontractno
			,paccountno
			,pcurno
			,coperdate
			,SYSDATE
			,'TranAmount=' || ptranamount || ';EntryAmount=' || pentryamount || ';sDocNo=' ||
			 sdocno || ';sLastDocNo=' || slastdocno(pcurno));
		COMMIT;
	EXCEPTION
		WHEN OTHERS THEN
			ROLLBACK;
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END savechecktrxnlisterr;

	FUNCTION checktrxnlist
	(
		pcurno     IN NUMBER
	   ,poperation IN PLS_INTEGER := cadjusting
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CheckTrxnList';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vcurrentcycle typebillingcycle;
		ventryamount  NUMBER;
		vtranamount   NUMBER;
		vresult       BOOLEAN;
	
	BEGIN
		t.enter(cmethodname, pcurno);
	
		SELECT nvl(SUM(amount), 0)
		INTO   vtranamount
		FROM   (SELECT - (amount - nvl(paidamount, 0)) amount
				FROM   tcontracttrxnlist
				WHERE  branch = cbranch
				AND    accountno = sdepaccount(pcurno).accountno
				AND    trantype < 3
				
				UNION ALL
				
				SELECT (amount - nvl(paidamount, 0)) amount
				FROM   tcontracttrxnlist
				WHERE  branch = cbranch
				AND    accountno = sdepaccount(pcurno).accountno
				AND    trantype > 2);
	
		ventryamount := sdepaccount(pcurno).remain;
		s.say(cmethodname || '  vTranAmount = ' || vtranamount || ', vEntryAmount = ' ||
			  ventryamount);
	
		vresult := vtranamount = ventryamount;
	
		IF NOT vresult
		THEN
		
			vcurrentcycle := getcurrentcycle;
		
			s.say(cmethodname || '   +++  DISCREPANCY   +++');
			s.say(cmethodname || '   ENTRIES:');
			FOR cc IN (SELECT e.debitaccount accountno
							 ,e.docno
							 ,e.no           entryno
							 ,e.valuedate    trandate
							 ,d.opdate       postdate
							 ,-e.value       amount
							 ,e.shortremark
							 ,e.fullremark
							 ,e.debitentcode
					   FROM   tdocument d
							 ,tentry    e
					   WHERE  e.branch = cbranch
					   AND    e.debitaccount = sdepaccount(pcurno).accountno
					   AND    d.branch = e.branch
					   AND    d.docno = e.docno
					   AND    d.newdocno IS NULL
					   AND    d.opdate BETWEEN
							  nvl(vcurrentcycle.statementdate + 1
								  ,to_date('01.01.1900', 'dd.mm.yyyy')) AND
							  vcurrentcycle.nextstatementdate
					   
					   UNION ALL
					   
					   SELECT e.creditaccount
							 ,e.docno
							 ,e.no
							 ,e.valuedate     trandate
							 ,d.opdate        postdate
							 ,e.value
							 ,e.shortremark
							 ,e.fullremark
							 ,e.debitentcode
					   FROM   tdocument d
							 ,tentry    e
					   WHERE  e.branch = cbranch
					   AND    e.creditaccount = sdepaccount(pcurno).accountno
					   AND    d.branch = e.branch
					   AND    d.docno = e.docno
					   AND    d.newdocno IS NULL
					   AND    d.opdate BETWEEN
							  nvl(vcurrentcycle.statementdate + 1
								  ,to_date('01.01.1900', 'dd.mm.yyyy')) AND
							  vcurrentcycle.nextstatementdate
					   ORDER  BY 2
								,3)
			LOOP
				s.say(cmethodname || '   AccountNo = ' || cc.accountno || ', docNo = ' || cc.docno ||
					  ', entryNo = ' || cc.entryno || ', tranDate = ' || htools.d2s(cc.trandate) ||
					  ', PostDate = ' || htools.d2s(cc.postdate) || ', amount = ' || cc.amount ||
					  ', shortRemark = ' || cc.shortremark || ', fullRemark = ' || cc.fullremark ||
					  ', debitEntCode = ' || cc.debitentcode);
			END LOOP;
		
			s.say(cmethodname || '');
		
			s.say(cmethodname || '   TRXN_LIST:');
			FOR cc IN (SELECT accountno
							 ,docno
							 ,entryno
							 ,trandate
							 ,postdate
							 ,amount
							 ,paidamount
							 ,trantype
							 ,debitentcode
							 ,paidfull
							 ,paidfulldate
					   FROM   tcontracttrxnlist ctl
					   WHERE  branch = cbranch
					   AND    accountno = sdepaccount(pcurno).accountno
					   AND    postdate BETWEEN
							  nvl(vcurrentcycle.statementdate + 1
								  ,to_date('01.01.1900', 'dd.mm.yyyy')) AND
							  vcurrentcycle.nextstatementdate
					   ORDER  BY 2
								,3)
			LOOP
				s.say(cmethodname || '   AccountNo = ' || cc.accountno || ', docNo = ' || cc.docno ||
					  ', entryNo = ' || cc.entryno || ', tranDate = ' || htools.d2s(cc.trandate) ||
					  ', PostDate = ' || htools.d2s(cc.postdate) || ', amount = ' || cc.amount ||
					  ', paidAmount = ' || cc.paidamount || ', tranType = ' || cc.trantype ||
					  ', entCode = ' || cc.debitentcode || ', PaidFull = ' || cc.paidfull ||
					  ', PaidFullDate = ' || htools.d2s(cc.paidfulldate));
			END LOOP;
		
			s.say(cmethodname || '');
			s.say(cmethodname || '   +++                 +++');
		
			IF poperation <> ccontrtypechanging
			THEN
				savechecktrxnlisterr(sdepaccount(pcurno).accountno
									,pcurno
									,vtranamount
									,ventryamount);
			END IF;
		
		END IF;
	
		t.leave(cmethodname, htools.b2s(vresult));
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END checktrxnlist;

	PROCEDURE setcardlimit
	(
		pcontractno IN typecontractno
	   ,ppan        IN typepan
	   ,pmbr        IN typembr
	   ,pcurno      IN NUMBER
	   ,pcltype     IN NUMBER := 0
	   ,pclamount   IN NUMBER := 0
	   ,pclprc      IN NUMBER := 0
	   ,pcashtype   IN NUMBER := 0
	   ,pcashamount IN NUMBER := 0
	   ,pcashprc    IN NUMBER := 0
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SetCardLimit';
		vlimitsetuprecord typeobjectlimitsettings;
	BEGIN
		t.enter(cmethodname);
	
		vlimitsetuprecord := getobjectlimitssetup(pcontractno, pcurno, ppan, pmbr);
	
		vlimitsetuprecord.credlimit.calcmethod := pcltype;
		vlimitsetuprecord.credlimit.amount     := pclamount;
		vlimitsetuprecord.credlimit.percent    := pclprc;
		vlimitsetuprecord.cashlimit.calcmethod := pcashtype;
		vlimitsetuprecord.cashlimit.amount     := pcashamount;
		vlimitsetuprecord.cashlimit.percent    := pcashprc;
	
		dml_limitsetup_updaterecord(vlimitsetuprecord, cexternalapicall);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END setcardlimit;

	FUNCTION getallowedoverdue(pcontractno IN typecontractno) RETURN typeallowedoverduearray IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetAllowedOverDue';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vprofileid     NUMBER;
		vallowedovd    NUMBER;
		vstcyclesarr   typestcyclefullinfoarray;
		vret           typeallowedoverduearray;
		vhistoryexists BOOLEAN := TRUE;
	
		FUNCTION readusedprofile
		(
			pcontractno IN typecontractno
		   ,pcurno      IN NUMBER
		   ,pdate       IN DATE
		) RETURN NUMBER IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename ||
												 '.GetAllowedOverDue.ReadUsedProfile';
			vprofileid NUMBER;
		BEGIN
			s.say(cmethodname || ' start', 1);
			SELECT profileid
			INTO   vprofileid
			FROM   tcontractinterestprofilelog
			WHERE  branch = cbranch
			AND    contractno = pcontractno
			AND    currencynumber = pcurno
			AND    statementdate = pdate
			AND    rownum = 1
			ORDER  BY packno DESC;
			s.say(cmethodname || ' end', 1);
			RETURN vprofileid;
		EXCEPTION
			WHEN no_data_found THEN
				RETURN NULL;
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END;
	
		PROCEDURE readallowoverdueparams(pprofileid IN NUMBER) IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename ||
												 '.GetAllowedOverDue.ReadAllowOverDueParams';
			cobjecttype CONSTANT NUMBER := custom_contractprofiles.getobjecttype;
		BEGIN
			s.say(cmethodname || ' start pProfileId=' || pprofileid, 1);
		
			IF NOT sprofile.exists(pprofileid)
			THEN
				sprofile(pprofileid)(custom_contractprofiles.cp_ovdallow) := nvl(contractparams.loadnumber(cobjecttype
																										  ,pprofileid
																										  ,'OvdValAllow'
																										  ,FALSE)
																				,1);
				IF sprofile(pprofileid) (custom_contractprofiles.cp_ovdallow) > 1
				THEN
					sprofile(pprofileid)(custom_contractprofiles.cp_ovdallowamt) := contractparams.loadnumber(cobjecttype
																											 ,pprofileid
																											 ,'OvdValAllowAmount');
					sprofile(pprofileid)(custom_contractprofiles.cp_ovdallowprc) := contractparams.loadnumber(cobjecttype
																											 ,pprofileid
																											 ,'OvdValAllowPrc');
				END IF;
				sprofile(pprofileid)(custom_contractprofiles.cp_ovdfeedate) := contractparams.loadnumber(cobjecttype
																										,pprofileid
																										,'OvdFeeDate');
			END IF;
		
			s.say(cmethodname || ' end', 1);
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END;
	
	BEGIN
		s.say(cmethodname || ' start', 1);
		contracttypeschema.scontractrow.no := pcontractno;
		scontractno                        := pcontractno;
		scontracttype                      := contract.gettype(pcontractno);
		readsetupscheme(FALSE);
		getcontractdata;
	
		vstcyclesarr := getstcyclefulllist(pcontractno);
		FOR i IN 1 .. vstcyclesarr.count
		LOOP
			vret(i).statementdate := vstcyclesarr(i).statementdate;
			vret(i).duedate := vstcyclesarr(i).duedate;
			vret(i).nextsd := vstcyclesarr(i).nextstatementdate;
			vret(i).allowedod_dom := 0;
			vret(i).allowedod_int := 0;
			FOR j IN 1 .. 2
			LOOP
				IF ifcurrencyisusedintype(j, scontracttype, scontractno)
				THEN
					vprofileid := getvaluebycurno(j
												 ,sblockparam.profileiddom
												 ,sblockparam.profileidint);
					IF vhistoryexists
					THEN
					
						vprofileid := readusedprofile(pcontractno, j, vstcyclesarr(i).statementdate);
						IF vprofileid IS NULL
						THEN
							vhistoryexists := FALSE;
							vprofileid     := getvaluebycurno(j
															 ,sblockparam.profileiddom
															 ,sblockparam.profileidint);
							readallowoverdueparams(vprofileid);
						ELSE
							readallowoverdueparams(vprofileid);
						
							IF sprofile(vprofileid) (custom_contractprofiles.cp_ovdfeedate) = 1
							THEN
								vprofileid := readusedprofile(pcontractno
															 ,j
															 ,vstcyclesarr(i).nextstatementdate);
							ELSE
							
								vprofileid := readusedprofile(pcontractno
															 ,j
															 ,vstcyclesarr(i).duedate);
								IF vprofileid IS NULL
								THEN
									vprofileid := readusedprofile(pcontractno
																 ,j
																 ,vstcyclesarr(i).nextstatementdate);
								END IF;
							END IF;
							IF vprofileid IS NOT NULL
							THEN
							
								readallowoverdueparams(vprofileid);
							END IF;
						END IF;
					END IF;
				
					vallowedovd := calcallowedoverdue(getvaluebycurno(j
																	 ,vstcyclesarr(i).minpaymentdom
																	 ,vstcyclesarr(i).minpaymentint)
													 ,sprofile(vprofileid)
													 ,sprecision(j));
				
					IF j = 1
					THEN
						vret(i).allowedod_dom := vallowedovd;
					ELSE
						vret(i).allowedod_int := vallowedovd;
					END IF;
				END IF;
			END LOOP;
		END LOOP;
		s.say(cmethodname || ' end', 1);
		RETURN vret;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END;

	FUNCTION adjmodeonget_atomarray RETURN adjustingmode.tatomarray IS
		cmethodname CONSTANT typemethodname := cpackagename || '.AdjModeOnGet_AtomArray';
		vresult adjustingmode.tatomarray;
	
		PROCEDURE addmode
		(
			patom        IN VARCHAR2
		   ,pname        IN VARCHAR2
		   ,pdescription IN VARCHAR2
		) IS
			cmethodname CONSTANT typemethodname := cpackagename || '.AddMode';
		BEGIN
			vresult(vresult.count + 1).atom := patom;
			vresult(vresult.count).name := pname;
			vresult(vresult.count).description := pdescription;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END addmode;
	
	BEGIN
		t.enter(cmethodname);
	
		addmode(adjustingmode.ao_processtrxn
			   ,'Process new transactions'
			   ,'Process new transactions');
		addmode(adjustingmode.ao_movetoinst
			   ,'Transfer to installments'
			   ,'Transfer new transactions to Installments');
		addmode(adjustingmode.ao_payinst, 'Repay installments', 'Repay installments');
		addmode(adjustingmode.ao_pbtransfer
			   ,'Transfer positive balance'
			   ,'Transfer current positive balance');
		addmode(adjustingmode.ao_corpautorep
			   ,'Repay from corporate account'
			   ,'Process repayment from the corporate account');
		addmode(adjustingmode.ao_autorepay
			   ,'Repay from autorepayment account'
			   ,'Process repayment from client''s autorepayment account');
		addmode(adjustingmode.ao_delinquency
			   ,'Calculate delinquency state'
			   ,'Update current delinquency state');
		addmode(adjustingmode.ao_generatedaf, 'Generate DAF', 'Generate DAF');
		addmode(adjustingmode.ao_updatelimits, 'Update limits', 'Update limits');
		addmode(adjustingmode.ao_eod, 'Close day', 'Perform end of day operation');
		addmode(adjustingmode.ao_migration, 'Migration', 'Process transactions (migration)');
	
		IF collectionavailable
		THEN
			addmode(adjustingmode.ao_collection, 'Collection', 'Collection');
		END IF;
	
		t.leave(cmethodname, vresult.count);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END adjmodeonget_atomarray;

	FUNCTION getadjmode_repayment RETURN adjustingmode.tatombitlist IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetAdjMode_Repayment';
		vresult adjustingmode.tatombitlist;
	BEGIN
		t.enter(cmethodname);
	
		vresult := adjustingmode.createvirtualmode(adjmodeonget_atomarray);
		vresult.delete(adjustingmode.ao_migration);
		vresult.delete(adjustingmode.ao_collection);
	
		t.leave(cmethodname, vresult.count);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getadjmode_repayment;

	PROCEDURE initgetdata4vcf(pcontracttype IN typecontracttype) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.InitGetData4VCF';
	BEGIN
		scontracttype := pcontracttype;
		readsetupscheme(FALSE);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END initgetdata4vcf;

	FUNCTION execgetbalance4vcf
	(
		pcontractno IN typecontractno
	   ,penddate    IN DATE
	) RETURN apitypesforvcf.typebalancelist IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.ExecGetBalance4VCF';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		coperdate   CONSTANT DATE := seance.getoperdate;
	
		venddate      DATE := nvl(penddate, coperdate);
		vabalancelist apitypesforvcf.typebalancelist;
	
		vlastsdforpenddate DATE;
		voverdueparameters custom_overdueparameterscalculation.typeoverdueparamsrecord;
	BEGIN
		s.say(cmethodname || ' ----<< BEGIN ');
	
		contracttypeschema.scontractrow.no := pcontractno;
		getcontractdata(pcreatenew => FALSE, penddate => venddate, pfromadjusting => FALSE);
	
		IF getcurrentcycle().lastduedate = coperdate
		THEN
			snowduedate := TRUE;
			s.say('   - ' || cmethodname || 'It''s DUE DATE NOW');
		ELSE
			snowduedate := FALSE;
		END IF;
	
		FOR ccur IN 1 .. 2
		LOOP
			IF sdepaccount(ccur).accountno IS NOT NULL
			THEN
			
				vabalancelist(ccur).currentbalance := -1 *
													  contracttools.get_eod_remain(paccountno       => sdepaccount(ccur)
																									   .accountno
																				  ,pdate            => venddate
																				  ,parchive         => FALSE
																				  ,pcheckemptyaccno => FALSE);
			
				s.say('   - ' || cmethodname || ' - "Remain for ' ||
					  REPLACE(REPLACE(ccur, 1, 'DOM'), 2, 'INT') || ' currency account on ' ||
					  venddate || '", - vaBalanceList(' || ccur || ').CurrentBalance  = ' || vabalancelist(ccur)
					  .currentbalance
					 ,1);
			
				SELECT MAX(statementdate)
				INTO   vlastsdforpenddate
				FROM   tcontractstcycle
				WHERE  branch = cbranch
				AND    contractno = pcontractno
				AND    statementdate < venddate;
				s.say('   - ' || cmethodname ||
					  ' - "Last Statement Date for specified date - vEndDate (vLastSDForPEndDate) " ' ||
					  htools.d2s(vlastsdforpenddate));
			
				IF vlastsdforpenddate IS NOT NULL
				THEN
				
					vabalancelist(ccur).previousbalance := -1 *
														   contracttools.get_eod_remain(paccountno       => sdepaccount(ccur)
																											.accountno
																					   ,pdate            => vlastsdforpenddate
																					   ,parchive         => FALSE
																					   ,pcheckemptyaccno => FALSE);
				
				END IF;
				s.say('   - ' || cmethodname || ' - "Previous Balance for ' ||
					  REPLACE(REPLACE(ccur, 1, 'DOM'), 2, 'INT') || ' currency account on ' ||
					  vlastsdforpenddate || '", - vaBalanceList(' || ccur ||
					  ').PreviousBalance  = ' || vabalancelist(ccur).previousbalance
					 ,1);
			
				vabalancelist(ccur).creditlimit := getcreditlimit(pcontractno
																 ,sdepaccount(ccur).currencyno);
				s.say('   - ' || cmethodname || ' - "Set Credit Limit for ' ||
					  REPLACE(REPLACE(ccur, 1, 'DOM'), 2, 'INT') ||
					  ' currency account", - vaBalanceList(' || ccur || ').CreditLimit  = ' || vabalancelist(ccur)
					  .creditlimit
					 ,1);
			
				spaidhistarray(ccur) := custom_overdueparameterscalculation.getoverdueparameters(paccountno           => sdepaccount(ccur)
																														 .accountno
																								,pcurrencynumber      => ccur
																								,pdate                => NULL
																								,pconsideroverduefrom => sdelparam.overdueint
																								,ooverdueparameters   => voverdueparameters);
			
				vabalancelist(ccur).currentamountdue := voverdueparameters.dueamount;
				vabalancelist(ccur).pastdueamount := voverdueparameters.overdueamount;
			
				s.say('   - ' || cmethodname || ' - "Current Min.Payment for ' ||
					  REPLACE(REPLACE(ccur, 1, 'DOM'), 2, 'INT') || ' currency", - vaBalanceList(' || ccur ||
					  ').CurrentAmountDue  = ' || vabalancelist(ccur).currentamountdue
					 ,1);
				s.say('   - ' || cmethodname || ' - "Current Overdue Amount for ' ||
					  REPLACE(REPLACE(ccur, 1, 'DOM'), 2, 'INT') || ' currency", - vaBalanceList(' || ccur ||
					  ').PastDueAmount  = ' || vabalancelist(ccur).pastdueamount
					 ,1);
			
				vabalancelist(ccur).pastduecount := 0;
				FOR j IN 1 .. spaidhistarray(ccur).count
				LOOP
					IF nvl(spaidhistarray(ccur)(j).overdueamount, 0) <> 0
					THEN
						vabalancelist(ccur).pastduecount := vabalancelist(ccur).pastduecount + 1;
					END IF;
				END LOOP;
				s.say('   - ' || cmethodname || ' - "Past Due Count for ' ||
					  REPLACE(REPLACE(ccur, 1, 'DOM'), 2, 'INT') || ' currency", - vaBalanceList(' || ccur ||
					  ').PastDueCount  = ' || vabalancelist(ccur).pastduecount
					 ,1);
			
				getcreditlastpayment(pcontractno => pcontractno
									,pcurrencyno => sdepaccount(ccur).currencyno
									,odate       => vabalancelist(ccur).lastpaymentdate
									,oamount     => vabalancelist(ccur).lastpaymentamount);
				s.say('   - ' || cmethodname || ' - "Last Payment Date for ' ||
					  REPLACE(REPLACE(ccur, 1, 'DOM'), 2, 'INT') ||
					  ' currency (amount, date)", - vaBalanceList(' || ccur ||
					  ').LastPaymentAmount  = ' || vabalancelist(ccur).lastpaymentamount ||
					  ', vaBalanceList(' || ccur || ').LastPaymentDate = ' || vabalancelist(ccur)
					  .lastpaymentdate
					 ,1);
			
				vabalancelist(ccur).billingcurrencycode := sdepaccount(ccur).currencyno;
				s.say('   - ' || cmethodname || ' - "Currency code for ' ||
					  REPLACE(REPLACE(ccur, 1, 'DOM'), 2, 'INT') || ' ", - vaBalanceList(' || ccur ||
					  ').BillingCurrencyCode  = ' || vabalancelist(ccur).billingcurrencycode
					 ,1);
			
				vabalancelist(ccur).ampastdueonebillingcycle := NULL;
				vabalancelist(ccur).ampastduetwobillingcycles := NULL;
				vabalancelist(ccur).ampastduethreebillingcycles := NULL;
				vabalancelist(ccur).ampastduefourbillingcycles := NULL;
				vabalancelist(ccur).ampastduefivebillingcycles := NULL;
				vabalancelist(ccur).ampastduesixbillingcycles := NULL;
				vabalancelist(ccur).ampastdueplusbillingcycles := NULL;
				vabalancelist(ccur).highbalance := NULL;
			END IF;
		END LOOP;
	
		s.say(cmethodname || ' ---->> END', 1);
		RETURN vabalancelist;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END execgetbalance4vcf;

	PROCEDURE downgetdata4vcf(pcontracttype IN typecontracttype) IS
	BEGIN
		NULL;
	END downgetdata4vcf;

	PROCEDURE getprofilescalculatedondate
	(
		pcontractno       IN typecontractno
	   ,pcurno            IN NUMBER
	   ,pdate             IN DATE
	   ,ointcalcprofileid OUT NUMBER
	   ,ompcalcprofileid  OUT NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetProfilesCalculatedOnDate';
		vcontracttype typecontracttype;
	BEGIN
		t.enter(cmethodname
			   ,'pContractNo = ' || pcontractno || ', pCurNo = ' || pcurno || ', pDate = ' ||
				htools.d2s(pdate));
	
		scontractno                          := pcontractno;
		vcontracttype                        := contract.gettype(scontractno);
		contracttypeschema.scontractrow.type := vcontracttype;
		contracttypeschema.scontractrow.no   := pcontractno;
	
		IF nvl(scontracttype, 0) <> vcontracttype
		THEN
			scontracttype := vcontracttype;
			readsetupscheme(FALSE);
		END IF;
	
		getcontractdata(penddate => pdate);
	
		IF pcurno = 1
		THEN
			IF nvl(sacparamccy(1) (cp_mpprofile), 0) <> 0
			   AND (nvl(sacparamccy(1) (cp_fixmpprofile), 0) = 1 OR sblockparam.mpprofileiddom = 0)
			THEN
				smpprofileid(1) := sacparamccy(1) (cp_mpprofile);
			ELSIF sblockparam.mpprofileiddom <> 0
			THEN
				readaltsetupscheme(NULL);
				smpprofileid(1) := smpaltprofile(1);
			ELSE
				smpprofileid(1) := smpmainprofile(1);
			END IF;
		
			IF nvl(sacparamccy(1) (cp_profile), 0) <> 0
			   AND (nvl(sacparamccy(1) (cp_fixprofile), 0) = 1 OR sblockparam.profileiddom = 0)
			THEN
				sprofileid(1) := sacparamccy(1) (cp_profile);
			ELSIF sblockparam.profileiddom <> 0
			THEN
				readaltsetupscheme(NULL);
				sprofileid(1) := sblockparam.profileiddom;
			ELSE
				sprofileid(1) := smainprofile(1);
			END IF;
		END IF;
	
		IF pcurno = 2
		THEN
			IF nvl(sacparamccy(2) (cp_mpprofile), 0) <> 0
			   AND (nvl(sacparamccy(2) (cp_fixmpprofile), 0) = 1 OR sblockparam.mpprofileidint = 0)
			THEN
				smpprofileid(2) := sacparamccy(2) (cp_mpprofile);
			ELSIF sblockparam.mpprofileidint <> 0
			THEN
				readaltsetupscheme(NULL);
				smpprofileid(2) := smpaltprofile(2);
			ELSE
				smpprofileid(2) := smpmainprofile(2);
			END IF;
		
			IF nvl(sacparamccy(2) (cp_profile), 0) <> 0
			   AND (nvl(sacparamccy(2) (cp_fixprofile), 0) = 1 OR sblockparam.profileidint = 0)
			THEN
				sprofileid(2) := sacparamccy(2) (cp_profile);
			ELSIF sblockparam.profileidint <> 0
			THEN
				readaltsetupscheme(NULL);
				sprofileid(2) := sblockparam.profileidint;
			ELSE
				sprofileid(2) := smainprofile(2);
			END IF;
		END IF;
	
		ointcalcprofileid := sprofileid(pcurno);
		ompcalcprofileid  := smpprofileid(pcurno);
		s.say(cmethodname ||
			  '        Interest Calculation Profile Identifier (oIntCalcProfileId ) = ' ||
			  ointcalcprofileid
			 ,1);
		s.say(cmethodname ||
			  '        Min Payment Calculation Profile Identifier (oMPCalcProfileId ) = ' ||
			  ompcalcprofileid
			 ,1);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getprofilescalculatedondate;

	FUNCTION getentryaggregates
	(
		pentryarray contracttypeschema.tentryarray
	   ,pstartdate  DATE
	   ,penddate    DATE
	) RETURN typeentryaggregatesrecord IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetEntryAggregates';
	
		ventryaggregates typeentryaggregatesrecord;
	BEGIN
		s.say(cmethodname || '    --<< BEGIN', 1);
		s.say(cmethodname || '      INPUT PARAMETERS:', 1);
		s.say(cmethodname || '       -> Entry Array: number of rows inside (pEntryArray.count) = ' ||
			  pentryarray.count
			 ,1);
		s.say(cmethodname ||
			  '       -> Start Date - date on which INCOME BALANCE is calculated (pStartDate) = ' ||
			  htools.d2s(pstartdate));
		s.say(cmethodname ||
			  '       -> End Date - date on which OUTCOME BALANCE is calculated (pEndDate) = ' ||
			  htools.d2s(penddate));
		s.say(cmethodname || '', 1);
	
		ventryaggregates.incomebalance  := NULL;
		ventryaggregates.outcomebalance := NULL;
		ventryaggregates.debitturnover  := 0;
		ventryaggregates.creditturnover := 0;
	
		FOR i IN 1 .. pentryarray.count
		LOOP
		
			IF ventryaggregates.outcomebalance IS NULL
			   AND pentryarray(i).opdate <= penddate
			THEN
				ventryaggregates.outcomebalance := pentryarray(i).remain;
				s.say(cmethodname ||
					  '     Entry Information corresponding to OUTCOME BALANCE choosing:  (pEntryArray[' || i ||
					  '].opDate= ' || htools.d2s(pentryarray(i).opdate) || ', docNo = ' || pentryarray(i)
					  .docno || ', entryNo = ' || pentryarray(i).no || ', entryAmount = ' || pentryarray(i)
					  .entvalue);
			END IF;
		
			IF ventryaggregates.incomebalance IS NULL
			   AND pentryarray(i).opdate < pstartdate
			THEN
				ventryaggregates.incomebalance := pentryarray(i).remain;
				s.say(cmethodname ||
					  '     Entry Information corresponding to INCOME BALANCE choosing: (pEntryArray[' || i ||
					  '].opDate= ' || htools.d2s(pentryarray(i).opdate) || ', docNo = ' || pentryarray(i)
					  .docno || ', entryNo = ' || pentryarray(i).no || ', entryAmount = ' || pentryarray(i)
					  .entvalue);
			END IF;
		
			IF pentryarray(i).opdate BETWEEN pstartdate AND penddate
			THEN
				IF pentryarray(i).debit
				THEN
					ventryaggregates.debitturnover := ventryaggregates.debitturnover + pentryarray(i)
													 .entvalue;
					s.say(cmethodname || '      Chosen DEBIT: (pEntryArray[' || i || '].opDate= ' ||
						  htools.d2s(pentryarray(i).opdate) || ', docNo = ' || pentryarray(i)
						  .docno || ', entryNo = ' || pentryarray(i).no || ', entryAmount = ' || pentryarray(i)
						  .entvalue);
				ELSE
					ventryaggregates.creditturnover := ventryaggregates.creditturnover + pentryarray(i)
													  .entvalue;
					s.say(cmethodname || '      Chosen CREDIT: (pEntryArray[' || i || '].opDate= ' ||
						  htools.d2s(pentryarray(i).opdate) || ', docNo = ' || pentryarray(i)
						  .docno || ', entryNo = ' || pentryarray(i).no || ', entryAmount = ' || pentryarray(i)
						  .entvalue);
				END IF;
			END IF;
		
			IF (ventryaggregates.incomebalance IS NOT NULL)
			   AND (ventryaggregates.outcomebalance IS NOT NULL)
			THEN
				EXIT;
			END IF;
		
		END LOOP;
	
		ventryaggregates.incomebalance  := nvl(ventryaggregates.incomebalance, 0);
		ventryaggregates.outcomebalance := nvl(ventryaggregates.outcomebalance, 0);
	
		s.say(cmethodname || '', 1);
		s.say(cmethodname || '     vEntryAggregates.incomeBalance = ' ||
			  ventryaggregates.incomebalance || ', vEntryAggregates.outcomeBalance = ' ||
			  ventryaggregates.outcomebalance || ', vEntryAggregates.debitTurnover = ' ||
			  ventryaggregates.debitturnover || ', vEntryAggregates.creditTurnover = ' ||
			  ventryaggregates.creditturnover);
		s.say(cmethodname || '    -->> END', 1);
		RETURN ventryaggregates;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getentryaggregates;

	FUNCTION getinterestcalclog
	(
		pcontractno    VARCHAR2
	   ,pstatementdate DATE
	) RETURN typeparsedinterestlog_tab IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.getParsedInterestLog';
	
		vresult typeparsedinterestlog_tab;
	BEGIN
		SELECT typeparsedinterestlog_obj(setup_branch
										,setup_currencynumber
										,setup_contractno
										,setup_statementdate
										,setup_groupid
										,setup_calcinfo
										,setup_groupname
										,dtl_tranrecno
										,dtl_intstartdate
										,dtl_intlastdate
										,dtl_fromdate
										,dtl_tranamount
										,dtl_baseamount
										,dtl_rate
										,dtl_days
										,dtl_calcinfo
										,trxn_accountno
										,trxn_amount
										,trxn_trandate
										,trxn_postdate
										,trxn_docno
										,trxn_entryno
										,trxn_debitrecno
										,repaym_recno
										,repaym_trandate
										,repaym_postdate
										,repaym_amount) BULK COLLECT
		INTO   vresult
		FROM   vaggregatedinterestlog
		WHERE  setup_branch = seance.getbranch
		AND    setup_contractno = pcontractno
		AND    setup_statementdate = pstatementdate;
	
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getinterestcalclog;

	FUNCTION interestcalcinfoparser(plogcalcinfo tcontractinterestsetuplog.calcinfo%TYPE)
		RETURN type_param_descr_val_varr IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.InterestCalcInfoParser';
	
		vvarraytoreturn      type_param_descr_val_varr := NEW type_param_descr_val_varr();
		vvarrayindex         NUMBER := 0;
		varrparams           uamp.tarrrecord;
		vreducedtermsbasedon NUMBER;
	
		PROCEDURE addinfo
		(
			pparameter   IN VARCHAR2
		   ,pdescription IN VARCHAR2
		   ,pvalue       IN VARCHAR2
		) IS
			cmethodname CONSTANT typemethodname := interestcalcinfoparser.cmethodname || '.AddInfo';
		BEGIN
			vvarraytoreturn.extend;
			vvarrayindex := vvarrayindex + 1;
			vvarraytoreturn(vvarrayindex) := NEW type_param_descr_val_obj(pparameter
																		 ,pdescription
																		 ,pvalue);
			s.say(cmethodname || ':  vVarrayToReturn[' || vvarrayindex || '].parameter = ' || vvarraytoreturn(vvarrayindex)
				  .parameter
				 ,1);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END addinfo;
	
	BEGIN
		varrparams := uamp.parsestring(plogcalcinfo, ';');
	
		FOR i IN 1 .. varrparams.count
		LOOP
			IF varrparams(i).name = 'Grace'
			THEN
				CASE
					WHEN varrparams(i).value = 'USED' THEN
						addinfo('Grace', 'Whether Grace Period Is Used', 'USED');
					ELSE
						addinfo('Grace', 'Whether Grace Period Is Used', 'NOT USED');
				END CASE;
			ELSIF varrparams(i).name = 'BasedOn'
			THEN
				CASE varrparams(i).value
					WHEN 1 THEN
						addinfo('BasedOn'
							   ,'Reduced Rate Term'
							   ,'Min Payment should be paid till Due Date');
						vreducedtermsbasedon := 1;
					WHEN 2 THEN
						addinfo('BasedOn'
							   ,'Reduced Rate Term'
							   ,'Statement Date Balance Should Be Paid till Due Date');
						vreducedtermsbasedon := 2;
					WHEN 3 THEN
						addinfo('BasedOn'
							   ,'Reduced Rate Term'
							   ,'Current Balance should be less than');
					WHEN 4 THEN
						addinfo('BasedOn'
							   ,'Reduced Rate Term'
							   ,'Unpaid Balance of Last SD Should Be Less than');
					
					WHEN 5 THEN
						addinfo('BasedOn'
							   ,'Reduced Rate Term'
							   ,'Unpaid SD Amount on Due Date is less than');
						vreducedtermsbasedon := 5;
					
					ELSE
						addinfo('BasedOn', 'Reduced RateTerms', NULL);
				END CASE;
			ELSIF varrparams(i).name = 'MaxSDBal'
				   OR varrparams(i).name = 'RedTermAmount'
			THEN
				addinfo('RedTermAmount', 'Reduced Term Amount To Compare', varrparams(i).value);
			
			ELSIF varrparams(i).name = 'RedTermUsage'
			THEN
				CASE varrparams(i).value
					WHEN custom_contractprofiles.cgraceperusage_always THEN
						addinfo('RedTermUsage', 'Reduced term usage period', 'Always');
					WHEN custom_contractprofiles.cgraceperusage_prevcycleonly THEN
						addinfo('RedTermUsage'
							   ,'Reduced term usage period'
							   ,'For previous cycle only');
					ELSE
						addinfo('RedTermUsage'
							   ,'For what period reduced term should be applied'
							   ,NULL);
				END CASE;
			
			ELSIF varrparams(i).name = 'YearDays'
			THEN
				addinfo('YearDays', 'Days in year', varrparams(i).value);
			ELSIF varrparams(i).name = 'UnPaidAmnt'
			THEN
				IF vreducedtermsbasedon = 1
				THEN
					addinfo('UnPaidAmnt', 'Unpaid Minimum Payment Amount', varrparams(i).value);
				ELSIF vreducedtermsbasedon = 2
				THEN
					addinfo('UnPaidAmnt', 'Unpaid Last SD Balance', varrparams(i).value);
				
				ELSIF vreducedtermsbasedon = 5
				THEN
					addinfo('UnPaidAmnt', 'Unpaid SD Amount on Due Date', varrparams(i).value);
				
				END IF;
				vreducedtermsbasedon := NULL;
			ELSIF varrparams(i).name = 'TrnDateIncluded'
			THEN
				addinfo('TrnDateIncluded'
					   ,'Include trxn with TranDate <='
					   ,to_char(to_date(varrparams(i).value, 'DDMMYYYY'), 'DD/MM/YYYY'));
			ELSIF varrparams(i).name = 'ChargeTo'
			THEN
				addinfo('ChargeTo'
					   ,'Charge interest till'
					   ,to_char(to_date(varrparams(i).value, 'DDMMYYYY'), 'DD/MM/YYYY'));
			ELSIF varrparams(i).name = 'Rate'
			THEN
				addinfo('Rate', 'Charge Interest by rate', varrparams(i).value);
			ELSIF varrparams(i).name = 'RateId'
			THEN
				addinfo('RateId', 'Interest rate Id: ', varrparams(i).value);
			ELSIF varrparams(i).name = 'RateType'
			THEN
			
				IF varrparams(i).value = 1
				THEN
					addinfo('RateType', 'Interest rate selection', 'Remaining balance');
				ELSIF varrparams(i).value = 2
				THEN
					addinfo('RateType', 'Interest rate selection', 'Discrete remaining balance');
				ELSIF varrparams(i).value = 3
				THEN
					addinfo('RateType', 'Interest rate selection', 'Transaction amount');
				END IF;
			
			ELSIF varrparams(i).name = 'RatePrdt'
			THEN
				IF varrparams(i).value = 1
				THEN
					addinfo('RatePrdt', 'Period Starts', 'Contract creation date');
				ELSE
					addinfo('RatePrdt', 'Period Starts', 'Transaction date');
				END IF;
			ELSIF varrparams(i).name = 'RateDate'
			THEN
				IF varrparams(i).value = custom_contractprofiles.cdate_current
				THEN
					addinfo('RateDate', 'Use rate defined on', 'Current business date');
				ELSIF varrparams(i).value = custom_contractprofiles.cdate_transaction
				THEN
					addinfo('RateDate', 'Use rate defined on', 'Transaction date');
				ELSIF varrparams(i).value = custom_contractprofiles.cdate_history
				THEN
					addinfo('RateDate', 'Use rate defined on', 'Rate history');
				ELSE
					addinfo('RateDate', 'Use rate defined on', 'Card creation date');
				END IF;
			ELSIF varrparams(i).name = 'PromRateId'
			THEN
				addinfo('PromRateId'
					   ,'Promotional Interest rate Id'
					   ,service.iif(varrparams(i).value = -1, 'Not used', varrparams(i).value));
			ELSIF varrparams(i).name = 'PrefRateId'
			THEN
				addinfo('PrefRateId'
					   ,'Preferential Interest rate Id'
					   ,service.iif(varrparams(i).value = -1, 'Not used', varrparams(i).value));
			ELSIF varrparams(i).name = 'RepayDate'
			THEN
				IF varrparams(i).value = 1
				THEN
					addinfo('RepayDate'
						   ,'Repayment Date'
						   ,'Transaction Date of Credit Transaction');
				ELSE
					addinfo('RepayDate', 'Repayment Date', 'Posting Date of Credit Transaction');
				END IF;
			ELSIF varrparams(i).name = 'ChargeOnPaid'
			THEN
				IF varrparams(i).value = 1
				THEN
					addinfo('ChargeOnPaid', 'Charge interest on paid amount', 'No');
				ELSE
					addinfo('ChargeOnPaid', 'Charge interest on paid amount', 'Yes');
				END IF;
			ELSIF varrparams(i).name = 'Only1'
			THEN
				IF varrparams(i).value = 1
				THEN
					addinfo('Only1', 'In First Billing Cycle Only', 'Yes');
				ELSE
					addinfo('Only1', 'In First Billing Cycle Only', 'No');
				END IF;
			
			ELSIF varrparams(i).name = 'PrefRateUsageStarts'
			THEN
				IF varrparams(i).value = custom_contractprofiles.cprefrateuse_contrcreationdate
				THEN
					addinfo('PrefRateUsageStarts'
						   ,'Prefer. rate usage starts from'
						   ,'Contract creation date');
				ELSIF varrparams(i).value = custom_contractprofiles.cprefrateuse_trandate
				THEN
					addinfo('PrefRateUsageStarts'
						   ,'Prefer. rate usage starts from'
						   ,'Transaction date');
				END IF;
			
			ELSIF varrparams(i).name = 'PrefRateValue'
			THEN
				addinfo('PrefRateValue', 'Preferential Rate Value', varrparams(i).value);
			ELSIF varrparams(i).name = 'PromRateId'
			THEN
				addinfo('PromRateId', 'Used Promotional Rate Id', varrparams(i).value);
			ELSIF varrparams(i).name = 'DontChargeOnPaid'
			THEN
				addinfo('DontChargeOnPaid', 'Don''t Charge On Paid Amount', varrparams(i).value);
			ELSIF varrparams(i).name = 'DDAmount'
			THEN
				addinfo('DDAmount', 'Amount on Due Date', varrparams(i).value);
			ELSIF varrparams(i).name = 'RateSelect'
			THEN
				IF varrparams(i).value IN ('MAX', 'REMAIN')
				THEN
					addinfo('RateSelect', 'Rate selected by', 'Remaining Balance');
				
				ELSIF varrparams(i).value = 'TRAN'
				THEN
					addinfo('RateSelect', 'Rate selected by', 'Transaction Amount');
				
				ELSE
					addinfo('RateSelect', 'Rate selected by', 'Discrete Balance');
				END IF;
			ELSIF varrparams(i).name = 'FromRemain'
			THEN
				addinfo('FromRemain', 'Interval from', varrparams(i).value);
			ELSIF varrparams(i).name = 'ToRemain'
			THEN
				addinfo('ToRemain', '', varrparams(i).value);
			
			ELSIF varrparams(i).name = 'TranRateId'
			THEN
				addinfo('TranRateId', 'Interest rate for this trxn', varrparams(i).value);
			
			ELSIF varrparams(i).name = 'IntChrgType'
			THEN
				CASE varrparams(i).value
					WHEN 1 THEN
						addinfo('IntChrgType', 'Charge type: ', 'Do not charge');
					WHEN 2 THEN
						addinfo('IntChrgType', 'Charge type: ', 'Flat amount on tiers');
				END CASE;
			ELSIF varrparams(i).name = 'Remain'
			THEN
				addinfo('Remain', 'Unpaid SD amount on Due Date: ', varrparams(i).value);
			
			END IF;
		END LOOP;
	
		RETURN vvarraytoreturn;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END interestcalcinfoparser;

	PROCEDURE getoverdueperiod
	(
		pcontractno    typecontractno
	   ,pdate          DATE
	   ,puom           NUMBER := NULL
	   ,olastovddate   OUT DATE
	   ,ooverdueperiod OUT NUMBER
	   ,ouom           OUT NOCOPY VARCHAR2
	) IS
		cmethodname CONSTANT VARCHAR2(100) := cpackagename || '.GetOverduePeriod';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vcontracttype typecontractno;
	
		vpaidhistarray     typepaidhistarray;
		voverdueparameters custom_overdueparameterscalculation.typeoverdueparamsrecord;
	
		vovddate_curr1 DATE;
		vovddate_curr2 DATE;
		vdeldate       DATE;
	
	BEGIN
		s.say(cmethodname || '   --<< BEGIN', 1);
		s.say(cmethodname || '    - INPUT PARAMETERS: pContractNo = ' || pcontractno ||
			  ', pDate = ' || htools.d2s(pdate) || ', wanted UOM (pUOM) = ' || puom ||
			  ', OperDate = ' || htools.d2s(seance.getoperdate));
	
		scontractno                          := pcontractno;
		vcontracttype                        := contract.gettype(scontractno);
		contracttypeschema.scontractrow.type := vcontracttype;
		contracttypeschema.scontractrow.no   := pcontractno;
	
		olastovddate   := NULL;
		ooverdueperiod := NULL;
		ouom           := NULL;
	
		s.say(cmethodname || '    sContractType = ' || scontracttype || ', vContractType = ' ||
			  vcontracttype
			 ,1);
		IF nvl(scontracttype, 0) <> vcontracttype
		THEN
			s.say(cmethodname || '    - info: scheme parameters are going to be loaded', 1);
			scontracttype := vcontracttype;
			readsetupscheme(FALSE);
		ELSE
			s.say(cmethodname || '    - info: scheme parameters have been loaded already', 1);
		END IF;
	
		s.say(cmethodname ||
			  '   From what day Overdue period should be calculated (sDelParam.OverdueInt) = ' ||
			  sdelparam.overdueint
			 ,1);
		FOR i IN 1 .. 2
		LOOP
			IF ifcurrencyisusedintype(i, scontracttype, pcontractno)
			THEN
			
				contracttools.loadcontractaccount(sitem(i).dep, sdepaccount(i));
				contracttools.loadcontractaccount(sitem(i).ovd, sovdaccount(i));
			
				vpaidhistarray := custom_overdueparameterscalculation.getoverdueparameters(paccountno           => sdepaccount(i)
																												   .accountno
																						  ,pcurrencynumber      => i
																						  ,pdate                => pdate
																						  ,pconsideroverduefrom => sdelparam.overdueint
																						  ,ooverdueparameters   => voverdueparameters);
			
				IF i = 1
				THEN
					vovddate_curr1 := voverdueparameters.overduedate;
				ELSE
					vovddate_curr2 := voverdueparameters.overduedate;
				END IF;
			
			END IF;
		END LOOP;
		s.say(cmethodname || '   vOvdDate_curr1 = ' || htools.d2s(vovddate_curr1) ||
			  ', vOvdDate_curr2 = ' || htools.d2s(vovddate_curr2));
	
		vdeldate     := least(nvl(vovddate_curr1, pdate), nvl(vovddate_curr2, pdate));
		olastovddate := vdeldate;
	
		IF sdelparam.overdueint IN (contractdelinqsetup.covdday, contractdelinqsetup.covdfirstday)
		   AND puom IS NULL
		   OR puom = coverdueuom_days
		THEN
			ooverdueperiod := pdate - vdeldate;
		
			ouom := 'day(s)';
		ELSIF sdelparam.overdueint IN
			  (contractdelinqsetup.covdcycle, contractdelinqsetup.covdfirstcycle)
			  AND puom IS NULL
			  OR puom = coverdueuom_cycles
		THEN
			SELECT COUNT(1)
			INTO   ooverdueperiod
			FROM   tcontractstcycle a
			WHERE  a.branch = cbranch
			AND    a.contractno = scontractno
			AND    a.lastduedate BETWEEN vdeldate AND pdate;
		
			ouom := 'cycle(s)';
		END IF;
	
		s.say(cmethodname || '    Overdue period on pDate (oOverduePeriod) = ' || ooverdueperiod
			 ,1);
		IF nvl(ooverdueperiod, 0) = 0
		THEN
			s.say(cmethodname || '    - info: there is no overdue on pDate', 1);
			ooverdueperiod := 0;
			olastovddate   := contracttypeschema.scontractrow.createdate;
			FOR cc IN (SELECT *
					   FROM   tcontractstatehistory
					   WHERE  branch = cbranch
					   AND    contractno = scontractno
					   AND    operdate <= pdate
					   ORDER  BY recno DESC)
			LOOP
				IF nvl(cc.overdue, 0) >= 0
				THEN
					olastovddate := cc.operdate;
					s.say(cmethodname || '   oLastOvdDate = ' || htools.d2s(olastovddate));
					IF puom IS NULL
					   OR (puom = coverdueuom_days AND
					   sdelparam.overdueint IN
					   (contractdelinqsetup.covdday, contractdelinqsetup.covdfirstday) OR
					   puom = coverdueuom_cycles AND
					   sdelparam.overdueint IN
					   (contractdelinqsetup.covdcycle, contractdelinqsetup.covdfirstcycle))
					THEN
						ooverdueperiod := cc.overdue;
					ELSE
					
						FOR i IN 1 .. 2
						LOOP
							IF ifcurrencyisusedintype(i, scontracttype, pcontractno)
							THEN
							
								vpaidhistarray := custom_overdueparameterscalculation.getoverdueparameters(paccountno           => sdepaccount(i)
																																   .accountno
																										  ,pcurrencynumber      => i
																										  ,pdate                => olastovddate
																										  ,pconsideroverduefrom => sdelparam.overdueint
																										  ,ooverdueparameters   => voverdueparameters);
							
								IF i = 1
								THEN
									vovddate_curr1 := voverdueparameters.overduedate;
								ELSE
									vovddate_curr2 := voverdueparameters.overduedate;
								END IF;
							
							END IF;
						END LOOP;
					
						vdeldate := least(nvl(vovddate_curr1, olastovddate)
										 ,nvl(vovddate_curr2, olastovddate));
						s.say(cmethodname ||
							  '   Delinquency occurance date in relation to oLastOvdDate (vDelDate) = ' ||
							  htools.d2s(vdeldate));
					
						IF puom = coverdueuom_days
						THEN
							ooverdueperiod := olastovddate - vdeldate;
						
							ouom := 'day(s)';
						ELSIF puom = coverdueuom_cycles
						THEN
							SELECT COUNT(1)
							INTO   ooverdueperiod
							FROM   tcontractstcycle a
							WHERE  a.branch = cbranch
							AND    a.contractno = scontractno
							AND    a.lastduedate BETWEEN vdeldate AND olastovddate;
						
							ouom := 'cycle(s)';
						END IF;
					END IF;
					EXIT;
				END IF;
			END LOOP;
		END IF;
	
		s.say(cmethodname || '   Last overdue date (oLastOvdDate) = ' || htools.d2s(olastovddate) ||
			  ', Overdue period (oOverduePeriod) = ' || ooverdueperiod ||
			  ', Unit of measure (oUOM) = ' || ouom
			 ,1);
		s.say(cmethodname || '   -->> END', 1);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getoverdueperiod;

	FUNCTION getcyclekeydates
	(
		pcontractno    IN typecontractno
	   ,pstatementdate IN DATE
	) RETURN typekeydatesrec IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCycleKeyDates';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vresult     typekeydatesrec := NULL;
		vcalendarid NUMBER;
	BEGIN
		t.enter(cmethodname, pstatementdate);
	
		IF pstatementdate IS NOT NULL
		THEN
			BEGIN
				SELECT dafdate
					  ,printedduedate
					  ,duedate
					  ,nextstatementdate
				INTO   vresult.dafdate
					  ,vresult.printedduedate
					  ,vresult.duedate
					  ,vresult.nextstatementdate
				FROM   tcontractstcycle
				WHERE  branch = cbranch
				AND    contractno = pcontractno
				AND    statementdate = pstatementdate;
				t.note(cmethodname
					  ,'Row found in tContractStCycle by specified pContractNo and pStatementDate');
			EXCEPTION
				WHEN no_data_found THEN
					t.note(cmethodname
						  ,'No row found by specified pContractNo and pStatementDate. Key dates will be taken from billing cycle calendar.');
					vcalendarid               := getcalendarid(pcontractno);
					vresult.dafdate           := contractcalendar.getdafdate(vcalendarid
																			,pstatementdate);
					vresult.printedduedate    := contractcalendar.getprintedduedate(vcalendarid
																				   ,pstatementdate);
					vresult.duedate           := contractcalendar.getpaymentduedate(vcalendarid
																				   ,pstatementdate);
					vresult.nextstatementdate := contractcalendar.getnextstatementdate(vcalendarid
																					  ,vresult.duedate);
			END;
		END IF;
	
		t.outpar('DafDate', vresult.dafdate);
		t.outpar('PrintedDueDate', vresult.printedduedate);
		t.outpar('DueDate', vresult.duedate);
		t.outpar('NextStatementDate', vresult.nextstatementdate);
	
		t.leave(cmethodname);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcyclekeydates;

	FUNCTION getbillingcyclecalendar(pcontractno typecontractno := NULL)
		RETURN tcontractcalendar.calendarid%TYPE IS
		cmethodname CONSTANT VARCHAR2(100) := cpackagename || '.GetBillingCycleCalendar';
	
		vcalendarid   tcontractcalendar.calendarid%TYPE;
		vcontracttype typecontracttype;
	
		vtypearray contractlink.typenumber;
	BEGIN
		s.say(cmethodname || '   --<< BEGIN', 1);
	
		IF NOT sacparam.exists(cp_billcyclecalendar)
		THEN
			sacparam(cp_billcyclecalendar) := NULL;
		END IF;
		IF NOT sactparam.exists(cctp_calendarid)
		THEN
			sactparam(cctp_calendarid) := NULL;
		END IF;
	
		s.say(cmethodname || '   INPUT PARAMETERS: Contract number (pContractNo) = ' ||
			  pcontractno);
		s.say(cmethodname ||
			  '    (implicit): Calendar Id on contract level (saCParam(cP_BillCycleCalendar)) = ' ||
			  sacparam(cp_billcyclecalendar) ||
			  ',  Calendar Id on CT level (saCTParam(cCTP_CalendarId)) = ' ||
			  sactparam(cctp_calendarid));
		s.say(cmethodname || ' ');
	
		IF pcontractno IS NULL
		THEN
			s.say(cmethodname ||
				  '    - info: Calendar is going to be taken from loaded global variables');
			IF nvl(sacparam(cp_billcyclecalendar), -1) = -1
			THEN
				vcalendarid := sactparam(cctp_calendarid);
			ELSE
				vcalendarid := sacparam(cp_billcyclecalendar);
			END IF;
		ELSE
		
			s.say(cmethodname || '    - info: Calendar is going to be calculated');
			vcalendarid := contractparams.loadnumber(contractparams.ccontract
													,pcontractno
													,'BillCycleCalendar'
													,pdoexception => FALSE);
		
			IF vcalendarid = -1
			THEN
				vcalendarid := NULL;
			END IF;
		
			IF vcalendarid IS NULL
			THEN
				vcontracttype := contract.gettype(pcontractno);
				IF contractparams.loadbool(contractparams.ccontracttype, vcontracttype, 'CorpMode')
				THEN
					IF contractlink.getlinktypes(vcontracttype, contractlink.clink, vtypearray) <> 1
					THEN
						error.raiseerror('Incorrect contract types link');
					END IF;
					vcalendarid := contractparams.loadnumber(contractparams.ccontracttype
															,vtypearray(1)
															,'CalendarId');
					s.say(cmethodname ||
						  '    - info: Calendar has been taken from corporative contract type');
				ELSE
					vcalendarid := contractparams.loadnumber(contractparams.ccontracttype
															,vcontracttype
															,'CalendarId');
					s.say(cmethodname ||
						  '    - info: Calendar has been taken from contract type parameters');
				END IF;
			ELSE
				s.say(cmethodname ||
					  '    - info: Calendar has been taken from contract parameters');
			END IF;
		END IF;
		s.say(cmethodname || '   Chosen calendar (vCalendarId) = ' || vcalendarid);
		s.say(cmethodname || '   -->> END');
		RETURN vcalendarid;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getbillingcyclecalendar;

	FUNCTION getoverduedata
	(
		pcontractno typecontractno
	   ,pdate       DATE
	) RETURN typeoverduedataarray IS
		cmethodname CONSTANT VARCHAR2(150) := cpackagename || '.GetOverdueData';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vitemcode    tcontractitem.itemcode%TYPE;
		vlastduedate DATE;
		vresult      typeoverduedataarray;
	BEGIN
		s.say(cmethodname || '     --<< BEGIN', 1);
		s.say(cmethodname || '      - INPUT PARAMETERS: pContractNo = ' || pcontractno ||
			  ', pDate = ' || htools.d2s(pdate));
		s.say('');
	
		SELECT MAX(duedate)
		INTO   vlastduedate
		FROM   tcontractstcycle
		WHERE  branch = cbranch
		AND    contractno = pcontractno
		AND    statementdate < pdate;
		s.say(cmethodname || '       Due Date chosen for overdue analyzing (vLastDueDate) = ' ||
			  htools.d2s(vlastduedate));
	
		FOR i IN 1 .. 2
		LOOP
		
			IF ifcurrencyisusedintype(i, NULL, pcontractno)
			THEN
				vitemcode := contracttypeitems.getitemcode(contract.gettype(pcontractno)
														  ,'ItemDeposit' || slabel(i));
				contracttools.loadcontractaccount(vitemcode, sdepaccount(i), pcontractno);
			
				vresult(i).minpayment := getminpayment(pcontractno, sdepaccount(i).accountno, pdate);
			
				getdueamount(paccountno     => sdepaccount(i).accountno
							,pdate          => pdate
							,odueamount     => vresult(i).dueamountonpdate
							,ooverdueamount => vresult(i).overdueamountonpdate);
			
				IF pdate >= vlastduedate
				THEN
				
					getdueamount(paccountno     => sdepaccount(i).accountno
								,pdate          => vlastduedate
								,odueamount     => vresult(i).overdueamountonduedate
								,ooverdueamount => vresult(i).overdueamountonduedate);
				
					vresult(i).overdueflag := nvl(abs(vresult(i).overdueamountonduedate), 0) > 0;
				END IF;
			
				IF vlastduedate IS NOT NULL
				   AND pdate < vlastduedate
				THEN
					s.say(cmethodname ||
						  '       - info: Since pDate < vLastDueDate then there is no overdue. Therefore variables are zeroed'
						 ,1);
					vresult(i).overdueamountonpdate := 0;
					vresult(i).overdueamountonduedate := 0;
					vresult(i).overdueflag := FALSE;
				END IF;
			
				vresult(i).accountremainonpdate := contracttools.get_eod_remain(sdepaccount(i)
																				.accountno
																			   ,pdate);
				vresult(i).minpayment := nvl(vresult(i).minpayment, 0);
				vresult(i).dueamountonpdate := nvl(abs(vresult(i).dueamountonpdate), 0);
				vresult(i).overdueamountonpdate := nvl(abs(vresult(i).overdueamountonpdate), 0);
				vresult(i).overdueamountonduedate := nvl(abs(vresult(i).overdueamountonduedate), 0);
				vresult(i).accountremainonpdate := nvl(vresult(i).accountremainonpdate, 0);
			
				s.say(cmethodname || '       METHOD OUTPUT FOR ACCOUNT (sDepAccount [' || i ||
					  '].AccountNo): ' || sdepaccount(i).accountno
					 ,1);
				s.say(cmethodname || '         Minimum payment (vArrayToReturn [' || i ||
					  '].MinPayment) = ' || vresult(i).minpayment
					 ,1);
				s.say(cmethodname || '         Due Amount on pDate (vArrayToReturn [' || i ||
					  '].DueAmountOnPDate) = ' || vresult(i).dueamountonpdate
					 ,1);
				s.say(cmethodname || '         OverDue Amount on pDate (vArrayToReturn [' || i ||
					  '].OverDueAmountOnPDate) = ' || vresult(i).overdueamountonpdate
					 ,1);
				s.say(cmethodname || '         OverDue Amount on Due Date (vArrayToReturn [' || i ||
					  '].OverDueAmountOnDueDate) = ' || vresult(i).overdueamountonduedate
					 ,1);
				s.say(cmethodname || '         Whether Overdue took place (vArrayToReturn [' || i ||
					  '].OverdueFlag) = ' || service.iif(vresult(i).overdueflag, 'YES', 'NO')
					 ,1);
				s.say(cmethodname || '         Account Remain On pDate (vArrayToReturn [' || i ||
					  '].AccountRemainOnPDate) = ' || vresult(i).accountremainonpdate
					 ,1);
			ELSE
				vresult(i) := NULL;
			END IF;
		END LOOP;
	
		s.say(cmethodname || '     -->> END', 1);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getoverduedata;

	FUNCTION getalllimitsvalue_fromhistory
	(
		pcontractno IN typecontractno
	   ,pdate       IN DATE := NULL
	) RETURN typealllimitarray IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetAllLimitsValue_FromHistory';
		cdate       CONSTANT DATE := nvl(pdate, seance.getoperdate);
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vcontracttype typecontracttype;
		vresult       typealllimitarray;
		vpan_mbr      VARCHAR2(50);
		vconvertedsum NUMBER;
		vsecondcurno  NUMBER;
		vmaincurno    NUMBER;
	
	BEGIN
		t.enter(cmethodname, 'pContractNo = ' || pcontractno || ', cDate = ' || htools.d2s(cdate));
	
		vresult(1)('-') := NULL;
		vresult(2)('-') := NULL;
	
		FOR cc IN (SELECT *
				   FROM   (SELECT ch.*
								 ,MAX(ch.recno) over(PARTITION BY key, addkey) maxrecno
								 ,CASE substr(addkey, 1, 3)
									  WHEN 'DOM' THEN
									   1
									  ELSE
									   2
								  END AS curno
								 ,regexp_replace(substr(addkey, 5), 'ACCOUNT', '-') AS pan_mbr
						   FROM   tcontracthistory ch
						   WHERE  ch.branch = cbranch
						   AND    ch.contractno = pcontractno
						   AND    ch.key IN ('CREDIT_LIMIT'
											,'CASH_LIMIT'
											,'USED_CREDIT_LIMIT'
											,'USED_CASH_LIMIT'
											,'USED_INSTALLMENT')
						   AND    operdate <= cdate
						   ORDER  BY ch.key
									,ch.addkey
									,ch.recno) sq
				   WHERE  sq.recno = sq.maxrecno)
		LOOP
			s.say(cmethodname || 'Limit parameter = ' || cc.key || ', CurNo = ' || cc.curno ||
				  ', Card = ' || masktodebug(cc.pan_mbr) || ', Limit value = ' || cc.value ||
				  ', Limit change date = ' || htools.d2s(cc.operdate));
		
			vpan_mbr := cc.pan_mbr;
		
			IF cc.key = 'CREDIT_LIMIT'
			THEN
				vresult(cc.curno)(vpan_mbr).estabcreditlimit := cc.value;
			ELSIF cc.key = 'CASH_LIMIT'
			THEN
				vresult(cc.curno)(vpan_mbr).estabcashlimit := cc.value;
			ELSIF cc.key = 'USED_CREDIT_LIMIT'
			THEN
				vresult(cc.curno)(vpan_mbr).usedcredlimit := cc.value;
			ELSIF cc.key = 'USED_CASH_LIMIT'
			THEN
				vresult(cc.curno)(vpan_mbr).usedcashlimit := cc.value;
			ELSIF cc.key = 'USED_INSTALLMENT'
			THEN
				vresult(cc.curno)(vpan_mbr).usedinstallment := cc.value;
			END IF;
		
			IF vresult(cc.curno)(vpan_mbr).estabcreditlimit IS NULL
			THEN
				vresult(cc.curno)(vpan_mbr).estabcreditlimit := 0;
			END IF;
			IF vresult(cc.curno)(vpan_mbr).estabcashlimit IS NULL
			THEN
				vresult(cc.curno)(vpan_mbr).estabcashlimit := 0;
			END IF;
		
			IF vresult(cc.curno)(vpan_mbr).usedcredlimit IS NULL
			THEN
				vresult(cc.curno)(vpan_mbr).usedcredlimit := 0;
			END IF;
			IF vresult(cc.curno)(vpan_mbr).usedcashlimit IS NULL
			THEN
				vresult(cc.curno)(vpan_mbr).usedcashlimit := 0;
			END IF;
			IF vresult(cc.curno)(vpan_mbr).usedinstallment IS NULL
			THEN
				vresult(cc.curno)(vpan_mbr).usedinstallment := 0;
			END IF;
		
		END LOOP;
	
		s.say(cmethodname || '        ++++ AVAILABLE LIMITS CALCULATION ++++');
		FOR i IN 1 .. 2
		LOOP
			IF vresult.exists(i)
			THEN
				s.say(cmethodname || '            Currency number (i) = ' || i ||
					  ', [1 - domestic currency, 2 - international one]');
				vpan_mbr := vresult(i).first;
			
				WHILE vpan_mbr IS NOT NULL
				LOOP
					s.say(cmethodname || '            vPAN_MBR_Index = ' || masktodebug(vpan_mbr));
					vresult(i)(vpan_mbr).availcreditlimit := greatest(nvl(vresult(i)(vpan_mbr)
																		  .estabcreditlimit
																		 ,0) - vresult(i)(vpan_mbr)
																	  .usedcredlimit - vresult(i)(vpan_mbr)
																	  .usedinstallment
																	 ,0);
					vresult(i)(vpan_mbr).availcashlimit := greatest(nvl(vresult(i)(vpan_mbr)
																		.estabcashlimit
																	   ,0) - vresult(i)(vpan_mbr)
																	.usedcashlimit
																   ,0);
					s.say(cmethodname || '          AvailCreditLimit = ' || vresult(i)(vpan_mbr)
						  .availcreditlimit || ', AvailCashLimit = ' || vresult(i)(vpan_mbr)
						  .availcashlimit);
					vpan_mbr := vresult(i).next(vpan_mbr);
				END LOOP;
			END IF;
		END LOOP;
		s.say(cmethodname || '        ++++                              ++++');
	
		IF vresult.count = 0
		THEN
			s.say('            ATTENTION!!! Contract <' || pcontractno ||
				  '> either has not been handled by RCM yet or not exist or contract limits were not specified on date <' ||
				  htools.d2s(cdate) || '>');
			RETURN vresult;
		END IF;
	
		vcontracttype := contract.gettype(pcontractno);
		s.say(cmethodname || '        vContractType = ' || vcontracttype);
		FOR i IN 1 .. 2
		LOOP
			sitem(i).dep := contracttypeitems.getitemcode(vcontracttype, 'ItemDeposit' || slabel(i));
			IF ifcurrencyisusedintype(i, vcontracttype)
			THEN
				contracttools.loadcontractaccount(sitem(i).dep, sdepaccount(i), pcontractno);
			END IF;
		END LOOP;
	
		slimittype := getlimittype_int(pcontractno);
		IF slimittype = caggregate
		THEN
			s.say('');
			sactparam(cctp_exchangerate) := nvl(contractparams.loadnumber(contractparams.ccontracttype
																		 ,vcontracttype
																		 ,'ExchangeRate'
																		 ,FALSE)
											   ,0);
			s.say(cmethodname ||
				  '        Exchange rate identifier (saCTParam(cCTP_ExchangeRate)) = ' ||
				  sactparam(cctp_exchangerate));
		
			IF NOT sdepaccount.exists(1)
			THEN
				sdepaccount(1) := NULL;
			END IF;
			IF NOT sdepaccount.exists(2)
			THEN
				sdepaccount(2) := NULL;
			END IF;
		
			vmaincurno   := service.iif(scardcount1 > 0, 1, 2);
			vsecondcurno := getvaluebycurno(vmaincurno, 2, 1);
		
			t.var('vMainCurNo', vmaincurno);
			t.var('vSecondCurNo', vsecondcurno);
		
			s.say(cmethodname || '            AGGREGATED LIMITS:');
		
			FOR i IN 1 .. 2
			LOOP
				s.say(cmethodname || '            Currency number (i) = ' || i ||
					  ', [1 - domestic currency, 2 - international one]');
				IF vresult.exists(i)
				THEN
					vpan_mbr := vresult(i).first;
				ELSE
					vpan_mbr := NULL;
				END IF;
			
				WHILE vpan_mbr IS NOT NULL
				LOOP
					s.say(cmethodname || '            vPAN_MBR_Index = ' || masktodebug(vpan_mbr));
					IF NOT vresult.exists(vmaincurno)
					THEN
						s.say(cmethodname ||
							  '            - info: Main currency limit information is not found');
						vresult(vmaincurno)(vpan_mbr) := NULL;
					ELSIF NOT vresult(vmaincurno).exists(vpan_mbr)
					THEN
						s.say(cmethodname ||
							  '            - info: Information for PAN_MBR is not found for main currency');
						vresult(vmaincurno)(vpan_mbr) := NULL;
					END IF;
				
					IF NOT vresult.exists(vsecondcurno)
					THEN
						s.say(cmethodname ||
							  '            - info: Minor currency limit information is not found');
						vresult(vsecondcurno)(vpan_mbr) := NULL;
					ELSIF NOT vresult(vsecondcurno).exists(vpan_mbr)
					THEN
						s.say(cmethodname ||
							  '            - info: Information for PAN_MBR is not found for minor currency');
						vresult(vsecondcurno)(vpan_mbr) := NULL;
					END IF;
				
					IF (i = vmaincurno)
					   OR ((i = vsecondcurno) AND
					   (vresult(vmaincurno)(vpan_mbr).estabcreditlimit IS NULL))
					THEN
					
						vconvertedsum := contracttools.getsumincurrency(nvl(vresult(vsecondcurno)(vpan_mbr)
																			.estabcreditlimit
																		   ,0)
																	   ,sdepaccount(vsecondcurno)
																		.currencyno
																	   ,sdepaccount(vmaincurno)
																		.currencyno
																	   ,sactparam(cctp_exchangerate));
						vresult(vmaincurno)(vpan_mbr).estabcreditlimitaggr := nvl(vresult(vmaincurno)(vpan_mbr)
																				  .estabcreditlimit
																				 ,0) +
																			  greatest(vconvertedsum
																					  ,0);
						vresult(vsecondcurno)(vpan_mbr).estabcreditlimitaggr := NULL;
					
						vconvertedsum := contracttools.getsumincurrency(nvl(vresult(vsecondcurno)(vpan_mbr)
																			.estabcashlimit
																		   ,0)
																	   ,sdepaccount(vsecondcurno)
																		.currencyno
																	   ,sdepaccount(vmaincurno)
																		.currencyno
																	   ,sactparam(cctp_exchangerate));
						vresult(vmaincurno)(vpan_mbr).estabcashlimitaggr := nvl(vresult(vmaincurno)(vpan_mbr)
																				.estabcashlimit
																			   ,0) +
																			greatest(vconvertedsum
																					,0);
						vresult(vsecondcurno)(vpan_mbr).estabcashlimitaggr := NULL;
					
						vconvertedsum := contracttools.getsumincurrency(nvl(vresult(vsecondcurno)(vpan_mbr)
																			.usedcredlimit
																		   ,0)
																	   ,sdepaccount(vsecondcurno)
																		.currencyno
																	   ,sdepaccount(vmaincurno)
																		.currencyno
																	   ,sactparam(cctp_exchangerate));
						vresult(vmaincurno)(vpan_mbr).usedcredlimitaggr := nvl(vresult(vmaincurno)(vpan_mbr)
																			   .usedcredlimit
																			  ,0) +
																		   greatest(vconvertedsum
																				   ,0);
						vresult(vsecondcurno)(vpan_mbr).usedcredlimitaggr := NULL;
					
						vconvertedsum := contracttools.getsumincurrency(nvl(vresult(vsecondcurno)(vpan_mbr)
																			.usedcashlimit
																		   ,0)
																	   ,sdepaccount(vsecondcurno)
																		.currencyno
																	   ,sdepaccount(vmaincurno)
																		.currencyno
																	   ,sactparam(cctp_exchangerate));
						vresult(vmaincurno)(vpan_mbr).usedcashlimitaggr := nvl(vresult(vmaincurno)(vpan_mbr)
																			   .usedcashlimit
																			  ,0) +
																		   greatest(vconvertedsum
																				   ,0);
						vresult(vsecondcurno)(vpan_mbr).usedcashlimitaggr := NULL;
					
						vconvertedsum := contracttools.getsumincurrency(nvl(vresult(vsecondcurno)(vpan_mbr)
																			.availcreditlimit
																		   ,0)
																	   ,sdepaccount(vsecondcurno)
																		.currencyno
																	   ,sdepaccount(vmaincurno)
																		.currencyno
																	   ,sactparam(cctp_exchangerate));
						vresult(vmaincurno)(vpan_mbr).availcreditlimitaggr := nvl(vresult(vmaincurno)(vpan_mbr)
																				  .availcreditlimit
																				 ,0) +
																			  greatest(vconvertedsum
																					  ,0);
						vresult(vsecondcurno)(vpan_mbr).availcreditlimitaggr := NULL;
					
						vconvertedsum := contracttools.getsumincurrency(nvl(vresult(vsecondcurno)(vpan_mbr)
																			.availcashlimit
																		   ,0)
																	   ,sdepaccount(vsecondcurno)
																		.currencyno
																	   ,sdepaccount(vmaincurno)
																		.currencyno
																	   ,sactparam(cctp_exchangerate));
						vresult(vmaincurno)(vpan_mbr).availcashlimitaggr := nvl(vresult(vmaincurno)(vpan_mbr)
																				.availcashlimit
																			   ,0) +
																			greatest(vconvertedsum
																					,0);
						vresult(vsecondcurno)(vpan_mbr).availcashlimitaggr := NULL;
					
						s.say(cmethodname || '              vPAN_MBR_Index = ' ||
							  masktodebug(vpan_mbr));
						s.say(cmethodname || '              EstabCreditLimitAggr = ' ||
							  vresult(vmaincurno)(vpan_mbr).estabcreditlimitaggr);
						s.say(cmethodname || '              EstabCashLimitAggr = ' ||
							  vresult(vmaincurno)(vpan_mbr).estabcashlimitaggr);
						s.say(cmethodname || '              UsedCredLimitAggr = ' ||
							  vresult(vmaincurno)(vpan_mbr).usedcredlimitaggr);
						s.say(cmethodname || '              UsedCashLimitAggr = ' ||
							  vresult(vmaincurno)(vpan_mbr).usedcashlimitaggr);
						s.say(cmethodname || '              AvailCreditLimitAggr = ' ||
							  vresult(vmaincurno)(vpan_mbr).availcreditlimitaggr);
						s.say(cmethodname || '              AvailCashLimitAggr = ' ||
							  vresult(vmaincurno)(vpan_mbr).availcashlimitaggr);
					END IF;
				
					vpan_mbr := vresult(i).next(vpan_mbr);
				
				END LOOP;
			END LOOP;
		END IF;
	
		t.leave(cmethodname);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getalllimitsvalue_fromhistory;

	PROCEDURE fillcontrattributecache
	(
		pcontractno IN typecontractno
	   ,pattrgroup  IN VARCHAR2
	   ,pstartdate  IN DATE
	   ,penddate    IN DATE
	   ,ocacheindex OUT NOCOPY VARCHAR2
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.FillContrAttributeCache';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		coperdate   CONSTANT DATE := seance.getoperdate;
	
		vstartdate  DATE := nvl(pstartdate, coperdate);
		venddate    DATE := nvl(penddate, vstartdate);
		vcacheindex VARCHAR2(150) := pcontractno || '-' || to_char(vstartdate, 'yyyymmdd') || '-' ||
									 to_char(venddate, 'yyyymmdd');
	
		vcontracttype  typecontracttype;
		vaalllimits    typealllimitarray;
		vpan_mbr_index VARCHAR2(100);
		vcacherowindex NUMBER := 0;
		vcurno         NUMBER;
	
		vcontrlevelfound    BOOLEAN := FALSE;
		vacctlevelfound     BOOLEAN := FALSE;
		vacctcardlevelfound BOOLEAN := FALSE;
	
		vcontrstminpaymdataarr typecontrstminpaymdataarr;
		vnumberrowstohandle    NUMBER;
	
		PROCEDURE putlimitvalues
		(
			plimitvalues    IN typealllimitrec
		   ,poattributesrec IN OUT NOCOPY typecontrattributesrec
		) IS
			cmethodname CONSTANT typemethodname := fillcontrattributecache.cmethodname ||
												   '.PutLimitValues';
		BEGIN
			poattributesrec.estab_credit_limit      := plimitvalues.estabcreditlimit;
			poattributesrec.cash_limit              := plimitvalues.estabcashlimit;
			poattributesrec.used_cred_limit         := plimitvalues.usedcredlimit;
			poattributesrec.used_cash_limit         := plimitvalues.usedcashlimit;
			poattributesrec.used_installment        := plimitvalues.usedinstallment;
			poattributesrec.avail_limit             := plimitvalues.availcreditlimit;
			poattributesrec.avail_cash_limit        := plimitvalues.availcashlimit;
			poattributesrec.aggr_estab_credit_limit := plimitvalues.estabcreditlimitaggr;
			poattributesrec.aggr_cash_limit         := plimitvalues.estabcashlimitaggr;
			poattributesrec.aggr_used_cred_limit    := plimitvalues.usedcredlimitaggr;
			poattributesrec.aggr_used_cash_limit    := plimitvalues.usedcashlimitaggr;
			poattributesrec.aggr_avail_limit        := plimitvalues.availcreditlimitaggr;
			poattributesrec.aggr_avail_cash_limit   := plimitvalues.availcashlimitaggr;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END putlimitvalues;
	
	BEGIN
		t.enter(cmethodname);
	
		s.say(cmethodname || '      - INPUT PARAMETERS: pContractNo = ' || pcontractno ||
			  ', Contract attribute group to be calculated (pAttributeGroup) = ' || pattrgroup ||
			  ', pBeginDate = ' || htools.d2s(pstartdate) || ', pEndDate = ' ||
			  htools.d2s(penddate) || ', Cache index (vCacheIndex) = ' || vcacheindex);
	
		s.say(cmethodname || '      vBeginDate = ' || htools.d2s(vstartdate) || ', vEndDate = ' ||
			  htools.d2s(venddate));
	
		ocacheindex := vcacheindex;
	
		vcontracttype := contract.gettype(pcontractno);
		IF contracttools.notequal(scontracttype, vcontracttype)
		THEN
			s.say(cmethodname || '      - info: scheme parameters are going to be loaded');
			scontracttype := vcontracttype;
			sactparam     := loadparam(scontracttype, cactp_ident);
			sact_cparam   := loadparam(scontracttype, cacp_ident, FALSE);
			FOR i IN 1 .. 2
			LOOP
				sitem(i).dep := contracttypeitems.getitemcode(scontracttype
															 ,'ItemDeposit' || slabel(i));
				sitem(i).ovd := contracttypeitems.getitemcode(scontracttype
															 ,'ItemOverdraft' || slabel(i));
			END LOOP;
		
			IF ifcurrencyisusedintype(1, scontracttype, scontractno)
			THEN
				sactparamccy(1) := loadparam(scontracttype, cactp_dom_ident);
				sacctparamccy(1) := loadparam(scontracttype, cacontrpdom_ident);
			END IF;
			IF ifcurrencyisusedintype(2, scontracttype, scontractno)
			THEN
				sactparamccy(2) := loadparam(scontracttype, cactp_int_ident);
				sacctparamccy(2) := loadparam(scontracttype, cacontrpint_ident);
			END IF;
		ELSE
			s.say(cmethodname || '      - info: scheme parameters have been loaded already');
		END IF;
	
		s.say(cmethodname || '      sContractNo = ' || scontractno);
	
		IF contracttools.notequal(scontractno, pcontractno)
		THEN
			s.say(cmethodname || '       - info: sContractNo and pContractNo are different');
			scontractno := pcontractno;
		
			FOR i IN 1 .. 2
			LOOP
				IF ifcurrencyisusedintype(i, vcontracttype)
				THEN
					contracttools.loadcontractaccount(sitem(i).dep, sdepaccount(i), scontractno);
					contracttools.loadcontractaccount(sitem(i).ovd, sovdaccount(i), scontractno);
					IF i = 1
					THEN
						sacparamccy(i)(0) := NULL;
						loadparam(scontractno, cacontrpdom_ident, sacctparamccy(i), sacparamccy(i));
					ELSE
						sacparamccy(i)(0) := NULL;
						loadparam(scontractno, cacontrpint_ident, sacctparamccy(i), sacparamccy(i));
					END IF;
					sprecision(i) := referencecurrency.getprecision(sdepaccount(i).currencyno);
					s.say(cmethodname || '       sDepAccount(' || i || ').AccountNo = ' || sdepaccount(i)
						  .accountno || ', sPrecision = ' || sprecision(i));
				END IF;
			END LOOP;
		END IF;
	
		IF scontrattrcalcflag.exists(vcacheindex)
		   AND scontrattrcalcflag(vcacheindex).exists(pattrgroup)
		THEN
			s.say(cmethodname ||
				  '      -info: Cache has been filled already for the attribute group ' ||
				  pattrgroup);
			RETURN;
		END IF;
	
		IF pattrgroup = cgroup_2
		   AND (NOT scontrattrcalcflag.exists(vcacheindex) OR
		   NOT scontrattrcalcflag(vcacheindex).exists(cgroup_2))
		THEN
			vaalllimits := getalllimitsvalue;
		END IF;
	
		IF scontrattrcache.count > 10
		THEN
			FOR i IN 1 .. 7
			LOOP
			
				IF scontrattrcache.first <> vcacheindex
				THEN
					s.say(cmethodname || '         - Snapshot with index ' ||
						  scontrattrcache.first || ' has been deleted');
					scontrattrcache.delete(scontrattrcache.first);
					scontrattrcalcflag.delete(scontrattrcalcflag.first);
				END IF;
			END LOOP;
		END IF;
	
		t.var('Current number of cache''s snapshot (sContrAttrCache.count)', scontrattrcache.count);
		IF scontrattrcache.exists(vcacheindex)
		THEN
			vcacherowindex := scontrattrcache(vcacheindex).count;
		END IF;
		t.var('Current number of rows in the cache attributes (vCacheRowIndex)', vcacherowindex);
	
		IF pattrgroup = cgroup_1
		THEN
		
			SELECT contractno
				  ,currencynumber
				  ,accountno
				  ,dafdate
				  ,printedduedate
				  ,duedate
				  ,statementdate
				  ,nextstatementdate
				  ,sdamount
				  ,minpayment BULK COLLECT
			INTO   vcontrstminpaymdataarr
			FROM   vcontractstcyclempdata
			WHERE  branch = cbranch
			AND    contractno = scontractno
			AND    statementdate <= venddate
			AND    statementdate >= to_date('01.01.1900', 'dd.mm.yyyy')
			UNION ALL
			SELECT contractno
				  ,NULL
				  ,NULL
				  ,dafdate
				  ,printedduedate
				  ,duedate
				  ,statementdate
				  ,nextstatementdate
				  ,NULL
				  ,NULL
			FROM   tcontractstcycle
			WHERE  branch = cbranch
			AND    contractno = scontractno
			AND    statementdate IS NULL
			AND    nextstatementdate > venddate
			ORDER  BY statementdate  DESC
					 ,currencynumber ASC;
		
			vnumberrowstohandle := vcontrstminpaymdataarr.count;
			IF vnumberrowstohandle >= 2
			THEN
				IF vcontrstminpaymdataarr(1)
				 .currencynumber <> vcontrstminpaymdataarr(2).currencynumber
				THEN
					vnumberrowstohandle := 2;
				ELSE
					vnumberrowstohandle := 1;
				END IF;
			END IF;
			s.say(cmethodname || '       Number of rows to handle (vNumberRowsToHandle) = ' ||
				  vnumberrowstohandle);
		
			IF vnumberrowstohandle > 0
			THEN
			
				FOR j IN 1 .. vcacherowindex
				LOOP
					IF scontrattrcache(vcacheindex)(j).account_no || scontrattrcache(vcacheindex)(j)
					.pan_mbr IS NULL
					THEN
						s.say(cmethodname ||
							  '         - info: Contract level exists in the cache for the contract'
							 ,1);
						scontrattrcache(vcacheindex)(j).st_date_on_spec_date := vcontrstminpaymdataarr(1)
																				.statementdate;
						scontrattrcache(vcacheindex)(j).due_date_on_spec_date := vcontrstminpaymdataarr(1)
																				 .duedate;
						scontrattrcache(vcacheindex)(j).prn_due_date_on_spec_date := vcontrstminpaymdataarr(1)
																					 .printedduedate;
						scontrattrcache(vcacheindex)(j).daf_date_on_spec_date := vcontrstminpaymdataarr(1)
																				 .dafdate;
						scontrattrcache(vcacheindex)(j).next_st_date_on_spec_date := vcontrstminpaymdataarr(1)
																					 .nextstatementdate;
					
						s.say(cmethodname ||
							  '       Updated attribute values: ST_DATE_ON_SPEC_DATE =' ||
							  htools.d2s(scontrattrcache(vcacheindex)(j).st_date_on_spec_date) ||
							  ', DUE_DATE_ON_SPEC_DATE = ' ||
							  htools.d2s(scontrattrcache(vcacheindex)(j).due_date_on_spec_date) ||
							  ', PRN_DUE_DATE_ON_SPEC_DATE = ' ||
							  htools.d2s(scontrattrcache(vcacheindex)(j).prn_due_date_on_spec_date) ||
							  ', DAF_DATE_ON_SPEC_DATE = ' ||
							  htools.d2s(scontrattrcache(vcacheindex)(j).daf_date_on_spec_date) ||
							  ', NEXT_ST_DATE_ON_SPEC_DATE = ' ||
							  htools.d2s(scontrattrcache(vcacheindex)(j).next_st_date_on_spec_date));
						vcontrlevelfound := TRUE;
						EXIT;
					END IF;
				END LOOP;
				IF NOT vcontrlevelfound
				THEN
					s.say(cmethodname ||
						  '       - info: Contract level DOES NOT exist in the cache for the contract'
						 ,1);
					vcacherowindex := vcacherowindex + 1;
					scontrattrcache(vcacheindex)(vcacherowindex).st_date_on_spec_date := vcontrstminpaymdataarr(1)
																						 .statementdate;
					scontrattrcache(vcacheindex)(vcacherowindex).due_date_on_spec_date := vcontrstminpaymdataarr(1)
																						  .duedate;
					scontrattrcache(vcacheindex)(vcacherowindex).prn_due_date_on_spec_date := vcontrstminpaymdataarr(1)
																							  .printedduedate;
					scontrattrcache(vcacheindex)(vcacherowindex).daf_date_on_spec_date := vcontrstminpaymdataarr(1)
																						  .dafdate;
					scontrattrcache(vcacheindex)(vcacherowindex).next_st_date_on_spec_date := vcontrstminpaymdataarr(1)
																							  .nextstatementdate;
				
					s.say(cmethodname || '         Added attribute values: ST_DATE_ON_SPEC_DATE =' ||
						  htools.d2s(scontrattrcache(vcacheindex)(vcacherowindex)
									 .st_date_on_spec_date) || ', DUE_DATE_ON_SPEC_DATE = ' ||
						  htools.d2s(scontrattrcache(vcacheindex)(vcacherowindex)
									 .due_date_on_spec_date) || ', PRN_DUE_DATE_ON_SPEC_DATE = ' ||
						  htools.d2s(scontrattrcache(vcacheindex)(vcacherowindex)
									 .prn_due_date_on_spec_date) || ', DAF_DATE_ON_SPEC_DATE = ' ||
						  htools.d2s(scontrattrcache(vcacheindex)(vcacherowindex)
									 .daf_date_on_spec_date) || ', NEXT_ST_DATE_ON_SPEC_DATE = ' ||
						  htools.d2s(scontrattrcache(vcacheindex)(vcacherowindex)
									 .next_st_date_on_spec_date));
				END IF;
			
				FOR i IN 1 .. vnumberrowstohandle
				LOOP
					FOR j IN 1 .. vcacherowindex
					LOOP
						IF scontrattrcache(vcacheindex)(j).account_no IS NOT NULL
						   AND scontrattrcache(vcacheindex)(j).pan_mbr IS NULL
						THEN
							IF scontrattrcache(vcacheindex)(j)
							.account_no = vcontrstminpaymdataarr(i).accountno
							THEN
								s.say(cmethodname || '         - info: Account <' ||
									  scontrattrcache(vcacheindex)(j)
									  .account_no || '> level exists in the cache for the contract'
									 ,1);
								scontrattrcache(vcacheindex)(j).mp_on_spec_date := vcontrstminpaymdataarr(i)
																				   .minpayment;
								s.say(cmethodname ||
									  '       Updated attribute value: MP_ON_SPEC_DATE =' ||
									  scontrattrcache(vcacheindex)(j).mp_on_spec_date
									 ,1);
								scontrattrcache(vcacheindex)(j).sd_amount_on_spec_date := vcontrstminpaymdataarr(i)
																						  .sdamount;
								s.say(cmethodname ||
									  '       Updated attribute value: SD_AMOUNT_ON_SPEC_DATE =' ||
									  scontrattrcache(vcacheindex)(j).sd_amount_on_spec_date
									 ,1);
								vacctlevelfound := TRUE;
								EXIT;
							END IF;
						END IF;
					END LOOP;
				
					IF NOT vacctlevelfound
					THEN
						s.say(cmethodname || '         - info: Account <' || vcontrstminpaymdataarr(i)
							  .accountno || '> level DOES NOT exist in the cache for the contract'
							 ,1);
						vcacherowindex := vcacherowindex + 1;
						scontrattrcache(vcacheindex)(vcacherowindex).account_no := vcontrstminpaymdataarr(i)
																				   .accountno;
						scontrattrcache(vcacheindex)(vcacherowindex).mp_on_spec_date := vcontrstminpaymdataarr(i)
																						.minpayment;
						s.say(cmethodname || '         Added attribute value: MP_ON_SPEC_DATE =' ||
							  scontrattrcache(vcacheindex)(vcacherowindex).mp_on_spec_date);
						scontrattrcache(vcacheindex)(vcacherowindex).sd_amount_on_spec_date := vcontrstminpaymdataarr(i)
																							   .sdamount;
						s.say(cmethodname ||
							  '         Added attribute value: SD_AMOUNT_ON_SPEC_DATE =' ||
							  scontrattrcache(vcacheindex)(vcacherowindex).sd_amount_on_spec_date);
						vacctlevelfound := FALSE;
					END IF;
				END LOOP;
			END IF;
		
			scontrattrcalcflag(vcacheindex)(cgroup_1) := 1;
		
		ELSIF pattrgroup = cgroup_2
		THEN
			s.say(cmethodname ||
				  '       - info: Limits are going to be filled with values (sAllLimits.count) = ' ||
				  vaalllimits.count);
		
			vcurno := vaalllimits.first;
		
			WHILE vcurno IS NOT NULL
			LOOP
				s.say(' ', 1);
				s.say(cmethodname || '       Currency number (vCurNo) = ' || vcurno ||
					  ', [1 - domestic currency, 2 - international one]');
				vpan_mbr_index := vaalllimits(vcurno).first;
				s.say(cmethodname || '       FIRST PAN_MBR found for the currency = ' ||
					  masktodebug(vpan_mbr_index) || ', ["-" means account limit (not card)]');
			
				WHILE vpan_mbr_index IS NOT NULL
				LOOP
					s.say(cmethodname || '         vPAN_MBR_Index = ' ||
						  masktodebug(vpan_mbr_index) || ' , ["-" means account limit (not card)]');
					FOR j IN 1 .. vcacherowindex
					LOOP
					
						s.say(cmethodname || '           Existed cache data ' ||
							  scontrattrcache(vcacheindex)(j)
							  .account_no || '<->' || scontrattrcache(vcacheindex)(j)
							  .pan_mbr ||
							  ', [null - contract level, "acc<->" - account level, "acc<->card" - account+card level, "<->PANMBR" - card level]');
						IF vpan_mbr_index = '-'
						THEN
							IF scontrattrcache(vcacheindex)(j).account_no IS NOT NULL
							   AND scontrattrcache(vcacheindex)(j)
							.pan_mbr IS NULL
							   AND scontrattrcache(vcacheindex)(j)
							.account_no = sdepaccount(vcurno).accountno
							THEN
								s.say(cmethodname || '         - info: Account <' ||
									  scontrattrcache(vcacheindex)(j)
									  .account_no || '> level exists in the cache for the contract'
									 ,1);
								putlimitvalues(vaalllimits(vcurno) ('-')
											  ,scontrattrcache(vcacheindex) (j));
								s.say(cmethodname ||
									  '         Updated attribute value: ESTAB_CREDIT_LIMIT =' ||
									  scontrattrcache(vcacheindex)(vcacherowindex)
									  .estab_credit_limit || ', USED_CRED_LIMIT = ' ||
									  scontrattrcache(vcacheindex)(vcacherowindex)
									  .used_cred_limit || ', AVAIL_LIMIT = ' ||
									  scontrattrcache(vcacheindex)(vcacherowindex)
									  .avail_limit || ' ..... ');
								vacctlevelfound := TRUE;
								EXIT;
							END IF;
						ELSIF vpan_mbr_index <> '-'
						THEN
							IF scontrattrcache(vcacheindex)(j).pan_mbr IS NOT NULL
							   AND scontrattrcache(vcacheindex)(j)
							.account_no IS NOT NULL
							   AND sdepaccount(vcurno).accountno = scontrattrcache(vcacheindex)(j)
							.account_no
							   AND scontrattrcache(vcacheindex)(j).pan_mbr = vpan_mbr_index
							THEN
								s.say(cmethodname || '         - info: Account <' ||
									  scontrattrcache(vcacheindex)(j)
									  .account_no || '>+card <' || scontrattrcache(vcacheindex)(j)
									  .pan_mbr || '> level exist in the cache for the contract');
								putlimitvalues(vaalllimits(vcurno) (vpan_mbr_index)
											  ,scontrattrcache(vcacheindex) (j));
								s.say(cmethodname ||
									  '         Updated attribute value: ESTAB_CREDIT_LIMIT =' ||
									  scontrattrcache(vcacheindex)(vcacherowindex)
									  .estab_credit_limit || ', USED_CRED_LIMIT = ' ||
									  scontrattrcache(vcacheindex)(vcacherowindex)
									  .used_cred_limit || ', AVAIL_LIMIT = ' ||
									  scontrattrcache(vcacheindex)(vcacherowindex)
									  .avail_limit || ' ..... ');
								vacctcardlevelfound := TRUE;
								EXIT;
							END IF;
						END IF;
					END LOOP;
				
					IF NOT vacctcardlevelfound
					   AND vpan_mbr_index <> '-'
					THEN
						s.say(cmethodname || '         - info: Account <' || sdepaccount(vcurno)
							  .accountno || '>+card <' || masktodebug(vpan_mbr_index) ||
							  '> level DOES NOT exist in the cache for the contract');
					
						vcacherowindex := vcacherowindex + 1;
					
						scontrattrcache(vcacheindex)(vcacherowindex).account_no := sdepaccount(vcurno)
																				   .accountno;
						scontrattrcache(vcacheindex)(vcacherowindex).pan_mbr := vpan_mbr_index;
					
						putlimitvalues(vaalllimits(vcurno) (vpan_mbr_index)
									  ,scontrattrcache(vcacheindex) (vcacherowindex));
					
						s.say(cmethodname ||
							  '         Added attribute value: ESTAB_CREDIT_LIMIT =' ||
							  scontrattrcache(vcacheindex)(vcacherowindex)
							  .estab_credit_limit || ', USED_CRED_LIMIT = ' ||
							  scontrattrcache(vcacheindex)(vcacherowindex)
							  .used_cred_limit || ', AVAIL_LIMIT = ' ||
							  scontrattrcache(vcacheindex)(vcacherowindex)
							  .avail_limit || ' ..... ');
					END IF;
					vacctcardlevelfound := FALSE;
					vpan_mbr_index      := vaalllimits(vcurno).next(vpan_mbr_index);
				END LOOP;
			
				IF NOT vacctlevelfound
				THEN
					s.say(cmethodname || '         - info: Account <' || sdepaccount(vcurno)
						  .accountno || '> level DOES NOT exist in the cache for the contract');
				
					vcacherowindex := vcacherowindex + 1;
				
					scontrattrcache(vcacheindex)(vcacherowindex).account_no := sdepaccount(vcurno)
																			   .accountno;
				
					putlimitvalues(vaalllimits(vcurno) ('-')
								  ,scontrattrcache(vcacheindex) (vcacherowindex));
				
					s.say(cmethodname || '         Added attribute value: ESTAB_CREDIT_LIMIT =' ||
						  scontrattrcache(vcacheindex)(vcacherowindex)
						  .estab_credit_limit || ', USED_CRED_LIMIT = ' ||
						  scontrattrcache(vcacheindex)(vcacherowindex)
						  .used_cred_limit || ', AVAIL_LIMIT = ' || scontrattrcache(vcacheindex)(vcacherowindex)
						  .avail_limit || ' ..... ');
				END IF;
				vacctlevelfound := FALSE;
				vcurno          := vaalllimits.next(vcurno);
			END LOOP;
			scontrattrcalcflag(vcacheindex)(cgroup_2) := 1;
		
		ELSIF pattrgroup = cgroup_3
		THEN
		
			FOR cc IN (SELECT *
					   FROM   (SELECT ctl.accountno
									 ,ctl.postdate
									 ,SUM(ctl.amount) over(PARTITION BY ctl.contractno, ctl.accountno, ctl.postdate) paidamount
									 ,MAX(ctl.postdate) over(PARTITION BY ctl.contractno, ctl.accountno) maxpostdate
							   FROM   tcontracttrxnlist ctl
							   WHERE  ctl.branch = cbranch
							   AND    ctl.contractno = scontractno
							   AND    postdate <= penddate
							   AND    trantype = ctrxntype_repayment)
					   WHERE  postdate = maxpostdate)
			LOOP
				FOR j IN 1 .. vcacherowindex
				LOOP
					IF scontrattrcache(vcacheindex)(j).account_no IS NOT NULL
					   AND scontrattrcache(vcacheindex)(j).pan_mbr IS NULL
					THEN
						IF scontrattrcache(vcacheindex)(j).account_no = cc.accountno
						THEN
							s.say(cmethodname || '       - info: Account <' ||
								  scontrattrcache(vcacheindex)(j)
								  .account_no || '> level exists in the cache for the contract'
								 ,1);
							scontrattrcache(vcacheindex)(j).last_payment_date := cc.postdate;
							scontrattrcache(vcacheindex)(j).last_paid_amount := cc.paidamount;
							s.say(cmethodname ||
								  '       Updated attribute value: LAST_PAYMENT_DATE =' ||
								  htools.d2s(scontrattrcache(vcacheindex)(j).last_payment_date) ||
								  ', LAST_PAID_AMOUNT = ' || scontrattrcache(vcacheindex)(j)
								  .last_paid_amount);
							vacctlevelfound := TRUE;
							EXIT;
						END IF;
					END IF;
				END LOOP;
			
				IF NOT vacctlevelfound
				THEN
					s.say(cmethodname || '       - info: Account <' || cc.accountno ||
						  '> level DOES NOT exist in the cache for the contract'
						 ,1);
					vcacherowindex := vcacherowindex + 1;
					scontrattrcache(vcacheindex)(vcacherowindex).account_no := cc.accountno;
					scontrattrcache(vcacheindex)(vcacherowindex).last_payment_date := cc.postdate;
					scontrattrcache(vcacheindex)(vcacherowindex).last_paid_amount := cc.paidamount;
					s.say(cmethodname || '         Added attribute value: LAST_PAYMENT_DATE = ' ||
						  htools.d2s(scontrattrcache(vcacheindex)(vcacherowindex)
									 .last_payment_date) || ', LAST_PAID_AMOUNT = ' ||
						  scontrattrcache(vcacheindex)(vcacherowindex).last_paid_amount);
					vacctlevelfound := FALSE;
				END IF;
			END LOOP;
			scontrattrcalcflag(vcacheindex)(cgroup_3) := 1;
		END IF;
	
		t.leave(cmethodname, ocacheindex);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END fillcontrattributecache;

	FUNCTION getcontrattr_cyclekeydates
	(
		pcontractno IN typecontractno
	   ,pdate       IN DATE
	) RETURN typecontrstminpaymdatarec IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetContrAttr_CycleKeyDates';
		vresult     typecontrstminpaymdatarec;
		vcacheindex VARCHAR2(150);
	BEGIN
		t.enter(cmethodname, 'pContractNo = ' || pcontractno || ', pDate = ' || htools.d2s(pdate));
	
		fillcontrattributecache(pcontractno, cgroup_1, pdate, pdate, vcacheindex);
	
		IF scontrattrcache.exists(vcacheindex)
		THEN
			t.var('Records in cache', scontrattrcache(vcacheindex).count);
			FOR i IN 1 .. scontrattrcache(vcacheindex).count
			LOOP
				s.say(cmethodname || '      -> sContrAttrCache(vCacheIndex)(' || i ||
					  ').ACCOUNT_NO = ' || scontrattrcache(vcacheindex)(i)
					  .account_no || ', sContrAttrCache(vCacheIndex)(' || i || ').PAN_MBR = ' ||
					  masktodebug(scontrattrcache(vcacheindex)(i).pan_mbr));
				IF nvl(scontrattrcache(vcacheindex)(i).account_no
					  ,scontrattrcache(vcacheindex)(i).pan_mbr) IS NULL
				THEN
					vresult.statementdate     := scontrattrcache(vcacheindex)(i)
												.st_date_on_spec_date;
					vresult.duedate           := scontrattrcache(vcacheindex)(i)
												.due_date_on_spec_date;
					vresult.printedduedate    := scontrattrcache(vcacheindex)(i)
												.prn_due_date_on_spec_date;
					vresult.dafdate           := scontrattrcache(vcacheindex)(i)
												.daf_date_on_spec_date;
					vresult.nextstatementdate := scontrattrcache(vcacheindex)(i)
												.next_st_date_on_spec_date;
					EXIT;
				END IF;
			END LOOP;
		ELSE
			t.note(cmethodname, 'Information was not found by input parameters!');
		END IF;
	
		t.leave(cmethodname
			   ,'SD = ' || htools.d2s(vresult.statementdate) || ', DD = ' ||
				htools.d2s(vresult.duedate) || ', PDD = ' || htools.d2s(vresult.printedduedate) ||
				', DAFDate = ' || htools.d2s(vresult.dafdate) || ', NextSD = ' ||
				htools.d2s(vresult.nextstatementdate));
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcontrattr_cyclekeydates;

	FUNCTION getcontrattr_minpayment
	(
		pcontractno IN typecontractno
	   ,pdate       IN DATE
	   ,pcurno      IN NUMBER
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetContrAttr_MinPayment';
		vcacheindex VARCHAR2(150);
		vresult     NUMBER;
	BEGIN
		t.enter(cmethodname
			   ,'pContractNo = ' || pcontractno || ', pDate = ' || htools.d2s(pdate) ||
				', pCurrencyNumber = ' || pcurno);
	
		fillcontrattributecache(pcontractno, cgroup_1, pdate, pdate, vcacheindex);
	
		IF scontrattrcache.exists(vcacheindex)
		THEN
			t.var('sContrAttrCache(vCacheIndex).count', scontrattrcache(vcacheindex).count);
			FOR i IN 1 .. scontrattrcache(vcacheindex).count
			LOOP
			
				s.say(cmethodname || '      -> sContrAttrCache(vCacheIndex)(' || i ||
					  ').ACCOUNT_NO = ' || scontrattrcache(vcacheindex)(i)
					  .account_no || ', sContrAttrCache(vCacheIndex)(' || i || ').PAN_MBR = ' ||
					  scontrattrcache(vcacheindex)(i).pan_mbr);
				IF scontrattrcache(vcacheindex)(i).account_no IS NOT NULL
				   AND scontrattrcache(vcacheindex)(i).pan_mbr IS NULL
				THEN
					IF scontrattrcache(vcacheindex)(i).account_no = sdepaccount(pcurno).accountno
					THEN
						vresult := scontrattrcache(vcacheindex)(i).mp_on_spec_date;
						EXIT;
					END IF;
				END IF;
			END LOOP;
		ELSE
			s.say(cmethodname || '     -info: information was not found by input parameters');
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcontrattr_minpayment;

	FUNCTION getcontrattr_sdamount
	(
		pcontractno     typecontractno
	   ,pdate           DATE
	   ,pcurrencynumber tcontractstminpaymentdata.currencynumber%TYPE
	) RETURN vcontractstcyclempdata.sdamount%TYPE IS
		cmethodname CONSTANT VARCHAR2(150) := cpackagename || '.GetContrAttr_SDAmount';
	
		vcacheindex       VARCHAR2(150);
		vsdamounttoreturn NUMBER;
	BEGIN
		s.say(cmethodname || '     --<< BEGIN');
		s.say(cmethodname || '      - INPUT PARAMETERS: pContractNo = ' || pcontractno ||
			  ', pDate = ' || htools.d2s(pdate) || ', pCurrencyNumber = ' || pcurrencynumber);
		s.say('');
		fillcontrattributecache(pcontractno, cgroup_1, pdate, pdate, vcacheindex);
		s.say(cmethodname || '      Cache index (vCacheIndex) = ' || vcacheindex);
		IF scontrattrcache.exists(vcacheindex)
		THEN
			s.say(cmethodname || '      sContrAttrCache (vCacheIndex).count = ' || scontrattrcache(vcacheindex)
				  .count
				 ,1);
			FOR i IN 1 .. scontrattrcache(vcacheindex).count
			LOOP
				s.say(cmethodname || '      -> sContrAttrCache(vCacheIndex)(' || i ||
					  ').ACCOUNT_NO = ' || scontrattrcache(vcacheindex)(i)
					  .account_no || ', sContrAttrCache(vCacheIndex)(' || i || ').PAN_MBR = ' ||
					  masktodebug(scontrattrcache(vcacheindex)(i).pan_mbr));
				IF scontrattrcache(vcacheindex)(i).account_no IS NOT NULL
				   AND scontrattrcache(vcacheindex)(i).pan_mbr IS NULL
				THEN
					IF scontrattrcache(vcacheindex)(i)
					.account_no = sdepaccount(pcurrencynumber).accountno
					THEN
						vsdamounttoreturn := scontrattrcache(vcacheindex)(i).sd_amount_on_spec_date;
						EXIT;
					END IF;
				END IF;
			END LOOP;
		ELSE
			s.say(cmethodname || '     -info: information was not found by input parameters');
		END IF;
		s.say(cmethodname || '     vSDAmountToReturn = ' || vsdamounttoreturn);
		s.say(cmethodname || '     -->> END');
		RETURN vsdamounttoreturn;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getcontrattr_sdamount;

	FUNCTION getcontrattr_alllimits
	(
		pcontractno IN typecontractno
	   ,pcurno      IN NUMBER
	   ,ppan        IN typepan
	   ,pmbr        IN typembr
	) RETURN typealllimitrec IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetContrAttr_AllLimits';
		cpanmbr     CONSTANT VARCHAR2(100) := nullif(ppan || '-' || pmbr, '-');
		coperdate   CONSTANT DATE := seance.getoperdate;
		vcacheindex VARCHAR2(150);
		vresult     typealllimitrec;
	BEGIN
		t.enter(cmethodname
			   ,'ContractNo = ' || pcontractno || ', CurrencyNumber = ' || pcurno || ', Card = ' ||
				masktodebug(ppan, pmbr));
	
		fillcontrattributecache(pcontractno, cgroup_2, coperdate, coperdate, vcacheindex);
		t.var('Cache index (vCacheIndex)', vcacheindex);
	
		IF scontrattrcache.exists(vcacheindex)
		THEN
		
			t.var('sContrAttrCache (vCacheIndex).count', scontrattrcache(vcacheindex).count);
		
			FOR i IN 1 .. scontrattrcache(vcacheindex).count
			LOOP
			
				s.say('BROWSE sContrAttrCache(vCacheIndex)(' || i || ').ACCOUNT_NO = ' ||
					  scontrattrcache(vcacheindex)(i)
					  .account_no || ', sContrAttrCache(vCacheIndex)(' || i || ').PAN_MBR = ' ||
					  masktodebug(scontrattrcache(vcacheindex)(i).pan_mbr));
			
				IF contracttools.equal(sdepaccount(pcurno).accountno
									  ,scontrattrcache(vcacheindex)(i).account_no)
				   AND contracttools.equal(cpanmbr, scontrattrcache(vcacheindex)(i).pan_mbr)
				THEN
				
					s.say('FOUND FOR ACCOUNT_NO = ' || sdepaccount(pcurno).accountno ||
						  ', PAN_MBR = ' || masktodebug(ppan, pmbr));
				
					vresult.estabcreditlimit     := scontrattrcache(vcacheindex)(i)
												   .estab_credit_limit;
					vresult.estabcashlimit       := scontrattrcache(vcacheindex)(i).cash_limit;
					vresult.usedcredlimit        := scontrattrcache(vcacheindex)(i).used_cred_limit;
					vresult.usedcashlimit        := scontrattrcache(vcacheindex)(i).used_cash_limit;
					vresult.usedinstallment      := scontrattrcache(vcacheindex)(i)
												   .used_installment;
					vresult.availcreditlimit     := scontrattrcache(vcacheindex)(i).avail_limit;
					vresult.availcashlimit       := scontrattrcache(vcacheindex)(i)
												   .avail_cash_limit;
					vresult.estabcreditlimitaggr := scontrattrcache(vcacheindex)(i)
												   .aggr_estab_credit_limit;
					vresult.estabcashlimitaggr   := scontrattrcache(vcacheindex)(i).aggr_cash_limit;
					vresult.usedcredlimitaggr    := scontrattrcache(vcacheindex)(i)
												   .aggr_used_cred_limit;
					vresult.usedcashlimitaggr    := scontrattrcache(vcacheindex)(i)
												   .aggr_used_cash_limit;
					vresult.availcreditlimitaggr := scontrattrcache(vcacheindex)(i)
												   .aggr_avail_limit;
					vresult.availcashlimitaggr   := scontrattrcache(vcacheindex)(i)
												   .aggr_avail_cash_limit;
				
					s.say('vLimitRecordToReturn.EstabCreditLimit = ' || vresult.estabcreditlimit ||
						  ', vLimitRecordToReturn.EstabCashLimit = ' || vresult.estabcashlimit ||
						  ', vLimitRecordToReturn.UsedCredLimit = ' || vresult.usedcredlimit ||
						  ', vLimitRecordToReturn.UsedCashLimit = ' || vresult.usedcashlimit ||
						  ', vLimitRecordToReturn.UsedInstallment = ' || vresult.usedinstallment ||
						  ', vLimitRecordToReturn.AvailCreditLimit = ' || vresult.availcreditlimit ||
						  ', vLimitRecordToReturn.AvailCashLimit = ' || vresult.availcashlimit ||
						  ', vLimitRecordToReturn.EstabCreditLimitAggr = ' ||
						  vresult.estabcreditlimitaggr ||
						  ', vLimitRecordToReturn.EstabCashLimitAggr = ' ||
						  vresult.estabcashlimitaggr ||
						  ', vLimitRecordToReturn.UsedCredLimitAggr = ' ||
						  vresult.usedcredlimitaggr ||
						  ', vLimitRecordToReturn.UsedCashLimitAggr = ' ||
						  vresult.usedcashlimitaggr ||
						  ', vLimitRecordToReturn.AvailCreditLimitAggr = ' ||
						  vresult.availcreditlimitaggr ||
						  ', vLimitRecordToReturn.AvailCashLimitAggr = ' ||
						  vresult.availcashlimitaggr);
				
					EXIT;
				
				END IF;
			
			END LOOP;
		ELSE
			s.say(cmethodname || '     -info: information was not found by input parameters');
		END IF;
	
		t.leave(cmethodname);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcontrattr_alllimits;

	FUNCTION getcontrattr_lastpaymdate
	(
		pcontractno     IN typecontractno
	   ,pdate           IN DATE
	   ,pcurrencynumber IN NUMBER := NULL
	) RETURN DATE IS
		cmethodname CONSTANT VARCHAR2(150) := cpackagename || '.GetContrAttr_LastPaymDate';
		vcacheindex VARCHAR2(150);
		vresult     DATE;
	BEGIN
		s.say(cmethodname || '     --<< BEGIN', 1);
		s.say(cmethodname || '      - INPUT PARAMETERS: pContractNo = ' || pcontractno ||
			  ', pDate = ' || htools.d2s(pdate) || ', pCurrencyNumber = ' || pcurrencynumber
			 ,1);
		s.say('');
		fillcontrattributecache(pcontractno, cgroup_3, pdate, pdate, vcacheindex);
		s.say(cmethodname || '      Cache index (vCacheIndex) = ' || vcacheindex, 1);
		IF scontrattrcache.exists(vcacheindex)
		THEN
			s.say(cmethodname || '      sContrAttrCache (vCacheIndex).count = ' || scontrattrcache(vcacheindex)
				  .count
				 ,1);
			FOR i IN 1 .. scontrattrcache(vcacheindex).count
			LOOP
				s.say(cmethodname || '      -> sContrAttrCache(vCacheIndex)(' || i ||
					  ').ACCOUNT_NO = ' || scontrattrcache(vcacheindex)(i)
					  .account_no || ', sContrAttrCache(vCacheIndex)(' || i || ').PAN_MBR = ' ||
					  masktodebug(scontrattrcache(vcacheindex)(i).pan_mbr));
				IF scontrattrcache(vcacheindex)(i).account_no IS NOT NULL
				   AND scontrattrcache(vcacheindex)(i).pan_mbr IS NULL
				THEN
					IF pcurrencynumber IS NOT NULL
					THEN
						IF scontrattrcache(vcacheindex)(i)
						.account_no = sdepaccount(pcurrencynumber).accountno
						THEN
							vresult := scontrattrcache(vcacheindex)(i).last_payment_date;
							EXIT;
						END IF;
					ELSE
						vresult := coalesce(greatest(vresult
													, scontrattrcache(vcacheindex)(i)
													 .last_payment_date)
										   ,scontrattrcache(vcacheindex)(i).last_payment_date);
					END IF;
				END IF;
			END LOOP;
		ELSE
			s.say(cmethodname || '     -info: information was not found by input parameters', 1);
		END IF;
		s.say(cmethodname || '     vLastPaymentDateToReturn = ' || htools.d2s(vresult));
		s.say(cmethodname || '     -->> END', 1);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getcontrattr_lastpaymdate;

	FUNCTION getcontrattr_lastpaidamount
	(
		pcontractno     IN typecontractno
	   ,pdate           IN DATE
	   ,pcurrencynumber IN NUMBER := NULL
	) RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(150) := cpackagename || '.GetContrAttr_LastPaidAmount';
		vcacheindex VARCHAR(150);
		vresult     NUMBER;
	BEGIN
		s.say(cmethodname || '     --<< BEGIN', 1);
		s.say(cmethodname || '      - INPUT PARAMETERS: pContractNo = ' || pcontractno ||
			  ', pDate = ' || htools.d2s(pdate) || ', pCurrencyNumber = ' || pcurrencynumber
			 ,1);
		s.say('');
		fillcontrattributecache(pcontractno, cgroup_3, pdate, pdate, vcacheindex);
		s.say(cmethodname || '      Cache index (vCacheIndex) = ' || vcacheindex, 1);
		IF scontrattrcache.exists(vcacheindex)
		THEN
			s.say(cmethodname || '      sContrAttrCache (vCacheIndex).count = ' || scontrattrcache(vcacheindex)
				  .count
				 ,1);
			FOR i IN 1 .. scontrattrcache(vcacheindex).count
			LOOP
				s.say(cmethodname || '      -> sContrAttrCache(vCacheIndex)(' || i ||
					  ').ACCOUNT_NO = ' || scontrattrcache(vcacheindex)(i)
					  .account_no || ', sContrAttrCache(vCacheIndex)(' || i || ').PAN_MBR = ' ||
					  masktodebug(scontrattrcache(vcacheindex)(i).pan_mbr));
				IF scontrattrcache(vcacheindex)(i).account_no IS NOT NULL
				   AND scontrattrcache(vcacheindex)(i).pan_mbr IS NULL
				THEN
					IF pcurrencynumber IS NOT NULL
					THEN
						s.say(cmethodname || '     sDepAccount(' || pcurrencynumber ||
							  ').AccountNo = ' || sdepaccount(pcurrencynumber).accountno
							 ,1);
						IF scontrattrcache(vcacheindex)(i)
						.account_no = sdepaccount(pcurrencynumber).accountno
						THEN
							vresult := scontrattrcache(vcacheindex)(i).last_paid_amount;
							s.say(cmethodname || '     sContrAttrCache(' || vcacheindex || ')(' || i ||
								  ').LAST_PAID_AMOUNT = ' || scontrattrcache(vcacheindex)(i)
								  .last_paid_amount
								 ,1);
							EXIT;
						END IF;
					ELSE
						vresult := coalesce(greatest(vresult
													, scontrattrcache(vcacheindex)(i)
													 .last_paid_amount)
										   ,scontrattrcache(vcacheindex)(i).last_paid_amount);
					END IF;
				END IF;
			END LOOP;
		ELSE
			s.say(cmethodname || '     -info: information was not found by input parameters', 1);
		END IF;
		s.say(cmethodname || '     vLastPaidAmountToReturn = ' || vresult, 1);
		s.say(cmethodname || '     -->> END', 1);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getcontrattr_lastpaidamount;

	FUNCTION deletecontract
	(
		pcontractno IN typecontractno
	   ,pmode       IN NUMBER := NULL
	) RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(100) := cpackagename || '.DeleteContract';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vacard       apitypes.typecardlist;
		vinstnoarray contractlink.typecontractarray;
		TYPE vinstarnoarray IS TABLE OF contractlink.typecontractarray INDEX BY PLS_INTEGER;
		vinstararray  vinstarnoarray;
		vbonusnoarray contractlink.typecontractarray;
		vcorpnoarray  contractlink.typecontractarray;
		vcontracttype NUMBER;
		vcontractstat VARCHAR(10);
		vinstlink     BOOLEAN := FALSE;
		vbonuslink    BOOLEAN := FALSE;
	
		PROCEDURE arcdata(pcontractno IN typecontractno) IS
			cmethodname CONSTANT VARCHAR2(100) := cpackagename || '.ArcData';
		BEGIN
			s.say(cmethodname || ' :Enter');
			INSERT INTO tcontracttrxnrepayment_arc
				SELECT trxnrp.*
				FROM   tcontracttrxnlist      trxnlist
					  ,tcontracttrxnrepayment trxnrp
				WHERE  trxnlist.branch = cbranch
				AND    trxnlist.contractno = pcontractno
				AND    trxnlist.branch = trxnrp.branch
				AND    trxnlist.trantype IN (ctrxntype_debit, ctrxntype_creditrev)
				AND    trxnlist.recno = trxnrp.debitrecno;
			DELETE FROM tcontracttrxnrepayment
			WHERE  branch = cbranch
			AND    debitrecno IN (SELECT trxnrp.debitrecno
								  FROM   tcontracttrxnlist      trxnlist
										,tcontracttrxnrepayment trxnrp
								  WHERE  trxnlist.branch = cbranch
								  AND    trxnlist.contractno = pcontractno
								  AND    trxnlist.branch = trxnrp.branch
								  AND    trxnlist.trantype IN (ctrxntype_debit, ctrxntype_creditrev)
								  AND    trxnlist.recno = trxnrp.debitrecno);
			INSERT INTO tcontracttrxnlist_arc
				SELECT *
				FROM   tcontracttrxnlist
				WHERE  branch = cbranch
				AND    contractno = pcontractno;
			DELETE FROM tcontracttrxnlist
			WHERE  branch = cbranch
			AND    contractno = pcontractno;
			s.say(cmethodname || ' :End');
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END;
	
	BEGIN
		s.say(cmethodname || ' :Enter' || ', ContractNo = ' || pcontractno || ', pMode = ' ||
			  pmode
			 ,1);
	
		IF NOT contract.checkstatus(contract.getstatus(pcontractno), contract.stat_close)
		THEN
			error.raiseerror('Error: contract ' || pcontractno || ' is not closed.');
		END IF;
	
		vacard := contract.getcardlist(pcontractno);
		FOR i IN 1 .. vacard.count
		LOOP
			IF vacard(i).pcstat IN (referencecrd_stat.card_open
						  ,referencecrd_stat.card_lost
						  ,referencecrd_stat.card_stolen
						  ,referencecrd_stat.card_compromised
						  ,referencecrd_stat.card_referral)
			THEN
				error.raiseerror('Error: contract ' || pcontractno ||
								 ' has active card. Card No: ' || vacard(i).pan || '-' || vacard(i).mbr);
			END IF;
		END LOOP;
	
		vcontracttype := contract.gettype(pcontractno);
		FOR i IN 1 .. 2
		LOOP
			contracttools.loadcontractaccount(contracttypeitems.getitemcode(vcontracttype
																		   ,'ItemDeposit' ||
																			slabel(i))
											 ,sdepaccount(i)
											 ,pcontractno);
			IF contractlink.getlinkno(pcontractno
									 ,contractlink.cmain
									 ,vinstnoarray
									 ,cinstlinkname
									 ,sdepaccount(i).currencyno) > 0
			THEN
				vinstlink := TRUE;
				vinstararray(i) := vinstnoarray;
				FOR j IN 1 .. vinstararray(i).count
				LOOP
				
					vcontractstat := contract.getstatus(vinstararray(i)(j).cno);
					IF NOT contract.checkstatus(vcontractstat, contract.stat_close)
					THEN
						error.raiseerror('Error: contract ' || pcontractno ||
										 ' is linked with an open installment contract ' ||
										 vinstararray(i)(j).cno);
					END IF;
				END LOOP;
			END IF;
		END LOOP;
		IF contractlink.getlinkno(pcontractno, contractlink.cmain, vbonusnoarray, 'BONUS') > 0
		THEN
			vbonuslink := TRUE;
			FOR j IN 1 .. vbonusnoarray.count
			LOOP
			
				vcontractstat := contract.getstatus(vbonusnoarray(j).cno);
				IF NOT contract.checkstatus(vcontractstat, contract.stat_close)
				THEN
					error.raiseerror('Error: contract ' || pcontractno ||
									 ' is linked with an open bonus contract ' || vbonusnoarray(j).cno);
				END IF;
			END LOOP;
		END IF;
	
		BEGIN
			SAVEPOINT spundo;
		
			arcdata(pcontractno);
		
			IF vinstlink
			THEN
				FOR i IN 1 .. 2
				LOOP
					IF vinstararray.exists(i)
					THEN
						FOR j IN 1 .. vinstararray(i).count
						LOOP
							IF contractlink.deletelink(pcontractno
													  ,vinstararray(i)(j).cno
													  ,cinstlinkname
													  ,sdepaccount(i).currencyno) <> 0
							THEN
								error.raiseerror('Error deleting link with installment contract ' ||
												 vinstararray(i)(j)
												 .cno || '~' || err.getfullmessage);
							END IF;
						END LOOP;
					END IF;
				END LOOP;
			END IF;
		
			IF vbonuslink
			THEN
				FOR j IN 1 .. vbonusnoarray.count
				LOOP
					IF contractlink.deletelink(pcontractno, vbonusnoarray(j).cno, 'BONUS') <> 0
					THEN
						error.raiseerror('Error deleting link with bonus contract ' || vbonusnoarray(j).cno || '~' ||
										 err.getfullmessage);
					END IF;
				END LOOP;
			END IF;
		
			IF contractlink.getlinkno(pcontractno, contractlink.clink, vcorpnoarray) > 0
			THEN
				FOR j IN 1 .. vcorpnoarray.count
				LOOP
					IF contractlink.deletelink(vcorpnoarray(j).cno, pcontractno) <> 0
					THEN
						error.raiseerror('Error deleting link with corporate contract ' || vcorpnoarray(j).cno || '~' ||
										 err.getfullmessage);
					END IF;
				END LOOP;
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				ROLLBACK TO spundo;
				RAISE;
		END;
	
		s.say(cmethodname || ' :End');
		RETURN contracttypeschema.c_rollback_unsupported;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END deletecontract;

	FUNCTION getcurrencynumberbyaccount(paccountno IN typeaccountno) RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(100) := cpackagename || '.GetCurrencyNumberByAccount';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vitemname tcontracttypeitemname.itemname%TYPE;
		vresult   NUMBER;
	BEGIN
		s.say(cmethodname || '     --<< BEGIN', 1);
		s.say(cmethodname || '      - INPUT PARAMETERS: pAccountNo = ' || paccountno, 1);
		s.say('');
	
		SELECT MIN(ctin.itemname)
		INTO   vitemname
		FROM   tcontractitem         ci
			  ,tcontract             c
			  ,tcontracttypeitemname ctin
		WHERE  ci.branch = cbranch
		AND    ci.key = paccountno
		AND    c.branch = ci.branch
		AND    c.no = ci.no
		AND    ctin.branch = ci.branch
		AND    ctin.itemcode = ci.itemcode
		AND    ctin.contracttype = c.type
		AND    ctin.itemname IN ('ITEMDEPOSITDOM', 'ITEMDEPOSITINT');
	
		s.say(cmethodname || '       found item name vItemName (vItemName) ' || vitemname, 1);
		IF vitemname IS NULL
		THEN
			error.raiseerror('No contract found for Account <' || paccountno || '>');
		ELSIF vitemname = 'ITEMDEPOSITDOM'
		THEN
			vresult := 1;
		ELSIF vitemname = 'ITEMDEPOSITINT'
		THEN
			vresult := 2;
		END IF;
	
		s.say(cmethodname || '       calculated currency number (vValueToReturn) = ' || vresult, 1);
		s.say(cmethodname || '     -->> END', 1);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getcurrencynumberbyaccount;

	FUNCTION getaccountbycurrencynumber
	(
		pcontractno     IN typecontractno
	   ,pcurrencynumber IN NUMBER
	) RETURN typeaccountno IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetAccountByCurrencyNumber';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vitemname tcontracttypeitemname.itemname%TYPE;
		vresult   typeaccountno;
	
	BEGIN
		s.say(cmethodname || '     --<< BEGIN', 1);
		s.say(cmethodname || '      - INPUT PARAMETERS: pContractNo = ' || pcontractno ||
			  ', pCurrencyNumber = ' || pcurrencynumber
			 ,1);
	
		vitemname := getvaluebycurno(pcurrencynumber, 'ITEMDEPOSITDOM', 'ITEMDEPOSITINT');
		s.say(cmethodname || '       detected item name vItemName (vItemName) ' || vitemname, 1);
	
		SELECT MIN(ci.key) accountno
		INTO   vresult
		FROM   tcontractitem         ci
			  ,tcontract             c
			  ,tcontracttypeitemname ctin
		WHERE  ci.branch = cbranch
		AND    ci.no = pcontractno
		AND    c.branch = ci.branch
		AND    c.no = ci.no
		AND    ctin.branch = ci.branch
		AND    ctin.itemcode = ci.itemcode
		AND    ctin.contracttype = c.type
		AND    ctin.itemname = vitemname;
	
		IF vresult IS NULL
		THEN
			error.raiseerror('No account found for contract <' || pcontractno ||
							 '> and currency number <' || pcurrencynumber || '>');
		END IF;
	
		s.say(cmethodname || '       found account number (vValueToReturn) = ' || vresult, 1);
		s.say(cmethodname || '     -->> END', 1);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getaccountbycurrencynumber;

	FUNCTION getcardaccountbycurrency
	(
		pcontractno  IN typecontractno
	   ,pcurrency    IN NUMBER
	   ,pdoexception IN BOOLEAN := TRUE
	) RETURN contracttools.taccountrecord IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCardAccountByCurrency';
	
		vresult       contracttools.taccountrecord;
		vcontracttype typecontracttype;
		vitemcode     NUMBER;
	
	BEGIN
		t.enter(cmethodname
			   ,'ContractNo = ' || pcontractno || ', Currency = ' || pcurrency ||
				', DoException = ' || htools.b2s(pdoexception));
	
		vcontracttype := contract.gettype(pcontractno, c_doexception);
	
		FOR i IN 1 .. 2
		LOOP
			vitemcode := contracttypeitems.getitemcode(vcontracttype, 'ItemDeposit' || slabel(i));
			contracttools.loadcontractaccount(vitemcode, vresult, pcontractno);
			IF vresult.currencyno = pcurrency
			THEN
				EXIT;
			ELSE
				vresult := NULL;
			END IF;
		END LOOP;
	
		IF (vresult.accountno IS NULL)
		   AND pdoexception
		THEN
			error.raiseerror('Account with currency <' || pcurrency ||
							 '> does not exists in contract <' || pcontractno || '>!');
		END IF;
	
		t.leave(cmethodname, 'AccountNo = ' || vresult.accountno);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getcardaccountbycurrency;

	FUNCTION needstatementgenerate
	(
		pcontractno IN typecontractno
	   ,pprevdate   IN OUT DATE
	   ,pcurdate    IN DATE
	   ,pperiodtype IN NUMBER
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.NeedStatementGenerate';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vlastregistredstatecode contractstatereference.typestatecode;
		vprevstatementdate      DATE;
		vstatementdate          DATE;
		vresult                 NUMBER := 0;
	
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		t.inpar('pPrevDate', htools.d2s(pprevdate));
		t.inpar('pCurDate', htools.d2s(pcurdate));
		t.inpar('pPeriodType', pperiodtype);
	
		SELECT MAX(decode(nextstatementdate, pcurdate, statementdate, nextstatementdate))
			  ,MAX(nextstatementdate)
		INTO   vprevstatementdate
			  ,vstatementdate
		FROM   (SELECT statementdate
					  ,nextstatementdate
				FROM   tcontractstcycle
				WHERE  branch = cbranch
				AND    contractno = pcontractno
				AND    nextstatementdate <= pcurdate);
	
		t.var('vPrevStatementDate', htools.d2s(vprevstatementdate));
		t.var('vStatementDate', htools.d2s(vstatementdate));
	
		pprevdate := coalesce(pprevdate
							 ,vprevstatementdate
							 ,contract.getcontractrecord(pcontractno).createdate);
	
		IF pperiodtype = statementrt.periodtype_contract
		THEN
		
			IF pcurdate = vstatementdate
			THEN
			
				vlastregistredstatecode := contractstatereference.getlastregisteredstate(pcontractno, pcurdate)
										   .statecode;
			
				vresult := nvl(contractstatereference.getstate(vlastregistredstatecode).statementgen
							  ,0);
			
			END IF;
		
		ELSE
			vresult := 1;
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END needstatementgenerate;

	FUNCTION getusedmpprofilesettings
	(
		pcontractno     typecontractno
	   ,pcurrencynumber NUMBER
	   ,pdate           DATE
	) RETURN types.arrstr1000 IS
		cmethodname CONSTANT VARCHAR2(100) := cpackagename || '.GetUsedMPProfileSettings';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vcontracttype        typecontracttype;
		vcontractstathistrec contractstatereference.typeregisteredstaterow;
	
		vmpprofileid       tcontractmpprofile.profileid%TYPE;
		vmpprofilesettings types.arrstr1000;
	BEGIN
		s.say(cmethodname || '   --<< BEGIN', 1);
		s.say(cmethodname || '    - INPUT PARAMETERS: pContractNo = ' || pcontractno ||
			  ', pCurrencyNumber = ' || pcurrencynumber || ', pDate = ' || htools.d2s(pdate));
	
		vcontracttype := contract.gettype(pcontractno, c_doexception);
	
		IF NOT smpmainprofile.exists(pcurrencynumber)
		   OR smpmainprofile(pcurrencynumber) IS NULL
		THEN
			smpmainprofile(pcurrencynumber) := nvl(contractparams.loadnumber(contractparams.ccontracttype
																			,vcontracttype
																			,'MPProfile' ||
																			 slabel(pcurrencynumber)
																			,FALSE)
												  ,0);
		END IF;
		s.say(cmethodname ||
			  '     MP profile ID taken from contract TYPE (sMPMainProfile (pCurrencyNumber)) = ' ||
			  smpmainprofile(pcurrencynumber)
			 ,1);
	
		sacparamccy(pcurrencynumber)(cp_mpprofile) := nvl(contractparams.loadnumber(contractparams.ccontract
																				   ,pcontractno
																				   ,'MPProfile' ||
																					slabel(pcurrencynumber)
																				   ,FALSE)
														 ,0);
		sacparamccy(pcurrencynumber)(cp_fixmpprofile) := nvl(contractparams.loadnumber(contractparams.ccontract
																					  ,pcontractno
																					  ,'FIXMPPROFILE' ||
																					   slabel(pcurrencynumber)
																					  ,FALSE)
															,0);
		s.say(cmethodname ||
			  '     MP profile ID taken from CONTRACT (saCParamCcy(pCurrencyNumber)(cP_MPProfile)) = ' ||
			  sacparamccy(pcurrencynumber) (cp_mpprofile)
			 ,1);
		s.say(cmethodname ||
			  '     Whether CONTRACT MP profile should be used regardless Delinquency state (saCParamCcy(pCurrencyNumber)(cP_FixMPProfile)) = ' ||
			  sacparamccy(pcurrencynumber) (cp_fixmpprofile)
			 ,1);
	
		vcontractstathistrec := contractstatereference.getlastregisteredstate(pcontractno => pcontractno
																			 ,pdate       => pdate);
		s.say(cmethodname || '     Last registered state: recNo = ' || vcontractstathistrec.recno ||
			  ', OperDate = ' || htools.d2s(vcontractstathistrec.operdate) || ', OverduePeriod = ' ||
			  vcontractstathistrec.overdue || ', Overlimit = ' || vcontractstathistrec.overlimit ||
			  ', state code = ' || vcontractstathistrec.statecode);
	
		IF NOT scontrtype_cache.exists(vcontracttype)
		   OR NOT scontrtype_cache(vcontracttype).delinqprofiles.exists(pcurrencynumber)
		THEN
			SELECT cbranch         branch
				  ,vcontracttype   contracttype
				  ,-              .75               period
				  ,-              .75               overlimit
				  ,pcurrencynumber currencynumber
				  ,0               profile
				  ,0               mpprofile BULK COLLECT
			INTO   scontrtype_cache(vcontracttype).delinqprofiles(pcurrencynumber)
			FROM   dual
			UNION ALL
			SELECT cdprof.*
			FROM   tcontractdelinqprofiles  cdprof
				  ,tcontractdelinqperiod    cdper
				  ,tcontractdelinqoverlimit cdol
			WHERE  cdprof.branch = cbranch
			AND    cdprof.contracttype = vcontracttype
			AND    cdprof.currencynumber = pcurrencynumber
			AND    cdper.branch = cdprof.branch
			AND    cdper.contracttype = cdprof.contracttype
			AND    cdper.period = cdprof.period
			AND    cdol.branch = cdprof.branch
			AND    cdol.contracttype = cdprof.contracttype
			AND    cdol.overlimit = cdprof.overlimit
			ORDER  BY 3 DESC
					 ,4 DESC;
		ELSE
			s.say(cmethodname ||
				  '     - info: delinquency settings were taken from contract type cache');
		END IF;
		s.say(cmethodname || '     DELINQUENCY SETTINGS:');
		FOR jj IN 1 .. scontrtype_cache(vcontracttype).delinqprofiles(pcurrencynumber).count
		LOOP
			s.say(cmethodname || '       sContrType_Cache(' || vcontracttype ||
				  ').DelinqProfiles[' || pcurrencynumber || '] [' || jj || '].period = ' || scontrtype_cache(vcontracttype)
				  .delinqprofiles(pcurrencynumber)(jj).period || ', Overlimit = ' || scontrtype_cache(vcontracttype)
				  .delinqprofiles(pcurrencynumber)(jj).overlimit || ', MP Profile = ' || scontrtype_cache(vcontracttype)
				  .delinqprofiles(pcurrencynumber)(jj).mpprofile);
		END LOOP;
	
		s.say(cmethodname ||
			  '     -info: MP Profile from delinquency settings is going to be chosen');
		smpaltprofile(pcurrencynumber) := 0;
		FOR i IN 1 .. scontrtype_cache(vcontracttype).delinqprofiles(pcurrencynumber).count
		LOOP
			s.say(cmethodname || '       sContrType_Cache(' || vcontracttype ||
				  ').DelinqProfiles[' || pcurrencynumber || '] [' || i || '].period =  ' || scontrtype_cache(vcontracttype)
				  .delinqprofiles(pcurrencynumber)(i).period || ', Overlimit = ' || scontrtype_cache(vcontracttype)
				  .delinqprofiles(pcurrencynumber)(i).overlimit || ', MP Profile = ' || scontrtype_cache(vcontracttype)
				  .delinqprofiles(pcurrencynumber)(i).mpprofile);
			IF nvl(vcontractstathistrec.overdue, - .75) >= 0
			THEN
				IF nvl(vcontractstathistrec.overdue, - .75) >= scontrtype_cache(vcontracttype)
				  .delinqprofiles(pcurrencynumber)(i)
				.period
				   AND nvl(vcontractstathistrec.overlimit, - .75) >= scontrtype_cache(vcontracttype)
				  .delinqprofiles(pcurrencynumber)(i).overlimit
				THEN
					smpaltprofile(pcurrencynumber) := nvl(scontrtype_cache(vcontracttype)
														  .delinqprofiles(pcurrencynumber)(i)
														  .mpprofile
														 ,0);
					s.say(cmethodname ||
						  '     MP Profile chosen according to Delinq. state settings (sMPAltProfile (pCurrencyNumber)) = ' ||
						  smpaltprofile(pcurrencynumber)
						 ,1);
					EXIT;
				END IF;
			ELSE
				IF nvl(vcontractstathistrec.overdue, - .75) <= scontrtype_cache(vcontracttype)
				  .delinqprofiles(pcurrencynumber)(i)
				.period
				   AND nvl(vcontractstathistrec.overlimit, - .75) >= scontrtype_cache(vcontracttype)
				  .delinqprofiles(pcurrencynumber)(i).overlimit
				THEN
					smpaltprofile(pcurrencynumber) := nvl(scontrtype_cache(vcontracttype)
														  .delinqprofiles(pcurrencynumber)(i)
														  .mpprofile
														 ,0);
					s.say(cmethodname ||
						  '     MP Profile chosen according to Delinq. state settings (sMPAltProfile (pCurrencyNumber)) = ' ||
						  smpaltprofile(pcurrencynumber)
						 ,1);
					EXIT;
				END IF;
			END IF;
		END LOOP;
	
		IF sacparamccy(pcurrencynumber)
		 (cp_mpprofile) <> 0
		   AND (sacparamccy(pcurrencynumber)
				(cp_fixmpprofile) = 1 OR smpaltprofile(pcurrencynumber) = 0)
		THEN
			vmpprofileid := sacparamccy(pcurrencynumber) (cp_mpprofile);
		ELSIF smpaltprofile(pcurrencynumber) <> 0
		THEN
			vmpprofileid := smpaltprofile(pcurrencynumber);
		ELSE
			vmpprofileid := smpmainprofile(pcurrencynumber);
		END IF;
		s.say(cmethodname || '     Final chosen MP ProfileID (vMPProfileId) = ' || vmpprofileid);
	
		custom_contractprofiles.getmpprofile(vmpprofileid, vmpprofilesettings);
		s.say(cmethodname || '   -->> END', 1);
	
		RETURN vmpprofilesettings;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getusedmpprofilesettings;

	PROCEDURE chooseprofiles
	(
		pcurno                   IN NUMBER
	   ,ompprofileidsource       OUT NOCOPY VARCHAR2
	   ,ointerestprofileidsource OUT NOCOPY VARCHAR2
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ChooseProfiles';
		vblockparam_mpprofileid  tcontractdelinqprofiles.mpprofile%TYPE;
		vblockparam_intprofileid tcontractdelinqprofiles.profile%TYPE;
	BEGIN
		s.say(cmethodname || '    --<< BEGIN', 1);
		s.say(cmethodname || '     - INPUT PARAMETERS: pCurrencyNumber = ' || pcurno, 1);
	
		sacparamccy(pcurno)(cp_mpprofile) := contractparams.loadchar(contractparams.ccontract
																	,scontractno
																	,upper('MPProfile' ||
																		   slabel(pcurno))
																	,FALSE);
		vblockparam_mpprofileid := getvaluebycurno(pcurno
												  ,sblockparam.mpprofileiddom
												  ,sblockparam.mpprofileidint);
	
		s.say(cmethodname || '         MP profile on type level ( sMPMainProfile[' || pcurno ||
			  '] ) = ' || smpmainprofile(pcurno)
			 ,1);
		s.say(cmethodname || '         MP profile in contract level ( saCParamCcy[' || pcurno ||
			  '][cP_MPProfile] ) = ' || sacparamccy(pcurno) (cp_mpprofile)
			 ,1);
		s.say(cmethodname ||
			  '           Use MP contract level profile regardless delinq. settings (saCParamCcy[' ||
			  pcurno || '][cP_FixMPProfile] ) = ' || sacparamccy(pcurno) (cp_fixmpprofile)
			 ,1);
		s.say(cmethodname ||
			  '         MP profile according to delinq. states: sBlockParam.MPProfileIdDOM = ' ||
			  sblockparam.mpprofileiddom || ', sBlockParam.MPProfileIdINT = ' ||
			  sblockparam.mpprofileidint || ', vBlockParam_MPProfileId = ' ||
			  vblockparam_mpprofileid
			 ,1);
	
		IF (nvl(sacparamccy(pcurno) (cp_mpprofile), 0) <> 0)
		   AND
		   ((vblockparam_mpprofileid = 0) OR (nvl(sacparamccy(pcurno) (cp_fixmpprofile), 0) = 1))
		THEN
			smpprofileid(pcurno) := sacparamccy(pcurno) (cp_mpprofile);
			ompprofileidsource := 'Contract parameters';
		ELSIF vblockparam_mpprofileid <> 0
		THEN
			smpprofileid(pcurno) := smpaltprofile(pcurno);
			ompprofileidsource := 'Delinquency settings';
		ELSE
			smpprofileid(pcurno) := smpmainprofile(pcurno);
			ompprofileidsource := 'Type parameters';
		END IF;
	
		sacparamccy(pcurno)(cp_profile) := contractparams.loadchar(contractparams.ccontract
																  ,scontractno
																  ,upper('Profile' ||
																		 slabel(pcurno))
																  ,FALSE);
		vblockparam_intprofileid := getvaluebycurno(pcurno
												   ,sblockparam.profileiddom
												   ,sblockparam.profileidint);
	
		s.say(cmethodname || '         Interest profile on type level ( sMainProfile[' || pcurno ||
			  '] ) = ' || smainprofile(pcurno)
			 ,1);
		s.say(cmethodname || '         Interest profile on contract level ( saCParamCcy[' ||
			  pcurno || '][cP_Profile] )= ' || sacparamccy(pcurno) (cp_profile)
			 ,1);
		s.say(cmethodname ||
			  '           Use Interest contract level profile regardless delinq. settings ( saCParamCcy[' ||
			  pcurno || '][cP_FixProfile] )= ' || sacparamccy(pcurno) (cp_fixprofile)
			 ,1);
		s.say(cmethodname ||
			  '         Interest profile according to delinq. states: sBlockParam.ProfileIdDOM = ' ||
			  sblockparam.profileiddom || ', sBlockParam.ProfileIdINT = ' ||
			  sblockparam.profileidint || ', vBlockParam_IntProfileID = ' ||
			  vblockparam_intprofileid
			 ,1);
	
		IF (nvl(sacparamccy(pcurno) (cp_profile), 0) <> 0)
		   AND
		   ((vblockparam_intprofileid = 0) OR (nvl(sacparamccy(pcurno) (cp_fixprofile), 0) = 1))
		THEN
			sprofileid(pcurno) := sacparamccy(pcurno) (cp_profile);
			ointerestprofileidsource := 'Contract parameters';
		ELSIF vblockparam_intprofileid <> 0
		THEN
			sprofileid(pcurno) := vblockparam_intprofileid;
			ointerestprofileidsource := 'Delinquency settings';
		ELSE
			sprofileid(pcurno) := smainprofile(pcurno);
			ointerestprofileidsource := 'Type parameters';
		END IF;
	
		s.say(cmethodname || '', 1);
		s.say(cmethodname || '      CHOOSING RESULT:', 1);
		s.say(cmethodname || '        Min Payment calculation profile ( sMPProfileID(' || pcurno ||
			  ') )= ' || smpprofileid(pcurno) || ', taken from (oMPProfileIDSource) = ' ||
			  ompprofileidsource
			 ,1);
		s.say(cmethodname || '        Interest calculation profile ( sProfileID(' || pcurno ||
			  ') ) = ' || sprofileid(pcurno) || ', taken from (oInterestProfileIDSource) = ' ||
			  ointerestprofileidsource
			 ,1);
	
		s.say(cmethodname || '    -->> END', 1);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END chooseprofiles;

	PROCEDURE chooseprofiles(pcurno IN NUMBER) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ChooseProfiles';
		vintprofilesource tinterestandmp_profhistory.interestprofwastakenfrom%TYPE;
		vmpprofilesource  tinterestandmp_profhistory.mpprofwastakenfrom%TYPE;
	BEGIN
		chooseprofiles(pcurno, vmpprofilesource, vintprofilesource);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END chooseprofiles;

	FUNCTION getcalculatedprofiles
	(
		pcontractno IN typecontractno
	   ,pcurno      IN NUMBER
	) RETURN typecalculatedprofiles_record IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetCalculatedProfiles';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vresult typecalculatedprofiles_record;
	BEGIN
		t.enter(cmethodname, 'ContractNo = ' || pcontractno || ', CurNo = ' || pcurno);
	
		scontracttype := contract.gettype(pcontractno);
	
		IF scontrtype_cache.exists(scontracttype)
		   AND scontrtype_cache(scontracttype).readsetupscheme_called
		THEN
			s.say(cmethodname || '        -info: Contract type cache has been filled already');
		ELSE
			s.say(cmethodname || '        -info: Contract type cache is going to be filled');
			readsetupscheme;
		END IF;
	
		contracttypeschema.scontractrow.no   := pcontractno;
		contracttypeschema.scontractrow.type := scontracttype;
		getcontractdata;
	
		chooseprofiles(pcurno, vresult.mpprofwastakenfrom, vresult.interestprofwastakenfrom);
	
		vresult.interestprofileid := sprofileid(pcurno);
		vresult.mpprofileid       := smpprofileid(pcurno);
	
		SELECT profilename
		INTO   vresult.interestprofilename
		FROM   tcontractprofile
		WHERE  branch = cbranch
		AND    profileid = vresult.interestprofileid;
	
		SELECT profilename
		INTO   vresult.mpprofilename
		FROM   tcontractmpprofile
		WHERE  branch = cbranch
		AND    profileid = vresult.mpprofileid;
	
		s.say(cmethodname || '     METHOD OUTPUT: ');
		s.say(cmethodname || '       Interest: profile ID = ' || vresult.interestprofileid ||
			  ', Profile name = ' || vresult.interestprofilename || ', From were taken = ' ||
			  vresult.interestprofwastakenfrom);
		s.say(cmethodname || '       MP: profile ID = ' || vresult.mpprofileid ||
			  ', Profile name = ' || vresult.mpprofilename || ', From were taken = ' ||
			  vresult.mpprofwastakenfrom);
	
		t.leave(cmethodname);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcalculatedprofiles;

	FUNCTION getcalculatedcyclecalendar(pcontractno typecontractno)
		RETURN tcontractcalendarreference%ROWTYPE IS
		cmethodname CONSTANT VARCHAR2(100) := cpackagename || '.GetCalculatedCycleCalendar';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		vcalendarid   tcontractcalendarreference.calendarid%TYPE;
		vrowtoreturn  tcontractcalendarreference%ROWTYPE;
		vcontracttype typecontracttype;
	BEGIN
		s.say(cmethodname || '    --<< BEGIN', 1);
		s.say(cmethodname || '      - INPUT PARAMETERS: Contract number (pContractNo) = ' ||
			  pcontractno
			 ,1);
		s.say(cmethodname || '', 1);
	
		vcontracttype := contract.gettype(pcontractno);
		sactparam(cctp_calendarid) := contractparams.loadnumber(contractparams.ccontracttype
															   ,vcontracttype
															   ,'CalendarId'
															   ,pdoexception => FALSE);
		sacparam(cp_billcyclecalendar) := contractparams.loadnumber(contractparams.ccontract
																   ,pcontractno
																   ,'BillCycleCalendar'
																   ,pdoexception => FALSE);
		s.say(cmethodname || '        vContractType = ' || vcontracttype ||
			  ', Calendar ID on type level ( saCTParam (cCTP_CalendarId) ) = ' ||
			  sactparam(cctp_calendarid) ||
			  ', Calendar ID on contract level ( saCParam  (cP_BillCycleCalendar) ) = ' ||
			  sacparam(cp_billcyclecalendar));
	
		vcalendarid := getbillingcyclecalendar(pcontractno);
		s.say(cmethodname || '        Chosen calendar id (vCalendarID) = ' || vcalendarid);
	
		SELECT *
		INTO   vrowtoreturn
		FROM   tcontractcalendarreference
		WHERE  branch = cbranch
		AND    calendarid = vcalendarid;
	
		s.say(cmethodname || '', 1);
		s.say(cmethodname || '     METHOD OUTPUT: ', 1);
		s.say(cmethodname || '       Calendar ID = ' || vrowtoreturn.calendarid ||
			  ', Calendar name = ' || vrowtoreturn.calendarname || ', Holiday calendar ID = ' ||
			  vrowtoreturn.holdaysid
			 ,1);
		s.say(cmethodname || '    -->> END', 1);
		RETURN vrowtoreturn;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getcalculatedcyclecalendar;

	PROCEDURE loadallschemaparams IS
		cmethodname CONSTANT typemethodname := cpackagename || '.LoadAllSchemaParams';
	BEGIN
		t.enter(cmethodname);
	
		sautounstick       := contractparams.loadbool(contractparams.cschema
													 ,cpackagename
													 ,'AutoUnstick'
													 ,c_noexception);
		scrdstsautounstick := contractparams.loadbool(contractparams.cschema
													 ,cpackagename
													 ,'CrdStsAutoUnstick'
													 ,c_noexception);
		spaidtoinst        := contractparams.loadbool(contractparams.cschema
													 ,cpackagename
													 ,'PaidToInst'
													 ,c_noexception);
		sdontcheckdata     := contractparams.loadbool(contractparams.cschema
													 ,cpackagename
													 ,'DontCheckData'
													 ,c_noexception);
		susereversalent    := contractparams.loadbool(contractparams.cschema
													 ,cpackagename
													 ,'UseReversalEnt'
													 ,c_noexception);
		supdatesd          := contractparams.loadbool(contractparams.cschema
													 ,cpackagename
													 ,'UpdateSD'
													 ,c_noexception);
		ssubstacconextract := contractparams.loadbool(contractparams.cschema
													 ,cpackagename
													 ,'SubstAccOnExtract'
													 ,c_noexception
													 ,1);
	
		scloserepaymententry := nvl(contractparams.loadchar(contractparams.cschema
														   ,cpackagename
														   ,'CloseRepaymentEntry'
														   ,c_noexception)
								   ,'ACC_IN');
		sclosepayoutentry    := nvl(contractparams.loadchar(contractparams.cschema
														   ,cpackagename
														   ,'ClosePayOutEntry'
														   ,c_noexception)
								   ,'ACC_OUT');
		sclosecardsmode      := nvl(contractparams.loadnumber(contractparams.cschema
															 ,cpackagename
															 ,'CloseCardsMode'
															 ,c_noexception)
								   ,contractrbstd.cclose_openedcards);
	
		saccumintaccmode := nvl(contractparams.loadnumber(contractparams.cschema
														 ,cpackagename
														 ,'UsePrcAcc'
														 ,c_noexception)
							   ,cintaccmode_donotaccumulate);
		sfillalwdovlattr := contractparams.loadbool(contractparams.cschema
												   ,cpackagename
												   ,'FillAlwdOvlAttr'
												   ,c_noexception
												   ,0);
		IF sfillalwdovlattr
		THEN
			salwdovlattrname := contractparams.loadchar(contractparams.cschema
													   ,cpackagename
													   ,'AlwdOvlAttrName'
													   ,c_noexception);
		END IF;
		sposbalanceblacklist := contractparams.loadnumber(contractparams.cschema
														 ,cpackagename
														 ,'PosBalanceBlackList'
														 ,c_noexception);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END loadallschemaparams;

	PROCEDURE initpackage IS
		cmethodname CONSTANT typemethodname := cpackagename || '.InitPackage';
	
		FUNCTION getright
		(
			pidentview   IN VARCHAR2
		   ,pidentmodify IN VARCHAR2
		) RETURN PLS_INTEGER IS
			cmethodname CONSTANT typemethodname := cpackagename || '.GetRight';
			vcheckrightparams contracttype.typecheckrightparams;
			vresult           PLS_INTEGER := c_cannothing;
		BEGIN
			t.enter(cmethodname, pidentview);
		
			vcheckrightparams.schemetype := custom_contractschemas.getrecord(cpackagename).type;
			vcheckrightparams.rightident := pidentview;
		
			IF contracttype.checkright(contracttype.right_scheme_parameters, vcheckrightparams)
			THEN
				vcheckrightparams.rightident := pidentmodify;
				vresult                      := service.iif(contracttype.checkright(contracttype.right_scheme_parameters
																				   ,vcheckrightparams)
														   ,c_canmodify
														   ,c_canview);
			END IF;
		
			t.leave(cmethodname, vresult);
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END getright;
	
	BEGIN
		t.enter(cmethodname);
	
		err.seterror(0, cmethodname);
	
		custom_overdueparameterscalculation.clearcache;
	
		slabel(1) := 'DOM';
		slabel(2) := 'INT';
	
		sfulllabel(1) := 'Domestic currency';
		sfulllabel(2) := 'International currency';
	
		sscoreproc(1).id := 1;
		sscoreproc(1).name := 'Contract Credit Limit Setup';
		sscoreproc(1).intervalname := 'Score for Credit Limit Value';
	
		slinkschemas.delete;
		slinkschemas(1) := 'SCH_Corporate';
	
		IF contractlink.getschemaslink('SCH_Customer'
									  ,contractlink.cmain
									  ,slinkschemasinst
									  ,cinstlinkname) <> 0
		THEN
			error.raiseerror(cmethodname);
		END IF;
	
		loadallschemaparams;
	
		scurright_contype := getright(cright_viewparams, cright_modifyparams);
	
		scurright_reference := getright(cright_viewreference, cright_modifyreference);
	
		error.raisewhenerr;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END initpackage;

	FUNCTION initadjusting(pcontracttype IN typecontracttype) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.InitAdjusting';
	BEGIN
		t.enter(cmethodname);
	
		err.seterror(0, cmethodname);
		scontracttype                        := pcontracttype;
		contracttypeschema.scontractrow.type := pcontracttype;
		readsetupscheme(NULL);
	
		sstatementpackno := 0;
		sstatstartdate   := NULL;
	
		sentriescount.delete;
	
		t.leave(cmethodname);
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END initadjusting;

	PROCEDURE doadjusting(paatomlist IN adjustingmode.tatombitlist) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.DoAdjusting';
		coperdate   CONSTANT DATE := seance.getoperdate;
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vvalue      NUMBER;
		vcorpacc    contracttools.taccountrecord;
		vminprc     NUMBER;
		voverlimit  typelimitarray;
		vdate       DATE;
		vcyclerecno NUMBER;
		vindebet    BOOLEAN;
		vmovement   BOOLEAN;
		vdafdate    DATE;
		vstmttrns   NUMBER;
	
		vshieldvalue         NUMBER;
		vdiscountshieldvalue NUMBER;
	
		vcredittrxn typetrxnrec;
		vdebittrxn  typetrxnrec;
	
		vamount NUMBER;
	
		vismigration            BOOLEAN;
		viseod                  BOOLEAN;
		vcurrencyisused         types.arrbool;
		vnewcycleprintedduedate DATE;
		vnewcycledafdate        DATE;
	
		vstatementfee NUMBER;
		vfullremark   typefullremark := NULL;
	
		vduedateremain NUMBER;
	
		vwherewastaken_intprofile  tinterestandmp_profhistory.interestprofwastakenfrom%TYPE;
		vwherewastaken_mpprofile   tinterestandmp_profhistory.mpprofwastakenfrom%TYPE;
		vlastregisteredprofilesrow tinterestandmp_profhistory%ROWTYPE;
	
		vhascreditbeforeadjusting BOOLEAN;
		vhascreditafteradjusting  BOOLEAN;
	
		vovdfeecalclog typeovdfeecalclog;
		vwarning       VARCHAR2(200);
		vfeevalue      NUMBER;
		vgst           NUMBER;
		vnewsd         DATE;
	
		PROCEDURE markcycleduedateaspassed IS
			cmethodname CONSTANT typemethodname := doadjusting.cmethodname ||
												   '.MarkCycleDueDateAsPassed';
		BEGIN
			t.enter(cmethodname);
		
			setcycleduedate(getcurrentcycle().recno, coperdate);
		
			contractrb.setlabel(crl_calculateddd);
			contractrb.setnvalue('RecNo', getcurrentcycle().recno);
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END markcycleduedateaspassed;
	
		FUNCTION gettrxnscount(paccount IN contracttools.taccountrecord) RETURN NUMBER IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.DoAdjusting.GetTrxnsCount';
			vresult NUMBER;
			vdate1  DATE;
			vdate2  DATE;
		BEGIN
			vdate1 := nvl(getcurrentcycle().statementdate, paccount.createdate - 1) + 1;
			vdate2 := getcurrentcycle().nextstatementdate;
		
			SELECT COUNT(*)
			INTO   vresult
			FROM   tcontracttrxnlist
			WHERE  branch = cbranch
			AND    accountno = paccount.accountno
			AND    postdate BETWEEN vdate1 AND vdate2;
		
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END gettrxnscount;
	
		PROCEDURE getcreditshieldamount
		(
			pcurrencynumber       NUMBER
		   ,ocreditshieldamount   OUT NUMBER
		   ,odiscountshieldamount OUT NUMBER
		) IS
			cmethodname CONSTANT VARCHAR2(100) := cpackagename ||
												  '.DoAdjusting.GetCreditShieldAmount';
		
			voperdateyear  NUMBER := extract(YEAR FROM coperdate);
			voperdatemonth NUMBER := extract(MONTH FROM coperdate);
		
			vfirstquarter  DATE := to_date('31.03.' || voperdateyear, 'dd.mm.yyyy');
			vsecondquarter DATE := to_date('30.06.' || voperdateyear, 'dd.mm.yyyy');
			vthirdquarter  DATE := to_date('30.09.' || voperdateyear, 'dd.mm.yyyy');
			vfourthquarter DATE := to_date('31.12.' || voperdateyear, 'dd.mm.yyyy');
		
			FUNCTION calcpromotionalshieldamount
			(
				pcurrency     IN NUMBER
			   ,pshieldtype   IN NUMBER
			   ,pshieldamount IN NUMBER
			   ,pshieldprc    IN NUMBER
			) RETURN NUMBER IS
				cmethodname CONSTANT VARCHAR2(80) := cpackagename ||
													 '.DoAdjusting.CalcPromotionalShieldAmount';
				vvalue NUMBER;
			BEGIN
				vvalue := abs(round(least(sdepaccount(pcurrency).remain, 0) * pshieldprc / 100
								   ,sprecision(pcurrency)));
				s.say(cmethodname || '  Calculated Promotional Percentage (vValue) = ' || vvalue ||
					  ', Flat Promotional Amount (pShieldAmount) = ' || pshieldamount
					 ,1);
				CASE pshieldtype
					WHEN cshieldnotused THEN
						RETURN 0;
					WHEN cshieldtotal THEN
						RETURN vvalue + pshieldamount;
					WHEN cshieldmax THEN
						RETURN greatest(vvalue, pshieldamount);
					WHEN cshieldmin THEN
						RETURN least(vvalue, pshieldamount);
					ELSE
						error.raiseerror('Unknown credit shield calculation type');
				END CASE;
			EXCEPTION
				WHEN OTHERS THEN
					error.save(cmethodname);
					RAISE;
			END calcpromotionalshieldamount;
		
			FUNCTION getshieldcalcdate RETURN DATE IS
				cmethodname CONSTANT VARCHAR2(150) := cpackagename ||
													  '.DoAdjusting.GetCreditShieldAmount.GetShieldCalcDate';
			
				vshieldcalcdate     DATE;
				vcertainmonthlydate DATE;
				vcertainquarterdate DATE;
			BEGIN
				s.say(cmethodname || '    --<< BEGIN', 1);
				s.say(cmethodname || '      -> INPUT PARAMETERS:', 1);
				s.say(cmethodname ||
					  '      (implicit) When Shield Should be charged (saCTParamCcy(pCurrencyNumber)(cCTP_ShieldWhenToCharge)) = ' ||
					  sactparamccy(pcurrencynumber)
					  (cctp_shieldwhentocharge) || ', [' || cshieldnotused ||
					  ' - Shouldn''t be charged, ' || cmonthlyeom ||
					  ' - Last business day of the month, ' || cmonthlyeoc ||
					  ' - Every Statement Date, ' || cqreom ||
					  ' - Last Business day of a quarter''s last month, ' || cqreoc ||
					  ' - Last Statement Date of a quarter, ' || cmonthlyonday ||
					  ' - Specific day of the month, ' || cqronday ||
					  ' - Specific day of the last quarter''s month, ' || cfirstsdafterqr ||
					  ' - First SD after the last month of a quarter' || ']');
				s.say(cmethodname || '      (implicit) cOperDate = ' || htools.d2s(coperdate));
				s.say(cmethodname || '      (implicit) CalendarID = ' ||
					  sactparam(cctp_shieldcalendar));
				s.say(cmethodname || '');
			
				CASE sactparamccy(pcurrencynumber) (cctp_shieldwhentocharge)
					WHEN cshieldnotused THEN
						vshieldcalcdate := to_date('01.01.1900', 'dd.mm.yyyy');
					WHEN cmonthlyeom THEN
						vshieldcalcdate := referencecalendar.getlastnotseldateinmonth(coperdate
																					 ,sactparam(cctp_shieldcalendar)
																					 ,TRUE);
					WHEN cmonthlyeoc THEN
						s.say(cmethodname ||
							  '      - info: Shield calculation date was taken as NextStatementDate');
						vshieldcalcdate := getcurrentcycle().nextstatementdate;
					WHEN cqreom THEN
						IF coperdate <= vfirstquarter
						THEN
							s.say(cmethodname ||
								  '      - info: cOperDate belongs to the first quarter');
							vshieldcalcdate := referencecalendar.getlastnotseldateinmonth(vfirstquarter
																						 ,sactparam(cctp_shieldcalendar)
																						 ,TRUE);
						ELSIF coperdate <= vsecondquarter
						THEN
							s.say(cmethodname ||
								  '      - info: cOperDate belongs to the second quarter');
							vshieldcalcdate := referencecalendar.getlastnotseldateinmonth(vsecondquarter
																						 ,sactparam(cctp_shieldcalendar)
																						 ,TRUE);
						ELSIF coperdate <= vthirdquarter
						THEN
							s.say(cmethodname ||
								  '      - info: cOperDate belongs to the third quarter');
							vshieldcalcdate := referencecalendar.getlastnotseldateinmonth(vthirdquarter
																						 ,sactparam(cctp_shieldcalendar)
																						 ,TRUE);
						ELSIF coperdate <= vfourthquarter
						THEN
							s.say(cmethodname ||
								  '      - info: cOperDate belongs to the fourth quarter');
							vshieldcalcdate := referencecalendar.getlastnotseldateinmonth(vfourthquarter
																						 ,sactparam(cctp_shieldcalendar)
																						 ,TRUE);
						ELSE
							error.raiseerror('Current operational date (cOperDate) can''t be attributed to any quarter');
						END IF;
					WHEN cqreoc THEN
						s.say(cmethodname || '      Operational date''s month (vOperDateMonth) = ' ||
							  voperdatemonth);
						IF voperdatemonth NOT IN
						   (extract(MONTH FROM vfirstquarter)
						   ,extract(MONTH FROM vsecondquarter)
						   ,extract(MONTH FROM vthirdquarter)
						   ,extract(MONTH FROM vfourthquarter))
						THEN
							s.say(cmethodname ||
								  '      - info: Since operational date does not belong to any quarter''s last month then credit shield should not be charged');
							vshieldcalcdate := to_date('01.01.1900', 'dd.mm.yyyy');
						ELSE
							s.say(cmethodname ||
								  '      - info: Shield calculation date was taken as NextStatementDate');
							vshieldcalcdate := getcurrentcycle().nextstatementdate;
						END IF;
					WHEN cmonthlyonday THEN
						s.say(cmethodname ||
							  '      Specific day (saCTParamCcy(pCurrencyNumber)(cCTP_ShieldCertainDay)) = ' ||
							  to_char(sactparamccy(pcurrencynumber) (cctp_shieldcertainday), '00')
							 ,1);
						vcertainmonthlydate := to_date(to_char(sactparamccy(pcurrencynumber)
															   (cctp_shieldcertainday)
															  ,'00') ||
													   to_char(coperdate, 'mmyyyy')
													  ,'ddmmyyyy');
						s.say(cmethodname || '      Certain monthly date (vCertainMonthlyDate) = ' ||
							  htools.d2s(vcertainmonthlydate));
						vshieldcalcdate := referencecalendar.getprevnotseldate(vcertainmonthlydate
																			  ,sactparam(cctp_shieldcalendar)
																			  ,TRUE);
					WHEN cqronday THEN
						s.say(cmethodname ||
							  '      Specific day (saCTParamCcy(pCurrencyNumber)(cCTP_ShieldCertainDay)) = ' ||
							  to_char(sactparamccy(pcurrencynumber) (cctp_shieldcertainday), '00')
							 ,1);
						IF coperdate <= vfirstquarter
						THEN
							vcertainquarterdate := to_date(to_char(sactparamccy(pcurrencynumber)
																   (cctp_shieldcertainday)
																  ,'00') ||
														   to_char(vfirstquarter, 'mmyyyy')
														  ,'ddmmyyyy');
						ELSIF coperdate <= vsecondquarter
						THEN
							vcertainquarterdate := to_date(to_char(sactparamccy(pcurrencynumber)
																   (cctp_shieldcertainday)
																  ,'00') ||
														   to_char(vsecondquarter, 'mmyyyy')
														  ,'ddmmyyyy');
						ELSIF coperdate <= vthirdquarter
						THEN
							vcertainquarterdate := to_date(to_char(sactparamccy(pcurrencynumber)
																   (cctp_shieldcertainday)
																  ,'00') ||
														   to_char(vthirdquarter, 'mmyyyy')
														  ,'ddmmyyyy');
						ELSIF coperdate <= vfourthquarter
						THEN
							vcertainquarterdate := to_date(to_char(sactparamccy(pcurrencynumber)
																   (cctp_shieldcertainday)
																  ,'00') ||
														   to_char(vfourthquarter, 'mmyyyy')
														  ,'ddmmyyyy');
						ELSE
							error.raiseerror('Current operational date (cOperDate) can''t be attributed to any quarter!');
						END IF;
						s.say(cmethodname ||
							  '      Quarter''s last month''s certain date (vCertainQuarterDate) = ' ||
							  htools.d2s(vcertainquarterdate));
						vshieldcalcdate := referencecalendar.getprevnotseldate(vcertainquarterdate
																			  ,sactparam(cctp_shieldcalendar)
																			  ,TRUE);
					
					WHEN cfirstsdafterqr THEN
						IF extract(MONTH FROM vfirstquarter + 1) = extract(MONTH FROM coperdate)
						   OR
						   extract(MONTH FROM vsecondquarter + 1) = extract(MONTH FROM coperdate)
						   OR extract(MONTH FROM vthirdquarter + 1) = extract(MONTH FROM coperdate)
						   OR
						   extract(MONTH FROM vfourthquarter + 1) = extract(MONTH FROM coperdate)
						THEN
							s.say(cmethodname ||
								  '      - info: Shield calculation date was taken as NextStatementDate');
							vshieldcalcdate := getcurrentcycle().nextstatementdate;
						END IF;
					
					ELSE
						error.raiseerror('When To Charge Credit Shield Option is specified incorrectly!');
				END CASE;
			
				s.say(cmethodname || '', 1);
				s.say(cmethodname || '      Shield calculation date (vShieldCalcDate) = ' ||
					  htools.d2s(vshieldcalcdate));
				s.say(cmethodname || '    -->> END', 1);
				RETURN vshieldcalcdate;
			
			EXCEPTION
				WHEN OTHERS THEN
					error.save(cmethodname);
					RAISE;
			END getshieldcalcdate;
		
			FUNCTION getshieldbaseamount RETURN NUMBER IS
				cmethodname CONSTANT VARCHAR2(150) := cpackagename ||
													  '.DoAdjusting.GetCreditShieldAmount.GetShieldBaseAmount';
			
				vbaseamount           NUMBER;
				vprevmonthlastworkday DATE;
				vpreviousworkday      DATE;
				vstartdate            DATE;
				venddate              DATE;
			
				vsupplamounttobase NUMBER := 0;
				vnoarray           contractlink.typecontractarray;
			
				vdateforgetsupplamount DATE;
				vinstallmentaccno      typeaccountno;
				vinstallmentaccremain  NUMBER;
			
			BEGIN
				s.say(cmethodname || '    --<< BEGIN', 1);
				s.say(cmethodname || '      -> INPUT PARAMETERS:', 1);
				s.say(cmethodname ||
					  '      (implicit) Base amount should be chosen as (saCTParamCcy(pCurrencyNumber)(cCTP_ShieldBaseAmount)) = ' ||
					  sactparamccy(pcurrencynumber)
					  (cctp_shieldbaseamount) || ', [' || ccurrentbalance ||
					  ' - Current account balance, ' || cpreveombalance ||
					  ' - Last business day of the previous month, ' || cpreveocbalance ||
					  ' - Last Statement Date balance, ' || cprevbusinessday ||
					  ' - Previous business day balance, ' || chighestbalwithinqr ||
					  ' - Highest balance of quarter, ' || chighestbalwithinmonth ||
					  ' - Highest balance of month' || ']');
			
				CASE sactparamccy(pcurrencynumber) (cctp_shieldbaseamount)
					WHEN ccurrentbalance THEN
						s.say(cmethodname ||
							  '      - info: Base Amount was taken as current account balance'
							 ,1);
						vbaseamount            := sdepaccount(pcurrencynumber).remain;
						vdateforgetsupplamount := coperdate;
					WHEN cpreveombalance THEN
						vprevmonthlastworkday := referencecalendar.getlastnotseldateinmonth(last_day(add_months(coperdate
																											   ,-1))
																						   ,sactparam(cctp_shieldcalendar)
																						   ,TRUE);
						s.say(cmethodname ||
							  '      Last Business Day of previous month balance (vPrevMonthLastWorkDay) = ' ||
							  htools.d2s(vprevmonthlastworkday));
					
						vbaseamount := contracttools.get_eod_remain(paccountno       => sdepaccount(pcurrencynumber)
																						.accountno
																   ,pdate            => vprevmonthlastworkday
																   ,parchive         => FALSE
																   ,pcheckemptyaccno => FALSE);
					
						vdateforgetsupplamount := vprevmonthlastworkday;
					WHEN cpreveocbalance THEN
						s.say(cmethodname ||
							  '      - info: Base Amount was taken as Last Statement Date balance');
						s.say(cmethodname || '              StatementDate = ' ||
							  htools.d2s(getcurrentcycle().statementdate));
						IF getcurrentcycle().statementdate IS NULL
						THEN
							vbaseamount := 0;
						ELSE
							vbaseamount := nvl(custom_overdueparameterscalculation.getlastpassedcycleinfo(paccountno => sdepaccount(pcurrencynumber).accountno, pcurrencynumber => pcurrencynumber, pdate => (getcurrentcycle().statementdate + 1))
											   .sdamount
											  ,0);
						END IF;
						vdateforgetsupplamount := getcurrentcycle().statementdate;
					WHEN cprevbusinessday THEN
						vpreviousworkday := referencecalendar.getprevnotseldate(coperdate - 1
																			   ,sactparam(cctp_shieldcalendar)
																			   ,TRUE);
						s.say(cmethodname ||
							  '      Previous business day balance (vPreviousWorkDay) = ' ||
							  htools.d2s(vpreviousworkday));
					
						vbaseamount := contracttools.get_eod_remain(paccountno       => sdepaccount(pcurrencynumber)
																						.accountno
																   ,pdate            => vpreviousworkday
																   ,parchive         => FALSE
																   ,pcheckemptyaccno => FALSE);
					
						vdateforgetsupplamount := vpreviousworkday;
					WHEN chighestbalwithinqr THEN
						s.say(cmethodname ||
							  '      - info: Base Amount was taken as Highest balance within a quarter'
							 ,1);
					
						IF sactparamccy(pcurrencynumber)
						 (cctp_shieldwhentocharge) <> cfirstsdafterqr
						THEN
							s.say(cmethodname ||
								  '      - info: date of credit shield charging IS NOT equal to "First SD after the last month of a quarter"');
							IF coperdate <= vfirstquarter
							THEN
								venddate := vfirstquarter;
							ELSIF coperdate <= vsecondquarter
							THEN
								venddate := vsecondquarter;
							ELSIF coperdate <= vthirdquarter
							THEN
								venddate := vthirdquarter;
							ELSIF coperdate <= vfourthquarter
							THEN
								venddate := vfourthquarter;
							ELSE
								error.raiseerror('Current operational date (cOperDate) can''t be attributed to any quarter');
							END IF;
						ELSE
							s.say(cmethodname ||
								  '      - info: date of credit shield charging is EQUAL TO "First SD after the last month of a quarter"');
						
							IF coperdate > vthirdquarter
							THEN
							
								venddate := vthirdquarter;
							ELSIF coperdate > vsecondquarter
							THEN
								venddate := vsecondquarter;
							ELSIF coperdate > vfirstquarter
							THEN
								venddate := vfirstquarter;
							
							ELSIF coperdate > add_months(vfourthquarter, -12)
							THEN
								venddate := add_months(vfourthquarter, -12);
							
							ELSE
								error.raiseerror('Current operational date (cOperDate) can''t be attributed to any quarter');
							END IF;
						END IF;
					
						vstartdate := add_months(venddate, -3) + 1;
						s.say(cmethodname || '      Beginning of the interval (vStartDate) = ' ||
							  htools.d2s(vstartdate) || ', Ending of the interval (vEndDate) = ' ||
							  htools.d2s(venddate));
					
						vbaseamount            := sch_rev_api.getlargestbalanceforperiod(paccountno   => sdepaccount(pcurrencynumber)
																										 .accountno
																						,pstartdate   => vstartdate
																						,penddate     => venddate
																						,parchiveflag => FALSE);
						vdateforgetsupplamount := venddate;
					WHEN chighestbalwithinmonth THEN
						s.say(cmethodname ||
							  '      - info: Base Amount was taken as Highest balance within current month');
						vstartdate := trunc(coperdate, 'mm');
						venddate   := referencecalendar.getlastnotseldateinmonth(coperdate
																				,sactparam(cctp_shieldcalendar)
																				,TRUE);
						s.say(cmethodname || '      Beginning of the interval (vStartDate) = ' ||
							  htools.d2s(vstartdate) || ', Ending of the interval (vEndDate) = ' ||
							  htools.d2s(venddate));
					
						vbaseamount            := sch_rev_api.getlargestbalanceforperiod(paccountno   => sdepaccount(pcurrencynumber)
																										 .accountno
																						,pstartdate   => vstartdate
																						,penddate     => venddate
																						,parchiveflag => FALSE);
						vdateforgetsupplamount := venddate;
				END CASE;
				vbaseamount := abs(least(vbaseamount, 0));
			
				CASE sactparamccy(pcurrencynumber) (cctp_supamnttoshieldbaseamount)
					WHEN cshiedlsupplamnt_zero THEN
						vsupplamounttobase := 0;
						s.say(cmethodname ||
							  '      - info: Supplementary amount to credit shield base is not chosen'
							 ,1);
					WHEN cshiedlsupplamnt_installment THEN
						s.say(cmethodname ||
							  '      - info: Supplementary amount to credit shield base is chosen as "Installment Amount"'
							 ,1);
						s.say(cmethodname ||
							  '        Date on which supplementary amount should be calculated (vSupplAmountToBase) = ' ||
							  htools.d2s(vdateforgetsupplamount));
						IF vdateforgetsupplamount IS NULL
						THEN
							vsupplamounttobase := 0;
						ELSE
							IF contractlink.getlinkno(scontractno
													 ,contractlink.cmain
													 ,vnoarray
													 ,cinstlinkname
													 ,sdepaccount(pcurrencynumber).currencyno) > 0
							THEN
								FOR m IN 1 .. vnoarray.count
								LOOP
								
									s.say(cmethodname ||
										  '      Linked Installment Contracts (vNoArray[' || m ||
										  '].cNo) = ' || vnoarray(m).cno);
									vinstallmentaccno := contract.getaccountnobyitemname(pno       => vnoarray(m).cno
																						,pitemname => 'ITEMINSTALLMENT');
									s.say(cmethodname ||
										  '      Installment contract''s account no (vInstallmentAccNo) = ' ||
										  vinstallmentaccno);
									vinstallmentaccremain := contracttools.get_eod_remain(paccountno       => vinstallmentaccno
																						 ,pdate            => vdateforgetsupplamount
																						 ,parchive         => FALSE
																						 ,pcheckemptyaccno => FALSE);
									s.say(cmethodname ||
										  '      Installment account remain (vInstallmentAccRemain) = ' ||
										  vinstallmentaccremain);
									vsupplamounttobase := vsupplamounttobase +
														  abs(vinstallmentaccremain);
								
								END LOOP;
							ELSE
								vsupplamounttobase := 0;
								s.say(cmethodname ||
									  '      - info: There is not any Installment contract linked to main one <' ||
									  scontractno || '>');
							END IF;
						END IF;
				END CASE;
				s.say(cmethodname ||
					  '      Supplementary Amount to credit shield base (vSupplAmountToBase) = ' ||
					  vsupplamounttobase);
				vbaseamount := vbaseamount + nvl(vsupplamounttobase, 0);
			
				s.say(cmethodname || '', 1);
				s.say(cmethodname ||
					  '      Base amount for credit shield calculation (vBaseAmount) = ' ||
					  vbaseamount);
				s.say(cmethodname || '    -->> END', 1);
				RETURN vbaseamount;
			EXCEPTION
				WHEN OTHERS THEN
					error.save(cmethodname);
					RAISE;
			END getshieldbaseamount;
		
			FUNCTION getshieldvalue RETURN NUMBER IS
				cmethodname CONSTANT VARCHAR2(150) := cpackagename ||
													  '.DoAdjusting.GetCreditShieldAmount.GetShieldValue';
			
				vvariableshieldpart NUMBER;
				vflatshieldpart     NUMBER;
			
				vprcpercent    NUMBER;
				vamountpercent NUMBER;
			
				vbaseamount NUMBER;
			
				vshieldamount NUMBER;
			BEGIN
				s.say(cmethodname || '    --<< BEGIN', 1);
				s.say(cmethodname || '      -> INPUT PARAMETERS:', 1);
				s.say(cmethodname ||
					  '      (implicit) Calculation method (saCTParamCcy(pCurrencyNumber)(cCTP_ShieldCalcMethod)) = ' ||
					  sactparamccy(pcurrencynumber)
					  (cctp_shieldcalcmethod) || ', [ ' || cbasedonfixedvalues ||
					  ' - Flat amount and Percentage Value are set as certain numbers, ' ||
					  cbasedoncredlimitrange ||
					  ' - Flat amount and Percentage Value are set via Interest Rate settings' || ']');
				s.say(cmethodname ||
					  '      (implicit) Calculation type for "Percentage value and Flat Amount"(saCTParamCcy(pCurrencyNumber)(cCTP_ShieldType)) = ' ||
					  sactparamccy(pcurrencynumber)
					  (cctp_shieldtype) || ', [ ' || cshieldtotal || ' - Calculate as total, ' ||
					  cshieldmax || ' - Maximum Value, ' || cshieldmin || ' - Minimum value' || ']');
			
				vbaseamount := getshieldbaseamount;
			
				s.say(cmethodname || '      vBaseAmount = ' || vbaseamount, 1);
				IF sactparamccy(pcurrencynumber) (cctp_shieldcalcmethod) = cbasedonfixedvalues
				THEN
					s.say(cmethodname ||
						  '      Percentage value (saCTParamCcy (pCurrencyNumber)(cCTP_ShieldPrc)) = ' ||
						  sactparamccy(pcurrencynumber) (cctp_shieldprc)
						 ,1);
					s.say(cmethodname ||
						  '      Flat Amount (saCTParamCcy (pCurrencyNumber)(cCTP_ShieldAmount)) = ' ||
						  sactparamccy(pcurrencynumber) (cctp_shieldamount)
						 ,1);
					vvariableshieldpart := round(vbaseamount * sactparamccy(pcurrencynumber)
												 (cctp_shieldprc) / 100
												,sprecision(pcurrencynumber));
					vflatshieldpart     := round(sactparamccy(pcurrencynumber) (cctp_shieldamount)
												,sprecision(pcurrencynumber));
				ELSIF sactparamccy(pcurrencynumber)
				 (cctp_shieldcalcmethod) = cbasedoncredlimitrange
				THEN
				
					s.say(cmethodname ||
						  '      Account Credit Limit (sDepAccount(pCurrencyNumber).Overdraft) = ' || sdepaccount(pcurrencynumber)
						  .overdraft
						 ,1);
					s.say(cmethodname ||
						  '      Rate ID for percentage value (saCTParamCcy(pCurrencyNumber)(cCTP_RangeShieldPrc)) = ' ||
						  sactparamccy(pcurrencynumber) (cctp_rangeshieldprc)
						 ,1);
					vprcpercent := referenceprchistory.getpercentbyid(pid     => sactparamccy(pcurrencynumber)
																				 (cctp_rangeshieldprc)
																	 ,pdate   => coperdate
																	 ,pcolumn => sdepaccount(pcurrencynumber)
																				 .overdraft);
					s.say(cmethodname || '      Percent for percentage value (vPrcPercent) = ' ||
						  vprcpercent
						 ,1);
				
					s.say(cmethodname ||
						  '      Rate ID for flat amount (saCTParamCcy(pCurrencyNumber)(cCTP_RangeShieldAmount)) = ' ||
						  sactparamccy(pcurrencynumber) (cctp_rangeshieldamount)
						 ,1);
					vamountpercent := referenceprchistory.getpercentbyid(pid     => sactparamccy(pcurrencynumber)
																					(cctp_rangeshieldamount)
																		,pdate   => coperdate
																		,pcolumn => sdepaccount(pcurrencynumber)
																					.overdraft);
					s.say(cmethodname || '      Percent for Flat amount (vAmountPercent) = ' ||
						  vamountpercent
						 ,1);
				
					vvariableshieldpart := round(vbaseamount * vprcpercent / 100
												,sprecision(pcurrencynumber));
				
					vflatshieldpart := round(vamountpercent, sprecision(pcurrencynumber));
				
				ELSE
					error.raiseerror('Unknown credit shield calculation method');
				END IF;
			
				s.say(cmethodname || '', 1);
				s.say(cmethodname || '      Calculated percentage value (vVariableShieldPart) = ' ||
					  vvariableshieldpart
					 ,1);
				s.say(cmethodname || '      Calculated flat amount (vFlatShieldPart) = ' ||
					  vflatshieldpart
					 ,1);
			
				CASE sactparamccy(pcurrencynumber) (cctp_shieldtype)
					WHEN cshieldtotal THEN
						vshieldamount := vvariableshieldpart + vflatshieldpart;
					WHEN cshieldmax THEN
						vshieldamount := greatest(vvariableshieldpart, vflatshieldpart);
					WHEN cshieldmin THEN
						vshieldamount := least(vvariableshieldpart, vflatshieldpart);
					ELSE
						error.raiseerror('Unknown credit shield calculation type');
				END CASE;
			
				s.say(cmethodname || '', 1);
				s.say(cmethodname || '      Calculated Shield Amount (vShieldAmount) = ' ||
					  vshieldamount
					 ,1);
				s.say(cmethodname || '    -->> END', 1);
				RETURN vshieldamount;
			EXCEPTION
				WHEN OTHERS THEN
					error.save(cmethodname);
					RAISE;
			END getshieldvalue;
		
			FUNCTION needchargecreditshield RETURN BOOLEAN IS
				cmethodname CONSTANT typemethodname := cpackagename || '.NeedChargeCreditShield';
				vresult BOOLEAN;
			BEGIN
				t.enter(cmethodname);
			
				t.var('Shield charge mode in type', sactparam(cctp_shieldchargemode));
				CASE sactparam(cctp_shieldchargemode)
					WHEN ccs_donotcharge THEN
						vresult := FALSE;
					WHEN ccs_alwayscharge THEN
						vresult := TRUE;
					WHEN ccs_charge4credit THEN
						vresult := sdepaccount(pcurrencynumber).remain < 0;
					ELSE
						error.raiseerror('Unsupported credit shield charge mode in type: ' ||
										 sactparam(cctp_shieldchargemode) || '!');
				END CASE;
				t.var('Need charge credit shield by type settings', htools.b2s(vresult));
			
				IF vresult
				THEN
				
					t.var('Shield charge mode in contract', sacparam(cp_useshield));
					CASE sacparam(cp_useshield)
						WHEN ccs_default THEN
							vresult := TRUE;
						WHEN ccs_charge THEN
							vresult := TRUE;
						WHEN ccs_nocharge THEN
							vresult := FALSE;
						ELSE
							error.raiseerror('Unsupported credit shield charge mode in contract: ' ||
											 sacparam(cp_useshield) || '!');
					END CASE;
					t.var('Need charge credit shield by contract settings', htools.b2s(vresult));
				
				END IF;
			
				t.leave(cmethodname, htools.b2s(vresult));
				RETURN vresult;
			EXCEPTION
				WHEN OTHERS THEN
					t.exc(cmethodname);
					error.save(cmethodname);
					RAISE;
			END needchargecreditshield;
		
		BEGIN
			s.say(cmethodname || '    --<< BEGIN');
			s.say(cmethodname || '      -> INPUT PARAMETERS:');
			s.say(cmethodname || '       Currency Number (pCurrencyNumber) = ' || pcurrencynumber);
			s.say(cmethodname || '       Used balance (sDepAccount(pCurrencyNumber).Remain) = ' || sdepaccount(pcurrencynumber)
				  .remain);
			s.say(cmethodname ||
				  '       Promotional Shield calculation type for promotional fee (saCTParamCcy(pCurrencyNumber)(cCTP_ProShieldType)) = ' ||
				  sactparamccy(pcurrencynumber) (cctp_proshieldtype));
			s.say(cmethodname ||
				  '       Promotional Shield Percentage value (saCTParamCcy(pCurrencyNumber)(cCTP_ProShieldPrc)) = ' ||
				  sactparamccy(pcurrencynumber) (cctp_proshieldprc));
			s.say(cmethodname ||
				  '       When Credit Shield Should be charged (saCTParamCcy(pCurrencyNumber)(cCTP_ShieldWhenToCharge)) = ' ||
				  sactparamccy(pcurrencynumber)
				  (cctp_shieldwhentocharge) || ', [1 - shoud not be charged]');
			s.say(cmethodname || '       ');
		
			IF needchargecreditshield
			   AND (NOT fintools.hasdebitentry(sdepaccount(pcurrencynumber).accountno
											  ,scrdshieldentcode
											  ,coperdate))
			THEN
			
				ocreditshieldamount   := 0;
				odiscountshieldamount := 0;
			
				IF sactparamccy(pcurrencynumber) (cctp_shieldwhentocharge) <> cshieldnotused
				THEN
				
					s.say(cmethodname || '       sShield(pCurrencyNumber).ProShieldType = ' ||
						  sactparamccy(pcurrencynumber) (cctp_proshieldtype));
				
					IF coperdate = getshieldcalcdate
					THEN
					
						IF (sactparamccy(pcurrencynumber) (cctp_proshieldtype) <> cshieldnotused)
						   AND shieldpromoperiodactive(pcurrencynumber)
						THEN
							s.say(cmethodname || '       Use Credit shield promotional');
							s.say(cmethodname || '       ProShieldDoBothEntries = ' ||
								  service.iif(sactparamccy(pcurrencynumber)
											  (cctp_proshielddoboth) = '1'
											 ,'true'
											 ,'false'));
							IF sactparamccy(pcurrencynumber) (cctp_proshielddoboth) = '1'
							THEN
								ocreditshieldamount   := getshieldvalue;
								odiscountshieldamount := ocreditshieldamount -
														 calcpromotionalshieldamount(pcurrencynumber
																					,sactparamccy(pcurrencynumber)
																					 (cctp_proshieldtype)
																					,sactparamccy(pcurrencynumber)
																					 (cctp_proshieldamount)
																					,sactparamccy(pcurrencynumber)
																					 (cctp_proshieldprc));
								IF odiscountshieldamount < 0
								THEN
									error.raiseerror('Regular credit shield fee amount is less than promotional credit shield fee amount: Regular Shield = ' ||
													 ocreditshieldamount ||
													 ', Promotional Shield = ' ||
													 calcpromotionalshieldamount(pcurrencynumber
																				,sactparamccy(pcurrencynumber)
																				 (cctp_proshieldtype)
																				,sactparamccy(pcurrencynumber)
																				 (cctp_proshieldamount)
																				,sactparamccy(pcurrencynumber)
																				 (cctp_proshieldprc)));
								END IF;
							ELSE
								ocreditshieldamount := calcpromotionalshieldamount(pcurrencynumber
																				  ,sactparamccy(pcurrencynumber)
																				   (cctp_proshieldtype)
																				  ,sactparamccy(pcurrencynumber)
																				   (cctp_proshieldamount)
																				  ,sactparamccy(pcurrencynumber)
																				   (cctp_proshieldprc));
							END IF;
							setispromoperiodforplsql(TRUE);
						ELSE
							ocreditshieldamount := getshieldvalue;
							setispromoperiodforplsql(FALSE);
						END IF;
					
					END IF;
				
				END IF;
			
				IF sactparamccy(pcurrencynumber) (cctp_shieldcalctype) <> cshieldstatic
				THEN
					t.var('Account remain before PL/SQL block'
						 ,sdepaccount(pcurrencynumber).remain);
					setvaluesforplsql(ocreditshieldamount
									 ,odiscountshieldamount
									 ,sdepaccount(pcurrencynumber).remain
									 ,abs(nvl(sovdaccount(pcurrencynumber).remain, 0))
									 ,sminpaymentod(pcurrencynumber)
									 ,sminpaymentdd(pcurrencynumber)
									 ,ssdbalanceod(pcurrencynumber)
									 ,ssdbalancedd(pcurrencynumber)
									 ,sblockparam.stateid);
					ocreditshieldamount := dynasql.runone(sactparamccy(pcurrencynumber)
														  (cctp_shieldplsql)
														 ,TRUE);
					t.var('Shield amount after PL/SQL block', ocreditshieldamount);
					odiscountshieldamount := getdiscountshieldfromplsql;
				END IF;
			
			END IF;
		
			s.say(cmethodname || '', 1);
			s.say(cmethodname || '       oCreditShieldAmount = ' || ocreditshieldamount ||
				  ', oDiscountShieldAmount = ' || odiscountshieldamount
				 ,1);
			s.say(cmethodname || '    -->> END', 1);
		
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END getcreditshieldamount;
	
		PROCEDURE calculatemp(pcyclerecno IN NUMBER) IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.DoAdjusting.CalculateMP';
			vmplog               tcontractminpaymentlog.calcinfo%TYPE;
			vcalculatedoverlimit NUMBER := 0;
			vmpleastvalue        NUMBER := 0;
			vbaseamount          NUMBER;
			vinstamount          NUMBER;
			vminamount           NUMBER;
			vbasegroup           NUMBER;
			vamountovd           NUMBER;
			vamountovl           NUMBER;
			vmp                  NUMBER;
		BEGIN
			FOR i IN 1 .. 2
			LOOP
				s.say(cmethodname || ' Whether currency is used (vCurrencyIsUsed(' || i || ')) = ' ||
					  service.iif(vcurrencyisused(i), 'YES', 'NO'));
				IF vcurrencyisused(i)
				THEN
				
					s.say(cmethodname ||
						  ' -> ^^^^^^^^^^^^^^^^^^^^ Min Payment Calculation ^^^^^^^^^^^^^^^^^^^^');
					s.say(cmethodname || ' -> sDepAccount.Remain =' || sdepaccount(i).remain);
					s.say(cmethodname || ' -> sDepAccount.Overdraft =' || sdepaccount(i).overdraft);
					s.say(cmethodname || ' -> sOvdAccount.Remain =' || sovdaccount(i).remain);
					s.say(cmethodname || ' -> sMPProfile.MinPayBase =' ||
						  smpprofile(smpprofileid(i)) (custom_contractprofiles.cp_mpp_base));
					s.say(cmethodname || ' -> sMPProfile.MinPayPrc =' ||
						  smpprofile(smpprofileid(i)) (custom_contractprofiles.cp_mpp_prc));
					s.say(cmethodname || ' -> sMPProfile.MPBalanceLess =' ||
						  smpprofile(smpprofileid(i))
						  (custom_contractprofiles.cp_mpp_mpbalanceless));
					s.say(cmethodname || ' -> ProfileId=' || smpprofile(smpprofileid(i))
						  (custom_contractprofiles.cp_mpp_profileid));
				
					vmplog := NULL;
					addlog(vmplog
						  ,'ProfileId=' || smpprofile(smpprofileid(i))
						   (custom_contractprofiles.cp_mpp_profileid));
					addlog(vmplog
						  ,'MPBalanceLess=' || smpprofile(smpprofileid(i))
						   (custom_contractprofiles.cp_mpp_mpbalanceless));
					addlog(vmplog, 'Remain=' || sdepaccount(i).remain);
					addlog(vmplog, 'CL=' || sdepaccount(i).overdraft);
					addlog(vmplog, 'Overdraft=' || sovdaccount(i).remain);
				
					IF -sdepaccount(i).remain <= nvl(smpprofile(smpprofileid(i))
									  (custom_contractprofiles.cp_mpp_mpbalanceless)
									 ,0)
					THEN
						vmp := 0;
						s.say(cmethodname || ' -> Final Min. Payment value (MP not calculated) = ' || vmp);
						addlog(vmplog, 'FinalValue=' || vmp);
					ELSE
						vinstamount := getinstallmentrepaymentsum(i, getcurrentcycle().recno);
						s.say(cmethodname || ' -> Installment Repayment Amount Included to MP =' ||
							  vinstamount);
						addlog(vmplog, 'Installment=' || vinstamount);
						vbasegroup := NULL;
						vminamount := nvl(smpprofile(smpprofileid(i))
										  (custom_contractprofiles.cp_mpp_amount)
										 ,0);
						addlog(vmplog
							  ,'BaseType=' || smpprofile(smpprofileid(i))
							   (custom_contractprofiles.cp_mpp_base));
						IF smpprofile(smpprofileid(i)) (custom_contractprofiles.cp_mpp_base) =
						   custom_contractprofiles.cmpbaselimit
						THEN
							vbaseamount := sdepaccount(i).overdraft;
						ELSIF smpprofile(smpprofileid(i)) (custom_contractprofiles.cp_mpp_base) =
							  custom_contractprofiles.cmpbaseused
						THEN
							vbaseamount := abs(least(sdepaccount(i).remain, 0));
						ELSE
							vbasegroup := calcminpaymentgroup(i, vmplog);
							addlog(vmplog, 'BaseGroup=' || vbasegroup);
							vbaseamount := sdepaccount(i).overdraft;
						END IF;
						addlog(vmplog, 'BaseAmount=' || vbaseamount);
						s.say(cmethodname || ' -> vBaseAmount(1) =' || vbaseamount ||
							  ' vBaseGroup=' || vbasegroup);
					
						IF NOT smpprofile(smpprofileid(i)) (custom_contractprofiles.cp_mpp_addunpaidmp) = '1'
						   AND smpprofile(smpprofileid(i))
						 (custom_contractprofiles.cp_mpp_incunpaidmp) = '1'
						   AND (smpprofile(smpprofileid(i)) (custom_contractprofiles.cp_mpp_base) <>
							custom_contractprofiles.cmpbasegroup)
						THEN
							s.say(cmethodname || ' -> MinPaymentOD =' || sminpaymentod(i), 1);
							vbaseamount := vbaseamount - sminpaymentod(i);
							addlog(vmplog, 'ExcludeOvd=' || sminpaymentod(i) || '@' || vbaseamount);
							s.say(cmethodname || ' -> vBaseAmount(2) =' || vbaseamount, 1);
						END IF;
					
						s.say(cmethodname ||
							  ' -> Add overlimit to calculated MP (sMPProfile(sMPProfileId(i))(custom_contractprofiles.cP_MPP_IncOverLimit)) = ' ||
							  smpprofile(smpprofileid(i))
							  (custom_contractprofiles.cp_mpp_incoverlimit)
							 ,1);
						s.say(cmethodname ||
							  ' -> Include overlimit to base calc. amount  (sMPProfile(sMPProfileId(i))(custom_contractprofiles.cP_MPP_AddOverLimit)) = ' ||
							  smpprofile(smpprofileid(i))
							  (custom_contractprofiles.cp_mpp_addoverlimit)
							 ,1);
						s.say(cmethodname ||
							  ' -> Min. payment calculation base  (sMPProfile(sMPProfileId(i))(custom_contractprofiles.cP_MPP_Base)) = ' ||
							  smpprofile(smpprofileid(i)) (custom_contractprofiles.cp_mpp_base)
							 ,1);
						IF NOT smpprofile(smpprofileid(i)) (custom_contractprofiles.cp_mpp_addoverlimit) = '1'
						   AND smpprofile(smpprofileid(i))
						 (custom_contractprofiles.cp_mpp_incoverlimit) = '1'
						   AND (smpprofile(smpprofileid(i)) (custom_contractprofiles.cp_mpp_base) =
							custom_contractprofiles.cmpbaseused)
						THEN
							vbaseamount := vbaseamount + sovdaccount(i).remain;
							addlog(vmplog
								  ,'ExcludeOvl=' || sovdaccount(i).remain || '@' || vbaseamount);
							s.say(cmethodname || ' -> vBaseAmount(3) =' || vbaseamount, 1);
						END IF;
					
						IF smpprofile(smpprofileid(i)) (custom_contractprofiles.cp_mpp_base) =
						   custom_contractprofiles.cmpbaseused
						THEN
							vbaseamount := greatest(vbaseamount - vinstamount, 0);
							addlog(vmplog, 'ExcludeIns=' || vinstamount || '@' || vbaseamount);
							s.say(cmethodname || ' -> vBaseAmount(4) =' || vbaseamount, 1);
						END IF;
					
						vminprc := round(smpprofile(smpprofileid(i))
										 (custom_contractprofiles.cp_mpp_prc) * vbaseamount / 100
										,sprecision(i));
						addlog(vmplog
							  ,'MPPrc=' || smpprofile(smpprofileid(i))
							   (custom_contractprofiles.cp_mpp_prc) || '@' || vbaseamount || '@' ||
							   vminprc);
						addlog(vmplog, 'MPFlat=' || vminamount);
					
						IF smpprofile(smpprofileid(i)) (custom_contractprofiles.cp_mpp_type) = 1
						THEN
							vmp := vminamount + nvl(vminprc, 0) + nvl(vbasegroup, 0);
						ELSIF smpprofile(smpprofileid(i)) (custom_contractprofiles.cp_mpp_type) = 2
						THEN
							vmp := greatest(greatest(vminamount, nvl(vminprc, 0))
										   ,nvl(vbasegroup, 0));
						ELSE
							vmp := least(least(vminamount, nvl(vminprc, vminamount))
										,nvl(vbasegroup, vminamount));
						END IF;
						addlog(vmplog
							  ,'MPCalc=' || smpprofile(smpprofileid(i))
							   (custom_contractprofiles.cp_mpp_type) || '@' || vmp);
						s.say(cmethodname || ' -> MinAmount =' || vminamount || ' MinPrc =' ||
							  vminprc || ' CalcValue =' || vmp || ' OldValue =' ||
							  sminpaymentod(i) || ' OverLimit = ' || abs(sovdaccount(i).remain)
							 ,1);
						vamountovd := 0;
						vamountovl := 0;
						IF smpprofile(smpprofileid(i))
						 (custom_contractprofiles.cp_mpp_incunpaidmp) = '1'
						THEN
							vamountovd := sminpaymentod(i);
							addlog(vmplog, 'IncludeOvd=' || vamountovd);
						END IF;
					
						IF smpprofile(smpprofileid(i))
						 (custom_contractprofiles.cp_mpp_incoverlimit) = 1
						THEN
							s.say(cmethodname ||
								  '   -> How overlimit should be calculated (sMPProfile(sMPProfileId(i))(custom_contractprofiles.cP_MPP_OvlCalcType) ) =' ||
								  smpprofile(smpprofileid(i))
								  (custom_contractprofiles.cp_mpp_ovlcalctype) || ', [' ||
								  custom_contractprofiles.chowovlcalc_total ||
								  ' - Total overlimit, ' ||
								  custom_contractprofiles.chowovlcalc_lastcycle ||
								  ' - Last cycle overlimit]');
							s.say(cmethodname || '   -> Total overlimit amount (abs (sOvdAccount(' || i ||
								  ').Remain))  =' || abs(sovdaccount(i).remain));
							IF smpprofile(smpprofileid(i))
							 (custom_contractprofiles.cp_mpp_ovlcalctype) =
							   custom_contractprofiles.chowovlcalc_total
							THEN
								vcalculatedoverlimit := abs(sovdaccount(i).remain);
							ELSIF smpprofile(smpprofileid(i))
							 (custom_contractprofiles.cp_mpp_ovlcalctype) =
								  custom_contractprofiles.chowovlcalc_lastcycle
							THEN
								vcalculatedoverlimit := contracttools.get_eod_remain(paccountno       => sovdaccount(i)
																										 .accountno
																					,pdate            => nvl(getcurrentcycle()
																											 .statementdate
																											,contracttypeschema.scontractrow.createdate - 1)
																					,parchive         => FALSE
																					,pcheckemptyaccno => FALSE);
								s.say(cmethodname ||
									  '   -> Cycle begin date (nvl (GetCurrentCycle().StatementDate, ContractTypeSchema.sContractRow.CreateDate -1)  =' ||
									  nvl(getcurrentcycle().statementdate
										 ,contracttypeschema.scontractrow.createdate - 1) ||
									  ', Overlimit on the cycle beginning date (vCalculatedOverLimit) = ' ||
									  abs(vcalculatedoverlimit));
								vcalculatedoverlimit := greatest(abs(sovdaccount(i).remain) -
																 abs(vcalculatedoverlimit)
																,0);
								s.say(cmethodname ||
									  '   -> Last cycle OverLimit (vCalculatedOverLimit) = ' ||
									  vcalculatedoverlimit
									 ,1);
							END IF;
						
							addlog(vmplog, 'IncludeOvl=' || vcalculatedoverlimit);
						END IF;
					
						IF smpprofile(smpprofileid(i))
						 (custom_contractprofiles.cp_mpp_incmax) = '1'
						THEN
							vamountovd := greatest(vamountovd, vcalculatedoverlimit);
							addlog(vmplog, 'UseMax=' || vamountovd);
							vamountovl           := 0;
							vcalculatedoverlimit := 0;
						END IF;
					
						vmp := nvl(vmp, 0) + nvl(vamountovd, 0) + nvl(vcalculatedoverlimit, 0) +
							   nvl(vinstamount, 0);
						addlog(vmplog, 'FinalValue=' || vmp);
					
						vmpleastvalue := smpprofile(smpprofileid(i))
										 (custom_contractprofiles.cp_mpp_mpnotless);
						s.say(cmethodname ||
							  ' -> Least possible value of the Minimum payment (vMPLeastValue) =' ||
							  vmpleastvalue);
						vmp := greatest(vmp, nvl(vmpleastvalue, 0));
						s.say(cmethodname ||
							  ' -> Min payment after "least value" applying (vAllValue) =' || vmp);
						addlog(vmplog, 'LeastValue=' || vmp);
					
						vmp := least(vmp, abs(least(sdepaccount(i).remain, 0)));
						addlog(vmplog, 'RestrictedValue=' || vmp);
						s.say(cmethodname || ' -> Final Min. Payment value (vAllValue) = ' || vmp);
					END IF;
				
					createstminpayrow(pcyclerecno, i, vmp, sdepaccount(i).remain);
				
					IF (sactparam(cctp_intlog) = '1')
					   AND (vmplog IS NOT NULL)
					THEN
						INSERT INTO tcontractminpaymentlog
						VALUES
							(cbranch
							,scontractno
							,i
							,coperdate
							,getpackno
							,vmplog);
					END IF;
				
				END IF;
			END LOOP;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END calculatemp;
	
		PROCEDURE changetrxnsbalance
		(
			pcurno IN NUMBER
		   ,pdate  IN DATE
		) IS
			cmethodname CONSTANT typemethodname := doadjusting.cmethodname || '.ChangeTrxnsBalance';
		
			vtrxntypetomove NUMBER;
		
			PROCEDURE dochangetrxnsbalance
			(
				pcurno          IN NUMBER
			   ,ptrxntypetomove IN NUMBER
			   ,pentcodes       IN tblnumber
			   ,pbalaccid       IN PLS_INTEGER
			   ,poffbalaccid    IN PLS_INTEGER
			   ,pdate           IN DATE
			   ,pisinterest     IN BOOLEAN
			   ,premarkparam    IN VARCHAR2
			) IS
				cmethodname CONSTANT typemethodname := changetrxnsbalance.cmethodname ||
													   '.DoChangeTrxnsBalance';
				vshortremark   typeshortremark;
				ventryident    typeentryident;
				vtrxnarray     typetrxnarray;
				vcreditaccid   PLS_INTEGER;
				vdebitaccid    PLS_INTEGER;
				vtrxntypetoset NUMBER;
			BEGIN
				t.enter(cmethodname
					   ,'pCurNo = ' || pcurno || ', pTrxnTypeToMove = ' || ptrxntypetomove ||
						', pDate = ' || htools.d2s(pdate));
			
				CASE ptrxntypetomove
				
					WHEN 0 THEN
					
						vtrxntypetoset := 1;
						vshortremark   := 'Bal -> Off';
						vdebitaccid    := pbalaccid;
						vcreditaccid   := poffbalaccid;
						ventryident    := service.iif(pisinterest
													 ,'INTEREST_BAL_TO_OFF'
													 ,'OVERDUE_FEE_BAL_TO_OFF');
					
						SELECT t.*
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL BULK COLLECT
						INTO   vtrxnarray
						FROM   tcontracttrxnlist t
						WHERE  t.branch = cbranch
						AND    t.accountno = sdepaccount(pcurno).accountno
						AND    t.trantype = ctrxntype_debit
						AND    nvl(t.paidfull, 0) = 0
						AND    t.trandate >= pdate
						AND    t.debitentcode MEMBER OF pentcodes
						AND    t.offbalance = ptrxntypetomove;
					
					WHEN 1 THEN
					
						vtrxntypetoset := 0;
						vshortremark   := 'Off -> Bal';
						vdebitaccid    := poffbalaccid;
						vcreditaccid   := pbalaccid;
						ventryident    := service.iif(pisinterest
													 ,'INTEREST_OFF_TO_BAL'
													 ,'OVERDUE_FEE_OFF_TO_BAL');
					
						SELECT t.*
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL
							  ,NULL BULK COLLECT
						INTO   vtrxnarray
						FROM   tcontracttrxnlist t
						WHERE  t.branch = cbranch
						AND    t.accountno = sdepaccount(pcurno).accountno
						AND    t.trantype = ctrxntype_debit
						AND    nvl(t.paidfull, 0) = 0
						AND    t.debitentcode MEMBER OF pentcodes
						AND    t.offbalance = ptrxntypetomove;
					
					ELSE
						error.raiseerror('Internal error: unsupported transaction type <' ||
										 ptrxntypetomove || '>!');
					
				END CASE;
			
				t.var('vTrxnTypeToSet', vtrxntypetoset);
				t.var('vaArrTrxn.count', vtrxnarray.count);
			
				FOR i IN 1 .. vtrxnarray.count
				LOOP
				
					savetrxntorollback(vtrxnarray(i));
				
					UPDATE tcontracttrxnlist
					SET    offbalance = vtrxntypetoset
					WHERE  branch = cbranch
					AND    recno = vtrxnarray(i).recno;
				
					vfullremark := getfullremark(pcurno, premarkparam, ventryident);
				
					doentry(pcurno
						   ,sabaccounts(pcurno) (vdebitaccid)
						   ,sabaccounts(pcurno) (vcreditaccid)
						   ,sdepaccount(pcurno).currencyno
						   ,vtrxnarray(i).amount
						   ,ventryident
						   ,vshortremark
						   ,vfullremark
						   ,pdotrxn => FALSE);
				
				END LOOP;
			
				t.leave(cmethodname);
			EXCEPTION
				WHEN OTHERS THEN
					error.save(cmethodname);
					RAISE;
			END dochangetrxnsbalance;
		
		BEGIN
			t.enter(cmethodname, 'pCurNo = ' || pcurno);
		
			t.var('sBlockParam.State.ChargeOVDFee', sblockparam.state.chargeovdfee);
			IF sblockparam.state.chargeovdfee IN
			   (contractstatereference.covdfeecharge, contractstatereference.covdfeeoffbalance)
			THEN
			
				vtrxntypetomove := htools.b2i(sblockparam.state.chargeovdfee =
											  contractstatereference.covdfeecharge);
			
				dochangetrxnsbalance(pcurno
									,vtrxntypetomove
									,tblnumber(sdelfeeonentcode)
									,cb_incaccodf
									,cb_incaccodfoffbal
									,pdate
									,FALSE
									,'TransFullRemarkOF');
			
			END IF;
		
			t.var('sBlockParam.State.ChargeInt', sblockparam.state.chargeint);
			IF sblockparam.state.chargeint IN
			   (contractstatereference.cintcharge, contractstatereference.cintoffbalance)
			THEN
			
				vtrxntypetomove := htools.b2i(sblockparam.state.chargeint =
											  contractstatereference.cintcharge);
			
				dochangetrxnsbalance(pcurno
									,vtrxntypetomove
									,sprconentcode
									,cb_incacc
									,cb_incaccoffbal
									,pdate
									,TRUE
									,'TransFullRemark');
			
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END changetrxnsbalance;
	
		FUNCTION contracthascredit RETURN BOOLEAN IS
			cmethodname CONSTANT typemethodname := cpackagename || '.ContractHasCredit';
			vresult BOOLEAN;
			vflag   NUMBER;
		BEGIN
			t.enter(cmethodname);
		
			SELECT COUNT(*)
			INTO   vflag
			FROM   tcontracttrxnlist
			WHERE  branch = cbranch
			AND    contractno = scontractno
			AND    trantype IN (ctrxntype_debit, ctrxntype_creditrev)
			AND    paidfull = 0
			AND    rownum = 1;
		
			vresult := vflag = 1;
		
			t.leave(cmethodname, htools.b2s(vresult));
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END contracthascredit;
	
		PROCEDURE chargemonthlyfee(pcurno IN NUMBER) IS
			cmethodname CONSTANT typemethodname := cpackagename || '.ChargeMonthlyFee';
			cstartdate  CONSTANT DATE := coalesce((getcurrentcycle().statementdate + 1)
												 ,to_date('01.01.1900', 'DD.MM.YYYY'));
		
			vmonthlyfeeprofile        custom_contractprofiles.typemonthlyfeerow;
			vmonthlyfeeprofileentries tblnumber;
			vneedchargemonthlyfee     BOOLEAN := FALSE;
			vmonthlyfeewaivedamount   NUMBER;
			vmonthlyfeeamount         NUMBER;
			vmonthlyfeebase           NUMBER;
			vfullpaiddate             DATE;
			venddate                  DATE;
			vcount                    NUMBER;
		
		BEGIN
			t.enter(cmethodname, pcurno);
		
			s.say(cmethodname || '      ^^^^^^^^^^ MONTHLY FEE CHARGE ^^^^^^^^^^');
			s.say(cmethodname || '       Monthly fee profile ID (saCTParamCcy(' || pcurno ||
				  ')(cCTP_MonthlyFeeProf)) = ' || sactparamccy(pcurno) (cctp_monthlyfeeprof));
			s.say(cmethodname || '       Monthly fee income account ( saBAccounts(' || pcurno ||
				  ')(cB_MonthlyFeeAcc).AccountNo ) = ' || sabaccounts(pcurno)(cb_monthlyfeeacc)
				  .accountno);
			s.say(cmethodname || '       Current account remain ( sDepAccount(' || pcurno ||
				  ').Remain ) = ' || sdepaccount(pcurno).remain);
		
			IF sactparamccy(pcurno) (cctp_monthlyfeeprof) IS NOT NULL
			THEN
			
				vmonthlyfeeprofile        := custom_contractprofiles.getmonthlyfeeprofile(sactparamccy(pcurno)
																						  (cctp_monthlyfeeprof));
				vmonthlyfeeprofileentries := custom_contractprofiles.getmonthlyfeeprofileentries(sactparamccy(pcurno)
																								 (cctp_monthlyfeeprof));
			
				IF (vmonthlyfeeprofile.chargecondition = custom_contractprofiles.cbalanceondd)
				   OR (vmonthlyfeeprofileentries.count > 0)
				THEN
				
					CASE vmonthlyfeeprofile.chargecondition
					
						WHEN custom_contractprofiles.cbalanceonsd THEN
						
							vneedchargemonthlyfee := sdepaccount(pcurno).remain < 0;
						
							IF NOT vneedchargemonthlyfee
							THEN
							
								venddate := getcurrentcycle().nextstatementdate;
							
								SELECT COUNT(*)
								INTO   vcount
								FROM   tcontracttrxnlist
								WHERE  branch = cbranch
								AND    accountno = sdepaccount(pcurno).accountno
								AND    postdate BETWEEN cstartdate AND venddate
								AND    debitentcode MEMBER OF vmonthlyfeeprofileentries
								AND    rownum = 1;
							
								vneedchargemonthlyfee := vcount = 1;
							
							END IF;
						
							vmonthlyfeebase := abs(least(sdepaccount(pcurno).remain, 0));
						
						WHEN custom_contractprofiles.cunpaidtrxns THEN
						
							SELECT COUNT(*)
								  ,SUM(amount - paidamount)
							INTO   vcount
								  ,vmonthlyfeebase
							FROM   tcontracttrxnlist
							WHERE  branch = cbranch
							AND    accountno = sdepaccount(pcurno).accountno
							AND    trantype IN (ctrxntype_debit, ctrxntype_creditrev)
							AND    contractno = scontractno
							AND    ((paidfulldate IS NULL) OR (paidfulldate > cstartdate))
							AND    debitentcode MEMBER OF vmonthlyfeeprofileentries;
						
							vneedchargemonthlyfee := vcount > 0;
						
						WHEN custom_contractprofiles.cbalanceondd THEN
						
							IF ssdbalancedd(pcurno) > 0
							THEN
								vneedchargemonthlyfee := TRUE;
								vmonthlyfeebase       := ssdbalancedd(pcurno);
							END IF;
						
						WHEN custom_contractprofiles.cbalanceondd_oper THEN
						
							dbms_session.set_context('CLIENTCONTEXT'
													,'TrxnListActualDate'
													,getcurrentcycle().duedate);
						
							venddate := getcurrentcycle().statementdate;
						
							SELECT COUNT(*)
								  ,SUM(sumleft)
							INTO   vcount
								  ,vmonthlyfeebase
							FROM   vrcmtransactions
							WHERE  branch = cbranch
							AND    accountno = sdepaccount(pcurno).accountno
							AND    trantype IN (ctrxntype_debit, ctrxntype_creditrev)
							AND    contractno = scontractno
							AND    postdate <= venddate
							AND    debitentcode MEMBER OF vmonthlyfeeprofileentries
							AND    sumleft > 0
							ORDER  BY packno
									 ,recno;
						
							vneedchargemonthlyfee := vcount > 0;
						
						ELSE
							error.raiseerror('Internal error: unsupported monthly fee charge condition: ' ||
											 vmonthlyfeeprofile.chargecondition || '!');
					END CASE;
				
					t.var('NeedChargeMonthlyFee', htools.b2s(vneedchargemonthlyfee));
				
					IF vneedchargemonthlyfee
					THEN
						t.var('MonthlyFeeBase', vmonthlyfeebase);
						vmonthlyfeeamount := contractcommission.getcommission(vmonthlyfeeprofile.tariffid
																			 ,vmonthlyfeebase
																			 ,vmonthlyfeebase
																			 ,sprecision(pcurno)
																			 ,coperdate);
						IF vmonthlyfeeamount > 0
						THEN
							doentry(pcurno
								   ,sdepaccount(pcurno)
								   ,sabaccounts(pcurno) (cb_monthlyfeeacc)
								   ,sdepaccount(pcurno).currencyno
								   ,vmonthlyfeeamount
								   ,'MONTHLY_FEE_ON'
								   ,'MnthlFee');
						END IF;
					END IF;
				
					t.var('Monthly fee waiver condition', vmonthlyfeeprofile.waivercondition);
				
					IF vmonthlyfeeprofile.waivercondition <> custom_contractprofiles.cwaivernone
					THEN
					
						vmonthlyfeewaivedamount := getmonthlyfeewaiveramount(pcurno
																			,getcurrentcycle()
																			 .statementdate);
					
						IF vmonthlyfeewaivedamount > 0
						THEN
							IF vmonthlyfeeprofile.waivercondition =
							   custom_contractprofiles.cwaiversd
							THEN
								s.say(cmethodname ||
									  '       Unpaid SD amount on Due Date (sSDBalanceDD(' ||
									  pcurno || ')) = ' || ssdbalancedd(pcurno));
								IF nvl(ssdbalancedd(pcurno), 0) = 0
								THEN
									doentry(pcurno
										   ,sabaccounts(pcurno) (cb_monthlyfeeacc)
										   ,sdepaccount(pcurno)
										   ,sdepaccount(pcurno).currencyno
										   ,vmonthlyfeewaivedamount
										   ,'MONTHLY_FEE_OFF'
										   ,'MnthlFee');
								ELSE
									s.say(cmethodname ||
										  '      - info: waiver condition has NOT BEEN satisfied');
								END IF;
							ELSIF vmonthlyfeeprofile.waivercondition =
								  custom_contractprofiles.cwaiverfull
							THEN
								vfullpaiddate := getfullpaymentdate(sdepaccount    (pcurno)
																	.accountno
																   ,getcurrentcycle()
																	.statementdate + 1
																   ,getcurrentcycle().duedate);
								s.say(cmethodname ||
									  '       When outstanding was totally paid (vFullPaidDate) = ' ||
									  htools.d2s(vfullpaiddate));
								IF vfullpaiddate >
								   nvl(getcurrentcycle().statementdate
									  ,to_date('01.01.1900', 'dd.mm.yyyy'))
								THEN
									doentry(pcurno
										   ,sabaccounts(pcurno) (cb_monthlyfeeacc)
										   ,sdepaccount(pcurno)
										   ,sdepaccount(pcurno).currencyno
										   ,vmonthlyfeewaivedamount
										   ,'MONTHLY_FEE_OFF'
										   ,'MnthlFee');
								ELSE
									vduedateremain := contracttools.get_eod_remain(sdepaccount    (pcurno)
																				   .accountno
																				  ,getcurrentcycle()
																				   .duedate);
									s.say(cmethodname ||
										  '       Due date remain (vDueDateRemain) = ' ||
										  vduedateremain);
									IF vduedateremain >= 0
									THEN
										doentry(pcurno
											   ,sabaccounts(pcurno) (cb_monthlyfeeacc)
											   ,sdepaccount(pcurno)
											   ,sdepaccount(pcurno).currencyno
											   ,vmonthlyfeewaivedamount
											   ,'MONTHLY_FEE_OFF'
											   ,'MnthlFee');
									ELSE
										s.say(cmethodname ||
											  '      - info: waiver condition has NOT BEEN satisfied');
									END IF;
								END IF;
							END IF;
						
						END IF;
					
					END IF;
				
				END IF;
			
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END chargemonthlyfee;
	
		PROCEDURE updatecontractstate IS
			cmethodname CONSTANT typemethodname := doadjusting.cmethodname ||
												   '.UpdateContractState';
			vcurrentlimitsetup typeobjectlimitsettings;
		
			FUNCTION reducebypercent
			(
				pamount    IN NUMBER
			   ,ppercent   IN NUMBER
			   ,pprecision IN NUMBER
			) RETURN NUMBER IS
			BEGIN
				RETURN round(pamount - (pamount * ppercent / 100), pprecision);
			END reducebypercent;
		
		BEGIN
			t.enter(cmethodname);
		
			getdelparameters;
		
			IF sblockparam.statechangeallowed
			   AND adjustingmode.isatomrunning(paatomlist, adjustingmode.ao_delinquency)
			   AND (((sblockparam.lastreggroupindex IS NULL) OR
			   (sblockparam.currentgroupindex <> sblockparam.lastreggroupindex)) OR
			   ((sblockparam.lastregisteredstatecode IS NULL) OR
			   (sblockparam.lastregisteredstatecode <> sblockparam.state.statecode)))
			THEN
			
				registernewstate(sblockparam.currentgroupindex
								,sblockparam.period
								,sblockparam.overlimit
								,sblockparam.aggregatedoverdueamount
								,sactparam((cctp_overdueamountcurr))
								,cadjusting);
			
				IF (sblockparam.currentgroupindex > sblockparam.lastreggroupindex)
				   AND (nvl(sblockparam.state.reducelimit, 0) > 0)
				THEN
				
					FOR i IN 1 .. 2
					LOOP
					
						IF vcurrencyisused(i)
						THEN
						
							vcurrentlimitsetup := getobjectlimitssetup(scontractno, i);
						
							vcurrentlimitsetup.credlimit.amount := reducebypercent(vcurrentlimitsetup.credlimit.amount
																				  ,sblockparam.state.reducelimit
																				  ,sprecision(i));
						
							IF vcurrentlimitsetup.tempcredlimit.calcmethod = clmtdefined
							THEN
								vcurrentlimitsetup.tempcredlimit.amount := reducebypercent(vcurrentlimitsetup.tempcredlimit.amount
																						  ,sblockparam.state.reducelimit
																						  ,sprecision(i));
							END IF;
						
							dml_limitsetup_updaterecord(vcurrentlimitsetup
													   ,cadjusting
													   ,pcheckscoring => FALSE);
						
						END IF;
					
					END LOOP;
				
				END IF;
			
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END updatecontractstate;
	
		FUNCTION needappendnewtrxns RETURN BOOLEAN IS
			cmethodname CONSTANT typemethodname := doadjusting.cmethodname || '.NeedAppendNewTrxns';
		
			cadjmodeswithappend CONSTANT tblchar20 := tblchar20(adjustingmode.ao_processtrxn
															   ,adjustingmode.ao_movetoinst
															   ,adjustingmode.ao_payinst
															   ,adjustingmode.ao_pbtransfer
															   ,adjustingmode.ao_corpautorep
															   ,adjustingmode.ao_autorepay
															   ,adjustingmode.ao_delinquency
															   ,adjustingmode.ao_eod);
		BEGIN
			FOR i IN 1 .. cadjmodeswithappend.count
			LOOP
				IF adjustingmode.isatomrunning(paatomlist, cadjmodeswithappend(i))
				THEN
					RETURN TRUE;
				END IF;
			END LOOP;
			RETURN FALSE;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END needappendnewtrxns;
	
		PROCEDURE paydebtfromexternalaccount
		(
			pcurno            IN NUMBER
		   ,paccountno        IN typeaccountno
		   ,psumselectionmode IN PLS_INTEGER
		) IS
			cmethodname CONSTANT typemethodname := doadjusting.cmethodname ||
												   '.PayDebtFromExternalAccount';
			vpayaccount contracttools.taccountrecord;
			vsum        NUMBER;
		BEGIN
			t.enter(cmethodname, paccountno);
		
			IF paccountno IS NOT NULL
			THEN
			
				CASE psumselectionmode
					WHEN cautopay_mponod THEN
						vsum := sminpaymentod(pcurno);
					WHEN cautopay_debtonsd THEN
						vsum := ssdbalanceod(pcurno);
					WHEN cautopay_debtonod THEN
						vsum := abs(least(sdepaccount(pcurno).remain, 0));
					ELSE
						error.raiseerror('Unknown autopay sum selection mode <' ||
										 psumselectionmode || '>!');
				END CASE;
			
				IF vsum > 0
				THEN
				
					contracttools.loadcontractaccountbyaccno(paccountno
															,vpayaccount
															,c_doexception);
				
					vsum := least(vpayaccount.remain, vsum);
				
					IF vsum > 0
					THEN
					
						doentry(pcurno
							   ,vpayaccount
							   ,sdepaccount(pcurno)
							   ,sdepaccount(pcurno).currencyno
							   ,vsum
							   ,'ACC_IN'
							   ,'Auto +');
					
						sminpaymentod(pcurno) := greatest(sminpaymentod(pcurno) - vvalue, 0);
					
						IF getcurrentcycle().duedate >= coperdate
						THEN
							sminpaymentdd(pcurno) := greatest(sminpaymentdd(pcurno) - vvalue, 0);
						END IF;
					
					END IF;
				
				END IF;
			
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END paydebtfromexternalaccount;
	
	BEGIN
		t.enter(cmethodname, contracttypeschema.scontractrow.no);
	
		t.var('cOperDate', htools.d2s(coperdate));
	
		startoperation;
	
		scontractstat := contract.getstatus(contracttypeschema.scontractrow.no);
		scontractno   := contracttypeschema.scontractrow.no;
	
		vhascreditbeforeadjusting := contracthascredit;
	
		FOR i IN 1 .. 2
		LOOP
			vcurrencyisused(i) := ifcurrencyisusedintype(i, scontracttype, scontractno);
		END LOOP;
	
		vismigration := adjustingmode.isatomrunning(paatomlist, adjustingmode.ao_migration);
		t.var('vIsMigration', htools.b2s(vismigration));
	
		IF vismigration
		THEN
		
			IF paatomlist.count > 1
			THEN
				error.raiseerror('Incorrect contract adjustment mode! Atomic operation <Process transactions (migration)> can be performed standalone only!');
			END IF;
		
			sprofileid := smainprofile;
			resetcurrentcycle;
		
			FOR i IN 1 .. 2
			LOOP
				slastdocno(i) := nvl(contractparams.loadnumber(contractparams.ccontract
															  ,scontractno
															  ,'LastDocNo_' || i
															  ,FALSE)
									,0);
				sacparamccy(i)(cp_lastdocno) := slastdocno(i);
				contracttools.loadcontractaccount(sitem(i).dep, sdepaccount(i));
			END LOOP;
		
			sacparam(cp_nextstmtdate) := contractparams.loadchar(contractparams.ccontract
																,scontractno
																,'NEXTSTMTDATE'
																,FALSE);
			t.var('saCParam(cP_NextStmtDate)', sacparam(cp_nextstmtdate));
		
			FOR i IN 1 .. 2
			LOOP
			
				IF vcurrencyisused(i)
				THEN
					appendnewtransactions(i, pmigrationmode => TRUE);
				END IF;
			
				custom_overdueparameterscalculation.paidhistorymigration(NULL
																		,i
																		,scontracttype
																		,scontractno
																		,(sacparam(cp_nextstmtdate) IS NOT NULL));
			
			END LOOP;
		
		ELSE
		
			getcontractdata(pfromadjusting => TRUE);
			readaltsetupscheme(NULL);
			s.say(cmethodname || '       DELINQUENCY STATE <' || sblockparam.state.statecode ||
				  '> SETTINGS FOR CALCULATED RISK GROUP');
			s.say(cmethodname || '         Charge OVD fee = ' ||
				  service.iif(sblockparam.state.chargeovdfee = 1, 'true', 'false'));
			s.say(cmethodname || '         Charge OVL fee = ' ||
				  service.iif(sblockparam.state.chargeovlfee = 1, 'true', 'false'));
			s.say(cmethodname || '         Statement gen = ' ||
				  service.iif(sblockparam.state.statementgen = 1, 'true', 'false'));
			s.say(cmethodname || '         Use Allowed OL = ' ||
				  service.iif(sblockparam.state.useallowedol = 1, 'true', 'false'));
			s.say(cmethodname || '         Charge interest = ' || sblockparam.state.chargeint);
			s.say(cmethodname || '         Use DOM Profile = ' || sblockparam.profileiddom);
			s.say(cmethodname || '         Use INT Profile = ' || sblockparam.profileidint);
			s.say(cmethodname || '         Use DOM MP Profile = ' || sblockparam.mpprofileiddom);
			s.say(cmethodname || '         Use INT MP Profile = ' || sblockparam.mpprofileidint);
		
			vnewsd := getnewnextsd(getbillingcyclecalendar);
		
			IF needchangenextsd(vnewsd, cadjusting, vwarning)
			THEN
			
				IF vwarning IS NOT NULL
				THEN
					contractadjwarning.appendwarning(vwarning);
				END IF;
			
				updatenextsd(vnewsd, cadjusting);
			
			END IF;
		
			FOR i IN 1 .. 2
			LOOP
			
				sprofileid(i) := NULL;
				smpprofileid(i) := NULL;
			
				IF vcurrencyisused(i)
				THEN
				
					chooseprofiles(i, vwherewastaken_mpprofile, vwherewastaken_intprofile);
				
					vlastregisteredprofilesrow := getlastregisteredprofiles(scontractno
																		   ,i
																		   ,coperdate);
					IF (vlastregisteredprofilesrow.profilehistid IS NULL)
					   OR (vlastregisteredprofilesrow.mpprofileid <> smpprofileid(i))
					   OR (vlastregisteredprofilesrow.interestprofileid <> sprofileid(i))
					THEN
					
						INSERT INTO tinterestandmp_profhistory
							(profilehistid
							,contractno
							,currencynumber
							,accountno
							,operdate
							,branch
							,overdueperiod
							,ovdperioduom
							,overlimit
							,packno
							,interestprofileid
							,interestprofwastakenfrom
							,mpprofileid
							,mpprofwastakenfrom
							,lastupdatedate)
						VALUES
							(seq_interestandmp_profhistory.nextval
							,scontractno
							,i
							,sdepaccount(i).accountno
							,coperdate
							,cbranch
							,nvl(sblockparam.period, - .75)
							,decode(sdelparam.overdueint
								   ,contractdelinqsetup.covdday
								   ,'Days (from last overdue)'
								   ,contractdelinqsetup.covdfirstday
								   ,'Days (from first overdue)'
								   ,contractdelinqsetup.covdcycle
								   ,'Cycles (from last overdue)'
								   ,contractdelinqsetup.covdfirstcycle
								   ,'Cycles (from first Overdue)')
							,nvl(sblockparam.overlimit, 0)
							,getpackno
							,sprofileid(i)
							,vwherewastaken_intprofile
							,coalesce(smpprofileid(i), vlastregisteredprofilesrow.mpprofileid, -1)
							,vwherewastaken_mpprofile
							,SYSDATE);
					END IF;
				END IF;
			END LOOP;
		
			slimittype := getlimittype_int(scontractno);
		
			t.var('Cycle.StatementDate', getcurrentcycle().statementdate);
			t.var('Cycle.DueDate', getcurrentcycle().duedate);
			t.var('Cycle.NextStatementDate', getcurrentcycle().nextstatementdate);
		
			t.var('LastCycle.StatementDate', getpreviouscycle().statementdate);
			t.var('LastCycle.DueDate', getpreviouscycle().duedate);
			t.var('LastCycle.NextStatementDate', getpreviouscycle().nextstatementdate);
		
			IF coperdate > getcurrentcycle().nextstatementdate
			THEN
				error.raiseerror('Statement date ' ||
								 htools.d2s(getcurrentcycle().nextstatementdate) ||
								 ' contract adjustment is missed!');
			END IF;
		
			IF getcurrentcycle().statementdate IS NOT NULL
			THEN
			
				IF getcurrentcycle().statementdate > coperdate
				THEN
					error.raiseerror('Cannot adjust contract before the last passed statement date (' ||
									 htools.d2s(getcurrentcycle().statementdate) || ')!');
				
				ELSIF getcurrentcycle().statementdate = coperdate
				THEN
					error.raiseerror('The contract already has been adjusted on statement date (' ||
									 htools.d2s(getcurrentcycle().statementdate) || ')!');
				END IF;
			END IF;
		
			IF getcurrentcycle().lastduedate IS NULL
			THEN
			
				IF coperdate > getcurrentcycle().duedate
				THEN
					error.raiseerror('Due Date ' || htools.d2s(getcurrentcycle().duedate) ||
									 ' contract adjustment is missed!');
				END IF;
			
			ELSE
			
				IF getcurrentcycle().lastduedate > coperdate
				THEN
					error.raiseerror('Cannot adjust contract before the last passed due date (' ||
									 htools.d2s(getcurrentcycle().lastduedate) || ')!');
				
				ELSIF getcurrentcycle().lastduedate = coperdate
				THEN
					error.raiseerror('The contract already has been adjusted on due date (' ||
									 htools.d2s(getcurrentcycle().lastduedate) || ')!');
				END IF;
			END IF;
		
			snowstatementdate := getcurrentcycle().nextstatementdate = coperdate;
			t.var('sNowStatementDate', htools.b2s(snowstatementdate));
		
			snowduedate := (getcurrentcycle().lastduedate IS NULL) AND
						   (getcurrentcycle().duedate = coperdate);
			t.var('sNowDueDate', htools.b2s(snowduedate));
		
			viseod := adjustingmode.isatomrunning(paatomlist, adjustingmode.ao_eod);
			t.var('vIsEOD', htools.b2s(viseod));
		
			IF snowstatementdate
			   AND viseod
			THEN
				IF hascorporatecontract
				THEN
					contractparams.savedate(contractparams.ccontract
										   ,getcorpcontractnumber
										   ,'SD2DAF'
										   ,coperdate);
				END IF;
				IF getcurrentcycle().statementdate IS NULL
				THEN
					FOR i IN 1 .. 2
					LOOP
						IF vcurrencyisused(i)
						THEN
							sstatstartdate := contracttools.leastdate(sstatstartdate
																	 ,sdepaccount(i).createdate);
						END IF;
					END LOOP;
				ELSE
					sstatstartdate := contracttools.leastdate(sstatstartdate
															 ,getcurrentcycle().statementdate + 1);
				END IF;
			END IF;
		
			s.say('');
			s.say(cmethodname ||
				  '      ^^^^^^^^^^ ADDING NEW TRANSACTIONS + TRANSFER TO INSTALLMENT ^^^^^^^^^^');
			IF needappendnewtrxns
			THEN
				FOR i IN 1 .. 2
				LOOP
					IF vcurrencyisused(i)
					THEN
						appendnewtransactions(i
											 ,(sactparam(cctp_useinst) = '1') AND
											  adjustingmode.isatomrunning(paatomlist
																		 ,adjustingmode.ao_movetoinst));
					END IF;
				END LOOP;
			END IF;
			s.say(cmethodname || '      ^^^^^^^^^^');
			s.say('');
		
			FOR i IN 1 .. 2
			LOOP
			
				IF vcurrencyisused(i)
				THEN
				
					s.say('');
					s.say(cmethodname || '      ^^^^^^^^^^ POSITIVE BALANCE TRANSFER ^^^^^^^^^^');
					IF adjustingmode.isatomrunning(paatomlist, adjustingmode.ao_pbtransfer)
					   AND sactparamccy(i) (cctp_pblimit) IS NOT NULL
					   AND sdepaccount(i).remain > sactparamccy(i) (cctp_pblimit)
					THEN
						IF sacparamccy(i) (cp_pbaccount) IS NULL
						THEN
							error.raiseerror('Account for positive balance transfer is not defined');
						END IF;
						vamount := sdepaccount(i).remain - sactparamccy(i) (cctp_pblimit);
						contracttools.loadcontractaccountbyaccno(sacparamccy(i) (cp_pbaccount)
																,vcorpacc
																,c_doexception);
						doentry(i
							   ,sdepaccount(i)
							   ,vcorpacc
							   ,sdepaccount(i).currencyno
							   ,vamount
							   ,'ACC_OUT'
							   ,'PBTransfer');
					END IF;
					s.say('');
					s.say(cmethodname || '      ^^^^^^^^^^');
				
					s.say('');
					s.say(cmethodname ||
						  '      ^^^^^^^^^^ SOME OVERDUE PARAMETERS CALCULATION ^^^^^^^^^^');
					getunpaidamounts(i
									,sminpaymentod(i)
									,sminpaymentdd(i)
									,ssdbalancedd(i)
									,ssdbalanceod(i));
					s.say('');
					s.say(cmethodname || '      ^^^^^^^^^^', 1);
				
					s.say('');
					s.say(cmethodname || '      ^^^^^^^^^^ AUTOMATIC REPAYMENT ^^^^^^^^^^');
				
					s.say(cmethodname ||
						  '      ---------- Automatic repayment from corporative account ----------');
					IF adjustingmode.isatomrunning(paatomlist, adjustingmode.ao_corpautorep)
					   AND (sminpaymentod(i) > 0)
					   AND hascorporatecontract
					THEN
						paydebtfromexternalaccount(i
												  ,getpaymentaccount(sdepaccount(i).currencyno)
												  ,cautopay_mponod);
						s.say(cmethodname || '      ---------- ');
					END IF;
				
					s.say(cmethodname ||
						  '      ---------- Automatic repayment from user account ----------');
					IF adjustingmode.isatomrunning(paatomlist, adjustingmode.ao_autorepay)
					THEN
						paydebtfromexternalaccount(i
												  ,sacparamccy(i) (cp_payaccount)
												  ,sacparamccy(i) (cp_payamount));
						s.say(cmethodname || '      ---------- ');
					END IF;
				
					s.say('');
					s.say(cmethodname || '      ^^^^^^^^^^');
				
				END IF;
			
			END LOOP;
		
			updatecontractstate;
			readaltsetupscheme(NULL);
		
			IF (sactparam(cctp_useinst) = '1')
			   AND (nvl(sblockparam.state.accelrtinstlmrepmnt, 0) = 1)
			THEN
				FOR i IN 1 .. 2
				LOOP
					IF vcurrencyisused(i)
					THEN
						installmentcontractsclosure(i);
					END IF;
				END LOOP;
			END IF;
		
			IF snowstatementdate
			THEN
			
				s.say('');
				s.say(cmethodname ||
					  '      ^^^^^^^^^^ OVERLIMIT CALCULATION (FOR OVERLIMIT FEE CALCULATION) ^^^^^^^^^^');
			
				IF slimittype = caggregate
				THEN
					s.say(cmethodname || '      Limit type is "Aggregated"');
				
					snotusedlimit(1) := greatest(sdepaccount(1).overdraft + sdepaccount(1).remain
												,0);
					snotusedlimit(2) := greatest(sdepaccount(2).overdraft + sdepaccount(2).remain
												,0);
				
					FOR i IN 1 .. 2
					LOOP
						voverlimit(i) := overlimitcalc(i);
					END LOOP;
				
				ELSE
					s.say(cmethodname || '      Limit type is NOT "Aggregated"');
				
					FOR i IN 1 .. 2
					LOOP
						voverlimit(i).cur1aggroverlimit := abs(least(sdepaccount(i).overdraft + sdepaccount(i)
																	 .remain
																	,0));
						snotusedlimit(i) := 0;
					END LOOP;
				END IF;
			
				FOR i IN 1 .. 2
				LOOP
					IF vcurrencyisused(i)
					THEN
						vvalue := voverlimit(i).cur1aggroverlimit + sovdaccount(i).remain;
						s.say(cmethodname || '      Overlimit (' || i ||
							  ') Correction Value (vValue) = ' || vvalue
							 ,1);
						vvalue := round(vvalue, sprecision(i));
						s.say(cmethodname || '      Overlimit (' || i ||
							  ') rounded Correction Value (vValue) = ' || vvalue
							 ,1);
						IF vvalue > 0
						THEN
							doentry(i
								   ,sovdaccount(i)
								   ,sabaccounts(i) (cb_techacc)
								   ,sdepaccount(i).currencyno
								   ,vvalue
								   ,'OVER_LIMIT_ON'
								   ,'OvrLmtOn'
								   ,pdotrxn => FALSE);
						ELSIF vvalue < 0
						THEN
							doentry(i
								   ,sabaccounts(i) (cb_techacc)
								   ,sovdaccount(i)
								   ,sdepaccount(i).currencyno
								   ,-vvalue
								   ,'OVER_LIMIT_OFF'
								   ,'OvrLmtOff'
								   ,pdotrxn => FALSE);
						END IF;
					END IF;
				END LOOP;
			
				IF viseod
				THEN
					FOR i IN 1 .. 2
					LOOP
						IF vcurrencyisused(i)
						THEN
							chargeovlfee(i);
						END IF;
					END LOOP;
				END IF;
			
			END IF;
			s.say(cmethodname || '      ^^^^^^^^^^');
			s.say('');
		
			FOR i IN 1 .. 2
			LOOP
			
				IF vcurrencyisused(i)
				THEN
				
					IF viseod
					THEN
					
						IF snowstatementdate
						THEN
							chargemonthlyfee(i);
						END IF;
					
						s.say('');
						s.say(cmethodname ||
							  '      ^^^^^^^^^^ REDISTRIBUTING INTEREST FROM/TO BALANCE/OFF-BALANCE ^^^^^^^^^^');
						s.say(cmethodname || '       Currency (i) = ' || i, 1);
						IF snowstatementdate
						THEN
							changetrxnsbalance(i, sdeldate(i));
						END IF;
						s.say(cmethodname || '      ^^^^^^^^^^', 1);
						s.say('');
					
						s.say('');
						s.say(cmethodname || '      ^^^^^^^^^^ INTEREST CHARGE ^^^^^^^^^^');
						s.say(cmethodname || '       Currency (i) = ' || i, 1);
						IF snowstatementdate
						THEN
							interestcharge(i);
						END IF;
						s.say(cmethodname || '      ^^^^^^^^^^', 1);
						s.say('');
					
						s.say('');
						s.say(cmethodname || '      ^^^^^^^^^^ OVERDUE FEE CHARGE ^^^^^^^^^^');
						s.say(cmethodname || '       Currency (i) = ' || i, 1);
					
						IF (snowstatementdate AND
						   (sprofile(sprofileid(i)) (custom_contractprofiles.cp_ovdfeedate) = 1))
						   OR
						   (snowduedate AND
						   (sprofile(sprofileid(i)) (custom_contractprofiles.cp_ovdfeedate) = 2))
						THEN
						
							calcovdfee(i, vfeevalue, vgst, vovdfeecalclog);
						
							chargeovdfee(i, vfeevalue, vgst, vovdfeecalclog);
						
							saveovdfeecalclog(vovdfeecalclog);
						
						END IF;
					
						s.say(cmethodname || '      ^^^^^^^^^^', 1);
						s.say('');
					
					END IF;
				
					IF viseod
					   OR adjustingmode.isatomrunning(paatomlist, adjustingmode.ao_delinquency)
					THEN
						s.say('');
						s.say(cmethodname ||
							  '      ^^^^^^^^^^ RETURNING ACCUMULATED INTEREST ONTO CARD ACCOUNT ^^^^^^^^^^');
						s.say(cmethodname || '       Currency (i) = ' || i, 1);
					
						s.say(cmethodname || '      Overdue Date (sDelDate(' || i || ')) =' ||
							  sdeldate(i) || ', Accumulation interest mode (sAccumIntAccMode) = ' ||
							  saccumintaccmode || ', [' || cintaccmode_donotaccumulate ||
							  ' - Don''t accumulate, ' || cintaccmode_bankincomeacc ||
							  ' - Using Bank Interest Income Acc, ' || cintaccmode_intaccbalance ||
							  ' - Using Bank Accumulate Interest Acc.(Balance), ' ||
							  cintaccmode_intacctechnical ||
							  ' - Using Bank Accumulate Interest Acc.(Technical)]');
					
						contractrbstd.changecontractparam(scontractno
														 ,'DelDate_' || i
														 ,to_char(sdeldate(i)
																 ,contractparams.cparam_date_format));
					
						s.say(cmethodname ||
							  '      Whether Interest should be charged according to current contract state (sBlockParam.State.ChargeInt) = ' ||
							  sblockparam.state.chargeint);
						IF (saccumintaccmode <> cintaccmode_donotaccumulate)
						   AND (sblockparam.state.chargeint IN
						   (contractstatereference.cintcharge
								,contractstatereference.cintoffbalance))
						   AND (sintaccount(i).accountno IS NOT NULL)
						   AND (sintaccount(i).remain < 0)
						THEN
						
							s.say(cmethodname ||
								  '      Interest accumulation account (sIntAccount(' || i ||
								  ').AccountNo) = ' || sintaccount(i).accountno);
						
							vfullremark := getfullremark(i, 'TransFullRemark');
						
							CASE saccumintaccmode
							
								WHEN cintaccmode_bankincomeacc THEN
								
									doentry(i
										   ,sdepaccount(i)
										   ,sintaccount(i)
										   ,sdepaccount(i).currencyno
										   ,abs(sintaccount(i).remain)
										   ,'CHARGE_INTEREST_GROUP_0'
										   ,'Accum%_0'
										   ,vfullremark);
								
									IF sblockparam.state.chargeint =
									   contractstatereference.cintoffbalance
									THEN
									
										doentry(i
											   ,sabaccounts(i) (cb_incacc)
											   ,sabaccounts(i) (cb_incaccoffbal)
											   ,sabaccounts(i)(cb_incacc).currencyno
											   ,abs(sintaccount(i).remain)
											   ,'CHARGE_INTEREST_GROUP_0'
											   ,'Bal -> Off'
											   ,pdotrxn => FALSE);
									END IF;
								
								WHEN cintaccmode_intaccbalance THEN
								
									doentry(i
										   ,sdepaccount(i)
										   ,sintaccount(i)
										   ,sdepaccount(i).currencyno
										   ,abs(sintaccount(i).remain)
										   ,'CHARGE_INTEREST_GROUP_0'
										   ,'Accum%_0'
										   ,vfullremark);
								
									IF sblockparam.state.chargeint =
									   contractstatereference.cintcharge
									THEN
									
										doentry(i
											   ,sabaccounts(i) (cb_accumintacc)
											   ,sabaccounts(i) (cb_incacc)
											   ,sdepaccount(i).currencyno
											   ,abs(sintaccount(i).remain)
											   ,'CHARGE_INTEREST_GROUP_0'
											   ,'Accum%_0'
											   ,vfullremark
											   ,pdotrxn => FALSE);
									
									ELSE
									
										doentry(i
											   ,sabaccounts(i) (cb_accumintacc)
											   ,sabaccounts(i) (cb_incaccoffbal)
											   ,sdepaccount(i).currencyno
											   ,abs(sintaccount(i).remain)
											   ,'CHARGE_INTEREST_GROUP_0'
											   ,'Accum%_0'
											   ,vfullremark
											   ,pdotrxn => FALSE);
									END IF;
								
								WHEN cintaccmode_intacctechnical THEN
								
									doentry(i
										   ,sabaccounts(i) (cb_accumintacc)
										   ,sintaccount(i)
										   ,sdepaccount(i).currencyno
										   ,abs(sintaccount(i).remain)
										   ,'CHARGE_INTEREST_GROUP_0'
										   ,'Accum%_0'
										   ,vfullremark
										   ,pdotrxn => FALSE);
								
									IF sblockparam.state.chargeint =
									   contractstatereference.cintcharge
									THEN
									
										doentry(i
											   ,sdepaccount(i)
											   ,sabaccounts(i) (cb_incacc)
											   ,sdepaccount(i).currencyno
											   ,abs(sintaccount(i).remain)
											   ,'CHARGE_INTEREST_GROUP_0'
											   ,'Accum%_0'
											   ,vfullremark);
									
									ELSE
									
										doentry(i
											   ,sdepaccount(i)
											   ,sabaccounts(i) (cb_incaccoffbal)
											   ,sdepaccount(i).currencyno
											   ,abs(sintaccount(i).remain)
											   ,'CHARGE_INTEREST_GROUP_0'
											   ,'Accum%_0'
											   ,vfullremark);
									END IF;
								
								ELSE
									NULL;
								
							END CASE;
						
							s.say(cmethodname ||
								  '      Interest was returned back onto card account'
								 ,1);
						
						END IF;
					END IF;
					s.say(cmethodname || '      ^^^^^^^^^^', 1);
					s.say('');
				
					s.say('');
					s.say(cmethodname ||
						  '      ^^^^^^^^^^ INSTALLMENT REPAYMENT (TRANSACTIONS ARE BEING RETURNED BACK TO RCM FROM INSTALLMENT) ^^^^^^^^^^'
						 ,1);
					s.say(cmethodname || '       Currency (i) = ' || i, 1);
				
					IF adjustingmode.isatomrunning(paatomlist, adjustingmode.ao_payinst)
					THEN
						IF vcurrencyisused(i)
						THEN
							installmentrepayment(i, cadjusting);
						END IF;
					END IF;
				
					s.say(cmethodname || '      ^^^^^^^^^^');
					s.say('');
				
				END IF;
			
			END LOOP;
		
			IF snowstatementdate
			   AND viseod
			THEN
				s.say('');
				s.say(cmethodname ||
					  '      ^^^^^^^^^^ STATEMENT GENERATION AND STATEMENT FEE CALCULATION ^^^^^^^^^^'
					 ,1);
				s.say(cmethodname ||
					  '       Statement generation conditions (saCTParam(cCTP_StmtMode)) = ' ||
					  sactparam(cctp_stmtmode) ||
					  ', 0-Don''t generate, 1-Indebtedness, 2-Movement, 3-Indebtedness or Movement, 4-Indebtedness and Movement, 5-In Any Case]'
					 ,1);
				s.say(cmethodname ||
					  '       Number of transaction for statement generation (saCTParam(cCTP_StmtTrns)) = ' ||
					  sactparam(cctp_stmttrns)
					 ,1);
			
				vindebet  := FALSE;
				vmovement := FALSE;
				FOR i IN 1 .. 2
				LOOP
					IF vcurrencyisused(i)
					THEN
						IF sdepaccount(i).remain < 0
						THEN
							vindebet := TRUE;
						END IF;
						vstmttrns := gettrxnscount(sdepaccount(i));
						s.say(cmethodname || '       Number of posted transactions (vStmtTrns) = ' ||
							  vstmttrns);
						IF vstmttrns <> 0
						THEN
							vmovement := TRUE;
							IF sactparam(cctp_stmtmode) IN (2, 3, 4)
							   AND vstmttrns < sactparam(cctp_stmttrns)
							THEN
								vmovement := FALSE;
							END IF;
						END IF;
					END IF;
					EXIT WHEN vmovement AND vindebet;
				END LOOP;
				s.say('');
				s.say(cmethodname || ' Whether indebtness exists (vIndebt) = ' ||
					  service.iif(vindebet, 'true', 'false') ||
					  ', whether transaction movement took place (vMovement) =' ||
					  service.iif(vmovement, 'true', 'false') ||
					  ', Statement Gen. PL/SQL block ID (saCTParam(cCTP_StmntPL_SQL)) = ' ||
					  sactparam(cctp_stmntpl_sql));
			
				IF sactparam(cctp_stmntpl_sql) IS NOT NULL
				THEN
					dynasql.setvaluechar(sactparam(cctp_stmntpl_sql), ':CONTRACTNO', scontractno);
				END IF;
			
				IF sblockparam.state.statementgen = 1
				   AND (sactparam(cctp_stmtmode) = 5 OR
				   (sactparam(cctp_stmtmode) IN (1, 3) AND vindebet) OR
				   (sactparam(cctp_stmtmode) IN (2, 3) AND vmovement) OR
				   (sactparam(cctp_stmtmode) = 4 AND vmovement AND vindebet))
				  
				   AND (sactparam(cctp_stmntpl_sql) IS NULL OR
				   nvl(dynasql.runone(sactparam(cctp_stmntpl_sql), TRUE, 1), 1) = 1)
				
				THEN
					createstatementpackrow(getcurrentcycle().statementdate);
					FOR i IN 1 .. 2
					LOOP
						s.say(cmethodname || '       Currency (i) = ' || i, 1);
						IF vcurrencyisused(i)
						THEN
						
							IF sactparam(cctp_stmntpl_sql) IS NOT NULL
							THEN
								dynasql.setvaluechar(sactparam(cctp_stmntpl_sql)
													,':CONTRACTNO'
													,scontractno);
								s.say(cmethodname ||
									  '      Statement Gen. PL/SQL block OUTPUT (DynaSQL.RunOne(saCTParam(cCTP_StmntPL_SQL), true)) = ' ||
									  dynasql.runone(sactparam(cctp_stmntpl_sql), TRUE)
									 ,1);
							ELSE
								s.say(cmethodname ||
									  '      Statement Gen. PL/SQL block OUTPUT (DynaSQL.RunOne(saCTParam(cCTP_StmntPL_SQL), true)) = NULL'
									 ,1);
							END IF;
						
							s.say(cmethodname ||
								  '      Statement Fee Calculation Type ( saCTParamCcy(i)(cCTP_StmntFeeCalcType) ) = ' ||
								  sactparamccy(i) (cctp_stmntfeecalctype) || ', [' ||
								  ccalctype_notcalc || ' - Don''t charge, ' ||
								  ccalctype_total || ' - Charge as total of, ' ||
								  ccalctype_min || '- Charge as minimum between, ' ||
								  ccalctype_max || '- Charge as maximum between]');
							s.say(cmethodname ||
								  '      Statement Fee Amount  ( saCTParamCcy(i)(cCTP_StmtFeeAmount) ) = ' ||
								  sactparamccy(i) (cctp_stmtfeeamount)
								 ,1);
							s.say(cmethodname ||
								  '      Statement Fee Percentage  ( saCTParamCcy(i)(cCTP_StmntFeePrcnt) ) = ' ||
								  sactparamccy(i) (cctp_stmntfeeprcnt)
								 ,1);
							s.say(cmethodname ||
								  '      Statement Fee Account ( saBAccounts(i)(cB_StmtFeeAcc).AccountNo ) = ' ||
								  sabaccounts(i)(cb_stmtfeeacc).accountno
								 ,1);
							s.say(cmethodname ||
								  '      Current balance ( sDepAccount(i).remain ) = ' || sdepaccount(i)
								  .remain
								 ,1);
						
							IF nvl(sactparamccy(i) (cctp_stmtfeeamount), 0) <> 0
							   AND sabaccounts(i)(cb_stmtfeeacc).accountno IS NOT NULL
							   OR sactparamccy(i) (cctp_stmntfeecalctype) <> ccalctype_notcalc
							THEN
								IF sactparamccy(i) (cctp_stmntfeecalctype) = ccalctype_total
								THEN
									vstatementfee := abs(least(sdepaccount(i).remain, 0) / 100) *
													 nvl(sactparamccy(i) (cctp_stmntfeeprcnt), 0) +
													 nvl(sactparamccy(i) (cctp_stmtfeeamount), 0);
								ELSIF sactparamccy(i) (cctp_stmntfeecalctype) = ccalctype_min
								THEN
									vstatementfee := least(abs(least(sdepaccount(i).remain, 0) / 100) *
														   nvl(sactparamccy(i) (cctp_stmntfeeprcnt)
															  ,0)
														  ,nvl(sactparamccy(i) (cctp_stmtfeeamount)
															  ,0));
								ELSIF sactparamccy(i) (cctp_stmntfeecalctype) = ccalctype_max
								THEN
									vstatementfee := greatest(abs(least(sdepaccount(i).remain, 0) / 100) *
															  nvl(sactparamccy(i)
																  (cctp_stmntfeeprcnt)
																 ,0)
															 ,nvl(sactparamccy(i)
																  (cctp_stmtfeeamount)
																 ,0));
								ELSE
									vstatementfee := sactparamccy(i) (cctp_stmtfeeamount);
								END IF;
								s.say(cmethodname ||
									  '      Calculated statement fee ( vStatementFee ) = ' ||
									  vstatementfee);
								doentry(i
									   ,sdepaccount(i)
									   ,sabaccounts(i) (cb_stmtfeeacc)
									   ,sdepaccount(i).currencyno
									   ,round(vstatementfee, sprecision(i))
									   ,'STATEMENT_FEE_ON'
									   ,'StmtFee');
							END IF;
						
						END IF;
					END LOOP;
				END IF;
				s.say(cmethodname || '      ^^^^^^^^^^', 1);
				s.say('');
			END IF;
		
			s.say('');
			s.say(cmethodname || '      ^^^^^^^^^^ CREDIT SHIELD CALCULATION ^^^^^^^^^^');
		
			t.var('sBlockParam.State.ChargeCrdShield', sblockparam.state.chargecrdshield);
		
			IF viseod
			   AND (sblockparam.state.chargecrdshield = 1)
			THEN
			
				FOR i IN 1 .. 2
				LOOP
				
					IF vcurrencyisused(i)
					THEN
					
						getcreditshieldamount(i, vshieldvalue, vdiscountshieldvalue);
					
						IF vshieldvalue > 0
						THEN
						
							IF vdiscountshieldvalue > 0
							THEN
							
								vdebittrxn := doentry(i
													 ,sdepaccount(i)
													 ,sabaccounts(i) (cb_shieldacc)
													 ,sdepaccount(i).currencyno
													 ,vshieldvalue
													 ,'CREDIT_SHIELD_PREMIUM'
													 ,'CS_Premium');
							
								vcredittrxn := doentry(i
													  ,sabaccounts(i) (cb_shieldacc)
													  ,sdepaccount(i)
													  ,sdepaccount(i).currencyno
													  ,vdiscountshieldvalue
													  ,'CREDIT_SHIELD_PREMIUM_DISC'
													  ,'CS_Discnt');
							
								dorepayment(i, vdebittrxn, vcredittrxn);
							
							ELSE
								doentry(i
									   ,sdepaccount(i)
									   ,sabaccounts(i) (cb_shieldacc)
									   ,sdepaccount(i).currencyno
									   ,vshieldvalue
									   ,'CREDIT_SHIELD_PREMIUM'
									   ,'CS_Premium');
							END IF;
						
						END IF;
					
					END IF;
				
				END LOOP;
			
			END IF;
		
			FOR i IN 1 .. 2
			LOOP
				IF vcurrencyisused(i)
				THEN
					chooseprofiles(i);
				END IF;
			END LOOP;
		
			IF snowduedate
			   AND viseod
			THEN
				markcycleduedateaspassed;
			END IF;
		
			IF snowstatementdate
			   AND viseod
			THEN
			
				vdate                   := contractcalendar.getnextstatementdate(getbillingcyclecalendar
																				,getnextduedate);
				vnewcycleprintedduedate := contractcalendar.getprintedduedate(getbillingcyclecalendar
																			 ,coperdate);
				vnewcycledafdate        := contractcalendar.getdafdate(getbillingcyclecalendar
																	  ,coperdate);
			
				s.say(cmethodname ||
					  '      Printed Due Date For The Cycle (vNewCyclePrintedDueDate) = ' ||
					  htools.d2s(vnewcycleprintedduedate));
				s.say(cmethodname || '      Daf Date For The Cycle (vNewCycleDafDate) = ' ||
					  htools.d2s(vnewcycledafdate));
				s.say(cmethodname || '      NextStDate(1) =' || htools.d2s(vdate));
				s.say(cmethodname || '      NextDueDate =' || htools.d2s(getnextduedate));
			
				vcyclerecno := createnextcycle(coperdate
											  ,getnextduedate
											  ,vdate
											  ,vnewcycleprintedduedate
											  ,vnewcycledafdate);
			
			END IF;
		
			FOR i IN 1 .. 2
			LOOP
				IF vcurrencyisused(i)
				THEN
					IF NOT checktrxnlist(i)
					THEN
						IF sdontcheckdata
						THEN
							contractadjwarning.appendwarning('Data integrity error!');
						ELSE
							error.raiseerror('Data integrity error!');
						END IF;
					END IF;
				END IF;
			END LOOP;
		
			s.say('');
			s.say(cmethodname ||
				  '      ^^^^^^^^^^ OVERLIMIT CALCULATION (FOR FINAL BALANCE ON OVERLIMIT ACCOUNT OBTAINING) ^^^^^^^^^^');
			IF slimittype = caggregate
			THEN
				s.say(cmethodname || '      Limit type is "Aggregated"');
				snotusedlimit(1) := greatest(sdepaccount(1).overdraft + sdepaccount(1).remain, 0);
				snotusedlimit(2) := greatest(sdepaccount(2).overdraft + sdepaccount(2).remain, 0);
				FOR i IN 1 .. 2
				LOOP
					voverlimit(i) := overlimitcalc(i);
				END LOOP;
			ELSE
				s.say(cmethodname || '      Limit type is NOT "Aggregated"');
				FOR i IN 1 .. 2
				LOOP
					voverlimit(i).cur1aggroverlimit := abs(least(sdepaccount(i)
																 .overdraft + sdepaccount(i).remain
																,0));
					snotusedlimit(i) := 0;
				END LOOP;
			END IF;
			FOR i IN 1 .. 2
			LOOP
				IF vcurrencyisused(i)
				THEN
					vvalue := voverlimit(i).cur1aggroverlimit + sovdaccount(i).remain;
					s.say(cmethodname || '      Overlimit (' || i ||
						  ') Correction Value (vValue) =' || vvalue);
					vvalue := round(vvalue, sprecision(i));
					s.say(cmethodname || '      Overlimit (' || i ||
						  ') rounded Correction Value (vValue) =' || vvalue);
					IF vvalue > 0
					THEN
						doentry(i
							   ,sovdaccount(i)
							   ,sabaccounts(i) (cb_techacc)
							   ,sdepaccount(i).currencyno
							   ,vvalue
							   ,'OVER_LIMIT_ON'
							   ,'OvrLmtOn'
							   ,pdotrxn => FALSE);
					ELSIF vvalue < 0
					THEN
						doentry(i
							   ,sabaccounts(i) (cb_techacc)
							   ,sovdaccount(i)
							   ,sdepaccount(i).currencyno
							   ,-vvalue
							   ,'OVER_LIMIT_OFF'
							   ,'OvrLmtOff'
							   ,pdotrxn => FALSE);
					END IF;
				END IF;
			END LOOP;
			s.say(cmethodname || '      ^^^^^^^^^^');
			s.say('');
		
			s.say('');
			s.say(cmethodname || '      ^^^^^^^^^^ MINIMUM PAYMENT CALCULATION ^^^^^^^^^^');
			IF snowstatementdate
			   AND viseod
			THEN
				calculatemp(vcyclerecno);
			END IF;
			s.say(cmethodname || '      ^^^^^^^^^^');
			s.say('');
		
			updatecontractstate;
		
			s.say('');
			s.say(cmethodname || '      ^^^^^^^^^^ DAF GENERATION ^^^^^^^^^^');
			IF sactparam(cctp_usedaf) = '1'
			   AND adjustingmode.isatomrunning(paatomlist, adjustingmode.ao_generatedaf)
			THEN
				s.say(cmethodname || '      Do daf =');
				s.say(cmethodname || '      sDAFReport (saCTParam(cCTP_DAFReport)) = ' ||
					  sactparam(cctp_dafreport));
				IF getcurrentcycle().statementdate IS NOT NULL
					OR snowstatementdate
				THEN
				
					s.say(cmethodname ||
						  '      DaAF Generation Date Stored in tContractStCycle (DafDate) = ' ||
						  htools.d2s(getcurrentcycle().dafdate));
				
					vdafdate := nvl(getcurrentcycle().dafdate
								   ,contractcalendar.getdafdate(getbillingcyclecalendar
															   ,nvl(getcurrentcycle().statementdate
																   ,coperdate)));
				
					s.say(cmethodname || '      vDAFDate =' || vdafdate, 1);
					s.say(cmethodname || '      cOperDate =' || coperdate, 1);
					IF coperdate = vdafdate
					THEN
						s.say(cmethodname || '      Do daf 2 =', 1);
						EXECUTE IMMEDIATE 'begin ' || sactparam(cctp_dafreport) ||
										  '.ExecuteRep(:No, :OperDate, false, 1, :Path); end;'
							USING scontractno, coperdate, sactparam(cctp_outpath);
					END IF;
				END IF;
			END IF;
			s.say(cmethodname || '      ^^^^^^^^^^', 1);
			s.say('');
		
			s.say('');
			s.say(cmethodname ||
				  '      ^^^^^^^^^^ CONTRACT STATUS CHANGING. ACCOUNTS/CARDS STATE CHANGING ^^^^^^^^^^');
			IF viseod
			   OR adjustingmode.isatomrunning(paatomlist, adjustingmode.ao_delinquency)
			THEN
			
				CASE sblockparam.state.contractblock
					WHEN 0 THEN
						contractrbstd.violateoff(scontractno, plog => c_writelog);
					WHEN 1 THEN
						contractrbstd.violateon(scontractno, plog => c_writelog);
					ELSE
						error.raiseerror('Unknown contract block mode: ' ||
										 sblockparam.state.contractblock || '!');
				END CASE;
			
				setcardsstatusintwcms(sblockparam.state.cardsign
									 ,sblockparam.state.cardblock
									 ,sblockparam.state.reissueban
									 ,cadjusting
									 ,c_dorollback
									 ,TRUE);
			
				setaccountsstatus(cadjusting, FALSE);
			
			END IF;
			s.say(cmethodname || '      ^^^^^^^^^^', 1);
			s.say('');
		
			s.say('');
			s.say(cmethodname || '      ^^^^^^^^^^ LIMITS RECALCULATION AND UPDATING ^^^^^^^^^^');
			IF viseod
			   OR adjustingmode.isatomrunning(paatomlist, adjustingmode.ao_updatelimits)
			THEN
			
				FOR i IN 1 .. 2
				LOOP
				
					IF vcurrencyisused(i)
					THEN
					
						IF snowstatementdate
						THEN
							correctusedlimits(i, TRUE);
						END IF;
					
						correctusedlimits(i, FALSE);
					
					END IF;
				
				END LOOP;
			
				processcontracttemplimits(cadjusting);
			
				updateallobjectslimitsintwcms(cadjusting);
			
			END IF;
		
			s.say(cmethodname || '      ^^^^^^^^^^');
			s.say('');
		
			vdate := greatest(nvl(sdepaccount(1).updatesysdate, sdepaccount(2).updatesysdate)
							 ,nvl(sdepaccount(2).updatesysdate, sdepaccount(1).updatesysdate));
		
			FOR i IN 1 .. 2
			LOOP
				IF vcurrencyisused(i)
				   AND (sdepaccount(i).updatesysdate < vdate)
				THEN
					sdummynum := contracttools.updateaccount(sdepaccount(i).accountno);
				END IF;
			END LOOP;
		
		END IF;
	
		adddocnotorollback;
	
		FOR i IN 1 .. 2
		LOOP
		
			IF slastdocno(i) > sacparamccy(i) (cp_lastdocno)
			THEN
				contractrbstd.changecontractparam(scontractno, 'LastDocNo_' || i, slastdocno(i));
			END IF;
		
			IF vcurrencyisused(i)
			THEN
			
				IF (snowstatementdate OR snowduedate)
				   AND viseod
				THEN
					custom_overdueparameterscalculation.prepareupd_contrstminpaymdata(scontractno
																					 ,sdepaccount(i)
																					  .accountno
																					 ,i
																					 ,getpackno
																					 ,coperdate
																					 ,0
																					 ,ctrxntype_debit
																					 ,snowstatementdate
																					 ,snowduedate);
				END IF;
			
				custom_overdueparameterscalculation.update_contrstminpaymentdata(i
																				,snowstatementdate
																				,snowduedate
																				,sdepaccount(i)
																				 .accountno || '-' || i || '-' ||
																				  to_char(coperdate
																						 ,'yyyy.mm.dd'));
			
			END IF;
		
		END LOOP;
	
		s.say('');
		s.say(cmethodname || '      ^^^^^^^^^^ COLLECTION ^^^^^^^^^^');
	
		IF adjustingmode.isatomrunning(paatomlist, adjustingmode.ao_collection)
		THEN
			IF collectionavailable
			THEN
				FOR i IN 1 .. 2
				LOOP
					IF vcurrencyisused(i)
					THEN
						sdummynum := contractcollection.checkcontractstate(scontractno
																		  ,scontractno
																		  ,contractadjustingpack.getcurrentpackno
																		  ,slabel(i)
																		  ,sdepaccount(i).accountno
																		  ,getcollectionattributes(i)
																		  ,c_dorollback);
					END IF;
				END LOOP;
			ELSE
				t.note(cmethodname
					  ,'Warning: collection adjusting mode is active, although collection module is not available!');
			END IF;
		END IF;
	
		setoperationrollbackdata(vcyclerecno, FALSE);
	
		IF vismigration
		THEN
			addadjustingpacknotorollback(crl_contractmigrated);
		
		ELSIF contractrb.hasrbdata
			  OR (sentryno <> 0)
		THEN
			addadjustingpacknotorollback(crl_contractadjusted);
		END IF;
	
		contracttypeschema.sdocno := sdocno;
	
		scontrattrcalcflag.delete;
	
		vhascreditafteradjusting      := contracthascredit;
		contracttypeschema.fcrediton  := nullif(NOT vhascreditbeforeadjusting AND
												vhascreditafteradjusting
											   ,FALSE);
		contracttypeschema.fcreditoff := nullif(vhascreditbeforeadjusting AND
												NOT vhascreditafteradjusting
											   ,FALSE);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END doadjusting;

	FUNCTION execadjusting RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ExecAdjusting';
	BEGIN
		doadjusting(adjustingmode.getrunningatoms);
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END execadjusting;

	PROCEDURE downadjusting(pcontracttype IN typecontracttype) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.DownAdjusting';
		vdummy BOOLEAN;
	BEGIN
		contracttypeschema.scontractrow.type := pcontracttype;
	
		IF nvl(sstatementpackno, 0) <> 0
		THEN
			spacket.datestart := sstatstartdate;
			spacket.code      := sstatementpackno;
			vdummy            := statementmanualrt.updatemanualpacket(spacket);
		END IF;
	
		contractsql.batchclear;
	
		tamcclearcache;
	
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END downadjusting;

	FUNCTION initundoadjusting(pcontracttype IN typecontracttype) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.InitUndoAdjusting';
	BEGIN
		t.enter(cmethodname);
	
		scontracttype                        := pcontracttype;
		contracttypeschema.scontractrow.type := pcontracttype;
		readsetupscheme(FALSE);
	
		t.leave(cmethodname);
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END initundoadjusting;

	FUNCTION undoadjusting RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UndoAdjusting';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vpackno          tcontracttrxnlist.packno%TYPE;
		vaarg            contracttools.typevarchar50;
		vifstatementdate BOOLEAN;
		vvalue           VARCHAR2(500);
		vifduedate       BOOLEAN;
		vkey             VARCHAR2(10);
		vcount           NUMBER := 1;
		vret             NUMBER;
		vcurpack         NUMBER;
		vsavpack         NUMBER;
		vacc             NUMBER;
	
		PROCEDURE undopaydate
		(
			pcurrencynumber IN NUMBER
		   ,pvalue          IN VARCHAR
		) IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.UndoAdjusting.UndoPayDate';
		BEGIN
			IF pvalue IS NULL
			THEN
				contractparams.deletevalue(contractparams.ccontract
										  ,contracttypeschema.scontractrow.no
										  ,'PayDate_' || pcurrencynumber);
			ELSE
				contractparams.savedate(contractparams.ccontract
									   ,contracttypeschema.scontractrow.no
									   ,'PayDate_' || pcurrencynumber
									   ,to_date(pvalue, 'DDMMYYYY'));
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				err.seterror(SQLCODE, cmethodname);
				error.save(cmethodname);
				RAISE;
		END undopaydate;
	
		PROCEDURE rollbackpaymhistory(ppackno IN NUMBER) IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.RollbackPaymHistory';
		BEGIN
			s.say(cmethodname || ' -> ContractNo = ' || scontractno || ' PackNo = ' || ppackno, 1);
			DELETE FROM trevpaymenthist
			WHERE  branch = cbranch
			AND    contractno = scontractno
			AND    packno = ppackno;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END rollbackpaymhistory;
	
	BEGIN
		custom_overdueparameterscalculation.clearcache;
		err.seterror(0, cmethodname);
		scontractno := contracttypeschema.scontractrow.no;
		s.say(cmethodname || ' ContractNo = ' || scontractno);
		IF contracttypeschema.srollbackdata IS NULL
		THEN
			RETURN 0;
		END IF;
		getcontractdata;
		LOOP
			vkey := contracttools.getdataforundo(vcount, vvalue);
			s.say(cmethodname || ' -> vKey=' || vkey);
			EXIT WHEN vkey IS NULL;
		
			IF vkey = '#ICC'
			THEN
				undoinstallmentclosure_legacy(vvalue);
			
			ELSIF vkey = '#LPN'
			THEN
				rollbackusedlimitschange(vvalue);
			
			ELSIF vkey = '#LHS'
			THEN
				s.say(cmethodname || '  Deleting limits change from tContractHistory, PackNo = ' ||
					  vvalue
					 ,1);
				contractparams.deletehistory(to_number(vvalue));
			
			ELSIF vkey = '#HPN'
			THEN
				contractparams.deletehistory(vvalue);
			
			ELSIF vkey = '#LAP'
			THEN
				vcurpack := contractadjustingpack.getcurrentpackno;
				vsavpack := nvl(contractparams.loadnumber(contractparams.ccontract
														 ,scontractno
														 ,'LastAdPackNo'
														 ,FALSE)
							   ,0);
				s.say(cmethodname || ' -> CurAdPackNo=' || vcurpack || ' SavAdPackNo=' || vsavpack
					 ,1);
				IF vsavpack > vcurpack
				THEN
					error.raiseerror('Adjustment procedure cannot be undone since this batch is not last for current contract');
				END IF;
				contractparams.savenumber(contractparams.ccontract
										 ,scontractno
										 ,'LastAdPackNo'
										 ,vvalue);
			
			ELSIF vkey = '#SSD'
			THEN
				deletecycle(vvalue);
				vifstatementdate := TRUE;
			
			ELSIF vkey = '#SDD'
			THEN
				setcycleduedate(vvalue, NULL);
				vifduedate := TRUE;
			
			ELSIF vkey = '#PCN'
			THEN
				rollbacktrxnlist(vvalue);
				vpackno := vvalue;
			
			ELSIF vkey = '#DOC'
			THEN
				IF entry.undo(entry.flnocheck, vvalue) <> 0
				THEN
					RETURN err.geterrorcode;
				END IF;
			
			ELSIF vkey = '#PD1'
			THEN
				undopaydate(1, vvalue);
			
			ELSIF vkey = '#PD2'
			THEN
				undopaydate(2, vvalue);
			
			ELSIF vkey = '#PHP'
			THEN
				rollbackpaymhistory(vvalue);
			
			ELSIF vkey = '#Von'
			THEN
				IF contract.setstatus(vvalue, contract.stat_violate, FALSE) <> 0
				THEN
					RETURN err.geterrorcode;
				END IF;
			
			ELSIF vkey = '#Vof'
			THEN
				IF contract.setstatus(vvalue, contract.stat_violate, TRUE) <> 0
				THEN
					RETURN err.geterrorcode;
				END IF;
			
			ELSIF vkey = '#LDN'
			THEN
				vret := contracttools.getargforundo(vvalue, vaarg);
				IF vret <> 2
				THEN
					error.raiseerror('Not enough values in #LDN undo label!');
				END IF;
				contractparams.savenumber(contractparams.ccontract
										 ,contracttypeschema.scontractrow.no
										 ,'LastDocNo_' || vaarg(1)
										 ,to_number(vaarg(2)));
			
			ELSIF vkey = '#DGR'
			THEN
				undoregisterstate(vvalue);
			
			ELSIF vkey = '#OFD'
			THEN
				vret := contracttools.getargforundo(vvalue, vaarg);
				IF vret < 2
				THEN
					error.raiseerror('Not enough values in #OFD undo label!');
				END IF;
				IF vret = 2
				THEN
					contractparams.deletevalue(contractparams.ccontract
											  ,contracttypeschema.scontractrow.no
											  ,'Last_Overdue_Fee_' || vaarg(1));
				ELSIF vret = 3
				THEN
					IF vaarg(3) = 'NULL'
					THEN
						contractparams.deletevalue(contractparams.ccontract
												  ,contracttypeschema.scontractrow.no
												  ,'Last_Overdue_Fee_' || vaarg(1));
					ELSE
						contractparams.savedate(contractparams.ccontract
											   ,contracttypeschema.scontractrow.no
											   ,'Last_Overdue_Fee_' || vaarg(1)
											   ,to_date(vaarg(3), 'DDMMYYYY'));
					END IF;
					undooverduefeelog(vaarg(2));
				END IF;
			
			ELSIF vkey = '#PLG'
			THEN
				undoprofilehistorysave(vvalue);
			
			ELSIF vkey = '#OAS'
			THEN
				vret := contracttools.getargforundo(vvalue, vaarg);
				IF vret = 2
				THEN
					s.say(cmethodname || ' -> vaArg(1)=' || vaarg(1) || ' vaArg(2)=' || vaarg(2)
						 ,1);
					contractparams.savechar(contractparams.ccontract
										   ,scontractno
										   ,'Acc_Status_' || vaarg(1)
										   ,vaarg(2));
				ELSIF vret = 1
				THEN
					s.say(cmethodname || ' -> vaArg(1)=' || vaarg(1), 1);
					contractparams.deletevalue(contractparams.ccontract
											  ,scontractno
											  ,'Acc_Status_' || vaarg(1));
				END IF;
			
			ELSIF vkey = '#ACS'
			THEN
				vret := contracttools.getargforundo(vvalue, vaarg);
				IF vret <> 2
				THEN
					error.raiseerror('Incorrect data for undo: <' || vvalue || '>!');
				END IF;
				s.say(cmethodname || ' -> vaArg(1)=' || vaarg(1) || ' vaArg(2)=' || vaarg(2));
				s.say(cmethodname || ' -> sDepAccount(vaArg(1)).AccountNo=' || sdepaccount(vaarg(1))
					  .accountno);
				vacc := account.newobject(sdepaccount(vaarg(1)).accountno, 'W');
				s.say(cmethodname || ' vAcc=' || vacc, 1);
				IF vacc = 0
				THEN
					RETURN err.geterrorcode;
				END IF;
				account.setacct_stat(vacc, vaarg(2));
				IF err.geterrorcode <> 0
				THEN
					err.saveerror;
					account.freeobject(vacc);
					err.restoreerror;
					RETURN err.geterrorcode;
				END IF;
				account.writeobject(vacc);
				IF err.geterrorcode <> 0
				THEN
					err.saveerror;
					account.freeobject(vacc);
					err.restoreerror;
					RETURN err.geterrorcode;
				END IF;
				account.freeobject(vacc);
			END IF;
		END LOOP;
	
		FOR i IN 1 .. 2
		LOOP
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			THEN
				custom_overdueparameterscalculation.fillstminpaymentdataarrays(sdepaccount(i)
																			   .accountno
																			  ,i
																			  ,NULL);
				custom_overdueparameterscalculation.rollbackaggregatedtrxn(sdepaccount(i).accountno
																		  ,i
																		  ,vpackno
																		  ,vifduedate
																		  ,vifstatementdate);
			END IF;
		END LOOP;
	
		custom_overdueparameterscalculation.clearcache;
		scontrattrcalcflag.delete;
		clearcontrtypecache;
	
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END undoadjusting;

	PROCEDURE dochangecontractparams(pfschparamlist IN contracttypeschema.typefschparamlist) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.DoChangeContractParams';
		coperdate   CONSTANT DATE := seance.getoperdate;
	
		vneedupdatelimits BOOLEAN := FALSE;
		vaparams          types.arrstr4000;
	
		PROCEDURE changecontractparam
		(
			pname      IN VARCHAR2
		   ,pnewvalue  IN VARCHAR2
		   ,pparamname IN VARCHAR2 := NULL
		) IS
			cmethodname CONSTANT typemethodname := dochangecontractparams.cmethodname ||
												   '.ChangeContractParam';
		BEGIN
			contractrbstd.changecontractparam(scontractno
											 ,pname
											 ,pnewvalue
											 ,pwritelog   => TRUE
											 ,pparamname  => pparamname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END changecontractparam;
	
		PROCEDURE int_setcorporatecontract(pparam IN contracttypeschema.typefschparam) IS
			cmethodname CONSTANT typemethodname := dochangecontractparams.cmethodname ||
												   '.Int_SetCorporateContract';
		BEGIN
			t.enter(cmethodname, pparam.stringvalue);
		
			vaparams := contracttools.parsestring(pparam.stringvalue, '@', 0, 1);
		
			IF vaparams.exists(1)
			THEN
			
				setcorporatecontract(vaparams(1), c_dorollback);
			ELSE
			
				setcorporatecontract(NULL, c_dorollback);
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_setcorporatecontract;
	
		PROCEDURE changecontractstate(pnewstatecode IN contractstatereference.typestatecode) IS
			cmethodname CONSTANT typemethodname := dochangecontractparams.cmethodname ||
												   '.ChangeContractState';
			voldstaterow contractstatereference.typeregisteredstaterow;
		BEGIN
			t.enter(cmethodname, pnewstatecode);
		
			contractrb.setlabel(crl_cstate);
		
			voldstaterow := contractstatereference.getlastregisteredstate(scontractno, coperdate);
		
			IF voldstaterow.stickmode = contractstatereference.cstickmanual
			THEN
			
				contractrb.setcvalue('OS', voldstaterow.statecode);
			ELSE
			
				contractrb.setcvalue('OS', contractstatereference.c_stateauto);
			END IF;
		
			contractrb.setcvalue('OD', voldstaterow.comments);
		
			a4mlog.cleanparamlist;
			a4mlog.addparamrec('CntrSt', voldstaterow.statecode, pnewstatecode);
		
			IF upper(pnewstatecode) = contractstatereference.c_stateauto
			THEN
				contractstatereference.resetcontractstate(scontractno, getpackno);
				a4mlog.logobject(object.gettype(contract.object_name)
								,scontractno
								,'Contract state was unstuck and changed from <' ||
								 voldstaterow.statecode || '> to <' || pnewstatecode ||
								 '> by batch operation'
								,a4mlog.act_change
								,a4mlog.putparamlist
								,powner => getclientid);
			
			ELSE
				contractstatereference.setcontractstate(scontractno
													   ,getpackno
													   ,pnewstatecode
													   ,'Set by batch operation');
				a4mlog.logobject(object.gettype(contract.object_name)
								,scontractno
								,'Contract state was stuck and changed from <' ||
								 voldstaterow.statecode || '> to <' || pnewstatecode ||
								 '> by batch operation'
								,a4mlog.act_change
								,a4mlog.putparamlist
								,powner => getclientid);
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END changecontractstate;
	
		PROCEDURE int_setbalancetransfersettings
		(
			pcurno IN NUMBER
		   ,pparam IN contracttypeschema.typefschparam
		) IS
			cmethodname CONSTANT typemethodname := dochangecontractparams.cmethodname ||
												   '.Int_SetBalanceTransferSettings';
			vaccountno typeaccountno := NULL;
		BEGIN
			t.enter(cmethodname, pparam.stringvalue);
		
			vaparams := contracttools.parsestring(pparam.stringvalue, '@', 0, 1);
		
			IF vaparams.exists(1)
			THEN
			
				vaccountno := contracttools.getvalidaccount(vaparams(1), pparam.id);
			END IF;
		
			changecontractparam('Account' || slabel(pcurno), vaccountno);
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_setbalancetransfersettings;
	
		PROCEDURE int_setautorepaymentsettings
		(
			pcurno IN NUMBER
		   ,pparam IN contracttypeschema.typefschparam
		) IS
			cmethodname CONSTANT typemethodname := dochangecontractparams.cmethodname ||
												   '.Int_SetAutoRepaymentSettings';
			vaccountno typeaccountno := NULL;
		BEGIN
			t.enter(cmethodname, pparam.stringvalue);
		
			vaparams := contracttools.parsestring(pparam.stringvalue, '@', 1, 2);
		
			IF vaparams.exists(1)
			THEN
			
				vaccountno := contracttools.getvalidaccount(vaparams(1), pparam.id);
			
				changecontractparam('PayAccount' || slabel(pcurno), vaccountno);
			END IF;
		
			IF vaparams.exists(2)
			THEN
			
				IF vaparams(2) IN (cautopay_mponod, cautopay_debtonsd, cautopay_debtonod)
				THEN
				
					changecontractparam('PayAmount' || slabel(pcurno), vaparams(2));
				ELSE
					error.raiseerror('Error: unsupported autopayment sum selection mode: <' ||
									 vaparams(2) || '>!');
				END IF;
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_setautorepaymentsettings;
	
		PROCEDURE int_setdafgenmode(pparam IN contracttypeschema.typefschparam) IS
			cmethodname CONSTANT typemethodname := dochangecontractparams.cmethodname ||
												   '.Int_SetDAFGenMode';
			vmodetoset NUMBER;
		BEGIN
			t.enter(cmethodname, pparam.stringvalue);
		
			vaparams := contracttools.parsestring(pparam.stringvalue, '@', 1, 1);
		
			CASE vaparams(1)
				WHEN 'DEF' THEN
					vmodetoset := cdaf_default;
				WHEN 'ON' THEN
					vmodetoset := cdaf_generate;
				WHEN 'OFF' THEN
					vmodetoset := cdaf_skip;
				ELSE
					error.raiseerror('Error: unsupported DAF generation mode: <' || vaparams(1) || '>!');
			END CASE;
		
			setdafgenmode(vmodetoset, c_dorollback);
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_setdafgenmode;
	
		PROCEDURE int_setdafparams
		(
			pcurno IN NUMBER
		   ,pparam IN contracttypeschema.typefschparam
		) IS
			cmethodname CONSTANT typemethodname := dochangecontractparams.cmethodname ||
												   '.Int_SetDAFParams';
			vprofileid NUMBER;
		BEGIN
			t.enter(cmethodname, pparam.stringvalue);
		
			vaparams := contracttools.parsestring(pparam.stringvalue, '@', 1, 2);
		
			CASE vaparams(1)
			
				WHEN 'ON' THEN
				
					setdafgenmode(cdaf_generate, c_dorollback);
				
					IF vaparams.count = 2
					THEN
					
						vprofileid := contracttools.getvalidnumber(vaparams(2)
																  ,'DAF profile ID'
																  ,contracttools.cnum_nonnegative);
					
						setdafprofile(pcurno, vprofileid, c_dorollback);
					END IF;
				
				WHEN 'OFF' THEN
				
					setdafprofile(pcurno, NULL, c_dorollback);
				
					setdafgenmode(cdaf_skip, c_dorollback);
				
				WHEN 'DEF' THEN
				
					setdafprofile(pcurno, NULL, c_dorollback);
				
				ELSE
				
					IF contracttools.isnumber(vaparams(1))
					THEN
					
						setdafprofile(pcurno, vaparams(1), c_dorollback);
					
					ELSE
					
						setdafgenmode(cdaf_default, c_dorollback);
					
						IF vaparams.count = 2
						THEN
						
							vprofileid := contracttools.getvalidnumber(vaparams(2)
																	  ,'DAF profile ID'
																	  ,contracttools.cnum_nonnegative);
						
							setdafprofile(pcurno, vprofileid, c_dorollback);
						END IF;
					END IF;
			END CASE;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_setdafparams;
	
		PROCEDURE int_setintsettings
		(
			pcurno IN NUMBER
		   ,pparam IN contracttypeschema.typefschparam
		) IS
			cmethodname CONSTANT typemethodname := dochangecontractparams.cmethodname ||
												   '.Int_SetIntSettings';
			vforceprofile NUMBER;
			vprofileid    NUMBER;
		BEGIN
			t.enter(cmethodname, pparam.stringvalue);
		
			vaparams := contracttools.parsestring(pparam.stringvalue, '@', 1, 2);
		
			IF vaparams(1) = 'DEFAULT'
			THEN
				IF vaparams.count > 1
				THEN
					error.raiseerror('Error: second value is not required when using ''DEFAULT'' value as first!');
				END IF;
			
				changecontractparam('Profile' || slabel(pcurno)
								   ,NULL
								   ,'Interest and Fees Calculation Profile for ' ||
									sfulllabel(pcurno));
				changecontractparam('FixProfile' || slabel(pcurno)
								   ,'0'
								   ,'Use Interest and Fees profile regardless of delinquency state for ' ||
									sfulllabel(pcurno));
			
			ELSE
			
				vprofileid := contracttools.getvalidnumber(vaparams(1)
														  ,'Interest calculation profile ID'
														  ,contracttools.cnum_nonnegative);
			
				changecontractparam('Profile' || slabel(pcurno)
								   ,vprofileid
								   ,'Interest and Fees Calculation Profile for ' ||
									sfulllabel(pcurno));
			
				IF vaparams.exists(2)
				THEN
				
					CASE vaparams(2)
						WHEN 'OFF' THEN
							vforceprofile := 0;
						WHEN 'ON' THEN
							vforceprofile := 1;
						ELSE
							error.raiseerror('Error: unsupported interest profile use mode: <' ||
											 vaparams(2) || '>!');
					END CASE;
				
					changecontractparam('FixProfile' || slabel(pcurno)
									   ,vforceprofile
									   ,'Use Interest and Fees profile regardless of delinquency state for ' ||
										sfulllabel(pcurno));
				END IF;
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_setintsettings;
	
		PROCEDURE int_setmpsettings
		(
			pcurno IN NUMBER
		   ,pparam IN contracttypeschema.typefschparam
		) IS
			cmethodname CONSTANT typemethodname := dochangecontractparams.cmethodname ||
												   '.Int_SetMPSettings';
			vforceprofile NUMBER;
			vprofileid    NUMBER;
		BEGIN
			t.enter(cmethodname, pparam.stringvalue);
		
			vaparams := contracttools.parsestring(pparam.stringvalue, '@', 1, 2);
		
			IF vaparams(1) = 'DEFAULT'
			THEN
				IF vaparams.count > 1
				THEN
					error.raiseerror('Error: second value not required when using ''DEFAULT'' value as first!');
				END IF;
			
				changecontractparam('MPProfile' || slabel(pcurno)
								   ,NULL
								   ,'Minimum Payment Calculation Profile for ' ||
									sfulllabel(pcurno));
				changecontractparam('FixMPProfile' || slabel(pcurno)
								   ,'0'
								   ,'Use Minimum Payment profile regardless of delinquency state for ' ||
									sfulllabel(pcurno));
			
			ELSE
			
				vprofileid := contracttools.getvalidnumber(vaparams(1)
														  ,'Minimum payment profile ID'
														  ,contracttools.cnum_nonnegative);
			
				changecontractparam('MPProfile' || slabel(pcurno)
								   ,vprofileid
								   ,'Minimum Payment Calculation Profile for ' ||
									sfulllabel(pcurno));
			
				IF vaparams.exists(2)
				THEN
				
					CASE vaparams(2)
						WHEN 'OFF' THEN
							vforceprofile := 0;
						WHEN 'ON' THEN
							vforceprofile := 1;
						ELSE
							error.raiseerror('Error: unsupported MP profile use mode: <' ||
											 vaparams(2) || '>!');
					END CASE;
				
					changecontractparam('FixMPProfile' || slabel(pcurno)
									   ,vforceprofile
									   ,'Use Minimum Payment profile regardless of delinquency state for ' ||
										sfulllabel(pcurno));
				END IF;
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_setmpsettings;
	
		PROCEDURE int_setbillingcalendar(pparam IN contracttypeschema.typefschparam) IS
			cmethodname CONSTANT typemethodname := dochangecontractparams.cmethodname ||
												   '.Int_SetBillingCalendar';
			vcalendarid NUMBER;
		BEGIN
			t.enter(cmethodname, pparam.stringvalue);
		
			vaparams := contracttools.parsestring(pparam.stringvalue, '@', 1, 1);
		
			IF vaparams(1) = 'DEF'
			THEN
			
				setbillingcalendar(-1, cbatchparamchange);
			
			ELSE
			
				vcalendarid := contracttools.getvalidnumber(vaparams(1)
														   ,'Calendar ID'
														   ,contracttools.cnum_nonnegative);
			
				setbillingcalendar(vcalendarid, cbatchparamchange);
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_setbillingcalendar;
	
		PROCEDURE int_setinttoinstmode(pparam IN contracttypeschema.typefschparam) IS
			cmethodname CONSTANT typemethodname := dochangecontractparams.cmethodname ||
												   '.Int_SetIntToInstMode';
			vcurno NUMBER;
		BEGIN
			t.enter(cmethodname, pparam.stringvalue);
		
			vaparams := contracttools.parsestring(pparam.stringvalue, '@', 2, 2);
		
			vcurno := contracttools.getvalidnumber(vaparams(1)
												  ,'Currency number'
												  ,pallowedvalues => tblnumber(1, 2));
		
			contracttools.raiseif(NOT ifcurrencyisusedintype(vcurno, scontracttype)
								 ,'Currency <' || slabel(vcurno) ||
								  '> is not used in contract type <' || scontracttype || '>!');
		
			contracttools.raiseif(sactparamccy(vcurno) (cctp_inttoinston) = 0
								 ,'Interest to installment transfer mode cannot be changed as transfer is turned off in contract type!');
		
			changecontractparam('IntToInstOn' || slabel(vcurno)
							   ,contracttools.getvalidnumber(vaparams(2)
															,'Transfer mode'
															,pallowedvalues => tblnumber(0, 1)));
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_setinttoinstmode;
	
		PROCEDURE int_setovdperiodcalcmode(pparam IN contracttypeschema.typefschparam) IS
			cmethodname CONSTANT typemethodname := dochangecontractparams.cmethodname ||
												   '.Int_SetOvdPeriodCalcMode';
			vperiodfrom     VARCHAR2(20);
			vperiodto       VARCHAR2(20);
			vperiodfromdate DATE;
			vmode           VARCHAR2(10);
		BEGIN
			t.enter(cmethodname, pparam.stringvalue);
		
			vaparams := contracttools.parsestring(pparam.stringvalue, '@', 1, 3, 3);
		
			vmode := contracttools.getvalidchar(vaparams(1)
											   ,'Overdue period calculation mode'
											   ,pprohibitnull => FALSE
											   ,pallowedvalues => tblchar1000('DEF'
																			 ,covdcalc_normal
																			 ,covdcalc_frzwithrep
																			 ,covdcalc_frzworep));
		
			IF vmode IN (to_char(covdcalc_frzwithrep), to_char(covdcalc_frzworep))
			THEN
			
				vperiodfromdate := contracttools.getvaliddate(vaparams(2), 'Period from');
				vperiodfrom     := to_char(vperiodfromdate, contractparams.cparam_date_format);
				vperiodto       := to_char(contracttools.getvaliddate(vaparams(3)
																	 ,'Period to'
																	 ,pminvalue => vperiodfromdate)
										  ,contractparams.cparam_date_format);
			
			ELSE
				contracttools.raiseif(vaparams(2) IS NOT NULL
									 ,'"Period from" parameter is not required in this mode!');
				contracttools.raiseif(vaparams(3) IS NOT NULL
									 ,'"Period to" parameter is not required in this mode!');
			END IF;
		
			changecontractparam('OvdPeriodCalcMode', nullif(vmode, 'DEF'));
		
			changecontractparam('OvdPeriodDateFrom', vperiodfrom);
			changecontractparam('OvdPeriodDateTo', vperiodto);
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_setovdperiodcalcmode;
	
		PROCEDURE checklimitparamsconsistency
		(
			pobjectlimitsettings IN typeobjectlimitsettings
		   ,plimittype           IN PLS_INTEGER
		) IS
			cmethodname CONSTANT typemethodname := cpackagename || '.CheckLimitParamsConsistency';
			vcurrentlimitsettings typelimitsettings;
			vnewlimitsettings     typelimitsettings;
		BEGIN
			t.enter(cmethodname
				   ,'LimitType = ' || plimittype || ', CurNo = ' || pobjectlimitsettings.curno ||
					', Card = ' || masktodebug(pobjectlimitsettings.pan, pobjectlimitsettings.mbr));
		
			vnewlimitsettings := CASE plimittype
									 WHEN ccredlimit THEN
									  pobjectlimitsettings.credlimit
									 WHEN ccashlimit THEN
									  pobjectlimitsettings.cashlimit
									 WHEN ctempcredlimit THEN
									  pobjectlimitsettings.tempcredlimit
									 WHEN ctempcashlimit THEN
									  pobjectlimitsettings.tempcredlimit
								 END;
		
			s.say('Limit settings: CalcMethod = ' || vnewlimitsettings.calcmethod || ', Amount = ' ||
				  vnewlimitsettings.amount || ', Percentage = ' || vnewlimitsettings.percent ||
				  ', Valid from = ' || htools.d2s(vnewlimitsettings.validfrom) || ', Valid to = ' ||
				  vnewlimitsettings.validto);
		
			IF vnewlimitsettings.calcmethod = clmtdefined
			THEN
				contracttools.validatenumber(vnewlimitsettings.amount
											,'Amount'
											,contracttools.cnum_nonnegative
											,TRUE);
				contracttools.raiseif(vnewlimitsettings.percent IS NOT NULL
									 ,'Value for "Percentage" field must be empty!');
			
			ELSIF vnewlimitsettings.calcmethod IN (clmttotal, clmtmax, clmtmin)
			THEN
				contracttools.validatenumber(vnewlimitsettings.amount
											,'Amount'
											,contracttools.cnum_nonnegative
											,TRUE);
				contracttools.validatenumber(vnewlimitsettings.percent
											,'Percentage'
											,contracttools.cnum_nonnegative
											,TRUE
											,pminvalue                      => 0
											,pmaxvalue                      => 100);
			
			ELSIF vnewlimitsettings.calcmethod IN (clmtnotdefined, clmtnotused, clmtastype)
			THEN
				contracttools.raiseif(vnewlimitsettings.amount IS NOT NULL
									 ,'Value for "Amount" field must be empty!');
				contracttools.raiseif(vnewlimitsettings.percent IS NOT NULL
									 ,'Value for "Percentage" field must be empty!');
			ELSE
				error.raiseerror('Unknown limit calculation method!');
			END IF;
		
			IF (plimittype IN (ctempcredlimit, ctempcashlimit))
			   AND (vnewlimitsettings.calcmethod IN (clmtdefined, clmttotal, clmtmax, clmtmin))
			THEN
			
				IF pobjectlimitsettings.pan IS NULL
				THEN
				
					contracttools.validatedate(vnewlimitsettings.validfrom, 'Valid from');
				
					vcurrentlimitsettings := CASE plimittype
												 WHEN ctempcredlimit THEN
												  getobjectlimitssetup(scontractno, pobjectlimitsettings.curno)
												  .tempcredlimit
												 ELSE
												  getobjectlimitssetup(scontractno, pobjectlimitsettings.curno)
												  .tempcashlimit
											 END;
				
					contracttools.raiseif((vcurrentlimitsettings.active) AND
										  (vnewlimitsettings.validfrom <>
										  vcurrentlimitsettings.validfrom)
										 ,'Cannot change temporary limit start date to <' ||
										  htools.d2s(vnewlimitsettings.validfrom) ||
										  '> as limit already active since <' ||
										  htools.d2s(vcurrentlimitsettings.validfrom) || '>!');
				
				ELSE
					contracttools.raiseif(vnewlimitsettings.validfrom IS NOT NULL
										 ,'"Valid from" parameter is not supported for account-card link temporary limit!');
				END IF;
			
				contracttools.validatedate(vnewlimitsettings.validto, 'Valid to');
			
				IF pobjectlimitsettings.pan IS NULL
				THEN
				
					contracttools.raiseif(vnewlimitsettings.validto < vnewlimitsettings.validfrom
										 ,'Temporary limit end date <' ||
										  htools.d2s(vnewlimitsettings.validto) ||
										  '> can not be less than start date <' ||
										  htools.d2s(vnewlimitsettings.validfrom) || '>!');
				
					contracttools.raiseif(vnewlimitsettings.validto < coperdate
										 ,'Temporary limit end date <' ||
										  htools.d2s(vnewlimitsettings.validto) ||
										  '> can not be less than business date <' ||
										  htools.d2s(coperdate) || '>!');
				
				END IF;
			
			ELSE
				contracttools.raiseif(vnewlimitsettings.validfrom IS NOT NULL
									 ,'Value for "Valid from" field must be empty!');
				contracttools.raiseif(vnewlimitsettings.validto IS NOT NULL
									 ,'Value for "Valid to" field must be empty!');
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END checklimitparamsconsistency;
	
		PROCEDURE int_changeobjectlimit
		(
			plimittype        IN PLS_INTEGER
		   ,pisaccount        IN BOOLEAN
		   ,pminparamcount    IN NUMBER
		   ,pmaxparamcount    IN NUMBER
		   ,pparam            IN contracttypeschema.typefschparam
		   ,oneedupdatelimits IN OUT BOOLEAN
		) IS
			cmethodname CONSTANT typemethodname := dochangecontractparams.cmethodname ||
												   '.Int_ChangeObjectLimit';
			voldlimitsettings typeobjectlimitsettings;
			vnewlimitsettings typeobjectlimitsettings;
			vcheckscoring     BOOLEAN := FALSE;
			vdoonline         BOOLEAN;
			vcurno            NUMBER;
		BEGIN
			t.enter(cmethodname
				   ,'LimitType = ' || plimittype || ', IsAccount = ' || htools.b2s(pisaccount) ||
					', ParamString = ' || pparam.stringvalue);
		
			vaparams := contracttools.parsestring(pparam.stringvalue
												 ,'@'
												 ,pminparamcount
												 ,pmaxparamcount
												 ,pmaxparamcount);
		
			vcurno := contracttools.getvalidnumber(vaparams(1)
												  ,'Currency number'
												  ,pallowedvalues => tblnumber(1, 2));
		
			IF pisaccount
			THEN
			
				voldlimitsettings := getobjectlimitssetup(scontractno, vcurno);
				vnewlimitsettings := voldlimitsettings;
			
				CASE plimittype
				
					WHEN ccredlimit THEN
					
						vnewlimitsettings.credlimit.calcmethod := clmtdefined;
						vnewlimitsettings.credlimit.amount     := contracttools.getvalidnumber(vaparams(2)
																							  ,'Limit amount'
																							  ,contracttools.cnum_nonnegative);
						vcheckscoring                          := htools.i2b(contracttools.getvalidnumber(vaparams(3)
																										 ,'Scoring check'
																										 ,pwhatisnull => 1
																										 ,pallowedvalues => tblnumber(0
																																	 ,1)));
					
					WHEN ccashlimit THEN
					
						vnewlimitsettings.cashlimit.calcmethod := contracttools.getvalidnumber(vaparams(2)
																							  ,'Calculation method'
																							  ,pallowedvalues => tblnumber(clmtnotdefined
																														  ,clmttotal
																														  ,clmtmax
																														  ,clmtmin
																														  ,clmtastype));
						vnewlimitsettings.cashlimit.amount     := contracttools.getvalidnumber(vaparams(3)
																							  ,'Amount'
																							  ,contracttools.cnum_nonnegative
																							  ,pprohibitnull => FALSE);
						vnewlimitsettings.cashlimit.percent    := contracttools.getvalidnumber(vaparams(4)
																							  ,'Percentage'
																							  ,contracttools.cnum_nonnegative
																							  ,pprohibitnull => FALSE
																							  ,pmaxvalue => 100);
					
					WHEN ctempcredlimit THEN
					
						vnewlimitsettings.tempcredlimit.calcmethod := contracttools.getvalidnumber(vaparams(2)
																								  ,'Calculation method'
																								  ,pallowedvalues => tblnumber(clmtnotused
																															  ,clmtdefined));
						vnewlimitsettings.tempcredlimit.amount     := contracttools.getvalidnumber(vaparams(3)
																								  ,'Amount'
																								  ,contracttools.cnum_nonnegative
																								  ,pprohibitnull => FALSE);
						vnewlimitsettings.tempcredlimit.validfrom  := contracttools.getvaliddate(vaparams(4)
																								,'Valid from'
																								,pprohibitnull => FALSE
																								,pwhatisnull => CASE
																												 vnewlimitsettings.tempcredlimit.calcmethod
																													WHEN
																													 clmtdefined THEN
																													 coperdate
																												END);
						vnewlimitsettings.tempcredlimit.validto    := contracttools.getvaliddate(vaparams(5)
																								,'Valid to'
																								,pprohibitnull => FALSE);
					
					WHEN ctempcashlimit THEN
					
						vnewlimitsettings.tempcashlimit.calcmethod := contracttools.getvalidnumber(vaparams(2)
																								  ,'Calculation method'
																								  ,pallowedvalues => tblnumber(clmtnotused
																															  ,clmttotal
																															  ,clmtmax
																															  ,clmtmin));
						vnewlimitsettings.tempcashlimit.amount     := contracttools.getvalidnumber(vaparams(3)
																								  ,'Amount'
																								  ,contracttools.cnum_nonnegative
																								  ,pprohibitnull => FALSE);
						vnewlimitsettings.tempcashlimit.percent    := contracttools.getvalidnumber(vaparams(4)
																								  ,'Percentage'
																								  ,contracttools.cnum_nonnegative
																								  ,pprohibitnull => FALSE
																								  ,pmaxvalue => 100);
						vnewlimitsettings.tempcashlimit.validfrom  := contracttools.getvaliddate(vaparams(5)
																								,'Valid from'
																								,pprohibitnull => FALSE
																								,pwhatisnull => CASE
																												 vnewlimitsettings.tempcashlimit.calcmethod
																													WHEN
																													 clmtnotused THEN
																													 NULL
																													ELSE
																													 coperdate
																												END);
						vnewlimitsettings.tempcashlimit.validto    := contracttools.getvaliddate(vaparams(6)
																								,'Valid to'
																								,pprohibitnull => FALSE);
					
					ELSE
						error.raiseerror('Internal error: unknown limit type <' || plimittype || '>!');
				END CASE;
			
			ELSE
			
				voldlimitsettings := getobjectlimitssetup(scontractno
														 ,vcurno
														 ,vaparams(2)
														 ,vaparams(3));
				vnewlimitsettings := voldlimitsettings;
			
				CASE plimittype
				
					WHEN ccredlimit THEN
					
						vnewlimitsettings.credlimit.calcmethod := contracttools.getvalidnumber(vaparams(4)
																							  ,'Calculation method'
																							  ,pallowedvalues => tblnumber(clmtastype
																														  ,clmtnotdefined
																														  ,clmttotal
																														  ,clmtmax
																														  ,clmtmin));
						vnewlimitsettings.credlimit.amount     := contracttools.getvalidnumber(vaparams(5)
																							  ,'Amount'
																							  ,contracttools.cnum_nonnegative
																							  ,pprohibitnull => FALSE);
						vnewlimitsettings.credlimit.percent    := contracttools.getvalidnumber(vaparams(6)
																							  ,'Percentage'
																							  ,contracttools.cnum_nonnegative
																							  ,pprohibitnull => FALSE
																							  ,pmaxvalue => 100);
					
					WHEN ccashlimit THEN
					
						vnewlimitsettings.cashlimit.calcmethod := contracttools.getvalidnumber(vaparams(4)
																							  ,'Calculation method'
																							  ,pallowedvalues => tblnumber(clmtastype
																														  ,clmtnotdefined
																														  ,clmttotal
																														  ,clmtmax
																														  ,clmtmin));
						vnewlimitsettings.cashlimit.amount     := contracttools.getvalidnumber(vaparams(5)
																							  ,'Amount'
																							  ,contracttools.cnum_nonnegative
																							  ,pprohibitnull => FALSE);
						vnewlimitsettings.cashlimit.percent    := contracttools.getvalidnumber(vaparams(6)
																							  ,'Percentage'
																							  ,contracttools.cnum_nonnegative
																							  ,pprohibitnull => FALSE
																							  ,pmaxvalue => 100);
					
					WHEN ctempcredlimit THEN
					
						vnewlimitsettings.tempcredlimit.calcmethod := contracttools.getvalidnumber(vaparams(4)
																								  ,'Calculation method'
																								  ,pallowedvalues => tblnumber(clmtnotused
																															  ,clmttotal
																															  ,clmtmax
																															  ,clmtmin));
						vnewlimitsettings.tempcredlimit.amount     := contracttools.getvalidnumber(vaparams(5)
																								  ,'Amount'
																								  ,contracttools.cnum_nonnegative
																								  ,pprohibitnull => FALSE);
						vnewlimitsettings.tempcredlimit.percent    := contracttools.getvalidnumber(vaparams(6)
																								  ,'Percentage'
																								  ,contracttools.cnum_nonnegative
																								  ,pprohibitnull => FALSE
																								  ,pmaxvalue => 100);
					
						vnewlimitsettings.tempcredlimit.validfrom := contracttools.getvaliddate(vaparams(7)
																							   ,'Valid from'
																							   ,pprohibitnull => FALSE);
						vnewlimitsettings.tempcredlimit.validto   := contracttools.getvaliddate(vaparams(8)
																							   ,'Valid to'
																							   ,pprohibitnull => FALSE);
					
					WHEN ctempcashlimit THEN
					
						vnewlimitsettings.tempcashlimit.calcmethod := contracttools.getvalidnumber(vaparams(4)
																								  ,'Calculation method'
																								  ,pallowedvalues => tblnumber(clmtnotused
																															  ,clmttotal
																															  ,clmtmax
																															  ,clmtmin));
						vnewlimitsettings.tempcashlimit.amount     := contracttools.getvalidnumber(vaparams(5)
																								  ,'Amount'
																								  ,contracttools.cnum_nonnegative
																								  ,pprohibitnull => FALSE);
						vnewlimitsettings.tempcashlimit.percent    := contracttools.getvalidnumber(vaparams(6)
																								  ,'Percentage'
																								  ,contracttools.cnum_nonnegative
																								  ,pprohibitnull => FALSE
																								  ,pmaxvalue => 100);
					
						vnewlimitsettings.tempcredlimit.validfrom := contracttools.getvaliddate(vaparams(7)
																							   ,'Valid from'
																							   ,pprohibitnull => FALSE);
						vnewlimitsettings.tempcashlimit.validto   := contracttools.getvaliddate(vaparams(8)
																							   ,'Valid to'
																							   ,pprohibitnull => FALSE);
					
					ELSE
						error.raiseerror('Internal error: unknown limit type <' || plimittype || '>!');
				END CASE;
			
			END IF;
		
			vdoonline := htools.i2b(contracttools.getvalidnumber(vaparams(pmaxparamcount)
																,'Do online'
																,pwhatisnull => 0
																,pallowedvalues => tblnumber(0, 1)));
		
			checklimitparamsconsistency(vnewlimitsettings, plimittype);
		
			checkifobjectlimitcanbeset(vnewlimitsettings, cbatchparamchange);
		
			processobjecttemplimits(voldlimitsettings, vnewlimitsettings, cbatchparamchange);
		
			dlg_setobjectlimits_save(vnewlimitsettings
									,cbatchparamchange
									,vdoonline
									,vcheckscoring);
		
			oneedupdatelimits := TRUE;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_changeobjectlimit;
	
		PROCEDURE int_markforinstallmenttransfer(pparam IN contracttypeschema.typefschparam) IS
			cmethodname CONSTANT typemethodname := dochangecontractparams.cmethodname ||
												   '.Int_MarkForInstallmentTransfer';
		BEGIN
			t.enter(cmethodname, pparam.stringvalue);
		
			vaparams := contracttools.parsestring(pparam.stringvalue, '@', 5, 7, 7);
		
			sdummynum := markforinstallmenttransfer(vaparams(1)
												   ,vaparams(2)
												   ,vaparams(3)
												   ,vaparams(4)
												   ,vaparams(5)
												   ,vaparams(6)
												   ,vaparams(7));
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_markforinstallmenttransfer;
	
	BEGIN
		t.enter(cmethodname);
	
		FOR i IN 1 .. pfschparamlist.count
		LOOP
		
			CASE pfschparamlist(i).id
			
				WHEN 'CORP' THEN
					int_setcorporatecontract(pfschparamlist(i));
				
				WHEN 'NEXTSTMTDATE' THEN
					changecontractparam('NEXTSTMTDATE', pfschparamlist(i).stringvalue);
				
				WHEN 'OVDDATE1' THEN
					changecontractparam('DELDATE_1', pfschparamlist(i).stringvalue);
				
				WHEN 'OVDDATE2' THEN
					changecontractparam('DELDATE_2', pfschparamlist(i).stringvalue);
				
				WHEN 'DC_CASEOPEN' THEN
					contractrbstd.investigationon(scontractno);
				
				WHEN 'DC_DONTUSEAUTO' THEN
					changecontractparam('DC_USEAUTOCONDITION', '1');
				
				WHEN 'CONTRACTSTATE' THEN
					changecontractstate(pfschparamlist(i).stringvalue);
				
				WHEN 'CARDLOCKSTATUS' THEN
					IF pfschparamlist(i)
					 .stringvalue IN
						(ccrdstatset_default, ccrdstatset_never, ccrdstatset_open, ccrdstatset_auto)
					THEN
						changecontractparam('CardLock', pfschparamlist(i).stringvalue);
					END IF;
				
				WHEN 'ACCLOCKSTATUS' THEN
					IF pfschparamlist(i).stringvalue IN ('0', '1', '2', '3', '4')
					THEN
						changecontractparam('ChangeAccStatus', pfschparamlist(i).stringvalue);
					END IF;
				
				WHEN 'ZEROMPCYCLES' THEN
					IF pfschparamlist(i)
					 .stringvalue IN ('0', cmp0_count, cmp0_dontcount, cmp0_restart)
					THEN
						changecontractparam('ZeroMPCycles', pfschparamlist(i).stringvalue);
					END IF;
				
				WHEN 'USESHIELD' THEN
					IF pfschparamlist(i).stringvalue IN (ccs_default, ccs_charge, ccs_nocharge)
					THEN
						changecontractparam('UseShield', pfschparamlist(i).stringvalue);
					END IF;
				
				WHEN 'PBACCOUNT1' THEN
					int_setbalancetransfersettings(1, pfschparamlist(i));
				
				WHEN 'PBACCOUNT2' THEN
					int_setbalancetransfersettings(2, pfschparamlist(i));
				
				WHEN 'AUTOPAYACC1' THEN
					int_setautorepaymentsettings(1, pfschparamlist(i));
				
				WHEN 'AUTOPAYACC2' THEN
					int_setautorepaymentsettings(2, pfschparamlist(i));
				
				WHEN 'DAF_GEN' THEN
					int_setdafgenmode(pfschparamlist(i));
				
				WHEN 'DAF1' THEN
					int_setdafparams(1, pfschparamlist(i));
				
				WHEN 'DAF2' THEN
					int_setdafparams(2, pfschparamlist(i));
				
				WHEN 'ICP1' THEN
					int_setintsettings(1, pfschparamlist(i));
				
				WHEN 'ICP2' THEN
					int_setintsettings(2, pfschparamlist(i));
				
				WHEN 'MPP1' THEN
					int_setmpsettings(1, pfschparamlist(i));
				
				WHEN 'MPP2' THEN
					int_setmpsettings(2, pfschparamlist(i));
				
				WHEN 'COV' THEN
					contractrbstd.createcoverage(scontractno
												,contracttypeschema.scontractrow.idclient
												,pfschparamlist(i).stringvalue);
				
				WHEN 'COVDEL' THEN
					loancoverage.deletecoverage(pfschparamlist(i).stringvalue);
				
				WHEN 'MOVEINT1' THEN
					moveinterest(1, pfschparamlist(i).stringvalue);
				
				WHEN 'MOVEINT2' THEN
					moveinterest(2, pfschparamlist(i).stringvalue);
				
				WHEN 'BILLCYCLECLNDR' THEN
					int_setbillingcalendar(pfschparamlist(i));
				
				WHEN 'INTTOINST' THEN
					int_setinttoinstmode(pfschparamlist(i));
				
				WHEN 'OVDPERIODCALCMODE' THEN
					int_setovdperiodcalcmode(pfschparamlist(i));
				
				WHEN 'CONTRACT_ID' THEN
					NULL;
				
				WHEN 'ACC_CREDLMT' THEN
					int_changeobjectlimit(ccredlimit
										 ,TRUE
										 ,2
										 ,4
										 ,pfschparamlist(i)
										 ,vneedupdatelimits);
				
				WHEN 'ACC_CASHLMT' THEN
					int_changeobjectlimit(ccashlimit
										 ,TRUE
										 ,2
										 ,5
										 ,pfschparamlist(i)
										 ,vneedupdatelimits);
				
				WHEN 'ACC_CREDTEMPLMT' THEN
					int_changeobjectlimit(ctempcredlimit
										 ,TRUE
										 ,2
										 ,6
										 ,pfschparamlist(i)
										 ,vneedupdatelimits);
				
				WHEN 'ACC_CASHTEMPLMT' THEN
					int_changeobjectlimit(ctempcashlimit
										 ,TRUE
										 ,2
										 ,7
										 ,pfschparamlist(i)
										 ,vneedupdatelimits);
				
				WHEN 'CARD_CREDLMT' THEN
					int_changeobjectlimit(ccredlimit
										 ,FALSE
										 ,4
										 ,7
										 ,pfschparamlist(i)
										 ,vneedupdatelimits);
				
				WHEN 'CARD_CASHLMT' THEN
					int_changeobjectlimit(ccashlimit
										 ,FALSE
										 ,4
										 ,7
										 ,pfschparamlist(i)
										 ,vneedupdatelimits);
				
				WHEN 'CARD_CREDTEMPLMT' THEN
					int_changeobjectlimit(ctempcredlimit
										 ,FALSE
										 ,4
										 ,9
										 ,pfschparamlist(i)
										 ,vneedupdatelimits);
				
				WHEN 'CARD_CASHTEMPLMT' THEN
					int_changeobjectlimit(ctempcashlimit
										 ,FALSE
										 ,4
										 ,9
										 ,pfschparamlist(i)
										 ,vneedupdatelimits);
				
				WHEN 'TRANSFER' THEN
					int_markforinstallmenttransfer(pfschparamlist(i));
				
				ELSE
					error.raiseerror('Parameter <' || pfschparamlist(i).id ||
									 '> is not supported by schema!');
				
			END CASE;
		
		END LOOP;
	
		IF vneedupdatelimits
		THEN
			updateallobjectslimitsintwcms(cbatchparamchange);
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dochangecontractparams;

	PROCEDURE changecontractparams
	(
		pcontractno    IN typecontractno
	   ,pcontracttype  IN typecontracttype
	   ,pfschparamlist IN contracttypeschema.typefschparamlist
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ChangeContractParams [OMS]';
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		initcontract(pcontractno);
	
		startoperation;
	
		dochangecontractparams(pfschparamlist);
	
		setoperationrollbackdata;
	
		scontrattrcalcflag.delete;
		clearcontrtypecache;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END changecontractparams;

	FUNCTION changecontractparams RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ChangeContractParams [batch]';
	BEGIN
		t.enter(cmethodname, contract.sparams);
	
		changecontractparams(contracttypeschema.scontractrow.no
							,contracttypeschema.scontractrow.type
							,contracttools.paramstringtolist(contract.sparams));
	
		t.leave(cmethodname);
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END changecontractparams;

	FUNCTION setdefaultvalues RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SetDefaultValues';
		vlimitsetuprecord typeobjectlimitsettings;
	BEGIN
		t.enter(cmethodname);
	
		sprofileid := smainprofile;
	
		FOR i IN 1 .. 2
		LOOP
		
			IF ifcurrencyisusedintype(i
									 ,contracttypeschema.scontractrow.type
									 ,contracttypeschema.scontractrow.no)
			THEN
			
				IF sdepaccount(i).accountno IS NULL
				THEN
					contracttools.createaccountbycode(contracttypeschema.scontractrow
													 ,sdepaccount(i)
													 ,c_dorollback);
				END IF;
			
				vlimitsetuprecord := getobjectlimitssetup(contracttypeschema.scontractrow.no, i);
			
				IF sactparamccy(i) (cctp_acccredlimitmin) IS NOT NULL
				THEN
					vlimitsetuprecord.credlimit.amount := sactparamccy(i) (cctp_acccredlimitmin);
				END IF;
			
				dml_limitsetup_updaterecord(vlimitsetuprecord, ccontractcreation);
			
				updateallobjectslimitsintwcms(ccontractcreation);
			
			ELSIF sdepaccount(i).accountno IS NOT NULL
			THEN
				error.raiseerror('Cannot use account <' || sdepaccount(i).accountno || '> for ' ||
								 slabel(i) ||
								 ' currency, as it is not used in contract type settings!');
			END IF;
		
		END LOOP;
	
		sdummynum := createnextcycle(NULL
									,NULL
									,contractcalendar.getnextstatementdate(getbillingcyclecalendar
																		  ,seance.getoperdate - 1)
									,NULL
									,NULL);
	
		registernewstate(scontrtype_cache(scontracttype).defaultriskgroup
						,sblockparam.period
						,sblockparam.overlimit
						,0
						,sactparam(cctp_overdueamountcurr)
						,ccontractcreation);
	
		IF contract.sparams IS NOT NULL
		THEN
			dochangecontractparams(contracttools.paramstringtolist(contract.sparams));
		END IF;
	
		t.leave(cmethodname);
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END setdefaultvalues;

	PROCEDURE drawcardclosemodecomponent
	(
		pdialog   IN NUMBER
	   ,pitemname IN typeitemname
	   ,px        IN NUMBER
	   ,py        IN NUMBER
	   ,pwidth    IN NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.DrawCardCloseModeComponent';
	BEGIN
		dlg_tools.makedroplist(pdialog
							  ,pitemname
							  ,px
							  ,py
							  ,pwidth
							  ,pwidth
							  ,'Close cards:'
							  ,'What cards should be closed');
		dialog.listaddrecord(pdialog
							,pitemname
							,contractrbstd.cclose_openedcards || '~Opened only');
		dialog.listaddrecord(pdialog, pitemname, contractrbstd.cclose_allcards || '~Any');
		dialog.listaddrecord(pdialog, pitemname, contractrbstd.cclose_none || '~None');
		dlg_tools.setdroplistvalue(pdialog, pitemname, sclosecardsmode);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END drawcardclosemodecomponent;

	FUNCTION dlg_schemaparams_create RETURN NUMBER IS
		cmethodname  CONSTANT typemethodname := cpackagename || '.Dlg_SchemaParams_Create';
		chandlername CONSTANT typemethodname := cpackagename || '.Dlg_SchemaParams_Handler';
	
		cdialogwidth  CONSTANT NUMBER := 72;
		cdialogheight CONSTANT NUMBER := 14;
	
		cpagewidth  CONSTANT NUMBER := cdialogwidth - 1;
		cpageheight CONSTANT NUMBER := cdialogheight - 4;
	
		vdialog NUMBER;
		vpage   NUMBER;
	
		vmenu    NUMBER;
		vsubmenu NUMBER;
	
		PROCEDURE makepage_common(ppage IN NUMBER) IS
			cmethodname CONSTANT typemethodname := dlg_schemaparams_create.cmethodname ||
												   '.MakePage_Common';
		BEGIN
			t.enter(cmethodname);
		
			dialog.bevel(ppage, 1, 1, cpagewidth - 1, 8, dialog.bevel_frame);
		
			dialog.inputcheck(ppage
							 ,'AutoUnstick'
							 ,3
							 ,2
							 ,42
							 ,'Automatically unstick contract state if it is unsticked in the state dictionary'
							 ,'Unstick contract state automatically');
			dialog.putbool(ppage, 'AutoUnstick', sautounstick);
		
			dialog.inputcheck(ppage
							 ,'CrdStsAutoUnstick'
							 ,3
							 ,3
							 ,42
							 ,'Automatically card status unsticking if it is unsticked in the state dictionary'
							 ,'Unstick card status automatically');
			dialog.putbool(ppage, 'CrdStsAutoUnstick', scrdstsautounstick);
		
			dialog.inputcheck(ppage
							 ,'PaidToInst'
							 ,3
							 ,4
							 ,42
							 ,'Transfer paid transactions to installments'
							 ,'Transfer paid transactions to installments');
			dialog.putbool(ppage, 'PaidToInst', spaidtoinst);
		
			dialog.inputcheck(ppage
							 ,'DontCheckData'
							 ,3
							 ,5
							 ,42
							 ,'Do not check data integrity during contract adjustment'
							 ,'Switch data integrity check off');
			dialog.putbool(ppage, 'DontCheckData', sdontcheckdata);
		
			dialog.inputcheck(ppage
							 ,'UseReversalEnt'
							 ,3
							 ,6
							 ,55
							 ,'Use reversal entries to pay for the original ones first'
							 ,'Use reversal entries to pay for');
			dialog.putbool(ppage, 'UseReversalEnt', susereversalent);
		
			dialog.inputcheck(ppage
							 ,'UpdateSD'
							 ,3
							 ,7
							 ,55
							 ,'Update cycle next statement date on billing cycled calendar change'
							 ,'Update next statement date on calendar change');
			dialog.putbool(ppage, 'UpdateSD', supdatesd);
		
			dialog.inputcheck(ppage
							 ,'SubstAccOnExtract'
							 ,3
							 ,8
							 ,42
							 ,'Account selection in accordance with transaction amount currency'
							 ,'Use RCM rules on account selection');
			dialog.putbool(ppage, 'SubstAccOnExtract', ssubstacconextract);
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makepage_common;
	
		PROCEDURE makepage_closure(ppage IN NUMBER) IS
			cmethodname CONSTANT typemethodname := dlg_schemaparams_create.cmethodname ||
												   '.MakePage_Closure';
		BEGIN
			t.enter(cmethodname);
		
			dlg_tools.drawnestedbevel(ppage, 1, 1, cpagewidth - 1, 6);
		
			objectentrycode.makeitem(ppage
									,citem_repaymententry
									,20
									,2
									,22
									,'Repayment entry:'
									,'Select entry code for debt repayment'
									,22);
			objectentrycode.filllist(ppage
									,citem_repaymententry
									,contractparams.cuserobject
									,NULL
									,pcode => referenceentry.getcode(scloserepaymententry));
		
			objectentrycode.makeitem(ppage
									,citem_payoutentry
									,20
									,3
									,22
									,'Pay-out entry:'
									,'Select entry code for positive balance pay-out'
									,22);
			objectentrycode.filllist(ppage
									,citem_payoutentry
									,contractparams.cuserobject
									,NULL
									,pcode => referenceentry.getcode(sclosepayoutentry));
		
			dlg_tools.drawnestedbevel(ppage, 1, 4, cpagewidth - 1, 6);
		
			drawcardclosemodecomponent(ppage, citem_cardstoclose, 20, 5, 22);
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makepage_closure;
	
		PROCEDURE makepage_other(ppage IN NUMBER) IS
			cmethodname CONSTANT typemethodname := dlg_schemaparams_create.cmethodname ||
												   '.MakePage_Other';
		BEGIN
			t.enter(cmethodname);
		
			dlg_tools.drawnestedbevel(ppage, 1, 1, cpagewidth - 1, 7);
		
			dlg_tools.makedroplist(ppage
								  ,'UsePrcAcc'
								  ,24
								  ,2
								  ,42
								  ,42
								  ,'Accumulate interest:'
								  ,'Interest accumulation mode (account)');
			dialog.listaddrecord(ppage
								,'UsePrcAcc'
								,cintaccmode_donotaccumulate || '~Do not accumulate');
			dialog.listaddrecord(ppage
								,'UsePrcAcc'
								,cintaccmode_bankincomeacc || '~Using bank income account');
			dialog.listaddrecord(ppage
								,'UsePrcAcc'
								,cintaccmode_intaccbalance ||
								 '~Using bank accumulate account (balance)');
			dialog.listaddrecord(ppage
								,'UsePrcAcc'
								,cintaccmode_intacctechnical ||
								 '~Using bank accumulate account (technical)');
			dlg_tools.setdroplistvalue(ppage, 'UsePrcAcc', saccumintaccmode);
		
			dlg_tools.drawnestedbevel(ppage, 1, 3, cpagewidth - 1, 7);
		
			dialog.inputcheck(ppage
							 ,'FillAlwdOvlAttr'
							 ,3
							 ,4
							 ,23
							 ,'Fill certain account attribute with allowed overlimit value during refresh procedure'
							 ,'Fill account attribute');
			dialog.setitempost(ppage, 'FillAlwdOvlAttr', chandlername);
			dialog.putbool(ppage, 'FillAlwdOvlAttr', sfillalwdovlattr);
		
			dialog.inputchar(ppage
							,'AlwdOvlAttrName'
							,28
							,4
							,15
							,'ID of the account attribute to be filled with allowed overlimit value');
			dialog.putchar(ppage, 'AlwdOvlAttrName', salwdovlattrname);
			dialog.statictext(ppage, 45, 4, 'with allowed overlimit');
		
			dlg_tools.drawnestedbevel(ppage, 1, 5, cpagewidth - 1, 7);
		
			objectentrycode.makeel_profileitem(ppage
											  ,'PosBalanceBlackList'
											  ,contractparams.cschema
											  ,cpackagename
											  ,39
											  ,6
											  ,27
											  ,'Positive balance entries blacklist:'
											  ,'List of entries, which cannot change card account balance to positive');
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makepage_other;
	
	BEGIN
		t.enter(cmethodname);
	
		vdialog := dialog.new(custom_contractschemas.makedialogcaption(cpackagename
																	  ,custom_contractschemas.c_cap_schparams)
							 ,0
							 ,0
							 ,cdialogwidth
							 ,cdialogheight
							 ,pextid => cmethodname);
	
		vmenu    := dialog.menu(vdialog);
		vsubmenu := dialog.submenu(vmenu, 'Dictionaries', 'Dictionaries');
	
		objectentrycode.add_mnu_ref_elprofiles(vdialog, vsubmenu);
	
		dialog.pagelist(vdialog, 'PageList', 1, 1, cpagewidth, cpageheight);
	
		vpage := dialog.page(vdialog, 'PageList', 'Common options');
		makepage_common(vpage);
	
		vpage := dialog.page(vdialog, 'PageList', 'Contract closure');
		makepage_closure(vpage);
	
		vpage := dialog.page(vdialog, 'PageList', 'Other');
		makepage_other(vpage);
	
		dlg_tools.startbuttondrawing(cdialogwidth, 2);
		dlg_tools.drawbutton(vdialog
							,cbtn_ok
							,'OK'
							,'Save changes and exit dialog'
							,cdialogheight - 2
							,dialog.cmok
							,pdefault => TRUE);
		dlg_tools.drawbutton(vdialog
							,cbtn_cancel
							,'Cancel'
							,'Cancel changes and exit dialog'
							,cdialogheight - 2
							,dialog.cmcancel);
	
		dialog.setdialogvalid(vdialog, chandlername);
	
		dlg_schemaparams_handler(dialog.wt_itempost, vdialog, upper('FillAlwdOvlAttr'), 0);
	
		t.leave(cmethodname);
		RETURN vdialog;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			dialog.destroy(vdialog);
			error.save(cmethodname);
			RAISE;
	END dlg_schemaparams_create;

	PROCEDURE dlg_schemaparams_save(pdialog IN NUMBER) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_SchemaParams_Save';
	
		vschemaid NUMBER;
	
		PROCEDURE logchanges
		(
			pparamname IN VARCHAR2
		   ,poldvalue  IN VARCHAR2
		   ,pnewvalue  IN VARCHAR2
		) IS
			cmethodname CONSTANT typemethodname := dlg_schemaparams_save.cmethodname ||
												   '.LogChanges';
		BEGIN
			t.enter(cmethodname);
		
			a4mlog.cleanparamlist;
			a4mlog.addparamrec(pparamname, poldvalue, pnewvalue);
			a4mlog.logobject(object.gettype(custom_contractschemas.object_name)
							,vschemaid
							,'"' || pparamname || '" parameter was changed'
							,a4mlog.act_change
							,a4mlog.putparamlist);
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END logchanges;
	
		PROCEDURE savebool
		(
			ovalue     IN OUT BOOLEAN
		   ,pitemname  IN typeitemname
		   ,pparamname IN VARCHAR2
		) IS
			cmethodname CONSTANT typemethodname := dlg_schemaparams_save.cmethodname || '.SaveBool';
			voldvalue BOOLEAN := ovalue;
		BEGIN
			t.enter(cmethodname, pitemname);
		
			ovalue := contractparams.savedialogbool(pdialog
												   ,pitemname
												   ,contractparams.cschema
												   ,cpackagename);
			IF ovalue <> voldvalue
			THEN
				logchanges(pparamname, htools.b2i(voldvalue), htools.b2i(ovalue));
			END IF;
		
			t.leave(cmethodname, htools.b2s(ovalue));
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END savebool;
	
		PROCEDURE savelistfieldnumber
		(
			ovalue     IN OUT NUMBER
		   ,pitemname  IN typeitemname
		   ,pparamname IN VARCHAR2
		   ,pisnull    IN BOOLEAN := FALSE
		   ,pidfield   IN VARCHAR2 := 'ItemId'
		) IS
			cmethodname CONSTANT typemethodname := dlg_schemaparams_save.cmethodname ||
												   '.SaveListFieldNumber';
			voldvalue NUMBER := ovalue;
		BEGIN
			t.enter(cmethodname, pitemname);
		
			ovalue := contractparams.savedialogfieldnumber(pdialog
														  ,pitemname
														  ,contractparams.cschema
														  ,cpackagename
														  ,pisnull
														  ,pidfield);
			IF ovalue <> voldvalue
			THEN
				logchanges(pparamname, voldvalue, ovalue);
			END IF;
		
			t.leave(cmethodname, ovalue);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END savelistfieldnumber;
	
		PROCEDURE savechar
		(
			povalue    IN OUT NOCOPY VARCHAR2
		   ,pitemname  IN typeitemname
		   ,pparamname IN VARCHAR2
		) IS
			cmethodname CONSTANT typemethodname := dlg_schemaparams_save.cmethodname || '.SaveChar';
			voldvalue VARCHAR2(200) := povalue;
		BEGIN
			t.enter(cmethodname, pitemname);
		
			povalue := contractparams.savedialogchar(pdialog
													,pitemname
													,contractparams.cschema
													,cpackagename);
			IF povalue <> voldvalue
			THEN
				logchanges(pparamname, voldvalue, povalue);
			END IF;
		
			t.leave(cmethodname, povalue);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END savechar;
	
		PROCEDURE saveentryident
		(
			povalue    IN OUT NOCOPY typeentryident
		   ,pitemname  IN typeitemname
		   ,pparamkey  IN VARCHAR2
		   ,pparamname IN VARCHAR2
		) IS
			cmethodname CONSTANT typemethodname := dlg_schemaparams_save.cmethodname ||
												   '.SaveEntryIdent';
			voldvalue typeentryident := povalue;
		BEGIN
			t.enter(cmethodname);
		
			povalue := objectentrycode.getitemident(pdialog, pitemname);
			contractparams.savechar(contractparams.cschema, cpackagename, pparamkey, povalue);
			IF povalue <> voldvalue
			THEN
				logchanges(pparamname, voldvalue, povalue);
			END IF;
		
			t.leave(cmethodname, povalue);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END saveentryident;
	
	BEGIN
		t.enter(cmethodname, pdialog);
	
		vschemaid := custom_contractschemas.getrecord(cpackagename).type;
	
		SAVEPOINT sp_saveschemaparameters;
	
		savebool(sautounstick, 'AutoUnstick', 'Unstick contract state');
		savebool(scrdstsautounstick, 'CrdStsAutoUnstick', 'Unstick card status');
		savebool(spaidtoinst, 'PaidToInst', 'Transfer unpaid trxns to installment');
		savebool(sdontcheckdata, 'DontCheckData', 'Switch data integrity check off');
		savebool(susereversalent, 'UseReversalEnt', 'Use reverse to repay initial trxns');
		savebool(supdatesd, 'UpdateSD', 'Update next statement date on calendar change');
		savebool(ssubstacconextract, 'SubstAccOnExtract', 'Use RCM rules on account selection');
	
		saveentryident(scloserepaymententry
					  ,citem_repaymententry
					  ,'CloseRepaymentEntry'
					  ,'Closing repayment entry');
		saveentryident(sclosepayoutentry
					  ,citem_payoutentry
					  ,'ClosePayOutEntry'
					  ,'Closing pay-out entry');
		savelistfieldnumber(sclosecardsmode, citem_cardstoclose, 'Cards close mode');
	
		savelistfieldnumber(saccumintaccmode, 'UsePrcAcc', 'Interest accumulation mode');
		savebool(sfillalwdovlattr
				,'FillAlwdOvlAttr'
				,'Fill account attribute with allowed overlimit value');
		IF sfillalwdovlattr
		THEN
			savechar(salwdovlattrname
					,'AlwdOvlAttrName'
					,'Allowed overlimit account user attribute name');
		END IF;
		savelistfieldnumber(sposbalanceblacklist
						   ,'PosBalanceBlackList'
						   ,'Positive balance entries blacklist'
						   ,TRUE
						   ,'val');
	
		COMMIT;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
		
			ROLLBACK TO sp_saveschemaparameters;
		
			loadallschemaparams;
			error.save(cmethodname);
			RAISE;
	END dlg_schemaparams_save;

	FUNCTION dlg_schemaparams_validate(pdialog IN NUMBER) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_SchemaParams_Validate';
	BEGIN
		t.enter(cmethodname);
	
		IF dialog.getbool(pdialog, 'FillAlwdOvlAttr')
		THEN
			dlg_tools.validatechar(pdialog, 'AlwdOvlAttrName', 'Attribute name');
		END IF;
	
		t.leave(cmethodname);
		RETURN TRUE;
	EXCEPTION
		WHEN dlg_tools.validate_error THEN
			t.exc(cmethodname);
			RETURN FALSE;
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_schemaparams_validate;

	PROCEDURE dlg_schemaparams_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_SchemaParams_Handler';
	BEGIN
		t.enter(cmethodname
			   ,'What = ' || pwhat || ', Dialog = ' || pdialog || ', ItemName = ' || pitemname ||
				', Cmd = ' || pcmd);
	
		CASE pwhat
		
			WHEN dialog.wt_itempost THEN
				IF pitemname = upper('FillAlwdOvlAttr')
				THEN
					dialog.setenable(pdialog
									,'AlwdOvlAttrName'
									,dialog.getbool(pdialog, 'FillAlwdOvlAttr'));
				END IF;
			
			WHEN dialog.wt_dialogvalid THEN
				IF pcmd = dialog.cmok
				   AND dlg_schemaparams_validate(pdialog)
				THEN
				
					dialog.putchar(pdialog
								  ,'AlwdOvlAttrName'
								  ,upper(dialog.getchar(pdialog, 'AlwdOvlAttrName')));
					dlg_schemaparams_save(pdialog);
				END IF;
			
			ELSE
				NULL;
		END CASE;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_schemaparams_handler;

	FUNCTION getschemaparametersdialog(pcanmodify IN BOOLEAN) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetSchemaParametersDialog';
	BEGIN
		RETURN dlg_schemaparams_create;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getschemaparametersdialog;

	FUNCTION dlg_typeparams_create(pcontracttype IN NUMBER) RETURN NUMBER IS
		cmethodname  CONSTANT typemethodname := cpackagename || '.Dlg_TypeParams_Create';
		chandlername CONSTANT typemethodname := cpackagename || '.Dlg_TypeParams_Handler';
	
		creadonly_ref CONSTANT BOOLEAN := scurright_reference = c_canview;
		creadonly_dlg CONSTANT BOOLEAN := scurright_contype = c_canview;
	
		cpagername CONSTANT typeitemname := 'PAGER';
	
		cdialogwidth  CONSTANT NUMBER := 81;
		cdialogheight CONSTANT NUMBER := 24;
	
		vdialog NUMBER;
	
		v1stlvlpage NUMBER;
		v2ndlvlpage NUMBER;
		v3rdlvlpage NUMBER;
	
		vmenu    NUMBER;
		vsubmenu NUMBER;
	
		vaspecificrules contractcollection.typestandardspecificrulearray;
		vacommonrules   contractcollection.typestandardcommonrulearray;
	
		vpanel   NUMBER;
		vpanel8  NUMBER;
		vpanel81 NUMBER;
	
		FUNCTION makepage
		(
			pdialog    IN NUMBER
		   ,ppagetitle IN VARCHAR2
		   ,ppagename  IN VARCHAR2
		) RETURN NUMBER IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_create.cmethodname || '.MakePage';
			cpagename   CONSTANT VARCHAR2(100) := upper(ppagename);
		
			vprevlevel  VARCHAR2(100);
			vleveltoadd VARCHAR2(100);
			vresult     NUMBER;
		
		BEGIN
			t.enter(cmethodname);
		
			vprevlevel := dialog.getaddinfo(pdialog);
			t.var('vPrevLevel', vprevlevel);
		
			vleveltoadd := nullif('_' || vprevlevel, '_');
			t.var('vLevelToAdd', vleveltoadd);
		
			vresult := dialog.page(pdialog
								  ,cpagername || vleveltoadd
								  ,ppagetitle
								  ,'PG' || vleveltoadd || '_' || cpagename);
		
			dialog.setaddinfo(vresult, nullif(vprevlevel || '_', '_') || cpagename);
			t.var('Saved page name', nullif(vprevlevel || '_', '_') || cpagename);
		
			t.leave(cmethodname);
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makepage;
	
		FUNCTION makepage
		(
			pdialog    IN NUMBER
		   ,ppagetitle IN VARCHAR2
		   ,ppagename  IN VARCHAR2
		   ,px         IN NUMBER
		   ,py         IN NUMBER
		   ,pwidth     IN NUMBER
		   ,pheight    IN NUMBER
		) RETURN NUMBER IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_create.cmethodname || '.MakePage';
			cpagename   CONSTANT VARCHAR2(100) := upper(ppagename);
			vresult NUMBER;
		BEGIN
			vresult := makepage(pdialog, ppagetitle, cpagename);
			dialog.pagelist(vresult
						   ,cpagername || nullif('_' || dialog.getaddinfo(pdialog), '_') || '_' ||
							cpagename
						   ,px
						   ,py
						   ,pwidth
						   ,pheight);
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makepage;
	
		PROCEDURE makeaccountinputfield
		(
			pdialog      IN NUMBER
		   ,pitemname    IN typeitemname
		   ,px           IN NUMBER
		   ,py           IN NUMBER
		   ,pcaption     IN VARCHAR2
		   ,phint        IN VARCHAR2
		   ,phandlername IN typemethodname
		) IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_create.cmethodname ||
												   '.MakeAccountInputField';
		BEGIN
			dialog.inputchar(pdialog, pitemname, px, py, 20, phint, 20, pcaption);
			dialog.setitempre(pdialog, pitemname, phandlername);
			contractparams.loaddialogchar(pdialog
										 ,pitemname
										 ,contractparams.ccontracttype
										 ,scontracttype);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makeaccountinputfield;
	
		PROCEDURE makepage_common(pdialog IN NUMBER) IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_create.cmethodname ||
												   '.MakePage_Common';
		BEGIN
			t.enter(cmethodname);
		
			v1stlvlpage := makepage(pdialog, 'Common', 'COMMON');
		
			dialog.bevel(v1stlvlpage, 1, 1, 78, 4, dialog.bevel_frame);
		
			makecheckbox(v1stlvlpage
						,'CorpMode'
						,24
						,2
						,'Use corporate operation mode'
						,'Use corporate operation mode'
						,chandlername);
		
			contractcalendar.dropbox_calendar_create(v1stlvlpage
													,'CalendarID'
													,24
													,3
													,50
													,'Cycles Calendar:'
													,'Billing cycles calendar'
													,contractparams.ccontracttype
													,scontracttype);
		
			dialog.inputchar(v1stlvlpage
							,'ExchangeRate'
							,24
							,4
							,50
							,'Currency Exchange Rate'
							,pcaption => 'Exchange Rate:');
			dialog.listaddfield(v1stlvlpage, 'ExchangeRate', 'ItemFlag', 'C', 1, 0);
			dialog.listaddfield(v1stlvlpage, 'ExchangeRate', 'ItemID', 'N', 5, 0);
			dialog.listaddfield(v1stlvlpage, 'ExchangeRate', 'ItemName', 'C', 40, 1);
			dialog.setreadonly(v1stlvlpage, 'ExchangeRate', TRUE);
			contracttools.fillexchangelist(v1stlvlpage, 'ExchangeRate', NULL);
			contractparams.loaddialogfieldnumber(v1stlvlpage
												,'ExchangeRate'
												,contractparams.ccontracttype
												,scontracttype
												,pdefaultvalue => NULL);
		
			contractlink.contracttypeitem(contractlink.clink
										 ,scontracttype
										 ,slinkschemas
										 ,contractlink.csingle2multiple
										 ,v1stlvlpage
										 ,'LINK'
										 ,1
										 ,5
										 ,78
										 ,5
										 ,'Corporate contract type'
										 ,'Corporate contract type'
										 ,preadonly => creadonly_dlg);
		
			dialog.bevel(v1stlvlpage
						,1
						,10
						,78
						,9
						,dialog.bevel_frame
						,pcaption => 'Accounts Usage and Calculation Setup');
		
			makecheckbox(v1stlvlpage
						,'UseCurDOM'
						,24
						,11
						,'Use Domestic Currency Account'
						,'Use Domestic Currency Account'
						,chandlername);
		
			custom_contractprofiles.makeitem(v1stlvlpage
											,'ProfileDOM'
											,24
											,12
											,50
											,'Calculation Profile:'
											,'Domestic Currency Interest Profile');
			custom_contractprofiles.fillitem(v1stlvlpage
											,'ProfileDOM'
											,getcurrency(scontracttype, 'ItemDepositDOM'));
			contractparams.loaddialogfieldnumber(v1stlvlpage
												,'ProfileDOM'
												,contractparams.ccontracttype
												,scontracttype
												,pdefaultvalue => NULL);
		
			custom_contractprofiles.makeitem(v1stlvlpage
											,'MPProfileDOM'
											,24
											,13
											,50
											,'MP Profile:'
											,'Domestic Currency Minimum Payment Profile');
			custom_contractprofiles.fillitem(v1stlvlpage, 'MPProfileDOM', NULL, pmpprofile => TRUE);
			contractparams.loaddialogfieldnumber(v1stlvlpage
												,'MPProfileDOM'
												,contractparams.ccontracttype
												,scontracttype
												,pdefaultvalue => NULL);
		
			makecheckbox(v1stlvlpage
						,'UseCurINT'
						,24
						,14
						,'Use International Currency Account'
						,'Use International Currency Account'
						,chandlername);
		
			custom_contractprofiles.makeitem(v1stlvlpage
											,'ProfileINT'
											,24
											,15
											,50
											,'Calculation Profile:'
											,'International Currency Interest Profile');
			custom_contractprofiles.fillitem(v1stlvlpage
											,'ProfileINT'
											,getcurrency(scontracttype, 'ItemDepositINT'));
			contractparams.loaddialogfieldnumber(v1stlvlpage
												,'ProfileINT'
												,contractparams.ccontracttype
												,scontracttype
												,pdefaultvalue => NULL);
		
			custom_contractprofiles.makeitem(v1stlvlpage
											,'MPProfileINT'
											,24
											,16
											,50
											,'MP Profile:'
											,'International Currency Minimum Payment Profile');
			custom_contractprofiles.fillitem(v1stlvlpage, 'MPProfileINT', NULL, pmpprofile => TRUE);
			contractparams.loaddialogfieldnumber(v1stlvlpage
												,'MPProfileINT'
												,contractparams.ccontracttype
												,scontracttype
												,pdefaultvalue => NULL);
		
			makecheckbox(v1stlvlpage
						,'SwitchFromDualToOneCur'
						,24
						,17
						,'Post all transactions on card account only'
						,'Post all transactions on card account only. Used for aggregated limit only');
		
			makecheckbox(v1stlvlpage
						,'IntLog'
						,24
						,18
						,'Save Interest Charging Log'
						,'Save Interest Charging Log');
		
			dlg_tools.setenabled(v1stlvlpage
								,tblchar100('UseCurDOM', 'UseCurINT')
								,NOT contract.existscontract(scontracttype));
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makepage_common;
	
		PROCEDURE makepage_delinquency(pdialog IN NUMBER) IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_create.cmethodname ||
												   '.MakePage_Delinquency';
		BEGIN
			t.enter(cmethodname);
		
			v1stlvlpage := makepage(pdialog, 'Delinquency States', 'DELINQUENCY');
		
			dialog.bevel(v1stlvlpage, 1, 1, 78, 2, dialog.bevel_frame, pcaption => 'Default state');
			contractstatereference.dropbox_state_create(v1stlvlpage
													   ,'DefState'
													   ,27
													   ,2
													   ,24
													   ,'Normal state:'
													   ,'Normal contract state'
													   ,pobjecttype            => contractparams.ccontracttype
													   ,pobjectno              => scontracttype);
		
			dialog.bevel(v1stlvlpage
						,1
						,3
						,78
						,3
						,dialog.bevel_frame
						,pcaption => 'Change card and account statuses at delinquency');
		
			dlg_tools.makedroplist(v1stlvlpage
								  ,'CardLock'
								  ,27
								  ,4
								  ,45
								  ,45
								  ,'Change card status:'
								  ,'Change card status at delinquency');
			dialog.listaddrecord(v1stlvlpage, 'CardLock', ccrdstatset_never || '~Never');
			dialog.listaddrecord(v1stlvlpage
								,'CardLock'
								,ccrdstatset_open || '~Always, if current status is "Opened"');
			dialog.listaddrecord(v1stlvlpage
								,'CardLock'
								,ccrdstatset_auto || '~If it was not changed manually');
			contractparams.loaddialogfieldnumber(v1stlvlpage
												,'CardLock'
												,contractparams.ccontracttype
												,scontracttype
												,pdefaultvalue => NULL);
		
			dlg_tools.makedroplist(v1stlvlpage
								  ,'ChangeAccStatus'
								  ,27
								  ,5
								  ,45
								  ,45
								  ,'Change account status:'
								  ,'Change account status at delinquency');
			dialog.listaddrecord(v1stlvlpage, 'ChangeAccStatus', '1~Never');
			dialog.listaddrecord(v1stlvlpage, 'ChangeAccStatus', '2~Always');
			dialog.listaddrecord(v1stlvlpage
								,'ChangeAccStatus'
								,'3~If it was not changed manually');
			dialog.listaddrecord(v1stlvlpage
								,'ChangeAccStatus'
								,'4~Always, if current status is "Opened"');
			contractparams.loaddialogfieldnumber(v1stlvlpage
												,'ChangeAccStatus'
												,contractparams.ccontracttype
												,scontracttype
												,pdefaultvalue => NULL);
		
			dialog.bevel(v1stlvlpage
						,1
						,6
						,78
						,2
						,dialog.bevel_frame
						,pcaption => 'No-overdue period calculation settings');
			dlg_tools.makedroplist(v1stlvlpage
								  ,'ZeroMPCycles'
								  ,27
								  ,7
								  ,24
								  ,24
								  ,'Cycles with MP = 0:'
								  ,'Cycles with MP = 0');
			dialog.listaddrecord(v1stlvlpage, 'ZeroMPCycles', cmp0_count || '~Count');
			dialog.listaddrecord(v1stlvlpage, 'ZeroMPCycles', cmp0_dontcount || '~Don''t count');
			dialog.listaddrecord(v1stlvlpage, 'ZeroMPCycles', cmp0_restart || '~Restart counting');
			contractparams.loaddialogfieldnumber(v1stlvlpage
												,'ZeroMPCycles'
												,contractparams.ccontracttype
												,scontracttype
												,pdefaultvalue => cmp0_count);
		
			dialog.setenable(v1stlvlpage
							,'ZeroMPCycles'
							,nvl(contractparams.loadnumber(contractparams.ccontracttype
														  ,scontracttype
														  ,'PeriodType'
														  ,FALSE)
								,contractdelinqsetup.covdday) IN
							 (contractdelinqsetup.covdcycle, contractdelinqsetup.covdfirstcycle));
		
			dialog.bevel(v1stlvlpage
						,1
						,8
						,78
						,3
						,dialog.bevel_frame
						,pcaption => 'Overdue period calculation mode');
			dlg_tools.makedroplist(v1stlvlpage
								  ,'OvdPeriodCalcMode'
								  ,27
								  ,9
								  ,26
								  ,26
								  ,'Calculation mode:'
								  ,'Overdue period calculation mode');
			dialog.listaddrecord(v1stlvlpage
								,'OvdPeriodCalcMode'
								,covdcalc_normal || '~Standard'
								,dialog.cmconfirm);
			dialog.listaddrecord(v1stlvlpage
								,'OvdPeriodCalcMode'
								,covdcalc_frzwithrep || '~Freeze (consider payments)'
								,dialog.cmconfirm);
			dialog.listaddrecord(v1stlvlpage
								,'OvdPeriodCalcMode'
								,covdcalc_frzworep || '~Freeze (ignore payments)'
								,dialog.cmconfirm);
			contractparams.loaddialogfieldnumber(v1stlvlpage
												,'OvdPeriodCalcMode'
												,contractparams.ccontracttype
												,scontracttype
												,pdefaultvalue => covdcalc_normal);
		
			dlg_tools.element_datefromto_create(v1stlvlpage
											   ,'OvdPeriodDates'
											   ,27
											   ,10
											   ,'Period from:'
											   ,'Calculation mode period start date'
											   ,'To:'
											   ,'Calculation mode period end date'
											   ,TRUE);
			dlg_tools.element_datefromto_load(v1stlvlpage
											 ,'OvdPeriodDates'
											 ,contractparams.ccontracttype
											 ,scontracttype
											 ,'OvdPeriodDateFrom'
											 ,'OvdPeriodDateTo');
		
			dlg_typeparams_handler(dialog.wtdialogvalid
								  ,v1stlvlpage
								  ,'OvdPeriodCalcMode'
								  ,dialog.cmconfirm);
		
			contractdelinqsetup.makeitem(v1stlvlpage
										,1
										,11
										,78
										,9
										,scontracttype
										,(saccumintaccmode <> cintaccmode_donotaccumulate)
										,(scurright_contype = c_canview)
										,scurright_reference);
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makepage_delinquency;
	
		PROCEDURE makepage_daf(pdialog IN NUMBER) IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_create.cmethodname ||
												   '.MakePage_DAF';
		BEGIN
			t.enter(cmethodname);
		
			v1stlvlpage := makepage(pdialog, 'DAF Generation', 'DAF', 1, 7, 77, 11);
		
			dialog.bevel(v1stlvlpage
						,1
						,1
						,78
						,5
						,dialog.bevel_frame
						,pcaption => 'Debit Advice File Generation');
		
			makecheckbox(v1stlvlpage
						,'UseDAF'
						,5
						,2
						,'Generate Debit Advice File automatically'
						,'Generate Debit Advice File automatically'
						,chandlername);
			contractparams.loaddialogbool(v1stlvlpage
										 ,'UseDAF'
										 ,contractparams.ccontracttype
										 ,scontracttype);
		
			dialog.inputchar(v1stlvlpage
							,'DAFReport'
							,24
							,3
							,50
							,'DAF generation report name'
							,pcaption => 'Generation report:');
			dialog.listaddfield(v1stlvlpage, 'DAFReport', 'ItemPackage', 'C', 30, 0);
			dialog.listaddfield(v1stlvlpage, 'DAFReport', 'ItemName', 'C', 50, 1);
			dialog.listaddfield(v1stlvlpage, 'DAFReport', 'ItemGroup', 'C', 20, 1);
			dialog.setreadonly(v1stlvlpage, 'DAFReport', TRUE);
		
			FOR i IN (SELECT a.*
							,b.name groupname
					  FROM   treferencereport      a
							,treferencereportgroup b
					  WHERE  a.branch = seance.getbranch
					  AND    b.branch = a.branch
					  AND    b.groupno = a.groupno
					  ORDER  BY a.groupno
							   ,a.repno)
			LOOP
				dialog.listaddrecord(pdialog
									,'DAFReport'
									,i.package || '~' || substr(i.name, 1, 50) || '~' ||
									 substr(i.groupname, 1, 20));
			END LOOP;
		
			contractparams.loaddialogfieldchar(v1stlvlpage
											  ,'DAFReport'
											  ,contractparams.ccontracttype
											  ,scontracttype
											  ,'ItemPackage'
											  ,'0');
		
			dialog.inputchar(v1stlvlpage
							,'OutPath'
							,24
							,4
							,52
							,'Debit Advice File saving path'
							,NULL
							,'DAF saving path:');
			dialog.setitempre(v1stlvlpage, 'OutPath', chandlername);
			contractparams.loaddialogchar(v1stlvlpage
										 ,'OutPath'
										 ,contractparams.ccontracttype
										 ,scontracttype);
		
			dialog.inputcheck(v1stlvlpage
							 ,'DAFGen4CType'
							 ,5
							 ,5
							 ,69
							 ,'Generate Debit Advice File by all contracts'
							 ,'Generate Debit Advice File by all contracts');
			contractparams.loaddialogbool(v1stlvlpage
										 ,'DAFGen4CType'
										 ,contractparams.ccontracttype
										 ,scontracttype);
		
			FOR i IN 1 .. 2
			LOOP
			
				v2ndlvlpage := makepage(v1stlvlpage, sfulllabel(i), slabel(i));
			
				dialog.bevel(v2ndlvlpage
							,1
							,1
							,76
							,2
							,dialog.bevel_frame
							,pcaption => 'Direct Debit Amount Calculation');
				contractddreference.makeitem(v2ndlvlpage
											,'DAFProfile' || slabel(i)
											,23
											,2
											,52
											,'Profile:');
				contractddreference.loaddialogvalue(v2ndlvlpage
												   ,'DAFProfile' || slabel(i)
												   ,contractddreference.ccontracttype
												   ,scontracttype);
			
			END LOOP;
		
			dlg_typeparams_handler(dialog.wtitempre, pdialog, 'USEDAF');
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makepage_daf;
	
		PROCEDURE makepage_statement(pdialog IN NUMBER) IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_create.cmethodname ||
												   '.MakePage_Statement';
		BEGIN
			t.enter(cmethodname);
		
			v1stlvlpage := makepage(pdialog, 'Statement', 'STATEMENT', 1, 8, 77, 7);
		
			dialog.bevel(v1stlvlpage, 1, 1, 78, 6, dialog.bevel_frame);
		
			statementtype.makestmttypecombo(v1stlvlpage
										   ,'StmtType'
										   ,25
										   ,2
										   ,49
										   ,'Statement type:'
										   ,statementrt.statement_contract);
			statementtype.selecttypeincombo(v1stlvlpage
										   ,'StmtType'
										   ,contractparams.loadchar(contractparams.ccontracttype
																   ,scontracttype
																   ,'StmtType'
																   ,FALSE));
		
			statementfolder.makefoldercombo(v1stlvlpage
										   ,'StmtFolder'
										   ,25
										   ,3
										   ,49
										   ,'Unload directory:');
			statementfolder.selectfolderincombo(v1stlvlpage
											   ,'StmtFolder'
											   ,contractparams.loadnumber(contractparams.ccontracttype
																		 ,scontracttype
																		 ,'StmtFolder'
																		 ,FALSE));
		
			dlg_tools.makedroplist(v1stlvlpage
								  ,'StmtMode'
								  ,25
								  ,4
								  ,49
								  ,49
								  ,'Generation condition:'
								  ,'Automatic Statement Generation Mode');
			dialog.listaddrecord(v1stlvlpage, 'StmtMode', '0~Do not generate', dialog.cmconfirm);
			dialog.listaddrecord(v1stlvlpage, 'StmtMode', '1~Indebtedness', dialog.cmconfirm);
			dialog.listaddrecord(v1stlvlpage, 'StmtMode', '2~Movement', dialog.cmconfirm);
			dialog.listaddrecord(v1stlvlpage
								,'StmtMode'
								,'3~Indebtedness or movement'
								,dialog.cmconfirm);
			dialog.listaddrecord(v1stlvlpage
								,'StmtMode'
								,'4~Indebtedness and movement'
								,dialog.cmconfirm);
			dialog.listaddrecord(v1stlvlpage, 'StmtMode', '5~Always', dialog.cmconfirm);
			contractparams.loaddialogfieldnumber(v1stlvlpage
												,'StmtMode'
												,contractparams.ccontracttype
												,scontracttype
												,pdefaultvalue => NULL);
		
			dialog.inputinteger(v1stlvlpage
							   ,'StmtTrns'
							   ,25
							   ,5
							   ,'Minimum transactions count for "movement" condition'
							   ,3
							   ,'Transactions count:');
			contractparams.loaddialognumber(v1stlvlpage
										   ,'StmtTrns'
										   ,contractparams.ccontracttype
										   ,scontracttype);
		
			dlg_typeparams_handler(dialog.wtdialogvalid, pdialog, 'StmtMode', dialog.cmconfirm);
		
			dialog.statictext(v1stlvlpage, 3, 6, 'Additional condition:');
			dlg_tools.drawbutton(v1stlvlpage
								,'StmntPL_SQL'
								,25
								,6
								,15
								,'PL/SQL Block'
								,'Additional conditions to check whether statement should be generated'
								,chandlername);
		
			FOR i IN 1 .. 2
			LOOP
			
				v2ndlvlpage := makepage(v1stlvlpage, sfulllabel(i), slabel(i));
			
				dialog.bevel(v2ndlvlpage
							,1
							,1
							,76
							,5
							,dialog.bevel_frame
							,pcaption => 'Statement fee');
			
				dlg_tools.makedroplist(v2ndlvlpage
									  ,'StmntFeeCalcType' || slabel(i)
									  ,24
									  ,2
									  ,20
									  ,20
									  ,'Type:'
									  ,'Statement fee calculation type');
				dialog.listaddrecord(v2ndlvlpage
									,'StmntFeeCalcType' || slabel(i)
									,ccalctype_notcalc || '~Do not charge'
									,dialog.cmconfirm);
				dialog.listaddrecord(v2ndlvlpage
									,'StmntFeeCalcType' || slabel(i)
									,ccalctype_total || '~As total of'
									,dialog.cmconfirm);
				dialog.listaddrecord(v2ndlvlpage
									,'StmntFeeCalcType' || slabel(i)
									,ccalctype_min || '~As minimum between'
									,dialog.cmconfirm);
				dialog.listaddrecord(v2ndlvlpage
									,'StmntFeeCalcType' || slabel(i)
									,ccalctype_max || '~As maximum between'
									,dialog.cmconfirm);
				contractparams.loaddialogfieldnumber(v2ndlvlpage
													,'StmntFeeCalcType' || slabel(i)
													,contractparams.ccontracttype
													,scontracttype
													,NULL
													,pdefaultvalue => ccalctype_notcalc);
			
				dialog.inputmoney(v2ndlvlpage
								 ,'StmntFeePrcnt' || slabel(i)
								 ,24
								 ,3
								 ,'Percentage from outstanding amount'
								 ,'Percentage:'
								 ,plen => 20);
				contractparams.loaddialognumber(v2ndlvlpage
											   ,'StmntFeePrcnt' || slabel(i)
											   ,contractparams.ccontracttype
											   ,scontracttype);
			
				dialog.inputmoney(v2ndlvlpage
								 ,'StmtFeeAmount' || slabel(i)
								 ,24
								 ,4
								 ,'Statement fee flat amount value'
								 ,'Flat amount:'
								 ,plen => 20);
				contractparams.loaddialognumber(v2ndlvlpage
											   ,'StmtFeeAmount' || slabel(i)
											   ,contractparams.ccontracttype
											   ,scontracttype);
			
				makeaccountinputfield(v2ndlvlpage
									 ,'StmtFeeAcc' || slabel(i)
									 ,24
									 ,5
									 ,'Fee income account:'
									 ,'Statement fee income account'
									 ,chandlername);
			
			END LOOP;
		
			dialog.bevel(v1stlvlpage
						,1
						,15
						,78
						,4
						,dialog.bevel_frame
						,pcaption => 'Promotional text');
			dialog.edittext(v1stlvlpage, 'PromText', 3, 16, 73, 3, 'Promotional text', '', 1000);
			dialog.puttext(v1stlvlpage
						  ,'PromText'
						  ,contractparams.loadchar(contractparams.ccontracttype
												  ,scontracttype
												  ,'PromText'
												  ,FALSE));
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makepage_statement;
	
		PROCEDURE makepage_otherfees(pdialog IN NUMBER) IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_create.cmethodname ||
												   '.MakePage_OtherFees';
		BEGIN
			t.enter(cmethodname);
		
			v1stlvlpage := makepage(pdialog, 'Other Fees', 'FEES', 1, 1, 77, 19);
		
			FOR i IN 1 .. 2
			LOOP
			
				v2ndlvlpage := makepage(v1stlvlpage, sfulllabel(i), slabel(i));
			
				dialog.bevel(v2ndlvlpage
							,1
							,1
							,76
							,3
							,dialog.bevel_frame
							,pcaption => 'Monthly fee');
				custom_contractprofiles.dropbox_monthlyfee_create(v2ndlvlpage
																 ,'MonthlyFeeProf' || slabel(i)
																 ,25
																 ,2
																 ,47
																 ,'Profile:'
																 ,'Monthly fee profile'
																 ,contractparams.ccontracttype
																 ,scontracttype
																 ,'<Do not charge>'
																 ,dialog.cmconfirm);
			
				makeaccountinputfield(v2ndlvlpage
									 ,'MonthlyFeeAcc' || slabel(i)
									 ,25
									 ,3
									 ,'Account:'
									 ,'Monthly fee income account'
									 ,chandlername);
			
				dialog.bevel(v2ndlvlpage
							,1
							,4
							,76
							,2
							,dialog.bevel_frame
							,pcaption => 'Goods and Services Tax');
				goodsservicestax.dropbox_profile_create(v2ndlvlpage
													   ,'GSTProfile' || slabel(i)
													   ,25
													   ,5
													   ,47
													   ,'Profile:'
													   ,'Choose GST profile'
													   ,contractparams.ccontracttype
													   ,scontracttype
													   ,'<Do not charge>');
			
			END LOOP;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makepage_otherfees;
	
		PROCEDURE makepage_limits(pdialog IN NUMBER) IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_create.cmethodname ||
												   '.MakePage_Limits';
		
			PROCEDURE loadlimit
			(
				pdialog            IN NUMBER
			   ,pcurno             IN NUMBER
			   ,plimitkind         IN PLS_INTEGER
			   ,pobjecttype        IN PLS_INTEGER
			   ,pownership         IN PLS_INTEGER
			   ,pcheckboxparamname IN VARCHAR2
			) IS
				cmethodname CONSTANT typemethodname := makepage_limits.cmethodname || '.LoadLimit';
				vlimitrecord    contracttypelimits.typelimitrecord;
				vobjectname     typeitemname;
				vlimitname      typeitemname;
				vidprefix       typeitemname;
				vincrsbyallwovl BOOLEAN;
			BEGIN
				t.enter(cmethodname
					   ,'CurNo = ' || pcurno || ', LimitKind = ' || plimitkind ||
						', ObjectType = ' || pobjecttype || ', Ownership = ' || pownership);
			
				IF dialog.getbool(pdialog, 'UseCur' || slabel(pcurno))
				THEN
				
					vobjectname := CASE pobjecttype
									   WHEN referencelimit.objtype_account THEN
										'ACC'
									   ELSE
										CASE pownership
											WHEN cco_primary THEN
											 'PRI'
											ELSE
											 'SUP'
										END
								   END;
					vlimitname  := upper(CASE plimitkind
											 WHEN clk_creditlimit THEN
											  'CredLimit'
											 ELSE
											  'CashLimit'
										 END);
					vidprefix   := CASE pobjecttype
									   WHEN referencelimit.objtype_account THEN
										'ACC'
									   ELSE
										'LINK'
								   END;
				
					vlimitrecord := contracttypelimits.getlimitsettings(scontracttype
																	   ,plimitkind
																	   ,pobjecttype
																	   ,pownership
																	   ,pcurno
																	   ,c_noexception);
				
					contracttypelimits.dropbox_limitid_setvalue(pdialog
															   ,vidprefix || vlimitname || 'ID'
															   ,vlimitrecord);
				
					dlg_tools.setdroplistvalue(pdialog
											  ,'#' || vobjectname || vlimitname || 'Type' ||
											   slabel(pcurno)
											  ,vlimitrecord.calcmethod);
					dialog.putnumber(pdialog
									,'#' || vobjectname || vlimitname || 'Prc' || slabel(pcurno)
									,vlimitrecord.percent);
					dialog.putnumber(pdialog
									,'#' || vobjectname || vlimitname || 'Amount' ||
									 slabel(pcurno)
									,vlimitrecord.flatamount);
				
					vincrsbyallwovl := contractparams.loadbool(contractparams.ccontracttype
															  ,scontracttype
															  ,pcheckboxparamname || slabel(pcurno)
															  ,c_noexception);
					dialog.putbool(pdialog
								  ,'#' || vobjectname || vlimitname || 'IncrsByAllwOvl' ||
								   slabel(pcurno)
								  ,vincrsbyallwovl);
				
				END IF;
			
				t.leave(cmethodname);
			EXCEPTION
				WHEN OTHERS THEN
					t.exc(cmethodname);
					error.save(cmethodname);
					RAISE;
			END loadlimit;
		
			FUNCTION getfirstavailablecurno RETURN NUMBER IS
				cmethodname CONSTANT typemethodname := makepage_limits.cmethodname ||
													   '.GetFirstAvailableCurNo';
			BEGIN
				FOR i IN 1 .. 2
				LOOP
					IF contractparams.loadbool(contractparams.ccontracttype
											  ,scontracttype
											  ,'UseCur' || slabel(i)
											  ,FALSE)
					THEN
						RETURN i;
					END IF;
				END LOOP;
				RETURN 0;
			EXCEPTION
				WHEN OTHERS THEN
					t.exc(cmethodname);
					error.save(cmethodname);
					RAISE;
			END getfirstavailablecurno;
		
			PROCEDURE dropbox_calcsettings_create
			(
				pdialog         IN NUMBER
			   ,pobject         IN VARCHAR2
			   ,plimitname      IN VARCHAR2
			   ,pcurno          IN NUMBER
			   ,px              IN NUMBER
			   ,py              IN NUMBER
			   ,plen            IN NUMBER
			   ,phint           IN VARCHAR2
			   ,pnotusedcaption IN VARCHAR2
			) IS
				cmethodname CONSTANT typemethodname := makepage_limits.cmethodname ||
													   '.DropBox_CalcSettings_Create';
				vobjlmtname   typeitemname := upper('#' || pobject || plimitname);
				vtypeitemname typeitemname := upper(vobjlmtname || 'Type' || slabel(pcurno));
			BEGIN
				t.enter(cmethodname, vtypeitemname);
			
				dlg_tools.makedroplist(pdialog
									  ,vtypeitemname
									  ,px
									  ,py
									  ,plen
									  ,plen
									  ,'Calculate as:'
									  ,phint);
				dialog.listaddrecord(pdialog
									,vtypeitemname
									,clmtnotdefined || '~' || pnotusedcaption
									,dialog.cmconfirm);
				dialog.listaddrecord(pdialog
									,vtypeitemname
									,clmttotal || '~Total of'
									,dialog.cmconfirm);
				dialog.listaddrecord(pdialog
									,vtypeitemname
									,clmtmax || '~Maximum between'
									,dialog.cmconfirm);
				dialog.listaddrecord(pdialog
									,vtypeitemname
									,clmtmin || '~Minimum between'
									,dialog.cmconfirm);
			
				dialog.inputmoney(pdialog
								 ,upper(vobjlmtname || 'Amount' || slabel(pcurno))
								 ,px
								 ,py + 1
								 ,'Flat amount value for limit calculation'
								 ,'Flat amount:'
								 ,2);
				dialog.inputmoney(pdialog
								 ,upper(vobjlmtname || 'Prc' || slabel(pcurno))
								 ,px
								 ,py + 2
								 ,'Percentage value for limit calculation'
								 ,'Percentage value:'
								 ,2);
			
				dialog.inputcheck(pdialog
								 ,upper(vobjlmtname || 'IncrsByAllwOvl' || slabel(pcurno))
								 ,px
								 ,py + 3
								 ,30
								 ,'Increase limit by allowed overlimit'
								 ,'Increase by allowed overlimit');
			
				t.leave(cmethodname);
			EXCEPTION
				WHEN OTHERS THEN
					t.exc(cmethodname);
					error.save(cmethodname);
					RAISE;
			END dropbox_calcsettings_create;
		
			PROCEDURE makepage_acc2cardlinklimit
			(
				ppage      IN NUMBER
			   ,pcurno     IN NUMBER
			   ,pownership IN PLS_INTEGER
			) IS
				cmethodname CONSTANT typemethodname := makepage_limits.cmethodname ||
													   '.MakePage_Acc2CardLinkLimit';
				vcaption   VARCHAR2(20) := CASE pownership
											   WHEN cco_primary THEN
												'Primary'
											   ELSE
												'Supplementary'
										   END;
				vownership VARCHAR2(3) := CASE pownership
											  WHEN cco_primary THEN
											   'PRI'
											  ELSE
											   'SUP'
										  END;
				vitemname  typeitemname := upper(vownership || 'CashLimitPBType' || slabel(pcurno));
			BEGIN
				t.enter(cmethodname);
			
				dialog.bevel(ppage
							,1
							,1
							,74
							,2
							,dialog.bevel_frame
							,pcaption => vcaption || ' Card Maximum Limit');
				dialog.inputmoney(ppage
								 ,vownership || 'CardCalcLimitMax' || slabel(pcurno)
								 ,22
								 ,2
								 ,'Card Calculated Limit maximum value'
								 ,'Maximum amount:');
				contractparams.loaddialognumber(ppage
											   ,vownership || 'CardCalcLimitMax' || slabel(pcurno)
											   ,contractparams.ccontracttype
											   ,scontracttype);
			
				dialog.bevel(ppage
							,1
							,3
							,74
							,10
							,dialog.bevel_frame
							,pcaption => vcaption || ' Card Default Credit Limit');
				dropbox_calcsettings_create(ppage
										   ,vownership
										   ,'CredLimit'
										   ,pcurno
										   ,22
										   ,4
										   ,48
										   ,vcaption || ' cards credit limit calculation type'
										   ,'Not used (100% of account credit limit)');
				loadlimit(ppage
						 ,pcurno
						 ,clk_creditlimit
						 ,referencelimit.objtype_acc2card
						 ,pownership
						 ,vownership || 'IncrsCrdLimByAllwOvl');
			
				dialog.bevel(ppage
							,1
							,8
							,74
							,5
							,dialog.bevel_top
							,pcaption => vcaption || ' Card Default Withdrawal Limit');
				dropbox_calcsettings_create(ppage
										   ,vownership
										   ,'CashLimit'
										   ,pcurno
										   ,22
										   ,9
										   ,48
										   ,vcaption || ' cards withdrawal limit calculation type'
										   ,'Not used (100% of card credit limit)');
				loadlimit(ppage
						 ,pcurno
						 ,clk_cashlimit
						 ,referencelimit.objtype_acc2card
						 ,pownership
						 ,vownership || 'IncrsCashLimByAllwOvl');
			
				dialog.bevel(ppage
							,1
							,13
							,74
							,3
							,dialog.bevel_frame
							,pcaption => 'Positive Balance Amount Usage');
				makecheckbox(ppage
							,vownership || 'LimitBPUse' || slabel(pcurno)
							,4
							,14
							,'Increase Total Available Limit by Positive Balance'
							,'Increase Total Available Limit by Positive Balance'
							,chandlername);
			
				dlg_tools.makedroplist(ppage
									  ,vitemname
									  ,22
									  ,15
									  ,48
									  ,48
									  ,'Withdrawal Limit:'
									  ,'Positive balance Impact on Card Limit calculation');
				dialog.listaddrecord(ppage
									,vitemname
									,cpb_donotuse || '~Calculate from Credit Limit'
									,dialog.cmconfirm);
				dialog.listaddrecord(ppage
									,vitemname
									,cpb_increasebase || '~Calculate from Total Limit'
									,dialog.cmconfirm);
				dialog.listaddrecord(ppage
									,vitemname
									,cpb_addtolimit || '~Increase by Positive Balance'
									,dialog.cmconfirm);
				contractparams.loaddialogfieldnumber(ppage
													,vitemname
													,contractparams.ccontracttype
													,scontracttype
													,pdefaultvalue => NULL);
			
				t.leave(cmethodname);
			EXCEPTION
				WHEN OTHERS THEN
					t.exc(cmethodname);
					error.save(cmethodname);
					RAISE;
			END makepage_acc2cardlinklimit;
		
		BEGIN
			t.enter(cmethodname);
		
			v1stlvlpage := makepage(pdialog, 'Limits', 'LIMITS', 1, 1, 77, 19);
		
			v2ndlvlpage := makepage(v1stlvlpage, 'Limit Types', 'TYPES');
		
			dialog.bevel(v2ndlvlpage
						,1
						,1
						,76
						,3
						,dialog.bevel_frame
						,TRUE
						,'Account Withdrawal Limit');
			contracttypelimits.dropbox_limitid_create(v2ndlvlpage
													 ,'AccCashLimitID'
													 ,15
													 ,2
													 ,60
													 ,'Limit name:'
													 ,'Specify account withdrawal limit name'
													 ,scontracttype
													 ,clk_cashlimit
													 ,referencelimit.objtype_account
													 ,cco_primary
													 ,getfirstavailablecurno);
			contracttypelimits.dropbox_period_create(v2ndlvlpage
													,'AccCashLimitPeriod'
													,15
													,3
													,20
													,'Recovery:'
													,'Account withdrawal limit reset period'
													,TRUE
													,crecoveryperiods
													,'AccCashLimitID');
		
			dialog.bevel(v2ndlvlpage, 1, 4, 76, 3, dialog.bevel_frame, TRUE, 'Cards Credit Limit');
			contracttypelimits.dropbox_limitid_create(v2ndlvlpage
													 ,'LinkCredLimitID'
													 ,15
													 ,5
													 ,60
													 ,'Limit name:'
													 ,'Specify cards credit limit name'
													 ,scontracttype
													 ,clk_creditlimit
													 ,referencelimit.objtype_acc2card
													 ,cco_primary
													 ,getfirstavailablecurno);
			contracttypelimits.dropbox_period_create(v2ndlvlpage
													,'LinkCredLimitPeriod'
													,15
													,6
													,20
													,'Recovery:'
													,'Cards credit limit reset period'
													,TRUE
													,crecoveryperiods
													,'LinkCredLimitID');
		
			dialog.bevel(v2ndlvlpage
						,1
						,7
						,76
						,3
						,dialog.bevel_frame
						,TRUE
						,'Cards Withdrawal Limit');
			contracttypelimits.dropbox_limitid_create(v2ndlvlpage
													 ,'LinkCashLimitID'
													 ,15
													 ,8
													 ,60
													 ,'Limit name:'
													 ,'Specify cards withdrawal limit name'
													 ,scontracttype
													 ,clk_cashlimit
													 ,referencelimit.objtype_acc2card
													 ,cco_primary
													 ,getfirstavailablecurno);
			contracttypelimits.dropbox_period_create(v2ndlvlpage
													,'LinkCashLimitPeriod'
													,15
													,9
													,20
													,'Recovery:'
													,'Cards withdrawal limit reset period'
													,TRUE
													,crecoveryperiods
													,'LinkCashLimitID');
		
			FOR i IN 1 .. 2
			LOOP
			
				v2ndlvlpage := makepage(v1stlvlpage, sfulllabel(i), slabel(i), 1, 1, 75, 17);
			
				v3rdlvlpage := makepage(v2ndlvlpage, 'Fees', 'FEES');
			
				dialog.bevel(v3rdlvlpage
							,1
							,1
							,74
							,2
							,dialog.bevel_frame
							,pcaption => 'Income account');
				makeaccountinputfield(v3rdlvlpage
									 ,'IncAccLimitChangeFee' || slabel(i)
									 ,40
									 ,2
									 ,'Account number:'
									 ,'Limit change fee income account number'
									 ,chandlername);
			
				dialog.bevel(v3rdlvlpage
							,1
							,3
							,74
							,3
							,dialog.bevel_frame
							,pcaption => 'Account limit fees');
			
				valuechangefee.dropbox_profile_create(v3rdlvlpage
													 ,'LCF_AccCredLmtProfile' || slabel(i)
													 ,40
													 ,4
													 ,30
													 ,'Credit limit change:'
													 ,'Select fee profile for account credit limit change'
													 ,contractparams.ccontracttype
													 ,scontracttype
													 ,'<Do not charge>');
				valuechangefee.dropbox_profile_create(v3rdlvlpage
													 ,'LCF_AccCredTempLmtProfile' || slabel(i)
													 ,40
													 ,5
													 ,30
													 ,'Temporary credit limit change:'
													 ,'Select fee profile for account temporary credit limit change'
													 ,contractparams.ccontracttype
													 ,scontracttype
													 ,'<Do not charge>');
			
				v3rdlvlpage := makepage(v2ndlvlpage, 'Account Limits', 'ACCOUNTLIMITS');
			
				dialog.bevel(v3rdlvlpage
							,1
							,1
							,74
							,2
							,dialog.bevel_frame
							,pcaption => 'Account Credit Limit');
				dialog.inputmoney(v3rdlvlpage
								 ,'AccCredLimitMin' || slabel(i)
								 ,22
								 ,2
								 ,'Account Credit Limit minimum value'
								 ,'Minimum amount:');
				contractparams.loaddialognumber(pdialog
											   ,'AccCredLimitMin' || slabel(i)
											   ,contractparams.ccontracttype
											   ,scontracttype);
				dialog.inputmoney(v3rdlvlpage
								 ,'AccCredLimitMax' || slabel(i)
								 ,57
								 ,2
								 ,'Account Credit Limit maximum value'
								 ,'Maximum amount:');
				contractparams.loaddialognumber(pdialog
											   ,'AccCredLimitMax' || slabel(i)
											   ,contractparams.ccontracttype
											   ,scontracttype);
			
				dialog.bevel(v3rdlvlpage
							,1
							,3
							,74
							,5
							,dialog.bevel_frame
							,pcaption => 'Account Default Withdrawal Limit');
				dropbox_calcsettings_create(v3rdlvlpage
										   ,'Acc'
										   ,'CashLimit'
										   ,i
										   ,22
										   ,4
										   ,48
										   ,'Increase account cash limit by allowed overlimit'
										   ,'Not used (100% of account credit limit)');
				loadlimit(v3rdlvlpage
						 ,i
						 ,clk_cashlimit
						 ,referencelimit.objtype_account
						 ,cco_primary
						 ,'AccIncrsCashLimByAllwOvl');
			
				dialog.bevel(v3rdlvlpage
							,1
							,8
							,74
							,2
							,dialog.bevel_frame
							,pcaption => 'Positive Balance Limit');
				dialog.inputmoney(v3rdlvlpage
								 ,'PBLimit' || slabel(i)
								 ,22
								 ,9
								 ,'Limit of Positive Balance Amount'
								 ,'Limit amount:');
				contractparams.loaddialognumber(v3rdlvlpage
											   ,'PBLimit' || slabel(i)
											   ,contractparams.ccontracttype
											   ,scontracttype);
			
				dialog.bevel(v3rdlvlpage
							,1
							,10
							,74
							,2
							,dialog.bevel_frame
							,pcaption => 'Positive Balance Amount Usage');
				dlg_tools.makedroplist(v3rdlvlpage
									  ,'AccCashLimitPBType' || slabel(i)
									  ,22
									  ,11
									  ,48
									  ,48
									  ,'Withdrawal Limit:'
									  ,'Positive balance amount usage in Account Withdrawal Limit calculation');
				dialog.listaddrecord(v3rdlvlpage
									,'AccCashLimitPBType' || slabel(i)
									,cpb_donotuse || '~Calculate from Credit Limit'
									,dialog.cmconfirm);
				dialog.listaddrecord(v3rdlvlpage
									,'AccCashLimitPBType' || slabel(i)
									,cpb_increasebase || '~Calculate from Total Limit'
									,dialog.cmconfirm);
				dialog.listaddrecord(v3rdlvlpage
									,'AccCashLimitPBType' || slabel(i)
									,cpb_addtolimit || '~Increase by Positive Balance'
									,dialog.cmconfirm);
				contractparams.loaddialogfieldnumber(v3rdlvlpage
													,'AccCashLimitPBType' || slabel(i)
													,contractparams.ccontracttype
													,scontracttype
													,pdefaultvalue => NULL);
			
				dialog.bevel(v3rdlvlpage
							,1
							,12
							,74
							,4
							,dialog.bevel_frame
							,pcaption => 'Allowed Overlimit (increases Available Balance)');
				dlg_tools.makedroplist(v3rdlvlpage
									  ,'AccOverLimitType' || slabel(i)
									  ,22
									  ,13
									  ,48
									  ,48
									  ,'Calculate as:'
									  ,'Account Allowed Overlimit calculation type');
				dialog.listaddrecord(v3rdlvlpage
									,'AccOverLimitType' || slabel(i)
									,clmtnotdefined || '~Not used'
									,dialog.cmconfirm);
				dialog.listaddrecord(v3rdlvlpage
									,'AccOverLimitType' || slabel(i)
									,clmttotal || '~Total of'
									,dialog.cmconfirm);
				dialog.listaddrecord(v3rdlvlpage
									,'AccOverLimitType' || slabel(i)
									,clmtmax || '~Maximum between'
									,dialog.cmconfirm);
				dialog.listaddrecord(v3rdlvlpage
									,'AccOverLimitType' || slabel(i)
									,clmtmin || '~Minimum between'
									,dialog.cmconfirm);
				contractparams.loaddialogfieldnumber(v3rdlvlpage
													,'AccOverLimitType' || slabel(i)
													,contractparams.ccontracttype
													,scontracttype
													,pdefaultvalue => NULL);
			
				dialog.inputmoney(v3rdlvlpage
								 ,'AccOverLimitAmount' || slabel(i)
								 ,22
								 ,14
								 ,'Account Allowed Overlimit flat amount value'
								 ,'Flat amount:');
				contractparams.loaddialognumber(v3rdlvlpage
											   ,'AccOverLimitAmount' || slabel(i)
											   ,contractparams.ccontracttype
											   ,scontracttype);
				dialog.inputmoney(v3rdlvlpage
								 ,'AccOverLimitPrc' || slabel(i)
								 ,22
								 ,15
								 ,'Account Allowed Overlimit percentage value from Account Credit Limit'
								 ,'Percentage value:');
				contractparams.loaddialognumber(v3rdlvlpage
											   ,'AccOverLimitPrc' || slabel(i)
											   ,contractparams.ccontracttype
											   ,scontracttype);
			
				v3rdlvlpage := makepage(v2ndlvlpage, 'Primary Cards Limits', 'PRICARDLIMIT');
				makepage_acc2cardlinklimit(v3rdlvlpage, i, cco_primary);
			
				v3rdlvlpage := makepage(v2ndlvlpage, 'Supplementary Cards Limits', 'SUPCARDLIMIT');
				makepage_acc2cardlinklimit(v3rdlvlpage, i, cco_supplementary);
			
				v3rdlvlpage := makepage(v2ndlvlpage, 'Additional account limits', 'ADDACCLIMITS');
				contracttypelimits.page_limits_create(v3rdlvlpage
													 ,75
													 ,17
													 ,scontracttype
													 ,clk_addlimit
													 ,referencelimit.objtype_account
													 ,cco_primary
													 ,i
													 ,creadonly_dlg);
			
			END LOOP;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makepage_limits;
	
		PROCEDURE makepage_debtcollection(pdialog IN NUMBER) IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_create.cmethodname ||
												   '.MakePage_DebtCollection';
		BEGIN
			t.enter(cmethodname);
		
			v1stlvlpage := makepage(pdialog, 'Debt Collection', 'DC', 1, 1, 77, 19);
		
			v2ndlvlpage := makepage(v1stlvlpage, 'Common', 'COMMON');
		
			contractdcsetup.makechargectitem(v2ndlvlpage
											,'DC_Charge'
											,1
											,1
											,76
											,15
											,schargefromparam);
			contractdcsetup.loadchargedialogvalues(v2ndlvlpage, 'DC_Charge', scontracttype);
		
			FOR i IN 1 .. 2
			LOOP
			
				v2ndlvlpage := makepage(v1stlvlpage, sfulllabel(i), slabel(i));
			
				contractdcsetup.makectitem(v2ndlvlpage
										  ,'DC_' || slabel(i)
										  ,1
										  ,1
										  ,76
										  ,15
										  ,sodparams
										  ,solparams);
				contractdcsetup.loaddialogvalues(v2ndlvlpage, 'DC_' || slabel(i), scontracttype);
			
			END LOOP;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makepage_debtcollection;
	
		PROCEDURE makepage_installment(pdialog IN NUMBER) IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_create.cmethodname ||
												   '.MakePage_Installment';
		BEGIN
			t.enter(cmethodname);
		
			v1stlvlpage := makepage(pdialog, 'Installment', 'INST', 1, 1, 77, 19);
		
			v2ndlvlpage := makepage(v1stlvlpage, 'Common', 'COMMON');
		
			makecheckbox(v2ndlvlpage
						,'UseInst'
						,2
						,1
						,'Use installments'
						,'Use installments'
						,chandlername);
		
			dialog.bevel(v2ndlvlpage
						,1
						,2
						,76
						,4
						,dialog.bevel_frame
						,pcaption => 'Minimum payment calculation');
			makecheckbox(v2ndlvlpage
						,'InstAddPay'
						,4
						,3
						,'Increase by installment repayment amount'
						,'Increase by installment repayment amount');
			makecheckbox(v2ndlvlpage
						,'InstAddAcc'
						,4
						,4
						,'Increase by installment acceleration amount'
						,'Increase by installment acceleration amount');
			makecheckbox(v2ndlvlpage
						,'InstAddInt'
						,4
						,5
						,'Increase by installment interest amount'
						,'Increase by installment interest amount');
		
			dialog.bevel(v2ndlvlpage
						,1
						,6
						,76
						,2
						,dialog.bevel_frame
						,pcaption => 'Repayment amount');
			makecheckbox(v2ndlvlpage
						,'InstDoOneEntry'
						,4
						,7
						,'Post Regular Repayment Amount and Credit Interest as one entry'
						,'Post Regular Repayment Amount and Credit Interest as one entry');
		
			dialog.bevel(v2ndlvlpage
						,1
						,8
						,76
						,2
						,dialog.bevel_frame
						,pcaption => 'Available Limit dependence');
			dlg_tools.makedroplist(v2ndlvlpage
								  ,'InstDepend'
								  ,20
								  ,9
								  ,52
								  ,52
								  ,'Installment debt:'
								  ,'Available Limit dependence from Installment indebtedness');
			dialog.listaddrecord(v2ndlvlpage
								,'InstDepend'
								,cinstnotdepend || '~Not decrease Available Limit');
			dialog.listaddrecord(v2ndlvlpage
								,'InstDepend'
								,cinstregpayment ||
								 '~Decrease Available Limit by Repayment amount');
			dialog.listaddrecord(v2ndlvlpage
								,'InstDepend'
								,cinstusedlimit || '~Decrease Available Limit by Unpaid amount');
			dialog.listaddrecord(v2ndlvlpage
								,'InstDepend'
								,cinstusedlimitandinterest ||
								 '~Decrease Available Limit by Unpaid amount + Interest');
			contractparams.loaddialogfieldnumber(v2ndlvlpage
												,'InstDepend'
												,contractparams.ccontracttype
												,NULL
												,NULL
												,1);
		
			FOR i IN 1 .. 2
			LOOP
			
				v2ndlvlpage := makepage(v1stlvlpage, sfulllabel(i), slabel(i), 1, 1, 77, 19);
			
				v3rdlvlpage := makepage(v2ndlvlpage, 'Linked types', 'TYPES');
			
				contractlink.contracttypeitem(contractlink.cmain
											 ,scontracttype
											 ,slinkschemasinst
											 ,contractlink.cmultiple2multiple
											 ,v3rdlvlpage
											 ,'LINK_INST_' || slabel(i)
											 ,1
											 ,1
											 ,75
											 ,15
											 ,NULL
											 ,'Installment contract type'
											 ,cinstlinkname
											 ,getcurrency(scontracttype
														 ,'ItemDeposit' || slabel(i))
											 ,FALSE
											 ,preadonly => creadonly_dlg);
			
				v3rdlvlpage := makepage(v2ndlvlpage, 'InstallmentOn fee', 'INSTONFEE');
			
				dialog.bevel(v3rdlvlpage, 1, 1, 75, 3, dialog.bevel_frame);
			
				makecheckbox(v3rdlvlpage
							,'InstOnFeeCalc' || slabel(i)
							,4
							,1
							,'Charge fee'
							,'Whether it is necessary to charge "Installment On" fee (during transferring transaction to Installment)'
							,chandlername);
			
				contractcommission.dropbox_commission_create(v3rdlvlpage
															,'InstallmentOnFee' || slabel(i)
															,16
															,2
															,30
															,'Tariff:'
															,'Tariff for "Installment On" fee calculation'
															,NULL
															,contractcommission.ctypeintervaltime
															,pobjecttype => contractparams.ccontracttype
															,pobjectno => scontracttype);
			
				makeaccountinputfield(v3rdlvlpage
									 ,'InstOnFeeAcc' || slabel(i)
									 ,16
									 ,3
									 ,'Fee account:'
									 ,'"Installment on" fee income account'
									 ,chandlername);
			
				v3rdlvlpage := makepage(v2ndlvlpage, 'Interest to installment', 'INT2INST');
			
				dialog.bevel(v3rdlvlpage, 1, 1, 75, 3, dialog.bevel_frame);
			
				makecheckbox(v3rdlvlpage
							,'IntToInstOn' || slabel(i)
							,4
							,1
							,'Transfer interest to installment'
							,'Whether it is necessary to transfer charged interest to installment'
							,chandlername);
			
				dlg_tools.element_datefromto_create(v3rdlvlpage
												   ,'IntToInstPeriod' || slabel(i)
												   ,18
												   ,2
												   ,'Active from:'
												   ,'Transfer period start date'
												   ,'Active to:'
												   ,'Transfer period end date'
												   ,TRUE);
				dlg_tools.element_datefromto_load(v3rdlvlpage
												 ,'IntToInstPeriod' || slabel(i)
												 ,contractparams.ccontracttype
												 ,scontracttype
												 ,'IntToInstFrom' || slabel(i)
												 ,'IntToInstTo' || slabel(i));
			
				contractlink.dropbox_linkedtypes_create(v3rdlvlpage
													   ,'IntToInstCT' || slabel(i)
													   ,18
													   ,3
													   ,8
													   ,43
													   ,'Contract type:'
													   ,'Installment contract type to be used for new contracts'
													   ,scontracttype
													   ,contractlink.cmain
													   ,cinstlinkname
													   ,getcurrency(scontracttype
																   ,'ItemDeposit' || slabel(i)));
			
				v3rdlvlpage := makepage(v2ndlvlpage, 'Debt restructuring', 'RESTRUCTURING');
			
				dlg_tools.drawnestedbevel(v3rdlvlpage, 1, 1, 75, 13);
			
				makecheckbox(v3rdlvlpage
							,'AllowRestructure' || slabel(i)
							,4
							,1
							,'Allow debt restructuring'
							,'Indicator of whether debt restructuring by transfer to installment is allowed'
							,chandlername);
			
				contractlink.dropbox_linkedtypes_create(v3rdlvlpage
													   ,'DebtToInstCT' || slabel(i)
													   ,21
													   ,2
													   ,8
													   ,40
													   ,'Contract type:'
													   ,'Installment contract type to be used for new contracts'
													   ,scontracttype
													   ,contractlink.cmain
													   ,cinstlinkname
													   ,getcurrency(scontracttype
																   ,'ItemDeposit' || slabel(i)));
			
				dlg_tools.drawnestedbevel(v3rdlvlpage, 1, 3, 75, 13);
			
				dialog.statictext(v3rdlvlpage, 6, 4, 'Change cards with state:');
				dlg_tools.element_cardstateslist_create(v3rdlvlpage
													   ,'RestrCardStatesFrom' || slabel(i)
													   ,3
													   ,5
													   ,30
													   ,6
													   ,'List of card states that should be changed during debt restructuring');
				dlg_tools.element_cardstateslist_load(v3rdlvlpage
													 ,'RestrCardStatesFrom' || slabel(i)
													 ,contractparams.ccontracttype
													 ,scontracttype);
			
				dialog.statictext(v3rdlvlpage, 40, 4, 'State/status after restructuring:');
				dlg_tools.item_cardattributes_create(v3rdlvlpage
													,'RestrCardStateTo' || slabel(i)
													,56
													,5
													,FALSE);
				dlg_tools.item_cardattributes_load(v3rdlvlpage
												  ,'RestrCardStateTo' || slabel(i)
												  ,contractparams.ccontracttype
												  ,scontracttype);
			
			END LOOP;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makepage_installment;
	
		PROCEDURE makepage_scoring(pdialog IN NUMBER) IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_create.cmethodname ||
												   '.MakePage_Scoring';
		BEGIN
			t.enter(cmethodname);
		
			v1stlvlpage := makepage(pdialog, 'Scoring', 'SCORING', 1, 1, 77, 17);
		
			FOR i IN 1 .. 2
			LOOP
			
				v2ndlvlpage := makepage(v1stlvlpage, sfulllabel(i), slabel(i));
			
				dialog.bevel(v2ndlvlpage
							,1
							,1
							,76
							,15
							,dialog.bevel_frame
							,pcaption           => 'Operation list'
							,panchor            => dialog.anchor_all);
				dialog.list(v2ndlvlpage, 'ScoreProc' || slabel(i), 3, 3, 70, 9, 'Operation list');
				dialog.listaddfield(v2ndlvlpage
								   ,'ScoreProc' || slabel(i)
								   ,'Used'
								   ,'C'
								   ,5
								   ,1
								   ,dialog.align_center);
				dialog.listaddfield(v2ndlvlpage, 'ScoreProc' || slabel(i), 'Id', 'N', 4, 0);
				dialog.listaddfield(v2ndlvlpage, 'ScoreProc' || slabel(i), 'ScoreId', 'N', 4, 0);
				dialog.listaddfield(v2ndlvlpage, 'ScoreProc' || slabel(i), 'Name', 'C', 45, 1);
				dialog.setcaption(v2ndlvlpage, 'ScoreProc' || slabel(i), 'Used~Operation name');
				dialog.setitempre(v2ndlvlpage, 'ScoreProc' || slabel(i), chandlername);
			
			END LOOP;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makepage_scoring;
	
		PROCEDURE makepage_bankaccounts(pdialog IN NUMBER) IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_create.cmethodname ||
												   '.MakePage_BankAccounts';
			vdrawaccumulationaccount BOOLEAN;
		BEGIN
			t.enter(cmethodname);
		
			vdrawaccumulationaccount := saccumintaccmode IN
										(cintaccmode_intaccbalance, cintaccmode_intacctechnical);
		
			v1stlvlpage := makepage(pdialog
								   ,'Bank Income Accounts'
								   ,'ACCOUNTS'
								   ,1
								   ,1
								   ,77
								   ,8 + htools.b2i(vdrawaccumulationaccount));
		
			FOR i IN 1 .. 2
			LOOP
			
				v2ndlvlpage := makepage(v1stlvlpage, sfulllabel(i), slabel(i));
			
				dialog.bevel(v2ndlvlpage
							,1
							,1
							,76
							,6 + htools.b2i(vdrawaccumulationaccount)
							,dialog.bevel_frame
							,panchor => dialog.anchor_all);
			
				dialog.statictext(v2ndlvlpage, 33, 2, 'Balance');
				dialog.statictext(v2ndlvlpage, 54, 2, 'Off-Balance');
			
				makeaccountinputfield(v2ndlvlpage
									 ,'IncomeAcc' || slabel(i)
									 ,27
									 ,3
									 ,'Interest Income:'
									 ,'Interest income account'
									 ,chandlername);
				makeaccountinputfield(v2ndlvlpage
									 ,'IncomeAcc_OffBal' || slabel(i)
									 ,50
									 ,3
									 ,NULL
									 ,'Off-balance interest income account'
									 ,chandlername);
				makeaccountinputfield(v2ndlvlpage
									 ,'IncomeAccODF' || slabel(i)
									 ,27
									 ,4
									 ,'Overdue Fee Income:'
									 ,'Overdue fee income account'
									 ,chandlername);
				makeaccountinputfield(v2ndlvlpage
									 ,'IncomeAccODF_OffBal' || slabel(i)
									 ,50
									 ,4
									 ,NULL
									 ,'Off-balance overdue fee income account'
									 ,chandlername);
				makeaccountinputfield(v2ndlvlpage
									 ,'IncomeAccOLF' || slabel(i)
									 ,27
									 ,5
									 ,'Over-limit Fee Income:'
									 ,'Over-limit fee income account'
									 ,chandlername);
				makeaccountinputfield(v2ndlvlpage
									 ,'TechnicalAcc' || slabel(i)
									 ,27
									 ,6
									 ,'Technical Account:'
									 ,'Technical account'
									 ,chandlername);
			
				IF vdrawaccumulationaccount
				THEN
					makeaccountinputfield(v2ndlvlpage
										 ,'BankAccumIntAcc' || slabel(i)
										 ,27
										 ,7
										 ,'Interest Accumulation:'
										 ,'Account for interest accumulation'
										 ,chandlername);
				END IF;
			
			END LOOP;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makepage_bankaccounts;
	
	BEGIN
		t.enter(cmethodname);
	
		scontracttype                        := pcontracttype;
		contracttypeschema.scontractrow.type := scontracttype;
		filldcarrays;
	
		vdialog := dialog.new(ctdialog.makedialogcaption(scontracttype, ctdialog.c_cap_typeparams)
							 ,0
							 ,0
							 ,cdialogwidth
							 ,cdialogheight
							 ,presizable => TRUE
							 ,pextid => cmethodname);
	
		dialog.pagelist(vdialog, cpagername, 1, 1, 79, 23);
	
		makepage_common(vdialog);
	
		makepage_delinquency(vdialog);
	
		makepage_daf(vdialog);
	
		makepage_statement(vdialog);
	
		makepage_otherfees(vdialog);
	
		makepage_limits(vdialog);
	
		IF debtcollectoravailable
		THEN
			makepage_debtcollection(vdialog);
		END IF;
	
		IF collectionavailable
		THEN
		
			contractcollection.makectsetupitem2(vdialog
											   ,cpagername
											   ,1
											   ,1
											   ,77
											   ,17
											   ,'Domestic currency'
											   ,'Rules for domestic currency account'
											   ,scontracttype
											   ,vacommonrules
											   ,vaspecificrules
											   ,slabel(1));
			contractcollection.makectsetupitem2(vdialog
											   ,cpagername
											   ,1
											   ,1
											   ,77
											   ,17
											   ,'International currency'
											   ,'Rules for international currency account'
											   ,scontracttype
											   ,vacommonrules
											   ,vaspecificrules
											   ,slabel(2));
		END IF;
	
		IF slinkschemasinst.count > 0
		THEN
			makepage_installment(vdialog);
		END IF;
	
		vpanel8 := dialog.page(vdialog, cpagername, 'Credit Shield');
	
		dialog.bevel(vpanel8, 1, 1, 78, 3, dialog.bevel_frame, pcaption => 'Premium charging');
	
		dlg_tools.makedroplist(vpanel8
							  ,'ShieldChargeMode'
							  ,22
							  ,2
							  ,25
							  ,25
							  ,'Charge mode:'
							  ,'Credit Shield Premium charge mode');
		dialog.listaddrecord(vpanel8, 'ShieldChargeMode', ccs_donotcharge || '~Do not charge');
		dialog.listaddrecord(vpanel8, 'ShieldChargeMode', ccs_alwayscharge || '~Always charge');
		dialog.listaddrecord(vpanel8
							,'ShieldChargeMode'
							,ccs_charge4credit || '~Charge when credit used');
		contractparams.loaddialogfieldnumber(vpanel8
											,'ShieldChargeMode'
											,contractparams.ccontracttype
											,scontracttype
											,NULL
											,ccs_donotcharge);
	
		referencecalendar.inputcalendar(vpanel8
									   ,'ShieldCalendar'
									   ,22
									   ,3
									   ,55
									   ,'Day off calendar:'
									   ,'Day off calendar');
		referencecalendar.setclndtodialog(vpanel8
										 ,'ShieldCalendar'
										 ,nvl(contractparams.loadnumber(contractparams.ccontracttype
																	   ,scontracttype
																	   ,'ShieldCalendar'
																	   ,c_noexception)
											 ,0));
	
		dialog.pagelist(vpanel8, 'CS_PAGER', 1, 5, 77, 15);
	
		FOR i IN 1 .. 2
		LOOP
		
			vpanel := dialog.page(vpanel8, 'CS_PAGER', sfulllabel(i));
		
			dialog.pagelist(vpanel, 'CS_REG_PREM' || i, 1, 1, 75, 13);
		
			vpanel81 := dialog.page(vpanel, 'CS_REG_PREM' || i, 'Regular premium amount');
		
			dialog.bevel(vpanel81
						,1
						,1
						,74
						,2
						,dialog.bevel_frame
						,pcaption           => 'Calculation type'
						,panchor            => dialog.anchor_left + dialog.anchor_top);
		
			dlg_tools.makedroplist(vpanel81
								  ,'ShieldCalcType' || slabel(i)
								  ,9
								  ,2
								  ,27
								  ,27
								  ,'Type:'
								  ,'Credit Shield Premium charge type');
			dialog.listaddrecord(vpanel81
								,'ShieldCalcType' || slabel(i)
								,cshieldstatic || '~Static'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ShieldCalcType' || slabel(i)
								,cshielddynamic || '~Dynamic'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ShieldCalcType' || slabel(i)
								,cshieldstaticpost || '~Static with a post control'
								,dialog.cmconfirm);
		
			dlg_tools.drawbutton(vpanel81
								,'ShieldPLSQL' || slabel(i)
								,40
								,2
								,16
								,'PL/SQL Block'
								,'Additional conditions to check whether credit shield should be charged'
								,chandlername);
		
			dialog.bevel(vpanel81
						,1
						,3
						,74
						,9
						,dialog.bevel_frame
						,pcaption           => 'Calculation Parameters'
						,panchor            => dialog.anchor_left + dialog.anchor_top);
		
			dlg_tools.makedroplist(vpanel81
								  ,'ShieldWhenToCharge' || slabel(i)
								  ,23
								  ,4
								  ,30
								  ,45
								  ,'When To Charge:'
								  ,'When credit shield should be charged');
			dialog.listaddrecord(vpanel81
								,'ShieldWhenToCharge' || slabel(i)
								,cshieldnotused || '~Not Used'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ShieldWhenToCharge' || slabel(i)
								,cmonthlyeom || '~Last business day of the month'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ShieldWhenToCharge' || slabel(i)
								,cmonthlyeoc || '~Every Statement Date'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ShieldWhenToCharge' || slabel(i)
								,cqreom || '~Last business day of quarter'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ShieldWhenToCharge' || slabel(i)
								,cqreoc || '~Last Statement Date of quarter'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ShieldWhenToCharge' || slabel(i)
								,cmonthlyonday || '~Every month on specific day'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ShieldWhenToCharge' || slabel(i)
								,cqronday || '~Specific day of the QR''s last month'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ShieldWhenToCharge' || slabel(i)
								,cfirstsdafterqr || '~First month after the last month of the QR'
								,dialog.cmconfirm);
		
			dialog.inputinteger(vpanel81
							   ,'ShieldCertainDay' || slabel(i)
							   ,63
							   ,4
							   ,'Certain day when credit shield should be charged'
							   ,2
							   ,'Day:');
		
			dlg_tools.makedroplist(vpanel81
								  ,'ShieldChargeBase' || slabel(i)
								  ,23
								  ,5
								  ,30
								  ,30
								  ,'Base Amount:'
								  ,'Base Amount on which credit shield should be charged');
			dialog.listaddrecord(vpanel81
								,'ShieldChargeBase' || slabel(i)
								,ccurrentbalance || '~Current Balance'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ShieldChargeBase' || slabel(i)
								,cpreveombalance || '~Previous Month Balance'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ShieldChargeBase' || slabel(i)
								,cpreveocbalance || '~Last Statement Date Balance'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ShieldChargeBase' || slabel(i)
								,cprevbusinessday || '~Previous Business Day Balance'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ShieldChargeBase' || slabel(i)
								,chighestbalwithinqr || '~Highest Balance Within Quarter'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ShieldChargeBase' || slabel(i)
								,chighestbalwithinmonth || '~Highest Balance Within Month'
								,dialog.cmconfirm);
		
			dlg_tools.makedroplist(vpanel81
								  ,'AddToShieldBaseAmount' || slabel(i)
								  ,58
								  ,5
								  ,13
								  ,13
								  ,'+'
								  ,'Supplementary amount should be added to base amount');
			dialog.listaddrecord(vpanel81
								,'AddToShieldBaseAmount' || slabel(i)
								,cshiedlsupplamnt_zero || '~0~'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'AddToShieldBaseAmount' || slabel(i)
								,cshiedlsupplamnt_installment || '~Inst. Amnt~'
								,dialog.cmconfirm);
		
			dlg_tools.makedroplist(vpanel81
								  ,'ShieldCalcMethod' || slabel(i)
								  ,23
								  ,6
								  ,30
								  ,30
								  ,'Calculation Method:'
								  ,'Method by which credit shield should be calculated');
			dialog.listaddrecord(vpanel81
								,'ShieldCalcMethod' || slabel(i)
								,cbasedonfixedvalues || '~Based On Fixed Values'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ShieldCalcMethod' || slabel(i)
								,cbasedoncredlimitrange || '~Based On Credit Limit Range'
								,dialog.cmconfirm);
		
			dlg_tools.makedroplist(vpanel81
								  ,'ShieldType' || slabel(i)
								  ,23
								  ,7
								  ,30
								  ,30
								  ,'Charge Type:'
								  ,'Credit Shield Premium charge type');
			dialog.listaddrecord(vpanel81
								,'ShieldType' || slabel(i)
								,cshieldtotal || '~Charge as total of'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ShieldType' || slabel(i)
								,cshieldmax || '~Charge as maximum between'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ShieldType' || slabel(i)
								,cshieldmin || '~Charge as minimum between'
								,dialog.cmconfirm);
		
			dialog.inputmoney(vpanel81
							 ,'ShieldAmount' || slabel(i)
							 ,23
							 ,8
							 ,'Flat amount for credit shield premium'
							 ,'Flat amount:'
							 ,plen => 32);
			dialog.setvisible(vpanel81, 'ShieldAmount' || slabel(i), FALSE);
		
			dialog.inputmoney(vpanel81
							 ,'ShieldPrc' || slabel(i)
							 ,23
							 ,9
							 ,'Percentage value for credit shield premium'
							 ,'Percentage value:'
							 ,proundpos => 4
							 ,plen => 32);
			dialog.setvisible(vpanel81, 'ShieldPrc' || slabel(i), FALSE);
		
			dlg_tools.makedroplist(vpanel81
								  ,'RangeShieldAmount' || slabel(i)
								  ,23
								  ,8
								  ,30
								  ,30
								  ,'Flat amount:'
								  ,'Flat amount for credit shield premium is calculated depending on Credit Limit Range');
			dialog.setvisible(vpanel81, 'RangeShieldAmount' || slabel(i), FALSE);
		
			dlg_tools.makedroplist(vpanel81
								  ,'RangeShieldPrc' || slabel(i)
								  ,23
								  ,9
								  ,30
								  ,30
								  ,'Percentage value:'
								  ,'Percentage value for credit shield premium is calculated depending on Credit Limit Range');
			dialog.setvisible(vpanel81, 'RangeShieldPrc' || slabel(i), FALSE);
		
			dialog.bevel(vpanel81
						,1
						,10
						,74
						,2
						,dialog.bevel_frame
						,pcaption           => ''
						,panchor            => dialog.anchor_left + dialog.anchor_top);
		
			vpanel81 := dialog.page(vpanel, 'CS_REG_PREM' || i, 'Promotional premium amount');
			dialog.bevel(vpanel81
						,1
						,1
						,74
						,11
						,dialog.bevel_frame
						,pcaption           => 'Calculation Parameters'
						,panchor            => dialog.anchor_left + dialog.anchor_top);
		
			dlg_tools.makedroplist(vpanel81
								  ,'ProShieldType' || slabel(i)
								  ,22
								  ,2
								  ,25
								  ,25
								  ,'Type:'
								  ,'Credit Shield Premium charge type');
			dialog.listaddrecord(vpanel81
								,'ProShieldType' || slabel(i)
								,cshieldnotused || '~Not used'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ProShieldType' || slabel(i)
								,cshieldtotal || '~Charge as total of'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ProShieldType' || slabel(i)
								,cshieldmax || '~Charge as maximum between'
								,dialog.cmconfirm);
			dialog.listaddrecord(vpanel81
								,'ProShieldType' || slabel(i)
								,cshieldmin || '~Charge as minimum between'
								,dialog.cmconfirm);
		
			dialog.inputmoney(vpanel81
							 ,'ProShieldAmount' || slabel(i)
							 ,22
							 ,3
							 ,'Flat amount for overdue payment'
							 ,'Flat amount:'
							 ,plen => 32);
			dialog.inputmoney(vpanel81
							 ,'ProShieldPrc' || slabel(i)
							 ,22
							 ,4
							 ,'Percentage value for overdue payment'
							 ,'Percentage value:'
							 ,proundpos => 3
							 ,plen => 32);
			referencecalendar.inputcalendar(vpanel81
										   ,'ProShieldClnd' || slabel(i)
										   ,22
										   ,5
										   ,16
										   ,'Using Calendar:'
										   ,'Calendar of Promotional premium usage');
			dialog.inputinteger(vpanel81
							   ,'ProShieldCycles' || slabel(i)
							   ,22
							   ,6
							   ,'Number of cycles from contract opening to apply promotional premium rate to'
							   ,2
							   ,'Number of cycles:');
		
			dialog.bevel(vpanel81
						,1
						,8
						,74
						,2
						,dialog.bevel_frame
						,pcaption           => ''
						,panchor            => dialog.anchor_left + dialog.anchor_top);
		
			dialog.inputcheck(vpanel81
							 ,'ProShieldDoBothEntries' || slabel(i)
							 ,4
							 ,9
							 ,34
							 ,'Post entry for difference between Regular premium amount and Promotional premium amount'
							 ,'Post discount as separate entry');
		
			dialog.inputchar(vpanel
							,'ShieldAcc' || slabel(i)
							,24
							,12
							,27
							,'Premium Income account'
							,pcaption => 'Income Account:');
			dialog.setitempre(vpanel, 'ShieldAcc' || slabel(i), chandlername);
		
		END LOOP;
	
		makepage_scoring(vdialog);
	
		makepage_bankaccounts(vdialog);
	
		vmenu    := dialog.menu(vdialog);
		vsubmenu := dialog.submenu(vmenu, 'Dictionaries', 'Dictionaries');
	
		IF scurright_reference = c_cannothing
		THEN
			dialog.setenable(vdialog, vsubmenu, FALSE);
		
		ELSE
		
			contractstatereference.ref_states_addtomenu(vdialog
													   ,vsubmenu
													   ,saccumintaccmode <>
														cintaccmode_donotaccumulate
													   ,creadonly_ref);
			dialog.menuitem(vsubmenu
						   ,'SprDD'
						   ,'Dictionary of direct debit calculation profile'
						   ,0
						   ,0
						   ,'Dictionary of direct debit calculation profile'
						   ,chandlername);
			dialog.menuitem(vsubmenu
						   ,'HoliDays'
						   ,'Dictionary of calendars'
						   ,0
						   ,0
						   ,'Dictionary of calendars'
						   ,chandlername);
			contractcalendar.ref_addtomenu(vdialog, vsubmenu, creadonly_ref);
			dialog.menuitem(vsubmenu
						   ,'SprGroup'
						   ,'Dictionary of operations groups'
						   ,0
						   ,0
						   ,'Dictionary of operations groups'
						   ,chandlername);
			dialog.menuitem(vsubmenu
						   ,'SprPrc'
						   ,'Dictionary of interest rates'
						   ,0
						   ,0
						   ,'Dictionary of interest rates'
						   ,chandlername);
			dialog.menuitem(vsubmenu
						   ,'ProfDir'
						   ,'Dictionary of interest and fees calculation profiles'
						   ,0
						   ,0
						   ,'Dictionary of interest and fees calculation profiles'
						   ,chandlername);
			dialog.menuitem(vsubmenu
						   ,'MPDir'
						   ,'Dictionary of minimum payment calculation profiles'
						   ,0
						   ,0
						   ,'Dictionary of minimum payment calculation profiles'
						   ,chandlername);
			dialog.menuitem(vsubmenu
						   ,'ShieldRate'
						   ,'Dictionary of credit shield rates'
						   ,0
						   ,0
						   ,'Dictionary of credit shield rates'
						   ,chandlername);
			refloancoverage.addmenu_view(vdialog, vsubmenu, creadonly_ref);
			contractsql.addmenu(vsubmenu
							   ,vsubmenu
							   ,'SprRemark'
							   ,'Dictionary of entry full remark'
							   ,contractsql.ctype_funcchar
							   ,'DEFAULT'
							   ,creadonly_ref
							   ,NULL
							   ,TRUE
							   ,scontracttype
							   ,cpackagename);
			contractcommission.addmenu_refview(vdialog, vsubmenu, preadonly => creadonly_ref);
			custom_contractprofiles.ref_monthlyfees_addtomenu(vdialog, vsubmenu, creadonly_ref);
			goodsservicestax.ref_addtomenu(vdialog, vsubmenu, creadonly_ref);
			valuechangefee.ref_addtomenu(vdialog
										,vsubmenu
										,'Dictionary of limit change fee profiles'
										,creadonly_ref);
		END IF;
	
		dlg_typeparams_handler(dialog.wtitempre, vdialog, 'CORPMODE');
	
		dlg_typeparams_handler(dialog.wtitempre, vdialog, 'USECURDOM');
		dlg_typeparams_handler(dialog.wtitempre, vdialog, 'USECURINT');
	
		dialog.setdialogpre(vdialog, chandlername);
		dialog.setdialogvalid(vdialog, chandlername);
		dialog.setdialogpost(vdialog, chandlername);
	
		dlg_tools.startbuttondrawing(cdialogwidth, 2);
		dlg_tools.drawbutton(vdialog
							,cbtn_ok
							,'OK'
							,'Save changes and exit dialog'
							,cdialogheight - 2
							,dialog.cmok
							,creadonly_dlg
							,TRUE
							,dialog.anchor_bottom);
		dlg_tools.drawbutton(vdialog
							,cbtn_cancel
							,'Cancel'
							,'Cancel changes and exit dialog'
							,cdialogheight - 2
							,dialog.cmcancel
							,chandlername
							,panchor => dialog.anchor_bottom);
	
		t.leave(cmethodname);
		RETURN vdialog;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_typeparams_create;

	PROCEDURE dlg_typeparams_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR
	   ,pcmd      IN NUMBER := 0
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_TypeParams_Handler';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vfn             VARCHAR(250);
		vcorpmode       BOOLEAN;
		vclnd           NUMBER;
		vscoreid        NUMBER;
		vperiodcount    NUMBER;
		voverlimitcount NUMBER;
		vcount          NUMBER;
		vshieldcalctype NUMBER;
		vshieldtype     NUMBER;
		vwhentocharge   NUMBER;
		vmaxcl          NUMBER;
	
		vneedincomeacc  BOOLEAN;
		vcurrencyactive BOOLEAN;
		venable         BOOLEAN;
	
		vitemname     typeitemname;
		vitemcurrency VARCHAR(3);
		vcurrencyused types.arrbool;
		vlimititem    typeitemname;
	
		PROCEDURE createoperations IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_handler.cmethodname ||
												   '.CreateOperations';
		BEGIN
			t.enter(cmethodname);
		
			contracttools.addentry2reference('OVER_LIMIT_ON', '99', 'Over limit charge');
			contracttools.addentry2reference('OVER_LIMIT_OFF', '99', 'Over limit discharge');
		
			contracttools.addentry2reference('OVERDUE_FEE_ON', '99', 'Overdue fee charge');
			contracttools.addentry2reference('OVERLIMIT_FEE_ON', '99', 'Over-limit fee charge');
		
			contracttools.addentry2reference('STATEMENT_FEE_ON', '99', 'Statement fee charge');
		
			contracttools.addentry2reference('INSTALLMENT_ON'
											,'99'
											,'Debt transfer to installment account');
			contracttools.addentry2reference('INSTALLMENT_ON_FEE'
											,'99'
											,'Fee for transferring to installment');
			contracttools.addentry2reference('INSTALLMENT_OFF', '99', 'Installment repayment');
		
			contracttools.addentry2reference('CREDIT_SHIELD_PREMIUM'
											,'99'
											,'Credit shield premium');
			contracttools.addentry2reference('CREDIT_SHIELD_PREMIUM_DISC'
											,'99'
											,'Credit shield premium discount');
		
			contracttools.addentry2reference('MONTHLY_FEE_ON', '99', 'Monthly fee charge');
			contracttools.addentry2reference('MONTHLY_FEE_OFF', '99', 'Monthly fee waiver');
		
			contracttools.addentry2reference('INTEREST_BAL_TO_OFF'
											,'99'
											,'Move interest from balance to off-balance');
			contracttools.addentry2reference('INTEREST_OFF_TO_BAL'
											,'99'
											,'Move interest from off-balance to balance');
		
			contracttools.addentry2reference('OVERDUE_FEE_BAL_TO_OFF'
											,'99'
											,'Move overdue fee from balance to off-balance');
			contracttools.addentry2reference('OVERDUE_FEE_OFF_TO_BAL'
											,'99'
											,'Move overdue fee from off-balance to balance');
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.show('Error regestering entries!', cmethodname);
		END createoperations;
	
		PROCEDURE shielditems
		(
			pcurno IN NUMBER
		   ,psign  IN VARCHAR2
		) IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_handler.cmethodname ||
												   '.ShieldItems';
		
			vshieldcalctype NUMBER := dialog.getcurrentrecordnumber(pdialog
																   ,'ShieldCalcType' ||
																	slabel(pcurno)
																   ,'ItemId');
			vtypefillarray  referenceprchistory.typeitemfillarray;
			vwhentocharge   NUMBER;
			vbaseamountid   NUMBER;
			vlistrecno      NUMBER;
		
			vshieldamountrateid NUMBER;
			vshieldprcrateid    NUMBER;
		
		BEGIN
			s.say(cmethodname || ' ----<< BEGING  ');
			s.say(cmethodname || ' "Parameters : Currency (pCurNo)" = ' || pcurno ||
				  ', "Regular or Promotional Premium Amount (pSign)" = ' || psign ||
				  ', (null) - regular, pro - promotional');
		
			vshieldamountrateid := dialog.getcurrentrecordnumber(pdialog
																,'RangeShieldAmount' ||
																 slabel(pcurno)
																,'ItemId');
			vshieldprcrateid    := dialog.getcurrentrecordnumber(pdialog
																,'RangeShieldPrc' || slabel(pcurno)
																,'ItemId');
			s.say(cmethodname || '    vShieldAmountRateId = ' || vshieldamountrateid ||
				  ', vShieldPrcRateId = ' || vshieldprcrateid);
		
			IF psign IS NULL
			THEN
				vwhentocharge := nvl(dialog.getcurrentrecordnumber(pdialog
																  ,'ShieldWhenToCharge' ||
																   slabel(pcurno)
																  ,'ItemId')
									,cmonthlyeoc);
				s.say(cmethodname || '    vWhenToCharge = ' || vwhentocharge);
				s.say(cmethodname || '    vShieldCalcType = ' || vshieldcalctype);
				IF vshieldcalctype IN (cshieldstatic, cshieldstaticpost)
				THEN
					dialog.setenable(pdialog, 'ShieldWhenToCharge' || slabel(pcurno), TRUE);
					IF vwhentocharge = cshieldnotused
					THEN
						dialog.setenable(pdialog, 'ShieldCertainDay' || slabel(pcurno), FALSE);
						dialog.setenable(pdialog, 'ShieldChargeBase' || slabel(pcurno), FALSE);
						dialog.setenable(pdialog, 'AddToShieldBaseAmount' || slabel(pcurno), FALSE);
						dialog.setenable(pdialog, 'ShieldCalcMethod' || slabel(pcurno), FALSE);
						dialog.setenable(pdialog, 'ShieldType' || slabel(pcurno), FALSE);
						dialog.setenable(pdialog, 'ShieldAmount' || slabel(pcurno), FALSE);
						dialog.setenable(pdialog, 'ShieldPrc' || slabel(pcurno), FALSE);
						dialog.setenable(pdialog, 'RangeShieldAmount' || slabel(pcurno), FALSE);
						dialog.setenable(pdialog, 'RangeShieldPrc' || slabel(pcurno), FALSE);
						dialog.setenable(pdialog, 'ShieldAcc' || slabel(pcurno), FALSE);
						dialog.setcurrec(pdialog
										,'ProShieldType' || slabel(pcurno)
										,cshieldnotused);
						dialog.setenable(pdialog, 'ProShieldType' || slabel(pcurno), FALSE);
					ELSE
						dialog.setenable(pdialog, 'ShieldCertainDay' || slabel(pcurno), TRUE);
						dialog.setenable(pdialog, 'ShieldChargeBase' || slabel(pcurno), TRUE);
						dialog.setenable(pdialog, 'AddToShieldBaseAmount' || slabel(pcurno), TRUE);
						dialog.setenable(pdialog, 'ShieldCalcMethod' || slabel(pcurno), TRUE);
						dialog.setenable(pdialog, 'ShieldType' || slabel(pcurno), TRUE);
						dialog.setenable(pdialog, 'ShieldAmount' || slabel(pcurno), TRUE);
						dialog.setenable(pdialog, 'ShieldPrc' || slabel(pcurno), TRUE);
						dialog.setenable(pdialog, 'RangeShieldAmount' || slabel(pcurno), TRUE);
						dialog.setenable(pdialog, 'RangeShieldPrc' || slabel(pcurno), TRUE);
					
						vbaseamountid := dialog.getcurrentrecordnumber(pdialog
																	  ,'ShieldChargeBase' ||
																	   slabel(pcurno)
																	  ,'ItemId');
						s.say(cmethodname || '  vWhenToCharge||_||vBaseAmountID = ' ||
							  vwhentocharge || '_' || vbaseamountid);
						IF vwhentocharge NOT IN (cmonthlyeom, cqreom, cfirstsdafterqr)
						   AND vbaseamountid IN (chighestbalwithinmonth, chighestbalwithinqr)
						   OR vwhentocharge IN (cmonthlyeom, cqreom)
						   AND vwhentocharge || '_' || vbaseamountid IN
						   (cmonthlyeom || '_' || chighestbalwithinqr
								  ,cqreom || '_' || chighestbalwithinmonth)
						THEN
							dialog.setcurrecbyvalue(pdialog
												   ,'ShieldChargeBase' || slabel(pcurno)
												   ,'ITEMID'
												   ,ccurrentbalance);
							s.say(cmethodname || '  -info: ShieldChargeBase ' || slabel(pcurno) ||
								  ' was changed to "Current Balance"');
						END IF;
					
						IF vwhentocharge NOT IN (cmonthlyeom, cqreom, cfirstsdafterqr)
						THEN
							vlistrecno := dialog.getrecnobyvalue(pdialog
																,'ShieldChargeBase' ||
																 slabel(pcurno)
																,'ITEMID'
																,chighestbalwithinmonth);
							s.say(cmethodname || '   cHighestBalWithinMonth - (vListRecNo) = ' ||
								  vlistrecno);
							dialog.listdeleterecord(pdialog
												   ,'ShieldChargeBase' || slabel(pcurno)
												   ,vlistrecno);
						
							vlistrecno := dialog.getrecnobyvalue(pdialog
																,'ShieldChargeBase' ||
																 slabel(pcurno)
																,'ITEMID'
																,chighestbalwithinqr);
							s.say(cmethodname || '   cHighestBalWithinQR - (vListRecNo) = ' ||
								  vlistrecno);
							dialog.listdeleterecord(pdialog
												   ,'ShieldChargeBase' || slabel(pcurno)
												   ,vlistrecno);
						END IF;
					
						IF vwhentocharge = cmonthlyeom
						THEN
							vlistrecno := dialog.getrecnobyvalue(pdialog
																,'ShieldChargeBase' ||
																 slabel(pcurno)
																,'ITEMID'
																,chighestbalwithinqr);
							dialog.listdeleterecord(pdialog
												   ,'ShieldChargeBase' || slabel(pcurno)
												   ,vlistrecno);
						
							vlistrecno := dialog.getrecnobyvalue(pdialog
																,'ShieldChargeBase' ||
																 slabel(pcurno)
																,'ITEMID'
																,chighestbalwithinmonth);
							IF vlistrecno IS NULL
							THEN
								dialog.listaddrecord(pdialog
													,'ShieldChargeBase' || slabel(pcurno)
													,chighestbalwithinmonth ||
													 '~Highest Balance Within Month~'
													,dialog.cmconfirm);
							END IF;
						
						ELSIF vwhentocharge IN (cqreom, cfirstsdafterqr)
						THEN
							vlistrecno := dialog.getrecnobyvalue(pdialog
																,'ShieldChargeBase' ||
																 slabel(pcurno)
																,'ITEMID'
																,chighestbalwithinmonth);
							dialog.listdeleterecord(pdialog
												   ,'ShieldChargeBase' || slabel(pcurno)
												   ,vlistrecno);
						
							vlistrecno := dialog.getrecnobyvalue(pdialog
																,'ShieldChargeBase' ||
																 slabel(pcurno)
																,'ITEMID'
																,chighestbalwithinqr);
							IF vlistrecno IS NULL
							THEN
								dialog.listaddrecord(pdialog
													,'ShieldChargeBase' || slabel(pcurno)
													,chighestbalwithinqr ||
													 '~Highest Balance Within Quarter~'
													,dialog.cmconfirm);
							END IF;
						
						END IF;
					
					END IF;
				
					dialog.setenable(pdialog
									,'ShieldPLSQL' || slabel(pcurno)
									,vshieldcalctype <> cshieldstatic);
				
				ELSE
					dialog.setenable(pdialog, 'ShieldWhenToCharge' || slabel(pcurno), FALSE);
					dialog.setenable(pdialog, 'ShieldCertainDay' || slabel(pcurno), FALSE);
					dialog.setenable(pdialog, 'ShieldChargeBase' || slabel(pcurno), FALSE);
					dialog.setenable(pdialog, 'AddToShieldBaseAmount' || slabel(pcurno), FALSE);
					dialog.setenable(pdialog, 'ShieldCalcMethod' || slabel(pcurno), FALSE);
					dialog.setenable(pdialog, 'ShieldType' || slabel(pcurno), FALSE);
					dialog.setvisible(pdialog, 'ShieldAmount' || slabel(pcurno), TRUE);
					dialog.setenable(pdialog, 'ShieldAmount' || slabel(pcurno), FALSE);
					dialog.setvisible(pdialog, 'ShieldPrc' || slabel(pcurno), TRUE);
					dialog.setenable(pdialog, 'ShieldPrc' || slabel(pcurno), FALSE);
					dialog.setenable(pdialog, 'RangeShieldAmount' || slabel(pcurno), FALSE);
					dialog.setenable(pdialog, 'RangeShieldPrc' || slabel(pcurno), FALSE);
					dialog.setcurrec(pdialog, 'ProShieldType' || slabel(pcurno), cshieldnotused);
				
					IF vshieldcalctype = cshielddynamic
					THEN
						dialog.setcurrec(pdialog, 'ShieldType' || slabel(pcurno), cshieldnotused);
						dialog.setenable(pdialog, 'ShieldType' || slabel(pcurno), FALSE);
						dialog.setenable(pdialog, 'ShieldPLSQL' || slabel(pcurno), TRUE);
					ELSE
						dialog.setenable(pdialog, 'ShieldAcc' || slabel(pcurno), FALSE);
					END IF;
				END IF;
			
				IF dialog.getcurrentrecordnumber(pdialog
												,'ShieldWhenToCharge' || slabel(pcurno)
												,'ItemId') IN (cmonthlyonday, cqronday)
				   AND vshieldcalctype <> cshielddynamic
				THEN
					dialog.setenable(pdialog, 'ShieldCertainDay' || slabel(pcurno), TRUE);
				ELSE
					dialog.setenable(pdialog, 'ShieldCertainDay' || slabel(pcurno), FALSE);
				END IF;
			
				vtypefillarray.delete;
				vtypefillarray(1).pcategory := referenceprchistory.ccreditshieldrate;
				vtypefillarray(1).pno := NULL;
				IF dialog.getcurrentrecordnumber(pdialog
												,'ShieldCalcMethod' || slabel(pcurno)
												,'ItemId') = cbasedonfixedvalues
				   OR dialog.getcurrentrecordnumber(pdialog
												   ,'ShieldCalcMethod' || slabel(pcurno)
												   ,'ItemId') IS NULL
				THEN
					dialog.setvisible(pdialog, 'ShieldAmount' || slabel(pcurno), TRUE);
					dialog.setvisible(pdialog, 'ShieldPrc' || slabel(pcurno), TRUE);
					dialog.setvisible(pdialog, 'RangeShieldAmount' || slabel(pcurno), FALSE);
					dialog.setvisible(pdialog, 'RangeShieldPrc' || slabel(pcurno), FALSE);
				ELSE
					dialog.setvisible(pdialog, 'ShieldAmount' || slabel(pcurno), FALSE);
					dialog.setvisible(pdialog, 'ShieldPrc' || slabel(pcurno), FALSE);
					dialog.setvisible(pdialog, 'RangeShieldAmount' || slabel(pcurno), TRUE);
					referenceprchistory.fillitem(pdialog
												,'RangeShieldAmount' || slabel(pcurno)
												,referenceprchistory.cremain
												,referenceprchistory.ccreditshieldrate
												,NULL
												,vtypefillarray
												,pcurrentid => vshieldamountrateid);
					dialog.setvisible(pdialog, 'RangeShieldPrc' || slabel(pcurno), TRUE);
					referenceprchistory.fillitem(pdialog
												,'RangeShieldPrc' || slabel(pcurno)
												,referenceprchistory.cremain
												,referenceprchistory.ccreditshieldrate
												,NULL
												,vtypefillarray
												,pcurrentid => vshieldprcrateid);
				END IF;
			
				dialog.setitemattributies(pdialog
										 ,'Pro' || 'ShieldType' || slabel(pcurno)
										 ,dialog.selecton);
				shielditems(pcurno, 'Pro');
			ELSE
				IF dialog.getcurrentrecordnumber(pdialog
												,psign || 'ShieldType' || slabel(pcurno)
												,'ItemId') = cshieldnotused
				   OR vshieldcalctype = cshielddynamic
				THEN
					dialog.setitemattributies(pdialog
											 ,psign || 'ShieldAmount' || slabel(pcurno)
											 ,dialog.selectoff);
					dialog.setitemattributies(pdialog
											 ,psign || 'ShieldPrc' || slabel(pcurno)
											 ,dialog.selectoff);
					dialog.setitemattributies(pdialog
											 ,psign || 'ShieldClnd' || slabel(pcurno)
											 ,dialog.selectoff);
					dialog.setitemattributies(pdialog
											 ,psign || 'ShieldCycles' || slabel(pcurno)
											 ,dialog.selectoff);
					dialog.setitemattributies(pdialog
											 ,psign || 'ShieldDoBothEntries' || slabel(pcurno)
											 ,dialog.selectoff);
					IF vshieldcalctype = cshielddynamic
					   OR vshieldcalctype IS NULL
					THEN
						dialog.setcurrec(pdialog
										,psign || 'ShieldType' || slabel(pcurno)
										,cshieldnotused);
						dialog.setitemattributies(pdialog
												 ,psign || 'ShieldType' || slabel(pcurno)
												 ,dialog.selectoff);
					END IF;
				ELSE
					dialog.setitemattributies(pdialog
											 ,psign || 'ShieldAmount' || slabel(pcurno)
											 ,dialog.selecton);
					dialog.setitemattributies(pdialog
											 ,psign || 'ShieldPrc' || slabel(pcurno)
											 ,dialog.selecton);
					dialog.setitemattributies(pdialog
											 ,psign || 'ShieldClnd' || slabel(pcurno)
											 ,dialog.selecton);
					dialog.setitemattributies(pdialog
											 ,psign || 'ShieldCycles' || slabel(pcurno)
											 ,dialog.selecton);
					dialog.setitemattributies(pdialog
											 ,psign || 'ShieldDoBothEntries' || slabel(pcurno)
											 ,dialog.selecton);
				END IF;
			END IF;
		
			dialog.setenable(pdialog, 'ShieldAcc' || slabel(pcurno), vshieldcalctype IS NOT NULL);
		
			s.say(cmethodname || ' ---->> END  ');
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END shielditems;
	
		PROCEDURE fillscore
		(
			pcurnum IN NUMBER
		   ,pid     IN NUMBER := NULL
		) IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_handler.cmethodname ||
												   '.FillScore';
		BEGIN
			dialog.listclear(pdialog, 'ScoreProc' || slabel(pcurnum));
			FOR i IN 1 .. sscoreproc.count
			LOOP
				BEGIN
					SELECT scoreid
					INTO   vscoreid
					FROM   tcontractrevscore
					WHERE  branch = cbranch
					AND    contracttype = scontracttype
					AND    scoreprocid = sscoreproc(i).id
					AND    currencynumber = pcurnum;
				EXCEPTION
					WHEN no_data_found THEN
						vscoreid := NULL;
				END;
				dialog.listaddrecord(pdialog
									,'ScoreProc' || slabel(pcurnum)
									,service.iif(vscoreid IS NULL, ' ', '+') || '~' || sscoreproc(i).id || '~' ||
									 vscoreid || '~' || sscoreproc(i).name);
			END LOOP;
			IF pid IS NOT NULL
			THEN
				dialog.setcurrecbyvalue(pdialog, 'ScoreProc' || slabel(pcurnum), 'Id', pid);
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END;
	
		PROCEDURE savelimit
		(
			pdialog          IN NUMBER
		   ,plimitkind       IN PLS_INTEGER
		   ,pobjecttype      IN PLS_INTEGER
		   ,pownership       IN PLS_INTEGER
		   ,plimititemname   IN typeitemname
		   ,pparamsitemname  IN typeitemname
		   ,pcheckboxname    IN typeitemname
		   ,pcheckboxcomment IN VARCHAR2
		) IS
			cmethodname     CONSTANT typemethodname := dlg_typeparams_handler.cmethodname ||
													   '.SaveLimit';
			cparamsitemname CONSTANT typeitemname := upper('#' || pparamsitemname);
			vlimitrecord   contracttypelimits.typelimitrecord;
			vcheckboxvalue BOOLEAN;
		BEGIN
			t.enter(cmethodname, plimititemname);
		
			FOR i IN 1 .. 2
			LOOP
			
				IF dialog.getbool(pdialog, 'UseCur' || slabel(i))
				THEN
				
					vlimitrecord := contracttypelimits.getlimitsettings(scontracttype
																	   ,plimitkind
																	   ,pobjecttype
																	   ,pownership
																	   ,i
																	   ,c_noexception);
				
					contracttypelimits.dropbox_limitid_getvalue(pdialog
															   ,plimititemname
															   ,vlimitrecord);
				
					vlimitrecord.calcmethod := dialog.getcurrentrecordnumber(pdialog
																			,cparamsitemname ||
																			 'Type' || slabel(i)
																			,'ItemId');
				
					IF vlimitrecord.calcmethod = clmtnotdefined
					THEN
					
						vlimitrecord.percent    := NULL;
						vlimitrecord.flatamount := NULL;
					
						vcheckboxvalue := dialog.getbool(pdialog
														,cparamsitemname || 'IncrsByAllwOvl' ||
														 slabel(i));
						contractparams.savebool(contractparams.ccontracttype
											   ,scontracttype
											   ,pcheckboxname || slabel(i)
											   ,vcheckboxvalue
											   ,TRUE
											   ,pcheckboxcomment || sfulllabel(i));
					
					ELSE
					
						vlimitrecord.flatamount := dlg_tools.getnumber(pdialog
																	  ,cparamsitemname || 'Amount' ||
																	   slabel(i)
																	  ,'Flat amount'
																	  ,dlg_tools.cnum_nonnegative);
						vlimitrecord.percent    := dlg_tools.getnumber(pdialog
																	  ,cparamsitemname || 'Prc' ||
																	   slabel(i)
																	  ,'Percentage value'
																	  ,pminvalue => 0
																	  ,pmaxvalue => 100);
					
						nullifyparams(tblchar100(pcheckboxname)
									 ,contractparams.ccontracttype
									 ,scontracttype
									 ,slabel(i)
									 ,c_writelog);
					
					END IF;
				
					vlimitrecord.blockid := NULL;
				
					contracttypelimits.dropbox_limitid_save(vlimitrecord);
				
				END IF;
			
			END LOOP;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END savelimit;
	
		PROCEDURE saveacc2cardlinkparameters
		(
			pcurno        IN NUMBER
		   ,pcurrencyused IN BOOLEAN
		   ,pownership    IN PLS_INTEGER
		) IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_handler.cmethodname ||
												   '.SaveAcc2CardLinkParameters';
			vcaption   VARCHAR2(20) := CASE pownership
										   WHEN cco_primary THEN
											'Primary'
										   ELSE
											'Supplementary'
									   END;
			vownership VARCHAR2(3) := CASE pownership
										  WHEN cco_primary THEN
										   'PRI'
										  ELSE
										   'SUP'
									  END;
		BEGIN
			t.enter(cmethodname);
		
			IF pcurrencyused
			THEN
			
				contractparams.savedialognumber(pdialog
											   ,vownership || 'CardCalcLimitMax' || slabel(pcurno)
											   ,contractparams.ccontracttype
											   ,scontracttype
											   ,pisnull => TRUE
											   ,pwhitelog => TRUE
											   ,pparamname => vcaption ||
															  ' Card Calculated Limit maximum value for ' ||
															  sfulllabel(pcurno));
			
				IF contractparams.savedialogbool(pdialog
												,vownership || 'LimitBPUse' || slabel(pcurno)
												,contractparams.ccontracttype
												,scontracttype
												,pwhitelog => TRUE
												,pparamname => 'Increase Total Available Limit by Positive Balance for ' ||
															   sfulllabel(pcurno))
				THEN
					contractparams.savedialogfieldnumber(pdialog
														,vownership || 'CashLimitPBType' ||
														 slabel(pcurno)
														,contractparams.ccontracttype
														,scontracttype
														,pwhitelog => TRUE
														,pparamname => 'PB Impact to ' || vcaption ||
																	   ' Card Limit calculation for ' ||
																	   sfulllabel(pcurno));
				ELSE
					nullifyparams(tblchar100(vownership || 'CashLimitPBType')
								 ,contractparams.ccontracttype
								 ,scontracttype
								 ,slabel(pcurno)
								 ,c_writelog);
				END IF;
			
			ELSE
				nullifyparams(tblchar100(vownership || 'CardCalcLimitMax'
										,vownership || 'LimitBPUse'
										,vownership || 'CashLimitPBType')
							 ,contractparams.ccontracttype
							 ,scontracttype
							 ,slabel(pcurno)
							 ,c_writelog);
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END saveacc2cardlinkparameters;
	
		PROCEDURE toggleinstallmentspage(pitemend IN VARCHAR2 := NULL) IS
			cmethodname CONSTANT typemethodname := dlg_typeparams_handler.cmethodname ||
												   '.ToggleInstallmentsPage';
			vitemend VARCHAR2(3);
			venable  BOOLEAN;
		BEGIN
			t.enter(cmethodname, pitemend);
		
			FOR i IN 1 .. 2
			LOOP
			
				vitemend := nvl(pitemend, slabel(i));
			
				venable := dialog.getbool(pdialog, 'UseInst') AND
						   dialog.getbool(pdialog, 'UseCur' || vitemend);
			
				dialog.setchildenabled(dialog.idbyname(pdialog, 'PG_INST_' || vitemend || '_TYPES')
									  ,venable);
				dialog.setchildenabled(dialog.idbyname(pdialog
													  ,'PG_INST_' || vitemend || '_INSTONFEE')
									  ,venable);
				dialog.setchildenabled(dialog.idbyname(pdialog
													  ,'PG_INST_' || vitemend || '_INT2INST')
									  ,venable);
				dialog.setchildenabled(dialog.idbyname(pdialog
													  ,'PG_INST_' || vitemend || '_RESTRUCTURING')
									  ,venable);
			
				IF venable
				THEN
					dlg_typeparams_handler(dialog.wtitempre, pdialog, 'INSTONFEECALC' || vitemend);
					dlg_typeparams_handler(dialog.wtitempre, pdialog, 'INTTOINSTON' || vitemend);
					dlg_typeparams_handler(dialog.wtitempre
										  ,pdialog
										  ,'ALLOWRESTRUCTURE' || vitemend);
				END IF;
			
				EXIT WHEN pitemend IS NOT NULL;
			
			END LOOP;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END toggleinstallmentspage;
	
	BEGIN
		t.enter(cmethodname
			   ,'What = ' || pwhat || ', Dialog = ' || pdialog || ', ItemName = ' || pitemname ||
				', Cmd = ' || pcmd);
	
		vitemname     := upper(pitemname);
		vitemcurrency := substr(vitemname, -3);
		IF vitemcurrency IN ('DOM', 'INT')
		THEN
			vitemname := substr(vitemname, 1, length(vitemname) - 3);
		ELSE
			vitemcurrency := NULL;
		END IF;
	
		t.var('vItemName', vitemname);
		t.var('vItemEnd', vitemcurrency);
	
		IF pwhat = dialog.wtdialogpre
		THEN
		
			FOR i IN 1 .. 2
			LOOP
			
				contractparams.loaddialogfieldnumber(pdialog
													,'ShieldCalcType' || slabel(i)
													,contractparams.ccontracttype
													,NULL
													,NULL
													,pdefaultvalue => cshieldstatic);
				contractparams.loaddialogfieldnumber(pdialog
													,'ShieldWhenToCharge' || slabel(i)
													,contractparams.ccontracttype
													,NULL
													,NULL
													,pdefaultvalue => cshieldnotused);
			
				IF dialog.getbool(pdialog, 'UseCur' || slabel(i))
				THEN
				
					IF contractparams.loaddialogfieldnumber(pdialog
														   ,'ShieldType' || slabel(i)
														   ,contractparams.ccontracttype
														   ,NULL
														   ,NULL
														   ,1) <> 1
					   OR contractparams.loaddialogfieldnumber(pdialog
															  ,'ShieldWhenToCharge' || slabel(i)
															  ,contractparams.ccontracttype
															  ,NULL
															  ,NULL
															  ,cmonthlyeoc) <> cshieldnotused
					THEN
					
						IF contractparams.loaddialogfieldnumber(pdialog
															   ,'ProShieldType' || slabel(i)
															   ,contractparams.ccontracttype
															   ,NULL
															   ,NULL
															   ,1) <> 1
						THEN
							contractparams.loaddialognumber(pdialog
														   ,'ProShieldAmount' || slabel(i)
														   ,contractparams.ccontracttype);
							contractparams.loaddialognumber(pdialog
														   ,'ProShieldPrc' || slabel(i)
														   ,contractparams.ccontracttype);
							referencecalendar.setclndtodialog(pdialog
															 ,'ProShieldClnd' || slabel(i)
															 ,contractparams.loadnumber(contractparams.ccontracttype
																					   ,scontracttype
																					   ,'ProShieldClnd' ||
																						slabel(i)
																					   ,FALSE));
							IF contractparams.loaddialognumber(pdialog
															  ,'ProShieldCycles' || slabel(i)
															  ,contractparams.ccontracttype) IS NULL
							THEN
								dialog.putnumber(pdialog, 'ProShieldCycles' || slabel(i), 0);
							END IF;
							contractparams.loaddialogbool(pdialog
														 ,'ProShieldDoBothEntries' || slabel(i)
														 ,contractparams.ccontracttype);
						END IF;
					END IF;
				
					contractparams.loaddialogchar(pdialog
												 ,'ShieldAcc' || slabel(i)
												 ,contractparams.ccontracttype);
					contractparams.loaddialogfieldnumber(pdialog
														,'ShieldCalcType' || slabel(i)
														,contractparams.ccontracttype
														,pdefaultvalue => cshieldstatic);
					contractparams.loaddialogfieldnumber(pdialog
														,'ShieldWhenToCharge' || slabel(i)
														,contractparams.ccontracttype
														,pdefaultvalue => cmonthlyeoc);
					contractparams.loaddialogfieldnumber(pdialog
														,'ShieldChargeBase' || slabel(i)
														,contractparams.ccontracttype
														,pdefaultvalue => ccurrentbalance);
					contractparams.loaddialogfieldnumber(pdialog
														,'AddToShieldBaseAmount' || slabel(i)
														,contractparams.ccontracttype
														,pdefaultvalue => cshiedlsupplamnt_zero);
					contractparams.loaddialogfieldnumber(pdialog
														,'ShieldCalcMethod' || slabel(i)
														,contractparams.ccontracttype
														,pdefaultvalue => cbasedonfixedvalues);
					contractparams.loaddialogfieldnumber(pdialog
														,'ShieldType' || slabel(i)
														,contractparams.ccontracttype
														,pdefaultvalue => cshieldtotal);
					IF contractparams.loaddialogfieldnumber(pdialog
														   ,'ShieldWhenToCharge' || slabel(i)
														   ,contractparams.ccontracttype
														   ,NULL
														   ,NULL
														   ,cmonthlyeoc) IN
					   (cmonthlyonday, cqronday)
					THEN
						contractparams.loaddialognumber(pdialog
													   ,'ShieldCertainDay' || slabel(i)
													   ,contractparams.ccontracttype);
					END IF;
				
					shielditems(i, NULL);
					shielditems(i, 'Pro');
				
					IF contractparams.loaddialogfieldnumber(pdialog
														   ,'ShieldCalcMethod' || slabel(i)
														   ,contractparams.ccontracttype
														   ,NULL
														   ,NULL
														   ,1) = cbasedonfixedvalues
					THEN
						contractparams.loaddialognumber(pdialog
													   ,'ShieldAmount' || slabel(i)
													   ,contractparams.ccontracttype);
						contractparams.loaddialognumber(pdialog
													   ,'ShieldPrc' || slabel(i)
													   ,contractparams.ccontracttype);
					ELSE
						contractparams.loaddialogfieldchar(pdialog
														  ,'RangeShieldAmount' || slabel(i)
														  ,contractparams.ccontracttype);
						contractparams.loaddialogfieldchar(pdialog
														  ,'RangeShieldPrc' || slabel(i)
														  ,contractparams.ccontracttype);
					END IF;
				
				ELSE
					dialog.setcurrec(pdialog, 'ShieldType' || slabel(i), 1);
					dialog.setitemattributies(pdialog, 'ShieldType' || slabel(i), dialog.selectoff);
					dialog.setitemattributies(pdialog
											 ,'ShieldWhenToCharge' || slabel(i)
											 ,dialog.selectoff);
					dialog.setitemattributies(pdialog
											 ,'ShieldCertainDay' || slabel(i)
											 ,dialog.selectoff);
					dialog.setitemattributies(pdialog
											 ,'ShieldChargeBase' || slabel(i)
											 ,dialog.selectoff);
					dialog.setitemattributies(pdialog
											 ,'AddToShieldBaseAmount' || slabel(i)
											 ,dialog.selectoff);
					dialog.setitemattributies(pdialog
											 ,'ShieldCalcMethod' || slabel(i)
											 ,dialog.selectoff);
					shielditems(i, NULL);
					dialog.setenable(pdialog, 'ShieldCalcType' || slabel(i), FALSE);
					dialog.setenable(pdialog, 'ShieldPLSQL' || slabel(i), FALSE);
				
				END IF;
			
				fillscore(i);
			
			END LOOP;
		
		ELSIF pwhat = dialog.wtitempre
		THEN
		
			IF vitemname = 'USECUR'
			THEN
			
				vcurrencyactive := dialog.getbool(pdialog, pitemname);
			
				IF vcurrencyactive
				   AND (getcurrency(scontracttype, 'ItemDeposit' || vitemcurrency) IS NULL)
				THEN
					dialog.putbool(pdialog, pitemname, FALSE);
					dlg_tools.raisevalidateerror(pdialog
												,pitemname
												,'You need to set type for account <ITEMDEPOSIT' ||
												 vitemcurrency || '>~to use ' ||
												 lower(sfulllabel(getcurnobyvalue(vitemcurrency
																				 ,'DOM'
																				 ,'INT'))) ||
												 ' in the contract!');
				END IF;
			
				IF dialog.getbool(pdialog, 'UseCurDOM')
				   AND dialog.getbool(pdialog, 'UseCurINT')
				THEN
					dlg_tools.toggleitem(pdialog
										,'SwitchFromDualToOneCur'
										,TRUE
										,'Post all transactions on card account only. Used for aggregated limit only');
				ELSE
					dlg_tools.toggleitem(pdialog
										,'SwitchFromDualToOneCur'
										,FALSE
										,'The option is available only if both currencies are used in the contract');
					dialog.putbool(pdialog, 'SwitchFromDualToOneCur', FALSE);
				END IF;
			
				dlg_tools.setenabled(pdialog
									,tblchar100('Profile', 'MPProfile')
									,vitemcurrency
									,vcurrencyactive);
			
				dialog.setchildenabled(dialog.idbyname(pdialog, 'PG_DAF_' || vitemcurrency)
									  ,vcurrencyactive AND NOT dialog.getbool(pdialog, 'CORPMODE'));
			
				dialog.setchildenabled(dialog.idbyname(pdialog, 'PG_STATEMENT_' || vitemcurrency)
									  ,vcurrencyactive);
			
				IF vcurrencyactive
				THEN
					dlg_typeparams_handler(dialog.wtdialogvalid
										  ,pdialog
										  ,'StmntFeeCalcType' || vitemcurrency
										  ,dialog.cmconfirm);
				END IF;
			
				dialog.setchildenabled(dialog.idbyname(pdialog, 'PG_FEES_' || vitemcurrency)
									  ,vcurrencyactive);
			
				IF vcurrencyactive
				THEN
					dlg_typeparams_handler(dialog.wtdialogvalid
										  ,pdialog
										  ,'MonthlyFeeProf' || vitemcurrency
										  ,dialog.cmconfirm);
				END IF;
			
				dialog.setchildenabled(dialog.idbyname(pdialog
													  ,'PG_LIMITS_' || vitemcurrency || '_FEES')
									  ,vcurrencyactive);
				dialog.setchildenabled(dialog.idbyname(pdialog
													  ,'PG_LIMITS_' || vitemcurrency ||
													   '_ACCOUNTLIMITS')
									  ,vcurrencyactive);
				dialog.setchildenabled(dialog.idbyname(pdialog
													  ,'PG_LIMITS_' || vitemcurrency ||
													   '_PRICARDLIMIT')
									  ,vcurrencyactive);
				dialog.setchildenabled(dialog.idbyname(pdialog
													  ,'PG_LIMITS_' || vitemcurrency ||
													   '_SUPCARDLIMIT')
									  ,vcurrencyactive);
				contracttypelimits.page_limits_enable(pdialog
													 ,'PG_LIMITS_' || vitemcurrency ||
													  '_ADDACCLIMITS'
													 ,getcurnobyvalue(vitemcurrency
																	 ,slabel(1)
																	 ,slabel(2))
													 ,vcurrencyactive);
			
				IF vcurrencyactive
				THEN
				
					dlg_typeparams_handler(dialog.wtdialogvalid
										  ,pdialog
										  ,'#ACCCASHLIMITTYPE' || vitemcurrency
										  ,dialog.cmconfirm);
					dlg_typeparams_handler(dialog.wtdialogvalid
										  ,pdialog
										  ,'ACCOVERLIMITTYPE' || vitemcurrency
										  ,dialog.cmconfirm);
				
					dlg_typeparams_handler(dialog.wtdialogvalid
										  ,pdialog
										  ,'#PRICREDLIMITTYPE' || vitemcurrency
										  ,dialog.cmconfirm);
					dlg_typeparams_handler(dialog.wtdialogvalid
										  ,pdialog
										  ,'#PRICASHLIMITTYPE' || vitemcurrency
										  ,dialog.cmconfirm);
					dlg_typeparams_handler(dialog.wtitempre
										  ,pdialog
										  ,'PRILIMITBPUSE' || vitemcurrency);
				
					dlg_typeparams_handler(dialog.wtdialogvalid
										  ,pdialog
										  ,'#SUPCREDLIMITTYPE' || vitemcurrency
										  ,dialog.cmconfirm);
					dlg_typeparams_handler(dialog.wtdialogvalid
										  ,pdialog
										  ,'#SUPCASHLIMITTYPE' || vitemcurrency
										  ,dialog.cmconfirm);
					dlg_typeparams_handler(dialog.wtitempre
										  ,pdialog
										  ,'SUPLIMITBPUSE' || vitemcurrency);
				
				END IF;
			
				IF debtcollectoravailable
				THEN
					dialog.setchildenabled(dialog.idbyname(pdialog, 'PG_DC_' || vitemcurrency)
										  ,vcurrencyactive);
				END IF;
			
				contractcollection.setctsetupitemenabled(pdialog, vitemcurrency, vcurrencyactive);
			
				IF slinkschemasinst.count > 0
				THEN
					toggleinstallmentspage(vitemcurrency);
				END IF;
			
				dialog.setchildenabled(dialog.idbyname(pdialog, 'PG_SCORING_' || vitemcurrency)
									  ,vcurrencyactive);
			
				dialog.setchildenabled(dialog.idbyname(pdialog, 'PG_ACCOUNTS_' || vitemcurrency)
									  ,vcurrencyactive);
			
				IF vcurrencyactive
				THEN
				
					dialog.setcurrec(pdialog, 'ShieldType' || vitemcurrency, 1);
					dialog.setitemattributies(pdialog
											 ,'ShieldType' || vitemcurrency
											 ,dialog.selecton);
					dialog.setitemattributies(pdialog
											 ,'ShieldWhenToCharge' || vitemcurrency
											 ,dialog.selecton);
					IF dialog.getcurrentrecordnumber(pdialog
													,'ShieldWhenToCharge' || vitemcurrency
													,'ItemId') NOT IN (cmonthlyonday, cqronday)
					THEN
						dialog.setitemattributies(pdialog
												 ,'ShieldCertainDay' || vitemcurrency
												 ,dialog.selectoff);
					ELSE
						dialog.setitemattributies(pdialog
												 ,'ShieldCertainDay' || vitemcurrency
												 ,dialog.selecton);
					END IF;
					dialog.setitemattributies(pdialog
											 ,'ShieldChargeBase' || vitemcurrency
											 ,dialog.selecton);
					dialog.setitemattributies(pdialog
											 ,'AddToShieldBaseAmount' || vitemcurrency
											 ,dialog.selecton);
					dialog.setitemattributies(pdialog
											 ,'ShieldCalcMethod' || vitemcurrency
											 ,dialog.selecton);
					shielditems(getcurnobyvalue(vitemcurrency, 'DOM', 'INT'), NULL);
				
					dialog.setenable(pdialog, 'ShieldCalcType' || vitemcurrency, TRUE);
					dialog.setenable(pdialog, 'ShieldPLSQL' || vitemcurrency, TRUE);
				
				ELSE
				
					dialog.setcurrec(pdialog, 'ShieldType' || vitemcurrency, 1);
					dialog.setitemattributies(pdialog
											 ,'ShieldType' || vitemcurrency
											 ,dialog.selectoff);
					dialog.setitemattributies(pdialog
											 ,'ShieldWhenToCharge' || vitemcurrency
											 ,dialog.selectoff);
					dialog.setitemattributies(pdialog
											 ,'ShieldCertainDay' || vitemcurrency
											 ,dialog.selectoff);
					dialog.setitemattributies(pdialog
											 ,'ShieldChargeBase' || vitemcurrency
											 ,dialog.selectoff);
					dialog.setitemattributies(pdialog
											 ,'AddToShieldBaseAmount' || vitemcurrency
											 ,dialog.selectoff);
					dialog.setitemattributies(pdialog
											 ,'ShieldCalcMethod' || vitemcurrency
											 ,dialog.selectoff);
					shielditems(service.iif(vitemcurrency = 'DOM', 1, 2), NULL);
					dialog.setenable(pdialog, 'ShieldCalcType' || vitemcurrency, FALSE);
					dialog.setenable(pdialog, 'ShieldPLSQL' || vitemcurrency, FALSE);
				
				END IF;
			
			ELSIF vitemname = 'CORPMODE'
			THEN
			
				IF dialog.getbool(pdialog, 'CORPMODE')
				THEN
					dlg_tools.toggleitem(pdialog
										,'CalendarID'
										,FALSE
										,'In corporate mode, the calendar from the corporate contract type is used');
					contractlink.contracttypeitemenable(pdialog, 'LINK', TRUE);
					dialog.putchar(pdialog, 'CalendarID', NULL);
					dialog.setenable(pdialog, 'UseDAF', FALSE);
					dialog.putbool(pdialog, 'UseDAF', FALSE);
					dlg_typeparams_handler(dialog.wtitempre, pdialog, 'USEDAF');
				ELSE
					dlg_tools.toggleitem(pdialog
										,'CalendarID'
										,TRUE
										,'Select the billing cycles calendar to be used in contracts');
					contractlink.contracttypeitemenable(pdialog, 'LINK', FALSE);
					dlg_tools.setlastselecteditemvalue(pdialog, 'CalendarID');
					dialog.setenable(pdialog, 'UseDAF', TRUE);
				END IF;
			
				FOR i IN 1 .. 2
				LOOP
					dialog.setchildenabled(dialog.idbyname(pdialog, 'PG_DAF_' || slabel(i))
										  ,dialog.getbool(pdialog, 'UseCur' || slabel(i)) AND
										   NOT dialog.getbool(pdialog, 'CORPMODE'));
				END LOOP;
			
			ELSIF vitemname = 'USEDAF'
			THEN
				dlg_tools.setenabled(pdialog
									,tblchar100('DAFReport', 'OutPath')
									,dialog.getbool(pdialog, 'UseDAF'));
			
			ELSIF pitemname = 'OUTPATH'
			THEN
				vfn := term.filedialog('Enter path', FALSE, NULL, NULL, TRUE);
				IF vfn IS NOT NULL
				THEN
					dialog.putchar(pdialog, 'OutPath', vfn);
				END IF;
			
			ELSIF pitemname = 'STMNTPL_SQL'
			THEN
				IF dialog.exec(dynasqldlg.editdlg(contractparams.loadnumber(contractparams.ccontracttype
																		   ,scontracttype
																		   ,pitemname
																		   ,FALSE)
												 ,pcanedit => (scurright_contype = c_canmodify))) =
				   dialog.cmok
				THEN
					contractparams.savenumber(contractparams.ccontracttype
											 ,scontracttype
											 ,pitemname
											 ,dynasqldlg.geteditsqlcode);
				END IF;
			
			ELSIF substr(vitemname, -10) = 'LIMITBPUSE'
			THEN
				dlg_tools.toggleitem(pdialog
									,substr(pitemname, 1, 3) || 'CASHLIMITPBTYPE' || vitemcurrency
									,dialog.getbool(pdialog, pitemname)
									,'Positive balance Impact on Card Limit calculation'
									,'Parameter not enabled');
			
			ELSIF vitemname = 'USEINST'
			THEN
			
				dlg_tools.togglepagebycheckbox(pdialog, 'PG_INST_COMMON', pitemname);
			
				toggleinstallmentspage;
			
			ELSIF vitemname = 'INSTONFEECALC'
			THEN
				dlg_tools.togglepagebycheckbox(pdialog
											  ,'PG_INST_' || vitemcurrency || '_INSTONFEE'
											  ,pitemname);
			
			ELSIF vitemname = 'INTTOINSTON'
			THEN
				dlg_tools.togglepagebycheckbox(pdialog
											  ,'PG_INST_' || vitemcurrency || '_INT2INST'
											  ,pitemname);
			
			ELSIF vitemname = 'ALLOWRESTRUCTURE'
			THEN
				dlg_tools.togglepagebycheckbox(pdialog
											  ,'PG_INST_' || vitemcurrency || '_RESTRUCTURING'
											  ,pitemname);
			
			ELSIF vitemname = 'SHIELDPLSQL'
			THEN
				IF dialog.exec(dynasqldlg.editdlg(contractparams.loadnumber(contractparams.ccontracttype
																		   ,scontracttype
																		   ,pitemname
																		   ,FALSE)
												 ,pexample => cshieldblockexample
												 ,pcanedit => (scurright_contype = c_canmodify))) =
				   dialog.cmok
				THEN
					contractparams.savenumber(contractparams.ccontracttype
											 ,scontracttype
											 ,pitemname
											 ,dynasqldlg.geteditsqlcode);
				END IF;
			
			ELSIF vitemname = 'SCOREPROC'
			THEN
				SAVEPOINT spscoresetup;
				IF dialog.exec(scoresetupdialog(dialog.getcurrentrecordnumber(pdialog
																			 ,pitemname
																			 ,'Id')
											   ,getcurnobyvalue(vitemcurrency, 'DOM', 'INT')
											   ,dialog.getcurrentrecordnumber(pdialog
																			 ,pitemname
																			 ,'ScoreId')
											   ,(scurright_contype = c_canview))) = dialog.cmok
				THEN
					COMMIT;
					fillscore(getcurnobyvalue(vitemcurrency, 'DOM', 'INT')
							 ,dialog.getcurrentrecordnumber(pdialog, pitemname, 'Id'));
				ELSE
					ROLLBACK TO spscoresetup;
				END IF;
			
			ELSIF vitemname IN ('INCOMEACC'
							   ,'INCOMEACC_OFFBAL'
							   ,'TECHNICALACC'
							   ,'INCOMEACCOLF'
							   ,'INCOMEACCODF'
							   ,'INCOMEACCODF_OFFBAL'
							   ,'STMTFEEACC'
							   ,'BANKACCUMINTACC'
							   ,'INSTONFEEACC'
							   ,'MONTHLYFEEACC'
							   ,'INCACCLIMITCHANGEFEE'
							   ,'SHIELDACC')
			THEN
				dlg_tools.rundlg_selectaccount(pdialog
											  ,vitemname || vitemcurrency
											  ,finderselectaccount.accompany);
			
			ELSIF pitemname = 'SPRDD'
			THEN
				dialog.exec(contractddreference.referencedialog(scurright_reference = c_canview));
				contractddreference.refreshitem(pdialog, 'DAFProfileDOM');
				contractddreference.refreshitem(pdialog, 'DAFProfileINT');
			
			ELSIF pitemname = 'HOLIDAYS'
			THEN
				referencecalendar.startup(scurright_reference = c_canview);
			
			ELSIF pitemname = 'SPRGROUP'
			THEN
				dialog.exec(custom_contractprofiles.groupdialog(scurright_reference = c_canview));
			
			ELSIF pitemname = 'SPRPRC'
			THEN
				dialog.exec(referenceprchistory.maindialog(referenceprchistory.ccontracttype
														  ,NULL
														  ,FALSE
														  ,scurright_reference = c_canview));
			
			ELSIF pitemname = 'PROFDIR'
			THEN
				dialog.exec(custom_contractprofiles.profiledialog(scurright_reference = c_canview));
				FOR i IN 1 .. 2
				LOOP
					IF dialog.getbool(pdialog, 'UseCur' || slabel(i))
					THEN
						custom_contractprofiles.fillitem(pdialog
														,'Profile' || slabel(i)
														,getcurrency(scontracttype
																	,'ItemDeposit' || slabel(i)));
						contractparams.loaddialogfieldnumber(pdialog
															,'Profile' || slabel(i)
															,contractparams.ccontracttype
															,scontracttype);
					END IF;
				END LOOP;
			
			ELSIF pitemname = 'MPDIR'
			THEN
				dialog.exec(custom_contractprofiles.mpprofiledialog(scurright_reference =
																	c_canview));
				FOR i IN 1 .. 2
				LOOP
					IF dialog.getbool(pdialog, 'UseCur' || slabel(i))
					THEN
						custom_contractprofiles.fillitem(pdialog
														,'MPProfile' || slabel(i)
														,NULL
														,pmpprofile => TRUE);
						contractparams.loaddialogfieldnumber(pdialog
															,'MPProfile' || slabel(i)
															,contractparams.ccontracttype
															,scontracttype);
					END IF;
				END LOOP;
			
			ELSIF pitemname = upper('SHIELDRATE')
			THEN
				dialog.exec(referenceprchistory.maindialog(referenceprchistory.ccreditshieldrate
														  ,NULL
														  ,FALSE
														  ,scurright_reference = c_canview));
			
			END IF;
		
		ELSIF pwhat = dialog.wtdialogvalid
		THEN
		
			IF pcmd = dialog.cmconfirm
			THEN
			
				CASE vitemname
				
					WHEN 'OVDPERIODCALCMODE' THEN
						dlg_tools.element_datefromto_enable(pdialog
														   ,'OvdPeriodDates'
														   ,dlg_tools.getdroplistvalue(pdialog
																					  ,pitemname
																					  ,pdoexception => c_noexception) IN
															(covdcalc_frzwithrep
														   ,covdcalc_frzworep)
														   ,dlg_tools.getdroplistvalue(pdialog
																					  ,pitemname
																					  ,pdoexception => c_noexception) IN
															(covdcalc_frzwithrep
														   ,covdcalc_frzworep));
					
					WHEN 'STMTMODE' THEN
						dialog.setenable(pdialog
										,'StmtTrns'
										,dlg_tools.getdroplistvalue(pdialog
																   ,pitemname
																   ,pdoexception => c_noexception) IN
										 (2, 3, 4));
					
					WHEN 'STMNTFEECALCTYPE' THEN
						dlg_tools.setenabled(pdialog
											,tblchar100('StmntFeePrcnt'
													   ,'StmtFeeAmount'
													   ,'StmtFeeAcc')
											,vitemcurrency
											,dlg_tools.getdroplistvalue(pdialog
																	   ,pitemname
																	   ,pdoexception => c_noexception) <>
											 ccalctype_notcalc);
					
					WHEN 'MONTHLYFEEPROF' THEN
						dialog.setenable(pdialog
										,'MonthlyFeeAcc' || vitemcurrency
										,custom_contractprofiles.dropbox_monthlyfee_getvalue(pdialog
																							,pitemname
																							,c_noexception) IS NOT NULL);
					
					WHEN 'ACCOVERLIMITTYPE' THEN
						venable := nvl(dlg_tools.getdroplistvalue(pdialog
																 ,pitemname
																 ,pdoexception => c_noexception)
									  ,clmtnotdefined) <> clmtnotdefined;
						dlg_tools.toggleitem(pdialog
											,vlimititem || 'AccOverLimitAmount' || vitemcurrency
											,venable
											,'Account Allowed Overlimit flat amount value'
											,'Parameter not required for the current overlimit calculation mode');
						dlg_tools.toggleitem(pdialog
											,vlimititem || 'AccOverLimitPrc' || vitemcurrency
											,venable
											,'Account Allowed Overlimit percentage value from Account Credit Limit'
											,'Parameter not required for the current overlimit calculation mode');
					
					ELSE
					
						IF substr(vitemname, 1, 4) IN ('#ACC', '#PRI', '#SUP')
						THEN
						
							vlimititem := substr(vitemname, 1, 13);
						
							venable := nvl(dlg_tools.getdroplistvalue(pdialog
																	 ,pitemname
																	 ,pdoexception => c_noexception)
										  ,clmtnotdefined) <> clmtnotdefined;
						
							dlg_tools.toggleitem(pdialog
												,vlimititem || 'Amount' || vitemcurrency
												,venable
												,'Flat amount value for limit calculation'
												,'Parameter not required for the current limit calculation mode');
							dlg_tools.toggleitem(pdialog
												,vlimititem || 'Prc' || vitemcurrency
												,venable
												,'Percentage value for limit calculation'
												,'Parameter not required for the current limit calculation mode');
							dlg_tools.toggleitem(pdialog
												,vlimititem || 'IncrsByAllwOvl' || vitemcurrency
												,NOT venable
												,'Increase limit by allowed overlimit'
												,'Parameter not applicable for the current limit calculation mode');
						
						END IF;
					
						IF instr(pitemname, 'SHIELD') > 0
						THEN
							IF instr(pitemname, 'PRO') > 0
							THEN
								shielditems(service.iif(substr(pitemname, length(pitemname) - 2, 3) =
														'DOM'
													   ,1
													   ,2)
										   ,'Pro');
							ELSE
								shielditems(service.iif(substr(pitemname, length(pitemname) - 2, 3) =
														'DOM'
													   ,1
													   ,2)
										   ,NULL);
							END IF;
						END IF;
					
				END CASE;
			
				dialog.cancelclose(pdialog);
			
			ELSIF pcmd = dialog.cmok
			THEN
			
				BEGIN
				
					SAVEPOINT spsaveparams;
				
					IF NOT (dialog.getbool(pdialog, 'UseCurDOM') OR
						dialog.getbool(pdialog, 'UseCurINT'))
					THEN
						dlg_tools.raisevalidateerror(pdialog
													,'UseCurDOM'
													,'You should choose at least one account currency to use!');
					END IF;
				
					SELECT (SELECT COUNT(*)
							FROM   tcontractdelinqperiod
							WHERE  branch = cbranch
							AND    contracttype = scontracttype)
						  ,(SELECT COUNT(*)
						   FROM   tcontractdelinqoverlimit
						   WHERE  branch = cbranch
						   AND    contracttype = scontracttype)
						  ,(SELECT COUNT(*)
						   FROM   tcontractdelinqsetup
						   WHERE  branch = cbranch
						   AND    contracttype = scontracttype)
					INTO   vperiodcount
						  ,voverlimitcount
						  ,vcount
					FROM   dual;
				
					IF (vperiodcount = 0)
					   OR (voverlimitcount = 0)
					   OR (voverlimitcount * vperiodcount <> vcount)
					THEN
						dlg_tools.raisevalidateerror(pdialog
													,'StatusList'
													,'Incorrect delinquency states setup!');
					END IF;
				
					IF statementtype.getselectedtype(pdialog, 'StmtType') IS NULL
					THEN
						dlg_tools.raisevalidateerror(pdialog, 'StmtType', 'Select statement type!');
					END IF;
				
					IF nvl(statementfolder.getselectedfolder(pdialog, 'StmtFolder'), 0) = 0
					THEN
						dlg_tools.raisevalidateerror(pdialog
													,'StmtType'
													,'Select unload directory!');
					END IF;
				
					FOR i IN 1 .. 2
					LOOP
					
						vneedincomeacc := valuechangefee.dropbox_profile_getvalue(pdialog
																				 ,'LCF_AccCredLmtProfile' ||
																				  slabel(i)
																				 ,c_noexception) IS NOT NULL OR
										  valuechangefee.dropbox_profile_getvalue(pdialog
																				 ,'LCF_AccCredTempLmtProfile' ||
																				  slabel(i)
																				 ,c_noexception) IS NOT NULL;
						dlg_tools.validateaccountno(pdialog
												   ,'IncAccLimitChangeFee' || slabel(i)
												   ,'Limit change fee income account number'
												   ,pprohibitnull => vneedincomeacc);
					
						vmaxcl := dlg_tools.getnumber(pdialog
													 ,'AccCredLimitMax' || slabel(i)
													 ,'Account Credit Limit maximum value'
													 ,dlg_tools.cnum_nonnegative
													 ,FALSE);
					
						IF vmaxcl IS NOT NULL
						THEN
						
							IF vmaxcl = 0
							THEN
								dlg_tools.rundlg_yesno(pdialog
													  ,'Attention'
													  ,'Are you sure you want to set the maximum credit limit to 0?'
													  ,'AccCredLimitMax' || slabel(i));
							END IF;
						
							dlg_tools.validatenumber(pdialog
													,'AccCredLimitMin' || slabel(i)
													,'Account Credit Limit minimum value'
													,dlg_tools.cnum_nonnegative
													,FALSE
													,pmaxvalue => vmaxcl);
						
						END IF;
					
					END LOOP;
				
					vcorpmode := contractparams.savedialogbool(pdialog
															  ,'CorpMode'
															  ,contractparams.ccontracttype
															  ,scontracttype
															  ,TRUE
															  ,'Use corporate operation mode');
				
					IF vcorpmode
					THEN
						nullifyparams(tblchar100('CalendarID')
									 ,contractparams.ccontracttype
									 ,scontracttype
									 ,NULL
									 ,TRUE);
					ELSE
						contractcalendar.dropbox_calendar_save(pdialog
															  ,'CalendarID'
															  ,TRUE
															  ,'Cycles Calendar');
					END IF;
				
					contractparams.savedialogfieldnumber(pdialog
														,'ExchangeRate'
														,contractparams.ccontracttype
														,scontracttype
														,TRUE
														,'ItemId'
														,TRUE
														,'Exchange Rate');
				
					FOR i IN 1 .. 2
					LOOP
					
						vcurrencyused(i) := contractparams.savedialogbool(pdialog
																		 ,'UseCur' || slabel(i)
																		 ,contractparams.ccontracttype
																		 ,scontracttype
																		 ,c_writelog
																		 ,'Use ' || sfulllabel(i) ||
																		  ' Account');
					
						IF vcurrencyused(i)
						THEN
							contractparams.savedialogfieldnumber(pdialog
																,'Profile' || slabel(i)
																,contractparams.ccontracttype
																,scontracttype
																,pwhitelog => TRUE
																,pparamname => 'Calculation Profile for ' ||
																			   sfulllabel(i));
							contractparams.savedialogfieldnumber(pdialog
																,'MPProfile' || slabel(i)
																,contractparams.ccontracttype
																,scontracttype
																,pwhitelog => TRUE
																,pparamname => 'Minimum Payment Calculation Profile for ' ||
																			   sfulllabel(i));
						ELSE
							nullifyparams(tblchar100('Profile', 'MPProfile')
										 ,contractparams.ccontracttype
										 ,scontracttype
										 ,slabel(i)
										 ,c_writelog);
						END IF;
					
					END LOOP;
				
					contractparams.savedialogbool(pdialog
												 ,'SwitchFromDualToOneCur'
												 ,contractparams.ccontracttype
												 ,scontracttype
												 ,c_writelog
												 ,'Post Transactions on PO account only');
				
					contractparams.savedialogbool(pdialog
												 ,'IntLog'
												 ,contractparams.ccontracttype
												 ,scontracttype
												 ,c_writelog
												 ,'Save Interest Charging Log');
				
					contractstatereference.dropbox_state_save(pdialog
															 ,'DefState'
															 ,TRUE
															 ,'Default contract state');
					contractparams.savedialogfieldnumber(pdialog
														,'CardLock'
														,contractparams.ccontracttype
														,pwhitelog                    => TRUE
														,pparamname                   => 'Change card status at delinquency');
					contractparams.savedialogfieldnumber(pdialog
														,'ChangeAccStatus'
														,contractparams.ccontracttype
														,pwhitelog                    => TRUE
														,pparamname                   => 'Change account status at delinquency');
					contractparams.savedialogfieldnumber(pdialog
														,'ZeroMPCycles'
														,contractparams.ccontracttype
														,pwhitelog                    => TRUE
														,pparamname                   => 'Change no-overdue period calculation settings');
				
					CASE
					 contractparams.savedialogfieldnumber(pdialog
														 ,'OvdPeriodCalcMode'
														 ,contractparams.ccontracttype
														 ,pwhitelog                    => TRUE
														 ,pparamname                   => 'Overdue period calculation mode')
						WHEN covdcalc_normal THEN
							nullifyparams(tblchar100('OvdPeriodDateFrom', 'OvdPeriodDateTo')
										 ,contractparams.ccontracttype
										 ,scontracttype
										 ,NULL
										 ,c_writelog);
						WHEN covdcalc_frzwithrep THEN
							dlg_tools.element_datefromto_save(pdialog
															 ,'OvdPeriodDates'
															 ,contractparams.ccontracttype
															 ,scontracttype
															 ,'OvdPeriodDateFrom'
															 ,'OvdPeriodDateTo');
						WHEN covdcalc_frzworep THEN
							dlg_tools.element_datefromto_save(pdialog
															 ,'OvdPeriodDates'
															 ,contractparams.ccontracttype
															 ,scontracttype
															 ,'OvdPeriodDateFrom'
															 ,'OvdPeriodDateTo');
						ELSE
							NULL;
					END CASE;
				
					IF vcorpmode
					   OR (NOT dialog.getbool(pdialog, 'UseDAF'))
					THEN
						nullifyparams(tblchar100('UseDAF', 'DAFReport', 'OutPath')
									 ,contractparams.ccontracttype
									 ,scontracttype
									 ,NULL
									 ,c_writelog);
					ELSE
						contractparams.savedialogbool(pdialog
													 ,'UseDAF'
													 ,contractparams.ccontracttype
													 ,scontracttype
													 ,c_writelog
													 ,'Generate Debit Advice File automatically');
						contractparams.savedialogfieldchar(pdialog
														  ,'DAFReport'
														  ,contractparams.ccontracttype
														  ,scontracttype
														  ,FALSE
														  ,pidfield                     => 'ItemPackage'
														  ,pwhitelog                    => TRUE
														  ,pparamname                   => 'DAF Generation report');
						contractparams.savedialogchar(pdialog
													 ,'OutPath'
													 ,contractparams.ccontracttype
													 ,scontracttype
													 ,TRUE
													 ,c_writelog
													 ,'DAF Report Output Path');
					END IF;
				
					contractparams.savedialogbool(pdialog
												 ,'DAFGen4CType'
												 ,contractparams.ccontracttype
												 ,pwhitelog                    => TRUE
												 ,pparamname                   => 'Generate Debit Advice File for all Contracts of Contract Type');
				
					FOR i IN 1 .. 2
					LOOP
						IF (NOT vcorpmode)
						   AND vcurrencyused(i)
						THEN
							contractddreference.savedialogvalue(pdialog
															   ,'DAFProfile' || slabel(i)
															   ,contractddreference.ccontracttype
															   ,scontracttype
															   ,FALSE
															   ,'Direct Debit Amount calculation profile for ' ||
																sfulllabel(i));
						ELSE
							contractddreference.deletevalue(contractddreference.ccontracttype
														   ,scontracttype
														   ,'DAFProfile' || slabel(i));
						END IF;
					END LOOP;
				
					contractparams.savechar(contractparams.ccontracttype
										   ,scontracttype
										   ,'StmtType'
										   ,statementtype.getselectedtype(pdialog, 'StmtType')
										   ,c_writelog
										   ,'Statement type');
					contractparams.savenumber(contractparams.ccontracttype
											 ,scontracttype
											 ,'StmtFolder'
											 ,statementfolder.getselectedfolder(pdialog
																			   ,'StmtFolder')
											 ,c_writelog
											 ,'Unload directory');
				
					IF contractparams.savedialogfieldnumber(pdialog
														   ,'StmtMode'
														   ,contractparams.ccontracttype
														   ,scontracttype
														   ,pwhitelog                    => TRUE
														   ,pparamname                   => 'Automatic Statement Generation Mode') IN
					   (2, 3, 4)
					THEN
						contractparams.savedialognumber(pdialog
													   ,'StmtTrns'
													   ,contractparams.ccontracttype
													   ,scontracttype
													   ,pwhitelog                    => TRUE
													   ,pparamname                   => 'Minimum transactions number');
					ELSE
						nullifyparams(tblchar100('StmtTrns')
									 ,contractparams.ccontracttype
									 ,scontracttype
									 ,NULL
									 ,c_writelog);
					END IF;
				
					contractparams.savedialogchar(pdialog
												 ,'PromText'
												 ,contractparams.ccontracttype
												 ,scontracttype
												 ,TRUE
												 ,TRUE);
				
					FOR i IN 1 .. 2
					LOOP
					
						IF vcurrencyused(i)
						THEN
						
							IF contractparams.savedialogfieldnumber(pdialog
																   ,'StmntFeeCalcType' || slabel(i)
																   ,contractparams.ccontracttype
																   ,scontracttype
																   ,pwhitelog => TRUE
																   ,pparamname => 'Statement fee calculation type' ||
																				  sfulllabel(i)) =
							   ccalctype_notcalc
							THEN
								nullifyparams(tblchar100('StmntFeePrcnt'
														,'StmtFeeAmount'
														,'StmtFeeAcc')
											 ,contractparams.ccontracttype
											 ,scontracttype
											 ,slabel(i)
											 ,TRUE);
							ELSE
								contractparams.savedialognumber(pdialog
															   ,'StmntFeePrcnt' || slabel(i)
															   ,contractparams.ccontracttype
															   ,pwhitelog => TRUE
															   ,pparamname => 'Percentage for Statement fee calculation ' ||
																			  sfulllabel(i));
								contractparams.savedialognumber(pdialog
															   ,'StmtFeeAmount' || slabel(i)
															   ,contractparams.ccontracttype
															   ,pwhitelog => TRUE
															   ,pparamname => 'Statement fee value for ' ||
																			  sfulllabel(i));
								contractparams.savedialogaccount(pdialog
																,'StmtFeeAcc' || slabel(i)
																,contractparams.ccontracttype
																,pwhitelog => TRUE
																,pparamname => 'Statement fee account for ' ||
																			   sfulllabel(i));
							END IF;
						
						ELSE
							nullifyparams(tblchar100('StmntFeeCalcType')
										 ,contractparams.ccontracttype
										 ,scontracttype
										 ,slabel(i)
										 ,TRUE);
						END IF;
					
					END LOOP;
				
					FOR i IN 1 .. 2
					LOOP
					
						IF vcurrencyused(i)
						THEN
						
							IF custom_contractprofiles.dropbox_monthlyfee_save(pdialog
																			  ,'MonthlyFeeProf' ||
																			   slabel(i)
																			  ,TRUE
																			  ,'Monthly fee profile ID for  ' ||
																			   sfulllabel(i)) IS NOT NULL
							THEN
								contractparams.savedialogchar(pdialog
															 ,'MonthlyFeeAcc' || slabel(i)
															 ,contractparams.ccontracttype
															 ,pwhitelog => TRUE
															 ,pparamname => 'Monthly fee income account ' ||
																			sfulllabel(i));
							END IF;
						
							goodsservicestax.dropbox_profile_save(pdialog
																 ,'GSTProfile' || slabel(i)
																 ,TRUE
																 ,'GST profile ID for ' ||
																  sfulllabel(i));
						
						ELSE
							nullifyparams(tblchar100('MonthlyFeeProf'
													,'MonthlyFeeAcc'
													,'GSTProfile')
										 ,contractparams.ccontracttype
										 ,scontracttype
										 ,slabel(i)
										 ,TRUE);
						END IF;
					
					END LOOP;
				
					savelimit(pdialog
							 ,clk_cashlimit
							 ,referencelimit.objtype_account
							 ,cco_primary
							 ,'AccCashLimitID'
							 ,'AccCashLimit'
							 ,'AccIncrsCashLimByAllwOvl'
							 ,'Account cash limit is increased by allowable overlimit');
					savelimit(pdialog
							 ,clk_creditlimit
							 ,referencelimit.objtype_acc2card
							 ,cco_primary
							 ,'LinkCredLimitID'
							 ,'PriCredLimit'
							 ,'PriIncrsCrdLimByAllwOvl'
							 ,'Primary cards credit limit is increased by allowable overlimit');
					savelimit(pdialog
							 ,clk_cashlimit
							 ,referencelimit.objtype_acc2card
							 ,cco_primary
							 ,'LinkCashLimitID'
							 ,'PriCashLimit'
							 ,'PriIncrsCashLimByAllwOvl'
							 ,'Primary cards cash limit is increased by allowable overlimit');
					savelimit(pdialog
							 ,clk_creditlimit
							 ,referencelimit.objtype_acc2card
							 ,cco_supplementary
							 ,'LinkCredLimitID'
							 ,'SupCredLimit'
							 ,'SupIncrsCrdLimByAllwOvl'
							 ,'Supplementary cards credit limit is increased by allowable overlimit');
					savelimit(pdialog
							 ,clk_cashlimit
							 ,referencelimit.objtype_acc2card
							 ,cco_supplementary
							 ,'LinkCashLimitID'
							 ,'SupCashLimit'
							 ,'SupIncrsCashLimByAllwOvl'
							 ,'Supplementary cards cash limit is increased by allowable overlimit');
				
					FOR i IN 1 .. 2
					LOOP
					
						IF vcurrencyused(i)
						THEN
							contractparams.savedialogaccount(pdialog
															,'IncAccLimitChangeFee' || slabel(i)
															,contractparams.ccontracttype
															,scontracttype
															,NOT vneedincomeacc
															,TRUE
															,'Limit change fee income account number');
							valuechangefee.dropbox_profile_save(pdialog
															   ,'LCF_AccCredLmtProfile' ||
																slabel(i)
															   ,TRUE
															   ,'Fee profile for account credit limit change');
							valuechangefee.dropbox_profile_save(pdialog
															   ,'LCF_AccCredTempLmtProfile' ||
																slabel(i)
															   ,TRUE
															   ,'Fee profile for account temporary credit limit change');
						ELSE
							nullifyparams(tblchar100('IncAccLimitChangeFee'
													,'LCF_AccCredLmtProfile'
													,'LCF_AccCredTempLmtProfile')
										 ,contractparams.ccontracttype
										 ,scontracttype
										 ,slabel(i)
										 ,TRUE);
						END IF;
					
						IF vcurrencyused(i)
						THEN
						
							contractparams.savedialognumber(pdialog
														   ,'AccCredLimitMin' || slabel(i)
														   ,contractparams.ccontracttype
														   ,scontracttype
														   ,TRUE
														   ,pwhitelog => TRUE
														   ,pparamname => 'Min Credit Limit for ' ||
																		  sfulllabel(i));
							contractparams.savedialognumber(pdialog
														   ,'AccCredLimitMax' || slabel(i)
														   ,contractparams.ccontracttype
														   ,scontracttype
														   ,TRUE
														   ,pwhitelog => TRUE
														   ,pparamname => 'Max Credit Limit for ' ||
																		  sfulllabel(i));
							contractparams.savedialognumber(pdialog
														   ,'PBLimit' || slabel(i)
														   ,contractparams.ccontracttype
														   ,scontracttype
														   ,TRUE
														   ,pwhitelog => TRUE
														   ,pparamname => 'Positive Balance Limit for ' ||
																		  sfulllabel(i));
							contractparams.savedialogfieldnumber(pdialog
																,'AccCashLimitPBType' || slabel(i)
																,contractparams.ccontracttype
																,scontracttype
																,pwhitelog => TRUE
																,pparamname => 'PB amount usage in Acc Withdrawal Limit calculation for ' ||
																			   sfulllabel(i));
						
							IF contractparams.savedialogfieldnumber(pdialog
																   ,'AccOverLimitType' || slabel(i)
																   ,contractparams.ccontracttype
																   ,scontracttype
																   ,pwhitelog => TRUE
																   ,pparamname => 'Account Allowed Overlimit calcualtion type for ' ||
																				  sfulllabel(i)) =
							   clmtnotdefined
							THEN
								nullifyparams(tblchar100('AccOverLimitAmount', 'AccOverLimitPrc')
											 ,contractparams.ccontracttype
											 ,scontracttype
											 ,slabel(i)
											 ,TRUE);
							ELSE
								contractparams.savedialognumber(pdialog
															   ,'AccOverLimitAmount' || slabel(i)
															   ,contractparams.ccontracttype
															   ,scontracttype
															   ,pwhitelog => TRUE
															   ,pparamname => 'Account Allowed Overlimit flat amount value for ' ||
																			  sfulllabel(i));
								dlg_tools.validatenumber(pdialog
														,'AccOverLimitPrc' || slabel(i)
														,'Percentage value'
														,pminvalue => 0
														,pmaxvalue => 100);
								contractparams.savedialognumber(pdialog
															   ,'AccOverLimitPrc' || slabel(i)
															   ,contractparams.ccontracttype
															   ,scontracttype
															   ,pwhitelog => TRUE
															   ,pparamname => 'Account Allowed Overlimit percentage value for ' ||
																			  sfulllabel(i));
							END IF;
						
						ELSE
							nullifyparams(tblchar100('AccCredLimitMin'
													,'AccCredLimitMax'
													,'PBLimit'
													,'AccCashLimitPBType'
													,'AccOverLimitType'
													,'AccOverLimitAmount'
													,'AccOverLimitPrc')
										 ,contractparams.ccontracttype
										 ,scontracttype
										 ,slabel(i)
										 ,TRUE);
						END IF;
					
						saveacc2cardlinkparameters(i, vcurrencyused(i), cco_primary);
					
						saveacc2cardlinkparameters(i, vcurrencyused(i), cco_supplementary);
					
					END LOOP;
				
					IF debtcollectoravailable
					THEN
					
						contractdcsetup.savechargedialogvalues(pdialog, 'DC_Charge', scontracttype);
					
						FOR i IN 1 .. 2
						LOOP
							IF vcurrencyused(i)
							THEN
								contractdcsetup.savedialogvalues(pdialog
																,'DC_' || slabel(i)
																,scontracttype);
							ELSE
								contractdcsetup.deletedialogvalues(pdialog
																  ,'DC_' || slabel(i)
																  ,scontracttype);
							END IF;
						END LOOP;
					
					END IF;
				
					IF slinkschemasinst.count > 0
					THEN
					
						contractparams.savedialogbool(pdialog
													 ,'UseInst'
													 ,contractparams.ccontracttype
													 ,scontracttype
													 ,c_writelog
													 ,'Use Installments');
						contractparams.savedialogbool(pdialog
													 ,'InstAddPay'
													 ,contractparams.ccontracttype
													 ,scontracttype
													 ,c_writelog
													 ,'Add Installment Repayment Amount to Minimum Payment Amount');
						contractparams.savedialogbool(pdialog
													 ,'InstAddAcc'
													 ,contractparams.ccontracttype
													 ,scontracttype
													 ,c_writelog
													 ,'Add Acceleration Amount to Minimum Payment Amount');
						contractparams.savedialogbool(pdialog
													 ,'InstAddInt'
													 ,contractparams.ccontracttype
													 ,scontracttype
													 ,c_writelog
													 ,'Add Interest Amount to Minimum Payment Amount');
						contractparams.savedialogbool(pdialog
													 ,'InstDoOneEntry'
													 ,contractparams.ccontracttype
													 ,scontracttype
													 ,c_writelog
													 ,'Post Regular repayment amount and Credit interest amount as one entry');
						contractparams.savedialogfieldnumber(pdialog
															,'InstDepend'
															,contractparams.ccontracttype
															,scontracttype
															,pwhitelog                    => TRUE
															,pparamname                   => 'Installment indebtedness');
					
						FOR i IN 1 .. 2
						LOOP
						
							IF vcurrencyused(i)
							   AND
							   contractparams.savedialogbool(pdialog
															,'InstOnFeeCalc' || slabel(i)
															,contractparams.ccontracttype
															,pwhitelog => TRUE
															,pparamname => 'Whether IntallmentOn fee should be calculated')
							THEN
								contractcommission.dropbox_commission_save(pdialog
																		  ,'InstallmentOnFee' ||
																		   slabel(i)
																		  ,TRUE
																		  ,'"Installment On" fee calculation tariff');
								contractparams.savedialogaccount(pdialog
																,'InstOnFeeAcc' || slabel(i)
																,contractparams.ccontracttype
																,pwhitelog => TRUE
																,pparamname => '"Installment On" fee account for ' ||
																			   sfulllabel(i));
							ELSE
								nullifyparams(tblchar100('InstOnFeeCalc'
														,'InstallmentOnFee'
														,'InstOnFeeAcc')
											 ,contractparams.ccontracttype
											 ,scontracttype
											 ,slabel(i)
											 ,TRUE);
							END IF;
						
							IF vcurrencyused(i)
							   AND
							   contractparams.savedialogbool(pdialog
															,'IntToInstOn' || slabel(i)
															,contractparams.ccontracttype
															,scontracttype
															,TRUE
															,'Whether interest should be transferred to installment')
							THEN
								dlg_tools.element_datefromto_save(pdialog
																 ,'IntToInstPeriod' || slabel(i)
																 ,contractparams.ccontracttype
																 ,scontracttype
																 ,'IntToInstFrom' || slabel(i)
																 ,'IntToInstTo' || slabel(i)
																 ,pfromprohibitnull => FALSE
																 ,ptoprohibitnull => FALSE);
								contractlink.dropbox_linkedtypes_save(pdialog
																	 ,'IntToInstCT' || slabel(i)
																	 ,TRUE
																	 ,FALSE
																	 ,'Installment contract type to be used for new contracts');
							ELSE
								nullifyparams(tblchar100('IntToInstOn'
														,'IntToInstFrom'
														,'IntToInstTo'
														,'IntToInstCT')
											 ,contractparams.ccontracttype
											 ,scontracttype
											 ,slabel(i)
											 ,TRUE);
							END IF;
						
							IF vcurrencyused(i)
							   AND
							   contractparams.savedialogbool(pdialog
															,'AllowRestructure' || slabel(i)
															,contractparams.ccontracttype
															,scontracttype
															,TRUE
															,'Indicator of whether debt restructuring by transfer to installment is allowed')
							THEN
								contractlink.dropbox_linkedtypes_save(pdialog
																	 ,'DebtToInstCT' || slabel(i)
																	 ,TRUE
																	 ,FALSE
																	 ,'Installment contract type to be used for debt restructuring');
								dlg_tools.element_cardstateslist_save(pdialog
																	 ,'RestrCardStatesFrom' ||
																	  slabel(i)
																	 ,contractparams.ccontracttype
																	 ,scontracttype);
								dlg_tools.item_cardattributes_save(pdialog
																  ,'RestrCardStateTo' || slabel(i)
																  ,contractparams.ccontracttype
																  ,scontracttype
																  ,TRUE);
							ELSE
								nullifyparams(tblchar100('AllowRestructure'
														,'DebtToInstCT'
														,'RestrCardStatesFrom')
											 ,contractparams.ccontracttype
											 ,scontracttype
											 ,slabel(i)
											 ,TRUE);
								dlg_tools.item_cardattributes_nullify(contractparams.ccontracttype
																	 ,scontracttype
																	 ,'RestrCardStateTo' ||
																	  slabel(i));
							END IF;
						
						END LOOP;
					
					END IF;
				
					NULL;
				
					FOR i IN 1 .. 2
					LOOP
					
						IF vcurrencyused(i)
						THEN
						
							contractparams.savedialogaccount(pdialog
															,'IncomeAcc' || slabel(i)
															,contractparams.ccontracttype
															,scontracttype
															,pwhitelog => TRUE
															,pparamname => 'Interest income account for ' ||
																		   sfulllabel(i));
							contractparams.savedialogaccount(pdialog
															,'IncomeAcc_OffBal' || slabel(i)
															,contractparams.ccontracttype
															,scontracttype
															,pisnull => TRUE
															,pwhitelog => TRUE
															,pparamname => 'Off-balance interest income account for ' ||
																		   sfulllabel(i));
							contractparams.savedialogaccount(pdialog
															,'IncomeAccODF' || slabel(i)
															,contractparams.ccontracttype
															,scontracttype
															,pwhitelog => TRUE
															,pparamname => 'Overdue fee income account for ' ||
																		   sfulllabel(i));
							contractparams.savedialogaccount(pdialog
															,'IncomeAccODF_OffBal' || slabel(i)
															,contractparams.ccontracttype
															,scontracttype
															,pisnull => TRUE
															,pwhitelog => TRUE
															,pparamname => 'Off-balance overdue fee income account for ' ||
																		   sfulllabel(i));
							contractparams.savedialogaccount(pdialog
															,'IncomeAccOLF' || slabel(i)
															,contractparams.ccontracttype
															,scontracttype
															,pwhitelog => TRUE
															,pparamname => 'Over-limit fee income account for ' ||
																		   sfulllabel(i));
							contractparams.savedialogaccount(pdialog
															,'TechnicalAcc' || slabel(i)
															,contractparams.ccontracttype
															,scontracttype
															,pwhitelog => TRUE
															,pparamname => 'Technical account for ' ||
																		   sfulllabel(i));
						
							IF saccumintaccmode IN
							   (cintaccmode_intaccbalance, cintaccmode_intacctechnical)
							THEN
								contractparams.savedialogaccount(pdialog
																,'BankAccumIntAcc' || slabel(i)
																,contractparams.ccontracttype
																,scontracttype
																,pwhitelog => TRUE
																,pparamname => 'Bank accumulate interest account for ' ||
																			   sfulllabel(i));
							END IF;
						
						ELSE
						
							nullifyparams(tblchar100('IncomeAcc'
													,'IncomeAcc_OffBal'
													,'IncomeAccODF'
													,'IncomeAccODF_OffBal'
													,'IncomeAccOLF'
													,'TechnicalAcc')
										 ,contractparams.ccontracttype
										 ,scontracttype
										 ,slabel(i)
										 ,TRUE);
						
							IF saccumintaccmode IN
							   (cintaccmode_intaccbalance, cintaccmode_intacctechnical)
							THEN
								nullifyparams(tblchar100('BankAccumIntAcc')
											 ,contractparams.ccontracttype
											 ,scontracttype
											 ,slabel(i)
											 ,TRUE);
							END IF;
						
						END IF;
					
					END LOOP;
				
					contractparams.savedialogfieldnumber(pdialog
														,'ShieldChargeMode'
														,contractparams.ccontracttype
														,scontracttype
														,pwhitelog                    => TRUE
														,pparamname                   => 'Credit Shield Premium charge mode');
					contractparams.savenumber(contractparams.ccontracttype
											 ,scontracttype
											 ,'ShieldCalendar'
											 ,referencecalendar.getclndfromdialog(pdialog
																				 ,'ShieldCalendar')
											 ,TRUE
											 ,'Credit shield calendar');
				
					FOR i IN 1 .. 2
					LOOP
					
						IF vcurrencyused(i)
						THEN
						
							vshieldtype := contractparams.savedialogfieldnumber(pdialog
																			   ,'ShieldType' ||
																				slabel(i)
																			   ,contractparams.ccontracttype
																			   ,pwhitelog => TRUE
																			   ,pparamname => 'Credit Shield Premium charge type for ' ||
																							  sfulllabel(i));
						
							vwhentocharge := contractparams.savedialogfieldnumber(pdialog
																				 ,'ShieldWhenToCharge' ||
																				  slabel(i)
																				 ,contractparams.ccontracttype
																				 ,pwhitelog => TRUE
																				 ,pparamname => 'When Credit Shield Should Be Calculated ' ||
																								sfulllabel(i));
						
							IF vwhentocharge <> cshieldnotused
							THEN
								IF vwhentocharge IN (cmonthlyonday, cqronday)
								THEN
									IF nvl(dialog.getchar(pdialog, 'ShieldCertainDay' || slabel(i))
										  ,0) BETWEEN 1 AND 31
									THEN
										contractparams.savedialognumber(pdialog
																	   ,'ShieldCertainDay' ||
																		slabel(i)
																	   ,contractparams.ccontracttype
																	   ,pwhitelog => TRUE
																	   ,pparamname => 'Certain day when credit shield should be charged ' ||
																					  sfulllabel(i));
									ELSE
										dialog.goitem(pdialog, 'ShieldCertainDay' || slabel(i));
										htools.sethotmessage('Error!'
															,'Certain calculation day may take values from 1 to 31');
										RAISE contractparams.incorrectvalue;
									END IF;
								ELSE
									contractparams.deletevalue(contractparams.ccontracttype
															  ,scontracttype
															  ,'ShieldCertainDay' || slabel(i));
								END IF;
								contractparams.savedialogfieldnumber(pdialog
																	,'ShieldChargeBase' ||
																	 slabel(i)
																	,contractparams.ccontracttype
																	,pwhitelog => TRUE
																	,pparamname => 'Base Amount on which credit shield should be charged ' ||
																				   sfulllabel(i));
								contractparams.savedialogfieldnumber(pdialog
																	,'AddToShieldBaseAmount' ||
																	 slabel(i)
																	,contractparams.ccontracttype
																	,pwhitelog => TRUE
																	,pparamname => 'Supplementary amount should be added to credit shield base amount ' ||
																				   sfulllabel(i));
								contractparams.savedialogfieldnumber(pdialog
																	,'ShieldCalcMethod' ||
																	 slabel(i)
																	,contractparams.ccontracttype
																	,pwhitelog => TRUE
																	,pparamname => 'Method by which credit shield should be calculated ' ||
																				   sfulllabel(i));
							
								IF dialog.getcurrentrecordnumber(pdialog
																,'ShieldCalcMethod' || slabel(i)
																,'ItemId') = cbasedonfixedvalues
								THEN
									contractparams.savedialognumber(pdialog
																   ,'ShieldAmount' || slabel(i)
																   ,contractparams.ccontracttype
																   ,pwhitelog => TRUE
																   ,pparamname => 'Flat amount for credit shield premium for ' ||
																				  sfulllabel(i));
									contractparams.savedialognumber(pdialog
																   ,'ShieldPrc' || slabel(i)
																   ,contractparams.ccontracttype
																   ,pwhitelog => TRUE
																   ,pparamname => 'Percentage value for credit shield premium for ' ||
																				  sfulllabel(i));
									contractparams.deletevalue(contractparams.ccontracttype
															  ,scontracttype
															  ,'RangeShieldAmount' || slabel(i));
									contractparams.deletevalue(contractparams.ccontracttype
															  ,scontracttype
															  ,'RangeShieldPrc' || slabel(i));
								ELSE
									contractparams.savedialogfieldchar(pdialog
																	  ,'RangeShieldAmount' ||
																	   slabel(i)
																	  ,contractparams.ccontracttype
																	  ,pwhitelog => TRUE
																	  ,pparamname => 'Flat amount for credit shield premium calculated depending on Credit Limit Range ' ||
																					 sfulllabel(i));
									contractparams.savedialogfieldchar(pdialog
																	  ,'RangeShieldPrc' ||
																	   slabel(i)
																	  ,contractparams.ccontracttype
																	  ,pwhitelog => TRUE
																	  ,pparamname => 'Percentage value for credit shield premium calculated depending on Credit Limit Range ' ||
																					 sfulllabel(i));
									contractparams.deletevalue(contractparams.ccontracttype
															  ,scontracttype
															  ,'ShieldAmount' || slabel(i));
									contractparams.deletevalue(contractparams.ccontracttype
															  ,scontracttype
															  ,'ShieldPrc' || slabel(i));
								END IF;
							
								IF contractparams.savedialogfieldnumber(pdialog
																	   ,'ProShieldType' ||
																		slabel(i)
																	   ,contractparams.ccontracttype
																	   ,pwhitelog => TRUE
																	   ,pparamname => 'Promotional Credit Shield Premium charge type for ' ||
																					  sfulllabel(i)) <> 1
								THEN
									contractparams.savedialognumber(pdialog
																   ,'ProShieldAmount' || slabel(i)
																   ,contractparams.ccontracttype
																   ,pwhitelog => TRUE
																   ,pparamname => 'Promotional Flat amount for credit shield premium for ' ||
																				  sfulllabel(i));
									contractparams.savedialognumber(pdialog
																   ,'ProShieldPrc' || slabel(i)
																   ,contractparams.ccontracttype
																   ,pwhitelog => TRUE
																   ,pparamname => 'Promotional Percentage value for credit shield premium for ' ||
																				  sfulllabel(i));
								
									vclnd := referencecalendar.getclndfromdialog(pdialog
																				,'ProShieldClnd' ||
																				 slabel(i));
									IF vclnd IS NULL
									THEN
										dialog.goitem(pdialog, 'ProShieldClnd' || slabel(i));
										RAISE contractparams.valuenotexists;
									END IF;
									contractparams.savenumber(contractparams.ccontracttype
															 ,scontracttype
															 ,'ProShieldClnd' || slabel(i)
															 ,vclnd
															 ,pwhitelog => TRUE
															 ,pparamname => 'Id of Promotional Premium Usage Calendar for ' ||
																			sfulllabel(i));
									contractparams.savedialognumber(pdialog
																   ,'ProShieldCycles' || slabel(i)
																   ,contractparams.ccontracttype
																   ,pwhitelog => TRUE
																   ,pparamname => 'Number of cycles from contract opening of promotional premium usage for ' ||
																				  sfulllabel(i));
									contractparams.savedialogbool(pdialog
																 ,'ProShieldDoBothEntries' ||
																  slabel(i)
																 ,contractparams.ccontracttype
																 ,pwhitelog => TRUE
																 ,pparamname => 'Do both shield premium and shield premium promotional discount for ' ||
																				sfulllabel(i));
								ELSE
									nullifyparams(tblchar100('ProShieldAmount'
															,'ProShieldPrc'
															,'ProShieldClnd'
															,'ProShieldCycles'
															,'ProShieldDoBothEntries')
												 ,contractparams.ccontracttype
												 ,scontracttype
												 ,slabel(i)
												 ,TRUE);
								END IF;
							
							ELSE
								nullifyparams(tblchar100('ShieldAmount'
														,'ShieldPrc'
														,'ProShieldType'
														,'ProShieldAmount'
														,'ProShieldPrc'
														,'ProShieldClnd'
														,'ProShieldCycles'
														,'ProShieldDoBothEntries'
														,'ShieldCertainDay'
														,'ShieldChargeBase'
														,'AddToShieldBaseAmount'
														,'ShieldCalcMethod'
														,'RangeShieldAmount'
														,'RangeShieldPrc')
											 ,contractparams.ccontracttype
											 ,scontracttype
											 ,slabel(i)
											 ,TRUE);
							END IF;
						
							vshieldcalctype := contractparams.savedialogfieldnumber(pdialog
																				   ,'ShieldCalcType' ||
																					slabel(i)
																				   ,contractparams.ccontracttype
																				   ,pwhitelog => TRUE
																				   ,pparamname => 'Credit Shield calculation type ' ||
																								  sfulllabel(i));
							IF NOT
								(vshieldcalctype = cshieldstatic AND vwhentocharge = cshieldnotused)
							THEN
								contractparams.savedialogaccount(pdialog
																,'ShieldAcc' || slabel(i)
																,contractparams.ccontracttype
																,pwhitelog => TRUE
																,pparamname => 'Premium income account for ' ||
																			   sfulllabel(i));
							END IF;
						
						ELSE
							nullifyparams(tblchar100('ShieldType'
													,'ShieldWhenToCharge'
													,'ShieldCertainDay'
													,'ShieldChargeBase'
													,'AddToShieldBaseAmount'
													,'ShieldCalcMethod'
													,'RangeShieldAmount'
													,'RangeShieldPrc'
													,'ShieldAmount'
													,'ShieldPrc'
													,'ProShieldType'
													,'ProShieldAmount'
													,'ProShieldPrc'
													,'ProShieldClnd'
													,'ShieldAcc'
													,'ProShieldCycles'
													,'ProShieldDoBothEntries'
													,'ShieldCalcType')
										 ,contractparams.ccontracttype
										 ,scontracttype
										 ,slabel(i)
										 ,TRUE);
						END IF;
					
					END LOOP;
				
					createoperations;
				
				EXCEPTION
					WHEN dlg_tools.validate_error THEN
						ROLLBACK TO spsaveparams;
					WHEN contractparams.valuenotexists THEN
						dialog.sethothint(pdialog, 'Value must be specified ');
						s.say(cmethodname || '  Value must be specified: ' || SQLERRM || ' ' ||
							  dbms_utility.format_error_backtrace);
						ROLLBACK TO spsaveparams;
						dialog.cancelclose(pdialog);
						RETURN;
					WHEN contractparams.incorrectvalue THEN
						dialog.sethothint(pdialog, 'Incorrect value');
						s.say(cmethodname || '  Incorrect value: ' || SQLERRM || ' ' ||
							  dbms_utility.format_error_backtrace);
						ROLLBACK TO spsaveparams;
						dialog.cancelclose(pdialog);
						RETURN;
					WHEN contractparams.accountnotexists THEN
						dialog.sethothint(pdialog, 'Incorrect account number');
						s.say(cmethodname || '  Incorrect account number: ' || SQLERRM || ' ' ||
							  dbms_utility.format_error_backtrace);
						ROLLBACK TO spsaveparams;
						dialog.cancelclose(pdialog);
						RETURN;
					WHEN OTHERS THEN
						err.seterror(SQLCODE, cmethodname);
						s.say(cmethodname || '  Other errors: ' || SQLERRM || ' ' ||
							  dbms_utility.format_error_backtrace);
						service.sayerr(pdialog, 'Error');
						dialog.goitem(pdialog, 'Cancel');
						dialog.cancelclose(pdialog);
						ROLLBACK TO spsaveparams;
						RETURN;
				END;
				COMMIT;
			END IF;
		END IF;
	EXCEPTION
		WHEN dlg_tools.validate_error THEN
			NULL;
		WHEN OTHERS THEN
			error.show(pwhere => cmethodname);
			dialog.goitem(pdialog, 'Cancel');
	END dlg_typeparams_handler;

	FUNCTION getsetupdialog(pcontracttype IN NUMBER) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetSetupDialog';
		vresult NUMBER := 0;
	BEGIN
		t.enter(cmethodname, pcontracttype);
	
		IF scurright_contype = c_cannothing
		THEN
			htools.showmessage('Attention'
							  ,'Not enough privileges to view contract type parameters!');
		ELSE
			vresult := dlg_typeparams_create(pcontracttype);
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getsetupdialog;

	FUNCTION dlg_managecard_create
	(
		pcardrecord IN apitypes.typecardrecord
	   ,pautomode   IN BOOLEAN
	) RETURN NUMBER IS
		cmethodname  CONSTANT typemethodname := cpackagename || '.Dlg_ManageCard_Create';
		chandlername CONSTANT typemethodname := cpackagename || '.Dlg_ManageCard_Handler';
	
		c_dialogwidth  CONSTANT NUMBER := 36;
		c_dialogheight CONSTANT NUMBER := 9;
	
		vdialog NUMBER;
	
	BEGIN
		t.enter(cmethodname);
	
		vdialog := dialog.new('Manage card ' || masktodialog(pcardrecord)
							 ,0
							 ,0
							 ,c_dialogwidth
							 ,c_dialogheight
							 ,pextid => cmethodname);
	
		dialog.hiddenchar(vdialog, citem_pan, pcardrecord.pan);
		dialog.hiddennumber(vdialog, citem_mbr, pcardrecord.mbr);
	
		dialog.hiddennumber(vdialog, citem_state, pcardrecord.a4mstat);
		dialog.hiddenchar(vdialog, citem_status, pcardrecord.pcstat);
	
		dialog.bevel(vdialog, 1, 1, c_dialogwidth - 1, 3, dialog.bevel_frame);
	
		dialog.inputcheck(vdialog, citem_useautomode, 3, 1, 16, 'Use auto mode', 'Use auto mode');
		dialog.putbool(vdialog, citem_useautomode, pautomode);
		dialog.setitempost(vdialog, citem_useautomode, chandlername);
	
		dlg_tools.item_cardattributes_create(vdialog, citem_cardattributes, 16, 2, FALSE);
	
		dialog.inputcheck(vdialog
						 ,citem_changeonline
						 ,3
						 ,5
						 ,21
						 ,'Change cards attributes in TWO at once'
						 ,'Apply changes online');
		dialog.putbool(vdialog, citem_changeonline, TRUE);
	
		dlg_managecard_handler(dialog.wt_itempost, vdialog, citem_useautomode, 0);
	
		dlg_tools.startbuttondrawing(c_dialogwidth, 2);
		dlg_tools.drawbutton(vdialog
							,cbtn_ok
							,'OK'
							,'Save changes and exit dialog'
							,c_dialogheight - 2
							,dialog.cmok
							,pdefault => TRUE);
		dlg_tools.drawbutton(vdialog
							,cbtn_cancel
							,'Cancel'
							,'Cancel changes and exit dialog'
							,c_dialogheight - 2
							,dialog.cmcancel);
	
		dialog.setdialogvalid(vdialog, chandlername);
	
		t.leave(cmethodname);
		RETURN vdialog;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			dialog.destroy(vdialog);
			error.save(cmethodname);
			RAISE;
	END dlg_managecard_create;

	FUNCTION dlg_managecard_getdata
	(
		pdialog        IN NUMBER
	   ,ocardrecord    OUT NOCOPY apitypes.typecardrecord
	   ,oprocessonline OUT BOOLEAN
	   ,ouseautomode   OUT BOOLEAN
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_ManageCard_GetData';
	BEGIN
		t.enter(cmethodname);
	
		ocardrecord.pan := dlg_tools.getchar(pdialog, citem_pan);
		ocardrecord.mbr := dlg_tools.getnumber(pdialog, citem_mbr);
		oprocessonline  := dlg_tools.getbool(pdialog, citem_changeonline);
		ouseautomode    := dlg_tools.getbool(pdialog, citem_useautomode);
		dlg_tools.item_cardattributes_get(pdialog
										 ,citem_cardattributes
										 ,ocardrecord.a4mstat
										 ,ocardrecord.pcstat);
	
		t.leave(cmethodname, htools.b2s(TRUE));
		RETURN TRUE;
	EXCEPTION
		WHEN dlg_tools.validate_error THEN
			t.leave(cmethodname, htools.b2s(FALSE));
			RETURN FALSE;
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_managecard_getdata;

	PROCEDURE dlg_managecard_save
	(
		pdialog        IN NUMBER
	   ,pcardrecord    IN apitypes.typecardrecord
	   ,pprocessonline IN BOOLEAN
	   ,puseautomode   IN BOOLEAN
	) IS
		PRAGMA AUTONOMOUS_TRANSACTION;
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_ManageCard_Save';
	
		vprocessoffline BOOLEAN := TRUE;
		vonlineerror    BOOLEAN := FALSE;
		vconnected      BOOLEAN := FALSE;
	
	BEGIN
		t.enter(cmethodname);
	
		IF pprocessonline
		   AND (pcardrecord.pcstat IS NOT NULL)
		THEN
		
			BEGIN
			
				remoteonline.logon;
				vconnected := TRUE;
				remoteonline.begintransaction;
			
				remoteonline.setcardstatus(pcardrecord.pan, pcardrecord.mbr, pcardrecord.pcstat);
			
			EXCEPTION
				WHEN OTHERS THEN
				
					closetwo(vconnected, FALSE);
				
					vonlineerror := TRUE;
			END;
		
		END IF;
	
		IF vonlineerror
		THEN
		
			vprocessoffline := htools.ask('Warning'
										 ,'Error when changing card status in TWO:~~' ||
										  error.gettext || '.~~Save changes in TWCMS only?');
		
			error.clear;
		END IF;
	
		IF vprocessoffline
		THEN
		
			BEGIN
			
				changecardattributes(getcardrecord(pcardrecord.pan, pcardrecord.mbr)
									,pcardrecord.a4mstat
									,pcardrecord.pcstat
									,NULL
									,csetcardstatus
									,c_norollback
									,puseautomode
									,pprocessonline AND (NOT vonlineerror));
			
				closetwo(vconnected, TRUE);
			
				COMMIT;
			
			EXCEPTION
				WHEN OTHERS THEN
				
					ROLLBACK;
				
					closetwo(vconnected, FALSE);
				
					error.save(cmethodname);
				
					htools.showmessage('Error', error.gettext);
				
					error.clear;
				
					dialog.cancelclose(pdialog);
			END;
		
		ELSE
			dialog.cancelclose(pdialog);
			ROLLBACK;
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_managecard_save;

	PROCEDURE dlg_managecard_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_ManageCard_Handler';
	
		vcardrecord    apitypes.typecardrecord;
		vprocessonline BOOLEAN;
		vuseautomode   BOOLEAN;
	
	BEGIN
		t.enter(cmethodname
			   ,'What = ' || pwhat || ', Dialog = ' || pdialog || ', ItemName = ' || pitemname ||
				', Cmd = ' || pcmd);
	
		CASE pwhat
		
			WHEN dialog.wt_itempost THEN
			
				IF pitemname = citem_useautomode
				THEN
				
					IF dialog.getbool(pdialog, citem_useautomode)
					THEN
					
						dlg_tools.item_cardattributes_set(pdialog
														 ,citem_cardattributes
														 ,sblockparam.state.cardsign
														 ,sblockparam.state.cardblock);
					
						dlg_tools.item_cardattributes_enable(pdialog, citem_cardattributes, FALSE);
					ELSE
					
						dlg_tools.item_cardattributes_set(pdialog
														 ,citem_cardattributes
														 ,dialog.getnumber(pdialog, citem_state)
														 ,dialog.getchar(pdialog, citem_status)
														 ,FALSE);
					
						dlg_tools.item_cardattributes_enable(pdialog, citem_cardattributes, TRUE);
					END IF;
				END IF;
			
			WHEN dialog.wt_dialogvalid THEN
			
				IF (pcmd = dialog.cmok)
				   AND dlg_managecard_getdata(pdialog, vcardrecord, vprocessonline, vuseautomode)
				THEN
					dlg_managecard_save(pdialog, vcardrecord, vprocessonline, vuseautomode);
				END IF;
			
			ELSE
				NULL;
		END CASE;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_managecard_handler;

	PROCEDURE dlg_managecards_filllist
	(
		pdialog   IN NUMBER
	   ,plistname IN typeitemname
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_ManageCards_FillList';
		vcardlist   apitypes.typecardlist;
		vcardinfo   typecardinfo;
		vcurrentpos NUMBER;
	BEGIN
		t.enter(cmethodname);
	
		vcurrentpos := dialog.getlistcurrentrecordnumber(pdialog, plistname);
	
		dialog.listclear(pdialog, plistname);
	
		vcardlist := contract.getcardlist(scontractno);
	
		FOR i IN 1 .. vcardlist.count
		LOOP
		
			getcardinfo(vcardlist(i), vcardinfo);
		
			IF vcardinfo.infosaved
			THEN
			
				dialog.listaddrecord(pdialog
									,plistname
									,vcardlist(i).pan || '~' || vcardlist(i).mbr || '~' ||
									  masktodialog(vcardlist(i)) || '~' ||
									  referencecardsign.getname(vcardlist(i).a4mstat) || '~' ||
									  referencecrd_stat.getname(vcardlist(i).pcstat) || '~' ||
									  CASE vcardinfo.setmode
										  WHEN 'A' THEN
										   'Auto'
										  WHEN 'M' THEN
										   'Manual'
										  ELSE
										   'Unknown'
									  END || '~' || CASE vcardinfo.sticktype
										  WHEN 'S' THEN
										   'Yes'
										  WHEN 'U' THEN
										   'No'
										  ELSE
										   'Unknown'
									  END || '~' || CASE vcardinfo.setmode
										  WHEN 'A' THEN
										   1
										  ELSE
										   0
									  END);
			END IF;
		
		END LOOP;
	
		IF vcurrentpos IS NOT NULL
		THEN
			dialog.setcurrec(pdialog, plistname, vcurrentpos);
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_managecards_filllist;

	FUNCTION dlg_managecards_create RETURN NUMBER IS
		cmethodname  CONSTANT typemethodname := cpackagename || '.Dlg_ManageCards_Create';
		chandlername CONSTANT typemethodname := cpackagename || '.Dlg_ManageCards_Handler';
	
		c_dialogwidth  CONSTANT NUMBER := 80;
		c_dialogheight CONSTANT NUMBER := 12;
	
		vdialog NUMBER;
	
	BEGIN
		t.enter(cmethodname);
	
		vdialog := dialog.new('Contract cards, managed by schema'
							 ,0
							 ,0
							 ,c_dialogwidth
							 ,c_dialogheight
							 ,pextid => cmethodname);
	
		dialog.bevel(vdialog, 1, 1, c_dialogwidth - 1, c_dialogheight - 3, dialog.bevel_frame);
	
		dialog.list(vdialog
				   ,clist_cards
				   ,3
				   ,3
				   ,c_dialogwidth - 7
				   ,c_dialogheight - 7
				   ,'Double-click a card to change it''s state/status');
		dialog.listaddfield(vdialog, clist_cards, citem_pan, 'C', 1, 0);
		dialog.listaddfield(vdialog, clist_cards, citem_mbr, 'N', 1, 0);
		dialog.listaddfield(vdialog, clist_cards, citem_card, 'C', 25, 1);
		dialog.listaddfield(vdialog, clist_cards, citem_state, 'C', 15, 1);
		dialog.listaddfield(vdialog, clist_cards, citem_status, 'C', 15, 1);
		dialog.listaddfield(vdialog, clist_cards, citem_cardmode, 'C', 10, 1);
		dialog.listaddfield(vdialog, clist_cards, citem_stuck, 'C', 5, 1);
		dialog.listaddfield(vdialog, clist_cards, citem_automode, 'C', 1, 0);
		dialog.setcaption(vdialog, clist_cards, 'Card~State~Status~Mode~Stuck~');
		dialog.setitempost(vdialog, clist_cards, chandlername);
	
		dlg_managecards_filllist(vdialog, clist_cards);
	
		dlg_tools.startbuttondrawing(c_dialogwidth, 1, 10);
		dlg_tools.drawbutton(vdialog
							,cbtn_ok
							,'Exit'
							,'Close dialog'
							,c_dialogheight - 1
							,dialog.cmok
							,pdefault => TRUE);
	
		dialog.setdialogvalid(vdialog, chandlername);
	
		t.leave(cmethodname);
		RETURN vdialog;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			dialog.destroy(vdialog);
			error.save(cmethodname);
			RAISE;
	END dlg_managecards_create;

	PROCEDURE dlg_managecards_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_ManageCards_Handler';
	BEGIN
		t.enter(cmethodname
			   ,'What = ' || pwhat || ', Dialog = ' || pdialog || ', ItemName = ' || pitemname ||
				', Cmd = ' || pcmd);
	
		IF (pwhat = dialog.wt_itempost)
		   AND (pitemname = clist_cards)
		THEN
			IF dialog.exec(dlg_managecard_create(getcardrecord(dialog.getcurrentrecordchar(pdialog
																						  ,clist_cards
																						  ,citem_pan)
															  ,dialog.getcurrentrecordnumber(pdialog
																							,clist_cards
																							,citem_mbr))
												,htools.i2b(dialog.getcurrentrecordnumber(pdialog
																						 ,clist_cards
																						 ,citem_automode)))) =
			   dialog.cmok
			THEN
				dlg_managecards_filllist(pdialog, clist_cards);
			END IF;
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_managecards_handler;

	FUNCTION dlg_creditrepayment_create RETURN NUMBER IS
		cmethodname  CONSTANT typemethodname := cpackagename || '.Dlg_CreditRepayment_Create';
		chandlername CONSTANT typemethodname := cpackagename || '.Dlg_CreditRepayment_Handler';
	
		cdialogwidth  CONSTANT NUMBER := 48;
		cdialogheight CONSTANT NUMBER := 10;
	
		vdialog NUMBER;
		vy      NUMBER := 1;
	
	BEGIN
		t.enter(cmethodname);
	
		vdialog := dialog.new('Credit repayment'
							 ,0
							 ,0
							 ,cdialogwidth
							 ,cdialogheight
							 ,pextid => cmethodname);
	
		FOR i IN 1 .. 2
		LOOP
		
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			THEN
			
				dialog.bevel(vdialog
							,1
							,vy
							,cdialogwidth - 1
							,3
							,dialog.bevel_frame
							,pcaption => sfulllabel(i));
				vy := vy + 1;
			
				dialog.inputchar(vdialog
								,citem_accountno || i
								,25
								,vy
								,20
								,'Account for debit'
								,NULL
								,'From account (' || getcurrencyabbr(i) || '):');
				dialog.setitemcommand(vdialog, citem_accountno || i, ccmd_findaccount);
				IF hascorporatecontract
				THEN
					dialog.putchar(vdialog
								  ,citem_accountno || i
								  ,getcorporatebankaccount(sdepaccount(i).currencyno));
				END IF;
				vy := vy + 1;
			
				dialog.inputmoney(vdialog
								 ,citem_amount || i
								 ,25
								 ,vy
								 ,'Credit repayment sum'
								 ,'Amount (' || getcurrencyabbr(i) || '):'
								 ,sprecision(i)
								 ,20);
				dialog.putnumber(vdialog, citem_amount || i, getminpaymentamount(i));
				vy := vy + 1;
			
			END IF;
		
		END LOOP;
	
		dlg_tools.startbuttondrawing(cdialogwidth, 2);
		dlg_tools.drawbutton(vdialog
							,cbtn_ok
							,'OK'
							,'Perform operation'
							,vy + 1
							,dialog.cmok
							,pdefault => TRUE);
		dlg_tools.drawbutton(vdialog
							,cbtn_cancel
							,'Cancel'
							,'Cancel operation and exit dialog'
							,vy + 1
							,dialog.cmcancel);
	
		dialog.setdialogvalid(vdialog, chandlername);
	
		t.leave(cmethodname);
		RETURN vdialog;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			dialog.destroy(vdialog);
			error.save(cmethodname);
			RAISE;
	END dlg_creditrepayment_create;

	FUNCTION dlg_creditrepayment_getdata
	(
		pdialog    IN NUMBER
	   ,oaaccounts OUT NOCOPY contracttools.typeaccarray
	   ,oapaysum   OUT NOCOPY types.arrnum
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_CreditRepayment_GetData';
		vnothingtopay BOOLEAN := TRUE;
	BEGIN
		t.enter(cmethodname, pdialog);
	
		FOR i IN 1 .. 2
		LOOP
		
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			THEN
			
				oapaysum(i) := dlg_tools.getnumber(pdialog
												  ,citem_amount || i
												  ,'Amount'
												  ,dlg_tools.cnum_nonnegative);
			
				IF oapaysum(i) > 0
				THEN
				
					oaaccounts(i).accountno := dlg_tools.getaccountno(pdialog, citem_accountno || i);
				
					vnothingtopay := FALSE;
				
				END IF;
			
			END IF;
		
		END LOOP;
	
		IF vnothingtopay
		THEN
			dlg_tools.raisevalidateerror(pdialog, NULL, 'Nothing to pay!');
		END IF;
	
		FOR i IN 1 .. 2
		LOOP
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			   AND (oapaysum(i) <> getminpaymentamount(i))
			THEN
				dlg_tools.rundlg_yesno(pdialog
									  ,'Warning'
									  ,'The amount you have entered (' ||
									   formatmoneywithabbr(oapaysum(i), i) ||
									   ') is not equal~to minimum payment amount (' ||
									   formatmoneywithabbr(getminpaymentamount(i), i) ||
									   ')!~Continue operation performance?'
									  ,citem_amount || i);
			END IF;
		END LOOP;
	
		t.leave(cmethodname, htools.b2s(TRUE));
		RETURN TRUE;
	EXCEPTION
		WHEN dlg_tools.validate_error THEN
			t.leave(cmethodname, htools.b2s(FALSE));
			RETURN FALSE;
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_creditrepayment_getdata;

	PROCEDURE dlg_creditrepayment_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_CreditRepayment_Handler';
		vaaccounts contracttools.typeaccarray;
		vapaysum   types.arrnum;
	BEGIN
		t.enter(cmethodname
			   ,'What = ' || pwhat || ', Dialog = ' || pdialog || ', ItemName = ' || pitemname ||
				', Cmd = ' || pcmd);
	
		IF pwhat = dialog.wt_dialogvalid
		THEN
		
			CASE pcmd
			
				WHEN dialog.cmok THEN
				
					IF dlg_creditrepayment_getdata(pdialog, vaaccounts, vapaysum)
					THEN
					
						getcontractdata(pcalcdelparams => FALSE);
					
						BEGIN
							startnewdocument;
							SAVEPOINT sp_creditrepayment;
							FOR i IN 1 .. 2
							LOOP
								IF ifcurrencyisusedintype(i, scontracttype, scontractno)
								   AND (vapaysum(i) > 0)
								THEN
									contracttools.loadcontractaccountbyaccno(vaaccounts(i)
																			 .accountno
																			,vaaccounts(i)
																			,c_doexception);
									doentry(i
										   ,vaaccounts(i)
										   ,sdepaccount(i)
										   ,sdepaccount(i).currencyno
										   ,vapaysum(i)
										   ,'ACC_IN'
										   ,'+'
										   ,pdotrxn => FALSE);
								END IF;
							END LOOP;
						EXCEPTION
							WHEN OTHERS THEN
								ROLLBACK TO sp_creditrepayment;
								dialog.cancelclose(pdialog);
								htools.showmessage('Error', error.getusertext);
						END;
					
					END IF;
				
				WHEN ccmd_findaccount THEN
				
					IF hascorporatecontract
					THEN
						dlg_tools.rundlg_selectaccount(pdialog
													  ,pitemname
													  ,finderselectaccount.accompany);
					ELSE
						dlg_tools.rundlg_selectaccount(pdialog
													  ,pitemname
													  ,finderselectaccount.acpersone
													  ,getclientid);
					END IF;
				
				ELSE
					NULL;
			END CASE;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_creditrepayment_handler;

	FUNCTION dlg_moveduedate_create RETURN NUMBER IS
		cmethodname  CONSTANT typemethodname := cpackagename || '.Dlg_MoveDueDate_Create';
		chandlername CONSTANT typemethodname := cpackagename || '.Dlg_MoveDueDate_Handler';
	
		cdialogwidth  CONSTANT NUMBER := 52;
		cdialogheight CONSTANT NUMBER := 8;
	
		vdialog NUMBER;
	
	BEGIN
		t.enter(cmethodname);
	
		vdialog := dialog.new('Change cycle due date'
							 ,0
							 ,0
							 ,cdialogwidth
							 ,cdialogheight
							 ,pextid => cmethodname);
	
		dialog.statictext(vdialog, 13, 2, 'Due date:');
		dialog.statictext(vdialog, 5, 3, 'Printed due date:');
		dialog.statictext(vdialog, 2, 4, 'Next statement date:');
	
		dialog.bevel(vdialog, 23, 1, 14, 4, dialog.bevel_frame, pcaption => 'Current');
	
		dlg_tools.drawindicator_date(vdialog
									,'CurrDD'
									,25
									,2
									,NULL
									,'Current cycle due date'
									,getcurrentcycle().duedate);
	
		dlg_tools.drawindicator_date(vdialog
									,'CurrPDD'
									,25
									,3
									,NULL
									,'Current cycle printed due date'
									,getcurrentcycle().printedduedate);
	
		dlg_tools.drawindicator_date(vdialog
									,'CurrSD'
									,25
									,4
									,NULL
									,'Current cycle statement date'
									,getcurrentcycle().nextstatementdate);
	
		dialog.bevel(vdialog, 38, 1, 14, 4, dialog.bevel_frame, pcaption => 'New');
	
		dialog.inputdate(vdialog, 'NewDD', 40, 2, 'Input a new due date');
		referencecalendar.setclndtodialog(vdialog
										 ,'NewDD'
										 ,contractcalendar.getcalendar(getbillingcyclecalendar)
										  .holdaysid);
		dialog.setitempost(vdialog, 'NewDD', chandlername);
	
		dlg_tools.drawindicator_date(vdialog
									,'NewPDD'
									,40
									,3
									,NULL
									,'New printed due date calculated from new due date');
	
		dlg_tools.drawindicator_date(vdialog
									,'NewSD'
									,40
									,4
									,NULL
									,'New statement date calculated from new due date');
	
		dialog.hiddenbool(vdialog, 'FromNextField', FALSE);
	
		dlg_tools.startbuttondrawing(cdialogwidth, 2);
		dlg_tools.drawbutton(vdialog
							,cbtn_ok
							,'OK'
							,'Perform operation'
							,cdialogheight - 2
							,dialog.cmok
							,pdefault => TRUE);
		dlg_tools.drawbutton(vdialog
							,cbtn_cancel
							,'Cancel'
							,'Cancel operation and exit dialog'
							,cdialogheight - 2
							,dialog.cmcancel);
	
		dialog.setdialogvalid(vdialog, chandlername);
	
		t.leave(cmethodname);
		RETURN vdialog;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			dialog.destroy(vdialog);
			error.save(cmethodname);
			RAISE;
	END dlg_moveduedate_create;

	PROCEDURE dlg_moveduedate_updatedata
	(
		pdialog  IN NUMBER
	   ,pduedate IN DATE
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_MoveDueDate_UpdateData';
	BEGIN
		t.enter(cmethodname);
	
		dialog.putdate(pdialog
					  ,'NewPDD'
					  ,referencecalendar.getnextnotseldate(getcurrentcycle             ()
														   .printedduedate +
															(pduedate - getcurrentcycle().duedate)
														  ,contractcalendar.getcalendar(getbillingcyclecalendar)
														   .holdaysid));
	
		dialog.putdate(pdialog
					  ,'NewSD'
					  ,contractcalendar.getnextstatementdate(getbillingcyclecalendar, pduedate));
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_moveduedate_updatedata;

	FUNCTION dlg_moveduedate_ensureduedate
	(
		pdialog       IN NUMBER
	   ,pprohibitnull IN BOOLEAN
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_MoveDueDate_EnsureDueDate';
		vresult     BOOLEAN := TRUE;
		vnewduedate DATE;
		vduedate    DATE;
	BEGIN
		t.enter(cmethodname);
	
		dialog.putdate(pdialog, 'NewPDD', NULL);
		dialog.putdate(pdialog, 'NewSD', NULL);
	
		vduedate := dlg_tools.getdate(pdialog
									 ,'NewDD'
									 ,'New due date'
									 ,pprohibitnull => pprohibitnull
									 ,pminvalue     => seance.getoperdate);
	
		IF vduedate IS NOT NULL
		THEN
		
			IF referencecalendar.isselectedday(vduedate
											  ,contractcalendar.getcalendar(getbillingcyclecalendar)
											   .holdaysid)
			THEN
			
				vnewduedate := referencecalendar.getnextnotseldate(vduedate
																  ,contractcalendar.getcalendar(getbillingcyclecalendar)
																   .holdaysid);
			
				vresult := htools.ask('Confirm'
									 ,'Cannot set <' || htools.d2s(vduedate) ||
									  '> due date, as it is a day off!~~Move the date forward to the first business day <' ||
									  vnewduedate || '>?');
			
				IF vresult
				THEN
					dialog.putdate(pdialog, 'NewDD', vnewduedate);
					dlg_moveduedate_updatedata(pdialog, vnewduedate);
				END IF;
			
				dialog.cancelclose(pdialog);
			
			ELSE
				dlg_moveduedate_updatedata(pdialog, vduedate);
			END IF;
		
		END IF;
	
		t.leave(cmethodname, htools.b2s(vresult));
		RETURN vresult;
	EXCEPTION
		WHEN dlg_tools.validate_error THEN
			t.leave(cmethodname, htools.b2s(FALSE));
			RETURN FALSE;
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_moveduedate_ensureduedate;

	PROCEDURE dlg_moveduedate_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER := 0
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_MoveDueDate_Handler';
		vnewpdd DATE;
		vnewdd  DATE;
		vnewsd  DATE;
		vrecno  NUMBER;
	BEGIN
		t.enter(cmethodname
			   ,'What = ' || pwhat || ', Dialog = ' || pdialog || ', ItemName = ' || pitemname ||
				', Cmd = ' || pcmd);
	
		CASE pwhat
		
			WHEN dialog.wt_itempost THEN
				dlg_moveduedate_handler(dialog.wt_nextfield, pdialog, 'NEWDD');
			
			WHEN dialog.wt_nextfield THEN
			
				IF pitemname = 'NEWDD'
				THEN
				
					dialog.putbool(pdialog, 'FromNextField', TRUE);
				
					IF dlg_moveduedate_ensureduedate(pdialog, FALSE)
					THEN
						NULL;
					END IF;
				
					dialog.putbool(pdialog, 'FromNextField', FALSE);
				
				END IF;
			
			WHEN dialog.wt_dialogvalid THEN
			
				IF pcmd = dialog.cmok
				THEN
				
					IF dialog.getbool(pdialog, 'FromNextField')
					THEN
						dialog.cancelclose(pdialog);
					
					ELSIF dlg_moveduedate_ensureduedate(pdialog, TRUE)
					THEN
					
						vnewdd  := dlg_tools.getdate(pdialog, 'NewDD', 'New due date');
						vnewpdd := dlg_tools.getdate(pdialog, 'NewPDD', 'New printed due date');
						vnewsd  := dlg_tools.getdate(pdialog, 'NewSD', 'New statement date');
					
						a4mlog.cleanparamlist;
						a4mlog.addparamrec('Due date', getcurrentcycle().duedate, vnewdd);
						a4mlog.addparamrec('Printed due date'
										  ,getcurrentcycle().printedduedate
										  ,vnewpdd);
						a4mlog.addparamrec('Statement date'
										  ,getcurrentcycle().nextstatementdate
										  ,vnewsd);
					
						IF a4mlog.getparamlistcount > 0
						THEN
						
							BEGIN
							
								SAVEPOINT sp_changedates;
							
								vrecno := getcurrentcycle().recno;
							
								a4mlog.logobject(object.gettype(contract.object_name)
												,scontractno
												,'Contract cycle number ' || vrecno ||
												 ' key dates were changed'
												,a4mlog.act_change
												,a4mlog.putparamlist
												,powner => getclientid);
							
								UPDATE tcontractstcycle
								SET    duedate           = vnewdd
									  ,printedduedate    = vnewpdd
									  ,nextstatementdate = vnewsd
								WHERE  branch = seance.getbranch
								AND    recno = vrecno;
							
							EXCEPTION
								WHEN OTHERS THEN
									ROLLBACK TO sp_changedates;
									dialog.cancelclose(pdialog);
									htools.showmessage('Error', error.getusertext);
							END;
						
						END IF;
					
					END IF;
				
				END IF;
			
			ELSE
				NULL;
		END CASE;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_moveduedate_handler;

	FUNCTION dlg_debtrestructuring_create RETURN NUMBER IS
		cmethodname  CONSTANT typemethodname := cpackagename || '.Dlg_DebtRestructuring_Create';
		chandlername CONSTANT typemethodname := cpackagename || '.Dlg_DebtRestructuring_Handler';
	
		cdialogwidth  CONSTANT NUMBER := 48;
		cdialogheight CONSTANT NUMBER := 10;
	
		vdialog NUMBER;
		vy      NUMBER := 1;
	
	BEGIN
		t.enter(cmethodname);
	
		vdialog := dialog.new('Debt restructuring'
							 ,0
							 ,0
							 ,cdialogwidth
							 ,cdialogheight
							 ,pextid => cmethodname);
	
		FOR i IN 1 .. 2
		LOOP
		
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			THEN
			
				dlg_tools.drawnestedbevel(vdialog
										 ,1
										 ,vy
										 ,cdialogwidth - 1
										 ,3 * (htools.b2i(smulticurrency) + 1) + 1);
			
				makecheckbox(vdialog
							,'DoRestructuring' || i
							,3
							,vy
							,'Apply for ' || sfulllabel(i)
							,'Restructure debt in ' || sfulllabel(i)
							,chandlername);
				vy := vy + 1;
			
				IF sdepaccount(i).remain >= 0
				THEN
					dlg_tools.toggleitem(vdialog
										,'DoRestructuring' || i
										,FALSE
										,'No debt for restructuring');
				END IF;
			
				dlg_tools.drawindicator_money(vdialog
											 ,citem_amount || i
											 ,21
											 ,vy
											 ,24
											 ,'Debt amount:'
											 ,'Debt amount to be restructured'
											 ,sprecision(i)
											 ,greatest(-sdepaccount(i).remain, 0));
				vy := vy + 1;
			
				contractlink.dropbox_contracts_create(vdialog
													 ,'ContractNo' || i
													 ,21
													 ,vy
													 ,22
													 ,'Use contract:'
													 ,'Contract to be used for restructuring'
													 ,contractlink.clinkedtocurrent +
													  contractlink.cnotlinked
													 ,scontractno
													 ,contractlink.cmain
													 ,cinstlinkname
													 ,getcurrency(scontracttype
																 ,'ItemDeposit' || slabel(i))
													 ,sactparamccy(i) (cctp_debttoinstct)
													 ,'<Create new contract>');
			
				vy := vy + 1;
			
				dlg_debtrestructuring_handler(dialog.wt_itempre, vdialog, 'DoRestructuring' || i);
			
			END IF;
		
		END LOOP;
	
		dlg_tools.startbuttondrawing(cdialogwidth, 2);
		dlg_tools.drawbutton(vdialog
							,cbtn_ok
							,'OK'
							,'Perform operation'
							,vy + 1
							,dialog.cmok
							,pdefault => TRUE);
		dlg_tools.drawbutton(vdialog
							,cbtn_cancel
							,'Cancel'
							,'Cancel operation and exit dialog'
							,vy + 1
							,dialog.cmcancel);
	
		dialog.setdialogvalid(vdialog, chandlername);
	
		t.leave(cmethodname);
		RETURN vdialog;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			dialog.destroy(vdialog);
			error.save(cmethodname);
			RAISE;
	END dlg_debtrestructuring_create;

	FUNCTION dlg_debtrestructuring_getdata
	(
		pdialog     IN NUMBER
	   ,oacontracts OUT NOCOPY types.arrstr20
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_DebtRestructuring_GetData';
	BEGIN
		t.enter(cmethodname, pdialog);
	
		FOR i IN 1 .. 2
		LOOP
		
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			   AND dialog.getbool(pdialog, 'DoRestructuring' || i)
			THEN
				oacontracts(i) := contractlink.dropbox_contracts_getvalue(pdialog
																		 ,'ContractNo' || i
																		 ,FALSE);
			END IF;
		
		END LOOP;
	
		IF oacontracts.count = 0
		THEN
			dlg_tools.raisevalidateerror(pdialog, NULL, 'No debt for restructuring!');
		END IF;
	
		t.leave(cmethodname, htools.b2s(TRUE));
		RETURN TRUE;
	EXCEPTION
		WHEN dlg_tools.validate_error THEN
			t.leave(cmethodname, htools.b2s(FALSE));
			RETURN FALSE;
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_debtrestructuring_getdata;

	PROCEDURE dlg_debtrestructuring_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER := 0
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_DebtRestructuring_Handler';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vinstallmentcontract apitypes.typecontractrecord;
		vinstallmentaccount  contracttools.taccountrecord;
		vacardlist           apitypes.typecardlist;
		vatrxnstotransfer    typetrxnarray;
		vacontracts          types.arrstr20;
		vcardstatus          typecardstatus;
		vcardstate           typecardstate;
		vastatesfrom         tblnumber;
		vloanno              NUMBER;
	
	BEGIN
		t.enter(cmethodname
			   ,'What = ' || pwhat || ', Dialog = ' || pdialog || ', ItemName = ' || pitemname ||
				', Cmd = ' || pcmd);
	
		IF pwhat = dialog.wt_itempre
		THEN
		
			IF dialog.getbool(pdialog, pitemname)
			THEN
				dialog.setenable(pdialog, 'ContractNo' || substr(pitemname, -1), TRUE);
				contractlink.dropbox_contracts_setvalue(pdialog
													   ,'ContractNo' || substr(pitemname, -1)
													   ,NULL);
			ELSE
				dialog.setenable(pdialog, 'ContractNo' || substr(pitemname, -1), FALSE);
				dialog.putstrdata(pdialog, 'ContractNo' || substr(pitemname, -1), NULL);
			END IF;
		
		ELSIF (pwhat = dialog.wt_dialogvalid)
			  AND (pcmd = dialog.cmok)
		THEN
		
			IF dlg_debtrestructuring_getdata(pdialog, vacontracts)
			THEN
			
				getcontractdata;
			
				BEGIN
				
					startoperation;
				
					contractoplog.init;
				
					SAVEPOINT sp_debtrestructuring;
				
					snowstatementdate := FALSE;
					snowduedate       := FALSE;
				
					FOR i IN 1 .. 2
					LOOP
					
						IF vacontracts.exists(i)
						THEN
						
							chooseprofiles(i);
						
							appendnewtransactions(i);
						
							vinstallmentcontract.no := vacontracts(i);
						
							getinstallmentcontract(i
												  ,sactparamccy(i) (cctp_debttoinstct)
												  ,FALSE
												  ,vinstallmentcontract
												  ,vinstallmentaccount);
						
							vloanno := createloanforamount(vinstallmentcontract.no
														  ,-sdepaccount(i).remain);
						
							SELECT l.*
								  ,NULL
								  ,NULL
								  ,NULL
								  ,NULL
								  ,NULL
								  ,NULL
								  ,NULL
								  ,NULL
								  ,NULL
								  ,NULL
								  ,NULL
								  ,NULL
								  ,vloanno
								  ,NULL BULK COLLECT
							INTO   vatrxnstotransfer
							FROM   tcontracttrxnlist l
							WHERE  l.branch = cbranch
							AND    l.accountno = sdepaccount(i).accountno
							AND    l.trantype IN (ctrxntype_debit, ctrxntype_creditrev)
							AND    l.paidfull = 0
							ORDER  BY l.docno
									 ,l.entryno;
						
							FOR j IN 1 .. vatrxnstotransfer.count
							LOOP
								startnewinstallment(i
												   ,vinstallmentcontract.no
												   ,cim_auto
												   ,vloanno
												   ,vatrxnstotransfer      (j)
													.amount - vatrxnstotransfer(j).paidamount
												   ,vatrxnstotransfer      (j).docno
												   ,vatrxnstotransfer      (j).entryno
												   ,vatrxnstotransfer      (j).recno);
							END LOOP;
						
							processinstallmenttrxns(i
												   ,vinstallmentcontract.no
												   ,vloanno
												   ,vinstallmentaccount
												   ,-sdepaccount(i).remain
												   ,vatrxnstotransfer
												   ,nvl(sactparamccy(i) (cctp_instonfeecalc), 0) = 1
												   ,TRUE);
						
							custom_overdueparameterscalculation.update_contrstminpaymentdata(i
																							,snowstatementdate
																							,snowduedate
																							,sdepaccount(i)
																							 .accountno || '-' || i || '-' ||
																							  to_char(seance.getoperdate
																									 ,'yyyy.mm.dd'));
						
							vastatesfrom := dlg_tools.element_cardstateslist_read(contractparams.ccontracttype
																				 ,scontracttype
																				 ,'RestrCardStatesFrom' ||
																				  slabel(i));
						
							dlg_tools.item_cardattributes_read(contractparams.ccontracttype
															  ,scontracttype
															  ,'RestrCardStateTo' || slabel(i)
															  ,vcardstate
															  ,vcardstatus);
						
							vacardlist := contract.getcardlist(scontractno);
						
							FOR j IN 1 .. vacardlist.count
							LOOP
							
								IF vacardlist(j).a4mstat MEMBER OF vastatesfrom
								THEN
									changecardattributes(vacardlist(j)
														,vcardstate
														,vcardstatus
														,vacardlist(j).remakedisable
														,csetcardstatus
														,c_dorollback
														,FALSE
														,FALSE);
								END IF;
							
							END LOOP;
						
						END IF;
					
					END LOOP;
				
					setoperationrollbackdata(padddocno => TRUE);
				
					FOR i IN 1 .. 2
					LOOP
					
						IF vacontracts.exists(i)
						   AND (slastdocno(i) > sacparamccy(i) (cp_lastdocno))
						THEN
							contractrbstd.changecontractparam(scontractno
															 ,'LastDocNo_' || i
															 ,slastdocno(i));
						END IF;
					
					END LOOP;
				
					contractoplog.done(scontractno, cso_restructuring, FALSE, pdocno => sdocno);
				
				EXCEPTION
					WHEN OTHERS THEN
						ROLLBACK TO sp_debtrestructuring;
						t.exc(cmethodname);
						error.save(cmethodname);
						contractoplog.clearlaststate;
						dialog.cancelclose(pdialog);
						htools.showmessage('Error', error.gettext);
				END;
			
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_debtrestructuring_handler;

	FUNCTION gettrxngroupdescription(pgroupid IN NUMBER) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetTrxnGroupDescription';
		vresult     VARCHAR2(100) := 'Unknown group <' || pgroupid || '>';
		vagrouplist custom_contractprofiles.typegrouparray;
	BEGIN
		t.enter(cmethodname, pgroupid);
	
		vagrouplist := custom_contractprofiles.getgroupfulllist;
	
		FOR i IN 1 .. vagrouplist.count
		LOOP
			IF vagrouplist(i).groupid = pgroupid
			THEN
				vresult := vagrouplist(i).groupname;
			END IF;
		END LOOP;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END gettrxngroupdescription;

	FUNCTION dlg_viewtransactions_create RETURN NUMBER IS
		cmethodname  CONSTANT typemethodname := cpackagename || '.Dlg_ViewTransactions_Create';
		chandlername CONSTANT typemethodname := cpackagename || '.Dlg_ViewTransactions_Handler';
		cbranch      CONSTANT NUMBER := seance.getbranch;
	
		cdialogwidth  CONSTANT NUMBER := 145;
		cdialogheight CONSTANT NUMBER := 31;
	
		vcycleno NUMBER;
		vdialog  NUMBER;
		vpage    NUMBER;
	
		FUNCTION gettrxnstatus
		(
			ptrantype   IN NUMBER
		   ,ppaidfull   IN NUMBER
		   ,ppaidamount IN NUMBER
		) RETURN VARCHAR2 IS
			cmethodname CONSTANT typemethodname := dlg_viewtransactions_create.cmethodname ||
												   '.GetTrxnStatus';
			vresult VARCHAR2(100);
		BEGIN
			t.enter(cmethodname);
		
			IF ptrantype IN (ctrxntype_debit, ctrxntype_creditrev)
			THEN
			
				IF ppaidfull = 1
				THEN
					vresult := 'Fully repaid';
				ELSIF ppaidamount > 0
				THEN
					vresult := 'Partially repaid';
				ELSE
					vresult := 'Not repaid';
				END IF;
			
			ELSIF ptrantype IN (ctrxntype_repayment, ctrxntype_debitrev)
			THEN
			
				IF ppaidfull = 1
				THEN
					vresult := 'Completely spent';
				ELSIF ppaidamount > 0
				THEN
					vresult := 'Partially spent';
				ELSE
					vresult := 'Not spent';
				END IF;
			
			END IF;
		
			t.leave(cmethodname, vresult);
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END gettrxnstatus;
	
	BEGIN
		t.enter(cmethodname);
	
		vdialog := dialog.new('Viewing contract transactions ' ||
							  contractdlg.makedialogcaption(scontractno)
							 ,0
							 ,0
							 ,cdialogwidth
							 ,cdialogheight
							 ,pextid => cmethodname);
	
		dialog.pagelist(vdialog, 'PAGER', 1, 1, cdialogwidth - 1, cdialogheight - 4);
	
		FOR i IN 1 .. 2
		LOOP
		
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			THEN
			
				vpage := dialog.page(vdialog
									,'PAGER'
									,sdepaccount(i)
									 .accountno || ' (' || sdepaccount(i).currencyno || ')');
			
				dialog.bevel(vpage
							,1
							,1
							,cdialogwidth - 2
							,25
							,dialog.bevel_frame
							,TRUE
							,'TRANSACTION LIST');
			
				dialog.list(vpage
						   ,clist_trxncommon || slabel(i)
						   ,3
						   ,3
						   ,cdialogwidth - 8
						   ,10
						   ,'List of contract transactions. Double-click on a transaction to view the original financial document'
						   ,TRUE);
				dialog.listaddfield(vpage
								   ,clist_trxncommon || slabel(i)
								   ,'CycleNo'
								   ,'N'
								   ,5
								   ,1
								   ,dialog.align_center);
				dialog.listaddfield(vpage, clist_trxncommon || slabel(i), 'ID', 'N', 20, 1);
				dialog.listaddfield(vpage, clist_trxncommon || slabel(i), 'TranDate', 'C', 12, 1);
				dialog.listaddfield(vpage, clist_trxncommon || slabel(i), 'PostDate', 'C', 12, 1);
				dialog.listaddfield(vpage, clist_trxncommon || slabel(i), 'GroupID', 'C', 20, 1);
				dialog.listaddfield(vpage, clist_trxncommon || slabel(i), 'TranType', 'N', 20, 1);
				dialog.listaddfield(vpage, clist_trxncommon || slabel(i), 'Amount', 'N', 20, 1);
				dialog.listaddfield(vpage, clist_trxncommon || slabel(i), 'Remain', 'N', 20, 1);
				dialog.listaddfield(vpage, clist_trxncommon || slabel(i), 'Status', 'C', 17, 1);
				dialog.listaddfield(vpage
								   ,clist_trxncommon || slabel(i)
								   ,'IntStartDate'
								   ,'C'
								   ,12
								   ,1);
				dialog.listaddfield(vpage, clist_trxncommon || slabel(i), 'IntEndDate', 'C', 12, 1);
				dialog.listaddfield(vpage, clist_trxncommon || slabel(i), 'CardNumber', 'C', 23, 1);
				dialog.listaddfield(vpage, clist_trxncommon || slabel(i), 'OffBalance', 'C', 10, 1);
				dialog.listaddfield(vpage, clist_trxncommon || slabel(i), 'PaidFull', 'N', 10, 0);
				dialog.listaddfield(vpage, clist_trxncommon || slabel(i), 'DocNo', 'N', 10, 0);
				dialog.setcaption(vpage
								 ,clist_trxncommon || slabel(i)
								 ,'Cycle~ID~Transaction date~Posting date~Operation group~Transaction type~Amount~Remain~Status~Interest start date~Interest end date~Card number~Offbalance');
				dialog.setitemchange(vpage, clist_trxncommon || slabel(i), chandlername);
				dialog.setitempost(vpage, clist_trxncommon || slabel(i), chandlername);
			
				vcycleno := 0;
			
				FOR j IN (SELECT *
						  FROM   (SELECT recno
										,postdate
										,trandate
										,groupid
										,trantype
										,amount
										,paidamount
										,paidfull
										,intstartdate
										,intenddate
										,pan
										,mbr
										,offbalance
										,docno
										,1 AS rectype
								  FROM   tcontracttrxnlist
								  WHERE  branch = cbranch
								  AND    accountno = sdepaccount(i).accountno
								  
								  UNION ALL
								  
								  SELECT recno
										,statementdate
										,nextstatementdate
										,NULL
										,NULL
										,NULL
										,NULL
										,NULL
										,NULL
										,NULL
										,NULL
										,NULL
										,NULL
										,NULL
										,2 AS rectype
								  FROM   tcontractstcycle
								  WHERE  branch = cbranch
								  AND    contractno = scontractno)
						  ORDER  BY postdate NULLS FIRST
								   ,rectype
								   ,recno)
				LOOP
				
					IF j.rectype = 1
					THEN
						dialog.listaddrecord(vpage
											,clist_trxncommon || slabel(i)
											,NULL || '~' || j.recno || '~' ||
											 htools.d2s(j.trandate) || '~' ||
											 htools.d2s(j.postdate) || '~' ||
											 gettrxngroupdescription(j.groupid) || '~' ||
											 gettrxntypedescription(j.trantype) || '~' ||
											 ltools.formatamount(j.amount
																,sdepaccount(i).currencyno) || '~' ||
											 ltools.formatamount(j.amount - j.paidamount
																,sdepaccount(i).currencyno) || '~' ||
											 gettrxnstatus(j.trantype, j.paidfull, j.paidamount) || '~' ||
											 htools.d2s(j.intstartdate) || '~' ||
											 htools.d2s(j.intenddate) || '~' ||
											 masktodialog(j.pan, j.mbr) || '~' ||
											 dlg_tools.getdescr_yesno(j.offbalance) || '~' ||
											 j.paidfull || '~' || j.docno);
					ELSE
					
						vcycleno := vcycleno + 1;
					
						dialog.listaddrecord(vpage
											,clist_trxncommon || slabel(i)
											,vcycleno || '~' || j.recno || '~' ||
											 htools.d2s(nvl(j.postdate + 1
														   ,contracttypeschema.scontractrow.createdate)) || '~' ||
											 htools.d2s(j.trandate));
					
					END IF;
				
				END LOOP;
			
				dialog.bevel(vpage
							,1
							,15
							,cdialogwidth - 2
							,11
							,dialog.bevel_frame
							,TRUE
							,'DETAILED INFORMATION');
			
				dialog.list(vpage
						   ,clist_trxndetail || slabel(i)
						   ,3
						   ,17
						   ,cdialogwidth - 8
						   ,7
						   ,'Information about the transaction. Double-click on a transaction to go to it in the general list of transactions');
				dialog.listaddfield(vpage, clist_trxndetail || slabel(i), 'ID', 'N', 5, 1);
				dialog.listaddfield(vpage, clist_trxndetail || slabel(i), 'TranDate', 'C', 12, 1);
				dialog.listaddfield(vpage, clist_trxndetail || slabel(i), 'PostDate', 'C', 12, 1);
				dialog.listaddfield(vpage, clist_trxndetail || slabel(i), 'Event', 'C', 30, 1);
				dialog.setcaption(vpage
								 ,clist_trxndetail || slabel(i)
								 ,'ID~Transaction date~Posting date~Event');
				dialog.setitempost(vpage, clist_trxndetail || slabel(i), chandlername);
			
				dialog.list(vpage
						   ,clist_cyclekeydates || slabel(i)
						   ,3
						   ,17
						   ,42
						   ,7
						   ,'Information about key dates of the cycle');
				dialog.listaddfield(vpage, clist_cyclekeydates || slabel(i), 'Date', 'C', 30, 1);
				dialog.listaddfield(vpage
								   ,clist_cyclekeydates || slabel(i)
								   ,'DateValue'
								   ,'C'
								   ,12
								   ,1);
				dialog.setcaption(vpage, clist_cyclekeydates || slabel(i), 'Key date~Value');
			
				dialog.list(vpage
						   ,clist_cycleparams || slabel(i)
						   ,49
						   ,17
						   ,50
						   ,7
						   ,'Information about key parameters of the cycle');
				dialog.listaddfield(vpage, clist_cycleparams || slabel(i), 'Param', 'C', 30, 1);
				dialog.listaddfield(vpage
								   ,clist_cycleparams || slabel(i)
								   ,'ParamValue'
								   ,'N'
								   ,20
								   ,1);
				dialog.setcaption(vpage
								 ,clist_cycleparams || slabel(i)
								 ,'Key cycle parameter~Value');
			
			END IF;
		
		END LOOP;
	
		dlg_tools.startbuttondrawing(cdialogwidth, 1);
		dlg_tools.drawbutton(vdialog
							,cbtn_cancel
							,'Exit'
							,'Click the button to close the dialog'
							,cdialogheight - 2
							,dialog.cmcancel
							,pdefault => TRUE);
	
		t.leave(cmethodname);
		RETURN vdialog;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			dialog.destroy(vdialog);
			error.save(cmethodname);
			RAISE;
	END dlg_viewtransactions_create;

	PROCEDURE dlg_viewtransactions_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER := 0
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_ViewTransactions_Handler';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vcycleinfo   tcontractstminpaymentdata%ROWTYPE;
		vdescription VARCHAR2(100);
		vcycle       typebillingcycle;
		vpostfix     VARCHAR2(100);
		vtrxn        typetrxnrec;
		vcurno       NUMBER;
		vrecno       NUMBER;
		vamount      NUMBER;
	
	BEGIN
		t.enter(cmethodname
			   ,'What = ' || pwhat || ', Dialog = ' || pdialog || ', ItemName = ' || pitemname ||
				', Cmd = ' || pcmd);
	
		vpostfix := substr(pitemname, -3);
	
		CASE pwhat
		
			WHEN dialog.wt_itempost THEN
			
				CASE substr(pitemname, 1, length(pitemname) - 3)
				
					WHEN clist_trxncommon THEN
						IF dialog.getcurrentrecordnumber(pdialog, pitemname, 'DocNo') IS NOT NULL
						THEN
							dialog.exec(transactionview.dialogview(dialog.getcurrentrecordnumber(pdialog
																								,pitemname
																								,'DocNo')));
						END IF;
					
					WHEN clist_trxndetail THEN
					
						dialog.setcurrecbyvalue(pdialog
											   ,clist_trxncommon || vpostfix
											   ,'ID'
											   ,dialog.getcurrentrecordnumber(pdialog
																			 ,clist_trxndetail ||
																			  vpostfix
																			 ,'ID'));
					
						dlg_viewtransactions_handler(dialog.wt_itemchange
													,pdialog
													,clist_trxncommon || vpostfix);
					
					ELSE
						NULL;
				END CASE;
			
			WHEN dialog.wt_itemchange THEN
			
				dialog.listclear(pdialog, clist_trxndetail || vpostfix);
				dialog.listclear(pdialog, clist_cyclekeydates || vpostfix);
				dialog.listclear(pdialog, clist_cycleparams || vpostfix);
			
				vcurno := getcurnobyvalue(vpostfix, 'DOM', 'INT');
			
				dialog.setvisible(pdialog
								 ,clist_trxndetail || vpostfix
								 ,dialog.getcurrentrecordnumber(pdialog, pitemname, 'DocNo') IS NOT NULL);
				dlg_tools.setvisible(pdialog
									,tblchar100(clist_cyclekeydates, clist_cycleparams)
									,vpostfix
									,dialog.getcurrentrecordnumber(pdialog, pitemname, 'DocNo') IS NULL);
			
				IF dialog.getcurrentrecordnumber(pdialog, pitemname, 'DocNo') IS NULL
				THEN
				
					int_getcycle(dialog.getcurrentrecordnumber(pdialog, pitemname, 'ID'), vcycle);
				
					vrecno := dialog.getcurrentrecordnumber(pdialog, pitemname, 'ID');
				
					IF vcycle.statementdate IS NOT NULL
					THEN
					
						SELECT *
						INTO   vcycleinfo
						FROM   tcontractstminpaymentdata
						WHERE  branch = cbranch
						AND    currencynumber = vcurno
						AND    screcno = vrecno;
					
					END IF;
				
					dialog.listaddrecord(pdialog
										,clist_cyclekeydates || vpostfix
										,'Statement Date' || '~' ||
										 htools.d2s(vcycle.statementdate));
					dialog.listaddrecord(pdialog
										,clist_cyclekeydates || vpostfix
										,'DAF Date' || '~' || htools.d2s(vcycle.dafdate));
					dialog.listaddrecord(pdialog
										,clist_cyclekeydates || vpostfix
										,'Printed Due Date' || '~' ||
										 htools.d2s(vcycle.printedduedate));
					dialog.listaddrecord(pdialog
										,clist_cyclekeydates || vpostfix
										,'Due Date' || '~' || htools.d2s(vcycle.duedate));
					IF vcycle.duedate IS NULL
					THEN
						dialog.listaddrecord(pdialog
											,clist_cyclekeydates || vpostfix
											,'Adjusted in due date' || '~');
					ELSE
						dialog.listaddrecord(pdialog
											,clist_cyclekeydates || vpostfix
											,'Adjusted in due date' || '~' ||
											 dlg_tools.getdescr_yesno(htools.b2i(vcycle.lastduedate IS NOT NULL)));
					END IF;
					dialog.listaddrecord(pdialog
										,clist_cyclekeydates || vpostfix
										,'Next Statement Date' || '~' ||
										 htools.d2s(vcycle.nextstatementdate));
				
					dialog.listaddrecord(pdialog
										,clist_cycleparams || vpostfix
										,'Minimum payment' || '~' ||
										 ltools.formatamount(vcycleinfo.minpayment
															,sdepaccount(vcurno).currencyno));
					dialog.listaddrecord(pdialog
										,clist_cycleparams || vpostfix
										,'Repayment at cycle end' || '~' ||
										 ltools.formatamount(vcycleinfo.repayment_atcycleend
															,sdepaccount(vcurno).currencyno));
					dialog.listaddrecord(pdialog
										,clist_cycleparams || vpostfix
										,'Unpaid SD amount on due date' || '~' ||
										 ltools.formatamount(vcycleinfo.unpaidsdamount_onduedate
															,sdepaccount(vcurno).currencyno));
					dialog.listaddrecord(pdialog
										,clist_cycleparams || vpostfix
										,'SD amount' || '~' ||
										 ltools.formatamount(vcycleinfo.sdamount
															,sdepaccount(vcurno).currencyno));
					dialog.listaddrecord(pdialog
										,clist_cycleparams || vpostfix
										,'Minimum payment payoff date' || '~' ||
										 htools.d2s(vcycleinfo.mp_payoffdate_atcycleend));
					dialog.listaddrecord(pdialog
										,clist_cycleparams || vpostfix
										,'Overdue amount on due date' || '~' ||
										 ltools.formatamount(vcycleinfo.overdueamount_onduedate
															,sdepaccount(vcurno).currencyno));
				
				ELSE
				
					vtrxn := gettrxn(dialog.getcurrentrecordnumber(pdialog, pitemname, 'ID'));
				
					dialog.listaddrecord(pdialog
										,clist_trxndetail || vpostfix
										,vtrxn.recno || '~' || htools.d2s(vtrxn.trandate) || '~' ||
										 htools.d2s(vtrxn.postdate) || '~' ||
										 gettrxntypedescription(vtrxn.trantype) || ' (' ||
										 gettrxngroupdescription(vtrxn.groupid) || ') ' ||
										 'amount ' ||
										 ltools.formatamount(vtrxn.amount
															,sdepaccount(vcurno).currencyno));
				
					IF vtrxn.trantype IN (ctrxntype_debit, ctrxntype_creditrev)
					THEN
						vdescription := 'Repayment';
					ELSE
						vdescription := 'Used';
					END IF;
				
					vamount := vtrxn.amount;
				
					FOR i IN (SELECT *
							  FROM   (SELECT packno
											,recno
											,creditrecno AS recid
											,trandate
											,postdate
											,amount
									  FROM   tcontracttrxnrepayment
									  WHERE  branch = cbranch
									  AND    debitrecno = vtrxn.recno
									  AND    vtrxn.trantype IN (ctrxntype_debit, ctrxntype_creditrev)
									  
									  UNION ALL
									  
									  SELECT packno
											,recno
											,debitrecno AS recid
											,trandate
											,postdate
											,amount
									  FROM   tcontracttrxnrepayment
									  WHERE  branch = cbranch
									  AND    creditrecno = vtrxn.recno
									  AND    vtrxn.trantype IN
											 (ctrxntype_repayment, ctrxntype_debitrev))
							  ORDER  BY packno
									   ,recno)
					LOOP
					
						vamount := vamount - i.amount;
					
						dialog.listaddrecord(pdialog
											,clist_trxndetail || vpostfix
											,i.recid || '~' || i.trandate || '~' || i.postdate || '~' ||
											 vdescription || ' ' ||
											 ltools.formatamount(i.amount
																,sdepaccount(vcurno).currencyno) || ', ' ||
											 'remain ' ||
											 ltools.formatamount(vamount
																,sdepaccount(vcurno).currencyno));
					END LOOP;
				
				END IF;
			
			ELSE
				NULL;
			
		END CASE;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_viewtransactions_handler;

	FUNCTION calccontractforclose(psaveinterestcalclog BOOLEAN := FALSE) RETURN typecloseinfoarray IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CalcContractForClose';
		coperdate   CONSTANT DATE := seance.getoperdate;
		cvaluedate CONSTANT DATE := CASE
										WHEN psaveinterestcalclog THEN
										 coperdate
									END;
	
		vnoarray         contractlink.typecontractarray;
		vresult          typecloseinfoarray;
		vrepaymentamount NUMBER;
	
	BEGIN
		t.enter(cmethodname, htools.b2s(psaveinterestcalclog));
	
		startoperation;
	
		getcontractdata;
	
		readaltsetupscheme(TRUE);
	
		assumetodayissd;
	
		SAVEPOINT spprepare;
	
		FOR i IN 1 .. 2
		LOOP
		
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			THEN
			
				vresult(i).account := sdepaccount(i);
			
				vresult(i).totalbalance := vresult(i).account.remain;
			
				chooseprofiles(i);
			
				appendnewtransactions(i);
			
				IF sdepaccount(i).remain < 0
				THEN
					doentry(i
						   ,sabaccounts(i) (cb_techacc)
						   ,sdepaccount(i)
						   ,sdepaccount(i).currencyno
						   ,-sdepaccount(i).remain
						   ,scloserepaymententry
						   ,'Temp trn'
						   ,pvaluedate => cvaluedate);
				END IF;
			
				IF (sovdaccount(i).accountno IS NOT NULL)
				   AND (sovdaccount(i).remain < 0)
				THEN
					doentry(i
						   ,sabaccounts(i) (cb_techacc)
						   ,sovdaccount(i)
						   ,sdepaccount(i).currencyno
						   ,-sovdaccount(i).remain
						   ,'OVER_LIMIT_OFF'
						   ,'OvrLmtOff'
						   ,pvaluedate => cvaluedate
						   ,pdotrxn => FALSE);
				END IF;
			
				sminpaymentdd(i) := getoverdueminpaymentamount(i, ssdbalancedd(i), ssdbalanceod(i));
			
				interestcharge(i);
			
			END IF;
		
		END LOOP;
	
		FOR i IN 1 .. 2
		LOOP
		
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			THEN
			
				vresult(i).prcchargearray := CASE i
												 WHEN 1 THEN
												  sprcchargedom
												 ELSE
												  sprcchargeint
											 END;
				FOR j IN 1 .. vresult(i).prcchargearray.count
				LOOP
					vresult(i).totalbalance := vresult(i)
											   .totalbalance - vresult(i).prcchargearray(j).amount;
				END LOOP;
			
				IF (getcurrentcycle().duedate IS NOT NULL)
				   AND (getcurrentcycle().duedate < coperdate)
				   AND (sprofile(sprofileid(i)) (custom_contractprofiles.cp_ovdfeedate) = 1)
				THEN
					calcovdfee(i
							  ,vresult(i).overduefee
							  ,vresult(i).overduefeegst
							  ,vresult(i).ovdfeecalclog);
					vresult(i).totalbalance := vresult(i).totalbalance - vresult(i).overduefee - vresult(i)
											   .overduefeegst;
				END IF;
			
				calcovlfee(i, vresult(i).overlimitfee, vresult(i).overlimitfeegst);
				vresult(i).totalbalance := vresult(i).totalbalance - vresult(i).overlimitfee - vresult(i)
										   .overlimitfeegst;
			
				IF (sactparam(cctp_useinst) = '1')
				   AND (contractlink.getlinkno(scontractno
											  ,contractlink.cmain
											  ,vnoarray
											  ,cinstlinkname
											  ,sdepaccount(i).currencyno) > 0)
				THEN
					FOR j IN 1 .. vnoarray.count
					LOOP
						vrepaymentamount := getinstallmentrepaymentamount(vnoarray(j).cno
																		 ,coperdate
																		 ,cclosing);
						vresult(i).installmentamount := vresult(i)
														.installmentamount + vrepaymentamount;
						vresult(i).totalbalance := vresult(i).totalbalance - vrepaymentamount;
					END LOOP;
				END IF;
			
			END IF;
		
		END LOOP;
	
		IF psaveinterestcalclog
		THEN
			ssavedinterestcalclog := getinterestcalclog(scontractno, coperdate);
		END IF;
	
		ROLLBACK TO spprepare;
	
		custom_overdueparameterscalculation.clearcache;
	
		t.leave(cmethodname);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			ROLLBACK TO spprepare;
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END calccontractforclose;

	FUNCTION getcloseinfo(pcontractno IN typecontractno) RETURN typecloseinfoarray IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CloseContract';
		vresult typecloseinfoarray;
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		contracttypeschema.scontractrow.no := pcontractno;
		scontractno                        := pcontractno;
		scontracttype                      := contract.gettype(pcontractno, c_doexception);
	
		readsetupscheme;
	
		vresult := calccontractforclose;
	
		t.leave(cmethodname);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcloseinfo;

	PROCEDURE checkcontractforclose(pcurno IN NUMBER) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CheckContractForClose';
	BEGIN
		t.enter(cmethodname);
	
		IF ifcurrencyisusedintype(pcurno, scontracttype, scontractno)
		THEN
		
			IF sdepaccount(pcurno).debitreserve <> 0
			THEN
				error.raiseerror('Contract can not be closed as there is an unhandled debit on-hold for account <' || sdepaccount(pcurno)
								 .accountno || '> exist!');
			END IF;
		
			IF sdepaccount(pcurno).creditreserve <> 0
			THEN
				error.raiseerror('Contract can not be closed as there is an unhandled credit on-hold for account <' || sdepaccount(pcurno)
								 .accountno || '> exist!');
			END IF;
		
			IF sdepaccount(pcurno).remain <> 0
			THEN
				error.raiseerror('Contract can not be closed as account <' || sdepaccount(pcurno)
								 .accountno || '> balance is not equal to 0!');
			END IF;
		
			IF sovdaccount(pcurno).remain <> 0
			THEN
				error.raiseerror('Contract can not be closed as account <' || sovdaccount(pcurno)
								 .accountno || '> balance is not equal to 0!');
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END checkcontractforclose;

	PROCEDURE doclosecontract
	(
		poacloseinfo   IN OUT NOCOPY typecloseinfoarray
	   ,poaaccounts    IN OUT NOCOPY contracttools.typeaccarray
	   ,pcardclosemode IN PLS_INTEGER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.DoCloseContract';
		coperdate   CONSTANT DATE := seance.getoperdate;
	BEGIN
		t.enter(cmethodname);
	
		startoperation;
	
		assumetodayissd;
	
		SAVEPOINT spclose;
	
		FOR i IN 1 .. 2
		LOOP
		
			IF poacloseinfo.exists(i)
			THEN
			
				appendnewtransactions(i);
			
				IF poacloseinfo(i).totalbalance < 0
				THEN
					doentry(i
						   ,poaaccounts(i)
						   ,sdepaccount(i)
						   ,sdepaccount(i).currencyno
						   ,-poacloseinfo(i).totalbalance
						   ,scloserepaymententry
						   ,'+');
				ELSIF poacloseinfo(i).totalbalance > 0
				THEN
					doentry(i
						   ,sdepaccount(i)
						   ,poaaccounts(i)
						   ,sdepaccount(i).currencyno
						   ,poacloseinfo(i).totalbalance
						   ,sclosepayoutentry
						   ,'-');
				END IF;
			
				IF (sovdaccount(i).accountno IS NOT NULL)
				   AND (sovdaccount(i).remain) < 0
				THEN
					doentry(i
						   ,sabaccounts(i) (cb_techacc)
						   ,sovdaccount(i)
						   ,sdepaccount(i).currencyno
						   ,-sovdaccount(i).remain
						   ,'OVER_LIMIT_OFF'
						   ,'OvrLmtOff'
						   ,pdotrxn => FALSE);
				END IF;
			
				sminpaymentdd(i) := getoverdueminpaymentamount(i, ssdbalancedd(i), ssdbalanceod(i));
			
				interestcharge(i);
			
				chargeovdfee(i
							,poacloseinfo(i).overduefee
							,poacloseinfo(i).overduefeegst
							,poacloseinfo(i).ovdfeecalclog);
			
				saveovdfeecalclog(poacloseinfo(i).ovdfeecalclog);
			
				chargeovlfee(i, poacloseinfo(i).overlimitfee, poacloseinfo(i).overlimitfeegst);
			
				installmentcontractsclosure(i);
			
				checkcontractforclose(i);
			
				addcreditlimittorollback(i);
			
				contracttools.setoverdraft(sdepaccount(i), 0);
			
			END IF;
		
		END LOOP;
	
		setoperationrollbackdata;
	
		contractrbstd.violateoff(scontractno, plog => c_writelog);
	
		contractrbstd.closecontract(scontractno, pcardclosemode, 'Contract closure');
	
		FOR i IN 1 .. 2
		LOOP
			custom_overdueparameterscalculation.update_contrstminpaymentdata(i
																			,(coperdate = getcurrentcycle()
																			 .nextstatementdate)
																			,(coperdate = getcurrentcycle()
																			 .duedate)
																			,sdepaccount(i)
																			 .accountno || '-' || i || '-' ||
																			  to_char(coperdate
																					 ,'yyyy.mm.dd'));
		END LOOP;
	
		a4mlog.logobject(object.gettype(contract.object_name)
						,scontractno
						,'Contract closure'
						,powner => getclientid);
	
		scontrattrcalcflag.delete;
	
		clearcontrtypecache;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			ROLLBACK TO spclose;
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END doclosecontract;

	FUNCTION closecontract
	(
		pcontractno IN typecontractno
	   ,pparams     IN contracttypeschema.tclosecontractparamrec
	) RETURN contractrb.trollbackdata IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CloseContract';
		vaparamlist     contracttypeschema.typefschparamlist;
		vaaccounts      contracttools.typeaccarray;
		vresult         contractrb.trollbackdata;
		vacloseinfo     typecloseinfoarray;
		vcardsclosemode PLS_INTEGER;
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		scontractno   := pcontractno;
		scontracttype := contract.gettype(pcontractno, c_doexception);
		scontractstat := contract.getstatus(pcontractno);
	
		IF contract.checkstatus(scontractstat, contract.stat_close)
		THEN
			error.raiseerror('Contract is already closed!');
		END IF;
	
		readsetupscheme;
	
		vaparamlist := contracttools.paramstringtolist(pparams.schparams, pprohibitdups => TRUE);
	
		FOR i IN 1 .. vaparamlist.count
		LOOP
		
			CASE vaparamlist(i).id
			
				WHEN 'PAYMENT_ACCOUNT_DOM' THEN
					vaaccounts(1).accountno := contracttools.getvalidaccount(vaparamlist(i)
																			 .stringvalue
																			,'Account for closing in domestic currency');
				
				WHEN 'PAYMENT_ACCOUNT_INT' THEN
					vaaccounts(2).accountno := contracttools.getvalidaccount(vaparamlist(i)
																			 .stringvalue
																			,'Account for closing in international currency');
				
				WHEN 'CLOSE_ALL_CARDS' THEN
					vcardsclosemode := contracttools.getvalidnumber(vaparamlist      (i).stringvalue
																   ,'Cards close mode'
																   ,pwhatisnull       => sclosecardsmode
																   ,pallowedvalues    => tblnumber(contractrbstd.cclose_none
																								  ,contractrbstd.cclose_openedcards
																								  ,contractrbstd.cclose_allcards));
				
				ELSE
					error.raiseerror('Closing parameter <' || vaparamlist(i).id ||
									 '> is not supported by schema!');
				
			END CASE;
		
		END LOOP;
	
		vacloseinfo := calccontractforclose;
	
		FOR i IN 1 .. 2
		LOOP
		
			IF vacloseinfo.exists(i)
			   AND (vacloseinfo(i).totalbalance <> 0)
			   AND (NOT vaaccounts.exists(i))
			THEN
				error.raiseerror('Closing account for ' || slabel(i) ||
								 ' currency required, but not set!');
			END IF;
		
		END LOOP;
	
		getcontractdata;
	
		doclosecontract(vacloseinfo, vaaccounts, vcardsclosemode);
	
		vresult := contractrb.getrbdata;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END closecontract;

	FUNCTION dlg_closecontract_create RETURN NUMBER IS
		cmethodname  CONSTANT typemethodname := cpackagename || '.Dlg_CloseContract_Create';
		chandlername CONSTANT typemethodname := cpackagename || '.Dlg_CloseContract_Handler';
	
		c_dialogwidth  CONSTANT NUMBER := 79;
		c_dialogheight CONSTANT NUMBER := 21;
	
		vnegtotal BOOLEAN := NULL;
		vdialog   NUMBER;
		vpage     NUMBER;
	
	BEGIN
		t.enter(cmethodname);
	
		sacloseinfo := calccontractforclose;
	
		vdialog := dialog.new(contractdlg.makedialogcaption(scontractno, contractdlg.c_cap_conclose)
							 ,0
							 ,0
							 ,c_dialogwidth
							 ,c_dialogheight
							 ,pextid => cmethodname);
	
		dialog.pagelist(vdialog, 'DebtsCalculation', 1, 1, c_dialogwidth - 1, 15);
	
		FOR i IN 1 .. 2
		LOOP
		
			IF sacloseinfo.exists(i)
			THEN
			
				vpage := dialog.page(vdialog
									,'DebtsCalculation'
									,referencecurrency.getabbreviation(sdepaccount(i).currencyno) ||
									 ' Currency');
				dialog.bevel(vpage
							,1
							,1
							,c_dialogwidth - 2
							,9
							,dialog.bevel_frame
							,pcaption => 'Debts calculation');
				dialog.list(vpage
						   ,clist_debtinfo || i
						   ,3
						   ,2
						   ,c_dialogwidth - 8
						   ,6
						   ,'Debts calculation');
				dialog.listaddfield(vpage, clist_debtinfo || i, 'Name', 'C', 40, 1);
				dialog.listaddfield(vpage, clist_debtinfo || i, 'Amount', 'C', 1, 1, 'R');
			
				dialog.listaddrecord(vpage
									,clist_debtinfo || i
									,'Account remain~' ||
									 ltools.formatamount(sacloseinfo(i).account.remain
														,sacloseinfo(i).account.currencyno));
			
				FOR j IN 1 .. sacloseinfo(i).prcchargearray.count
				LOOP
					dialog.listaddrecord(vpage
										,clist_debtinfo || i
										, 'Interest by ' || sacloseinfo(i).prcchargearray(j)
										 .groupid || ' operation group~' ||
										  ltools.formatamount(-sacloseinfo(i).prcchargearray(j)
															  .amount
															 ,sacloseinfo (i).account.currencyno));
				END LOOP;
			
				dialog.listaddrecord(vpage
									,clist_debtinfo || i
									,'Overdue fee~' ||
									 ltools.formatamount(-sacloseinfo(i).overduefee
														,sacloseinfo (i).account.currencyno));
			
				dialog.listaddrecord(vpage
									,clist_debtinfo || i
									,'Overdue fee GST~' ||
									 ltools.formatamount(-sacloseinfo(i).overduefeegst
														,sacloseinfo (i).account.currencyno));
			
				dialog.listaddrecord(vpage
									,clist_debtinfo || i
									,'Overlimit fee~' ||
									 ltools.formatamount(-sacloseinfo(i).overlimitfee
														,sacloseinfo (i).account.currencyno));
			
				dialog.listaddrecord(vpage
									,clist_debtinfo || i
									,'Overlimit fee GST~' ||
									 ltools.formatamount(-sacloseinfo(i).overlimitfeegst
														,sacloseinfo (i).account.currencyno));
			
				dialog.listaddrecord(vpage
									,clist_debtinfo || i
									,'Installment amount~' ||
									 ltools.formatamount(-sacloseinfo(i).installmentamount
														,sacloseinfo (i).account.currencyno));
			
				dlg_tools.drawindicator_money(vpage
											 ,citem_overdraft || i
											 ,18
											 ,11
											 ,20
											 ,'Overdraft:'
											 ,'Account overdraft (credit limit)'
											 ,sprecision(i)
											 ,sacloseinfo(i).account.overdraft);
			
				dlg_tools.drawindicator_money(vpage
											 ,citem_debithold || i
											 ,18
											 ,12
											 ,20
											 ,'Debit on-hold:'
											 ,'Account debit on-hold'
											 ,sprecision(i)
											 ,sacloseinfo(i).account.debitreserve);
			
				dlg_tools.drawindicator_money(vpage
											 ,citem_credithold || i
											 ,18
											 ,13
											 ,20
											 ,'Credit on-hold:'
											 ,'Account credit on-hold'
											 ,sprecision(i)
											 ,sacloseinfo(i).account.creditreserve);
			
				dlg_tools.drawindicator_money(vpage
											 ,citem_balance || i
											 ,56
											 ,11
											 ,20
											 ,'Total balance:'
											 ,'Total balance for currency'
											 ,sprecision(i)
											 ,sacloseinfo(i).totalbalance);
			
				IF sacloseinfo(i).totalbalance < 0
				THEN
					vnegtotal := TRUE;
				ELSIF sacloseinfo(i).totalbalance > 0
				THEN
					vnegtotal := FALSE;
				END IF;
			
				IF vnegtotal IS NOT NULL
				THEN
				
					dialog.inputchar(vpage
									,citem_paymethod || i
									,56
									,12
									,18
									,service.iif(vnegtotal
												,'Select source type to pay indebtedness from'
												,'Select a way to transfer positive balance')
									,pcaption => service.iif(vnegtotal, 'Pay from:', 'Transfer to:'));
					dialog.listaddfield(vpage, citem_paymethod || i, cfld_id, 'N', 1, 0);
					dialog.listaddfield(vpage, citem_paymethod || i, cfld_name, 'C', 20, 1);
					dialog.listaddrecord(vpage
										,citem_paymethod || i
										,cmode_cashaccount || '~Cash account'
										,dialog.cmconfirm);
					dialog.listaddrecord(vpage
										,citem_paymethod || i
										,cmode_clientaccount || '~Customer''s account'
										,dialog.cmconfirm);
					dialog.listaddrecord(vpage
										,citem_paymethod || i
										,cmode_bankaccount || '~Intrabank account'
										,dialog.cmconfirm);
					IF hascorporatecontract
					THEN
						dialog.listaddrecord(vpage
											,citem_paymethod || i
											,cmode_corpaccount || '~Corporate account'
											,dialog.cmconfirm);
					END IF;
					dialog.setcurrecbyvalue(vpage
										   ,citem_paymethod || i
										   ,cfld_id
										   ,cmode_clientaccount);
					dialog.setreadonly(vpage, citem_paymethod || i);
				
					dialog.inputchar(vpage
									,citem_accountno || i
									,56
									,13
									,20
									,service.iif(vnegtotal
												,'Account to pay indebtedness from'
												,'Account to transfer positive balance')
									,pcaption => 'Account:');
					dialog.setitemcommand(vpage, citem_accountno || i, ccmd_findaccount);
				
				END IF;
			
			END IF;
		
		END LOOP;
	
		dlg_tools.drawindicator_integer(vdialog
									   ,citem_cardscount
									   ,19
									   ,17
									   ,20
									   ,'Active cards:'
									   ,'Number of cards in OPEN state'
									   ,contract.getcardlist(scontractno, NULL, referencecrd_stat.cardopen)
										.count);
	
		dialog.bevel(vdialog, 1, 16, 79, 2, dialog.bevel_frame, pcaption => 'Cards closing');
		drawcardclosemodecomponent(vdialog, citem_cardstoclose, 57, 17, 18);
	
		dlg_tools.startbuttondrawing(c_dialogwidth, 2);
		dlg_tools.drawbutton(vdialog
							,cbtn_ok
							,'OK'
							,'Press this button to close contract'
							,c_dialogheight - 2
							,dialog.cmok
							,pdefault => TRUE);
		dlg_tools.drawbutton(vdialog
							,cbtn_cancel
							,'Cancel'
							,'Press this button to cancel operation'
							,c_dialogheight - 2
							,dialog.cmcancel);
	
		dialog.setdialogvalid(vdialog, chandlername);
	
		t.leave(cmethodname);
		RETURN vdialog;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			dialog.destroy(vdialog);
			error.save(cmethodname);
			RAISE;
	END dlg_closecontract_create;

	FUNCTION dlg_closecontract_getdata
	(
		pdialog        IN NUMBER
	   ,oaaccounts     OUT NOCOPY contracttools.typeaccarray
	   ,ocardclosemode OUT PLS_INTEGER
	) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_CloseContract_GetData';
	
		vtotalbalance NUMBER;
		vpaymethod    NUMBER;
	
	BEGIN
		t.enter(cmethodname, pdialog);
	
		FOR i IN 1 .. 2
		LOOP
		
			IF dialog.existsitembyname(pdialog, clist_debtinfo || i)
			THEN
			
				dlg_tools.validatenumber(pdialog
										,citem_debithold || i
										,pcheckmode => dlg_tools.cnum_zero
										,perrmsg => 'Contract can not be closed as there is an unhandled debit on-hold exist!');
			
				dlg_tools.validatenumber(pdialog
										,citem_credithold || i
										,pcheckmode => dlg_tools.cnum_zero
										,perrmsg => 'Contract can not be closed as there is an unhandled debit on-hold exist!');
			
				vtotalbalance := dlg_tools.getnumber(pdialog
													,citem_balance || i
													,perrmsg => 'Internal error: total balance cannot be empty!');
			
				IF vtotalbalance <> 0
				THEN
				
					vpaymethod := dialog.getcurrentrecordnumber(pdialog
															   ,citem_paymethod || i
															   ,cfld_id);
				
					IF vpaymethod IN (cmode_clientaccount, cmode_bankaccount)
					THEN
						oaaccounts(i).accountno := dlg_tools.getaccountno(pdialog
																		 ,citem_accountno || i);
					ELSIF vpaymethod = cmode_cashaccount
					THEN
						oaaccounts(i).accountno := dlg_tools.getaccountno(pdialog
																		 ,citem_accountno || i
																		 ,perrmsg => 'Cash account for currency ' ||
																					 referencecurrency.getabbreviation(sdepaccount(i)
																													   .currencyno) ||
																					 ' is not defined!');
					ELSIF vpaymethod = cmode_corpaccount
					THEN
						oaaccounts(i).accountno := dlg_tools.getaccountno(pdialog
																		 ,citem_accountno || i
																		 ,perrmsg => 'Cannot get corporate account for contract!');
					END IF;
				END IF;
			END IF;
		END LOOP;
	
		ocardclosemode := dlg_tools.getdroplistvalue(pdialog
													,citem_cardstoclose
													,'Cards close mode');
	
		t.leave(cmethodname, htools.b2s(TRUE));
		RETURN TRUE;
	EXCEPTION
		WHEN dlg_tools.validate_error THEN
			t.leave(cmethodname, htools.b2s(FALSE));
			RETURN FALSE;
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_closecontract_getdata;

	PROCEDURE dlg_closecontract_handler
	(
		pwhat     IN CHAR
	   ,pdialog   IN NUMBER
	   ,pitemname IN VARCHAR2
	   ,pcmd      IN NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Dlg_CloseContract_Handler';
	
		vaaccounts     contracttools.typeaccarray;
		vaccountno     typeaccountno := NULL;
		vcardclosemode PLS_INTEGER;
		vcurrencyno    VARCHAR2(1);
		vpaymode       PLS_INTEGER;
	
	BEGIN
		t.enter(cmethodname
			   ,'What = ' || pwhat || ', Dialog = ' || pdialog || ', ItemName = ' || pitemname ||
				', Cmd = ' || pcmd);
	
		IF pwhat = dialog.wt_dialogvalid
		THEN
		
			CASE pcmd
			
				WHEN dialog.cmok THEN
				
					IF dlg_closecontract_getdata(pdialog, vaaccounts, vcardclosemode)
					THEN
					
						getcontractdata(pcalcdelparams => FALSE);
					
						BEGIN
							SAVEPOINT sp_closecontract;
							contractoplog.init;
							doclosecontract(sacloseinfo, vaaccounts, vcardclosemode);
							contractoplog.done(scontractno, cso_closecontract);
						EXCEPTION
							WHEN OTHERS THEN
								contractoplog.clearlaststate;
								ROLLBACK TO sp_closecontract;
								dialog.cancelclose(pdialog);
								htools.showmessage('Error', error.getusertext);
						END;
					
					END IF;
				
				WHEN ccmd_findaccount THEN
				
					vcurrencyno := substr(pitemname, -1);
				
					CASE
					 dialog.getcurrentrecordnumber(pdialog, citem_paymethod || vcurrencyno, cfld_id)
					
						WHEN cmode_clientaccount THEN
							dlg_tools.rundlg_selectaccount(pdialog
														  ,citem_accountno || vcurrencyno
														  ,finderselectaccount.acpersone
														  ,contracttypeschema.scontractrow.idclient);
						
						WHEN cmode_bankaccount THEN
							dlg_tools.rundlg_selectaccount(pdialog
														  ,citem_accountno || vcurrencyno
														  ,finderselectaccount.accompany);
						
						ELSE
							NULL;
					END CASE;
				
				WHEN dialog.cmconfirm THEN
				
					vcurrencyno := substr(pitemname, -1);
				
					vpaymode := dialog.getcurrentrecordnumber(pdialog
															 ,citem_paymethod || vcurrencyno
															 ,cfld_id);
				
					dialog.setenable(pdialog
									,citem_accountno || vcurrencyno
									,vpaymode IN (cmode_clientaccount, cmode_bankaccount));
				
					IF vpaymode = cmode_cashaccount
					THEN
						vaccountno := kassaaccount.getkassaaccount(sdepaccount(vcurrencyno)
																   .currencyno);
					
					ELSIF vpaymode = cmode_corpaccount
					THEN
						vaccountno := getcorporatebankaccount(sdepaccount(vcurrencyno).currencyno
															 ,c_noexception);
					END IF;
				
					dialog.putchar(pdialog, citem_accountno || vcurrencyno, vaccountno);
				
					dialog.cancelclose(pdialog);
				
				ELSE
					NULL;
			END CASE;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END dlg_closecontract_handler;

	PROCEDURE undostatuschange_legacy(pisbatch IN BOOLEAN) IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.UndoStatusChanging_Legacy';
		vcount            NUMBER := 1;
		vkey              VARCHAR2(10);
		vvalue            VARCHAR(250);
		vbeforeclosurests VARCHAR2(20) := NULL;
		vclosepackno      NUMBER;
	BEGIN
		IF pisbatch
		THEN
			LOOP
				vkey := contracttools.getdataforundo(vcount, vvalue);
				EXIT WHEN vkey IS NULL;
				IF vkey = '#Vof'
				THEN
					IF contract.setstatus(scontractno, contract.stat_violate, TRUE) <> 0
					THEN
						error.raiseerror(err.getfullmessage);
					END IF;
				ELSIF vkey = '#Von'
				THEN
					IF contracttools.resetviolatedstat(contracttypeschema.scontractrow.no) <> 0
					THEN
						error.raiseerror(err.getfullmessage);
					END IF;
				END IF;
			END LOOP;
		ELSE
			vclosepackno := contractparams.loadnumber(contractparams.ccontract
													 ,scontractno
													 ,'ClosePackNo'
													 ,FALSE);
			t.var('vClosePackNo', vclosepackno);
			IF nvl(vclosepackno, -1) = -1
			THEN
				ROLLBACK;
				error.raiseerror('This contract was closed with a batch operation, you can not reopen it with a manual operation');
			END IF;
			vbeforeclosurests := contractparams.loadchar(contractparams.ccontract
														,scontractno
														,'BeforeClosureStatus'
														,FALSE);
			IF nvl(vbeforeclosurests, 'N') <> 'N'
			THEN
				contract.setstatus(scontractno, REPLACE(vbeforeclosurests, '00000'));
				contractparams.deletevalue(contractparams.ccontract
										  ,scontractno
										  ,'BeforeClosureStatus');
				contractparams.deletevalue(contractparams.ccontract, scontractno, 'ClosePackNo');
			END IF;
		END IF;
	
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END undostatuschange_legacy;

	PROCEDURE undobatchcontractclose_legacy IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.UndoBatchContractClose_Legacy';
		coperdate   CONSTANT DATE := seance.getoperdate;
	
		vlimit1   NUMBER;
		vlimit2   NUMBER;
		vdocno    NUMBER;
		vlinkno   VARCHAR(20);
		vavllimit NUMBER;
		vpackno   NUMBER;
	
		vhistpackno      tcontracthistory.packno%TYPE;
		vifduedate       BOOLEAN;
		vifstatementdate BOOLEAN;
		vcacheindex      VARCHAR2(50);
	BEGIN
	
		scontractstat := contract.getstatus(contracttypeschema.scontractrow.no);
		IF NOT contract.checkstatus(scontractstat, contract.stat_close)
		THEN
			error.raiseerror('Contract is not closed!');
		END IF;
	
		IF contracttypeschema.scontractrow.closedate <> coperdate
		THEN
			error.raiseerror('Contract closure date is not equal to business date!');
		END IF;
	
		IF contracttools.openaccounts(contracttypeschema.scontractrow.no) <> 0
		THEN
			error.raiseerror('Error reopening accounts!');
		END IF;
	
		IF contracttools.unclosecard(contracttypeschema.scontractrow.no) IS NULL
		THEN
			error.raiseerror('Error reopening cards!');
		END IF;
	
		IF contracttools.opencontract(contracttypeschema.scontractrow.no) <> 0
		THEN
			error.raiseerror('Error reopening contract!');
		END IF;
	
		vlimit1 := contractparams.loadnumber(contractparams.ccontract, scontractno, 'Limit1', FALSE);
		vlimit2 := contractparams.loadnumber(contractparams.ccontract, scontractno, 'Limit2', FALSE);
		s.say(cmethodname || ' vLimit1 =' || vlimit1, 1);
		s.say(cmethodname || ' vLimit2 =' || vlimit2, 1);
		vdocno  := contractparams.loadnumber(contractparams.ccontract
											,scontractno
											,'CloseDocNo'
											,FALSE);
		vpackno := contractparams.loadnumber(contractparams.ccontract
											,scontractno
											,'ClosePackNo'
											,FALSE);
		vlinkno := contractparams.loadchar(contractparams.ccontract
										  ,scontractno
										  ,'CloseLinkNo'
										  ,FALSE);
	
		vhistpackno := contractparams.loadnumber(contractparams.ccontract
												,scontractno
												,'ClsContrHistPack'
												,FALSE);
		IF vhistpackno IS NOT NULL
		THEN
			contractparams.deletehistory(vhistpackno);
			contractparams.deletevalue(contractparams.ccontract, scontractno, 'ClsContrHistPack');
		END IF;
	
		undostatuschange_legacy(TRUE);
	
		IF vlinkno IS NOT NULL
		THEN
			contractlink.addcontractlink(contractlink.cmain, vlinkno, scontractno);
		END IF;
	
		IF NOT hascorporatecontract
		THEN
			IF ifcurrencyisusedintype(1, scontracttype, scontractno)
			THEN
				contracttools.setoverdraft(sdepaccount(1), vlimit1);
			END IF;
			IF ifcurrencyisusedintype(2, scontracttype, scontractno)
			THEN
				contracttools.setoverdraft(sdepaccount(2), vlimit2);
			END IF;
		ELSE
			IF ifcurrencyisusedintype(1, scontracttype, scontractno)
			THEN
				IF canexceedlimit(sdepaccount(1).currencyno, vavllimit)
				   OR (vavllimit IS NOT NULL AND vavllimit >= vlimit1)
				THEN
					contracttools.setoverdraft(sdepaccount(1), vlimit1);
				ELSE
					error.raiseerror('Maximum limit value should not exceed ' ||
									 ltools.formatamount(vavllimit + sdepaccount(1).overdraft
														,sdepaccount(1).currencyno) || '(' ||
									 referencecurrency.getabbreviation(sdepaccount(1).currencyno) || ')');
				END IF;
			
				IF NOT canexceedacccashlimit(sdepaccount(1).currencyno, vavllimit)
				   AND vavllimit IS NOT NULL
				   AND getalllimitsvalue_fromhistory(scontractno) (1)('-')
				.estabcashlimit > vavllimit
				THEN
				
					error.raiseerror('According to corporate contract settings, maximum account cash limit value should not exceed ' ||
									 ltools.formatamount(vavllimit, sdepaccount(1).currencyno) || '(' ||
									 referencecurrency.getabbreviation(sdepaccount(1).currencyno) ||
									 ') for this customer contract.');
				END IF;
			
			END IF;
		
			IF ifcurrencyisusedintype(2, scontracttype, scontractno)
			THEN
				IF canexceedlimit(sdepaccount(2).currencyno, vavllimit)
				   OR (vavllimit IS NOT NULL AND vavllimit >= vlimit2)
				THEN
					contracttools.setoverdraft(sdepaccount(2), vlimit2);
				ELSE
					error.raiseerror('Maximum limit value should not exceed ' ||
									 ltools.formatamount(vavllimit + sdepaccount(2).overdraft
														,sdepaccount(2).currencyno) || '(' ||
									 referencecurrency.getabbreviation(sdepaccount(2).currencyno) || ')');
				END IF;
			
				IF NOT canexceedacccashlimit(sdepaccount(2).currencyno, vavllimit)
				   AND vavllimit IS NOT NULL
				   AND getalllimitsvalue_fromhistory(scontractno) (2)('-')
				.estabcashlimit > vavllimit
				THEN
					error.raiseerror('According to corporate contract settings, maximum account cash limit value should not exceed ' ||
									 ltools.formatamount(vavllimit, sdepaccount(2).currencyno) || '(' ||
									 referencecurrency.getabbreviation(sdepaccount(2).currencyno) ||
									 ') for this customer contract.');
				END IF;
			END IF;
		END IF;
	
		IF vdocno IS NOT NULL
		THEN
			IF entry.undo(entry.flnocheck, vdocno) <> 0
			THEN
				error.raiseerror('Error undoing entry!');
			END IF;
			contractparams.deletevalue(contractparams.ccontract, scontractno, 'CloseDocNo');
		END IF;
		s.say(cmethodname || ' -> PackNo=' || vpackno, 1);
		IF vpackno IS NOT NULL
		THEN
			rollbacktrxnlist(vpackno);
		END IF;
	
		undoinstallmentclosure_legacy;
	
		a4mlog.logobject(object.gettype(contract.object_name)
						,scontractno
						,'Cancel contract closure'
						,powner => getclientid);
	
		FOR i IN 1 .. 2
		LOOP
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			THEN
			
				vcacheindex := sdepaccount(i)
							   .accountno || '-' || i || '-' || to_char(coperdate, 'yyyy.mm.dd');
				s.say(cmethodname || '  Cache Index (vCacheIndex) = ' || vcacheindex);
				IF custom_overdueparameterscalculation.scache(vcacheindex)
				 .minpaymentstdataarray.exists(1)
				THEN
					vifduedate       := contracttypeschema.scontractrow.closedate = custom_overdueparameterscalculation.scache(vcacheindex).minpaymentstdataarray(custom_overdueparameterscalculation.scache(vcacheindex).minpaymentstdataarray.count)
									   .duedate;
					vifstatementdate := contracttypeschema.scontractrow.closedate = custom_overdueparameterscalculation.scache(vcacheindex).minpaymentstdataarray(custom_overdueparameterscalculation.scache(vcacheindex).minpaymentstdataarray.count)
									   .statementdate;
				END IF;
			
				custom_overdueparameterscalculation.rollbackaggregatedtrxn(sdepaccount(i).accountno
																		  ,i
																		  ,vpackno
																		  ,vifduedate
																		  ,vifstatementdate);
			END IF;
		END LOOP;
		custom_overdueparameterscalculation.clearcache;
	
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END undobatchcontractclose_legacy;

	PROCEDURE undomanualcontractclose_legacy IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.UndoManualContractClose_Legacy';
		vlimit1          NUMBER;
		vlimit2          NUMBER;
		vdocno           NUMBER;
		vlinkno          VARCHAR(20);
		vavllimit        NUMBER;
		vpackno          NUMBER;
		vhistpackno      tcontracthistory.packno%TYPE;
		vcacheindex      VARCHAR2(50);
		vifstatementdate BOOLEAN;
		vifduedate       BOOLEAN;
	BEGIN
	
		SAVEPOINT spunclose;
		scontractstat := contract.getstatus(contracttypeschema.scontractrow.no);
		IF NOT contract.checkstatus(scontractstat, contract.stat_close)
		THEN
			htools.showmessage('Warning', 'Contract is not closed!');
			RETURN;
		END IF;
	
		IF contracttools.openaccounts(contracttypeschema.scontractrow.no) <> 0
		THEN
			error.raiseerror('Error reopening accounts!');
		END IF;
	
		IF contracttools.unclosecard(contracttypeschema.scontractrow.no) IS NULL
		THEN
			error.raiseerror('Error reopening cards!');
		END IF;
	
		IF contracttools.opencontract(contracttypeschema.scontractrow.no) <> 0
		THEN
			error.raiseerror('Error reopening contract!');
		END IF;
	
		vlimit1 := contractparams.loadnumber(contractparams.ccontract, scontractno, 'Limit1', FALSE);
		vlimit2 := contractparams.loadnumber(contractparams.ccontract, scontractno, 'Limit2', FALSE);
		s.say(cmethodname || ' vLimit1 =' || vlimit1, 1);
		s.say(cmethodname || ' vLimit2 =' || vlimit2, 1);
		vdocno  := contractparams.loadnumber(contractparams.ccontract
											,scontractno
											,'CloseDocNo'
											,FALSE);
		vpackno := contractparams.loadnumber(contractparams.ccontract
											,scontractno
											,'ClosePackNo'
											,FALSE);
		vlinkno := contractparams.loadchar(contractparams.ccontract
										  ,scontractno
										  ,'CloseLinkNo'
										  ,FALSE);
	
		vhistpackno := contractparams.loadnumber(contractparams.ccontract
												,scontractno
												,'ClsContrHistPack'
												,FALSE);
		IF vhistpackno IS NOT NULL
		THEN
			contractparams.deletehistory(vhistpackno);
			contractparams.deletevalue(contractparams.ccontract, scontractno, 'ClsContrHistPack');
		END IF;
	
		undostatuschange_legacy(FALSE);
	
		IF vlinkno IS NOT NULL
		THEN
			contractlink.addcontractlink(contractlink.cmain, vlinkno, scontractno);
		END IF;
	
		IF NOT hascorporatecontract
		THEN
			IF ifcurrencyisusedintype(1, contracttypeschema.scontractrow.type, scontractno)
			THEN
				contracttools.setoverdraft(sdepaccount(1), vlimit1);
			END IF;
			IF ifcurrencyisusedintype(2, contracttypeschema.scontractrow.type, scontractno)
			THEN
				contracttools.setoverdraft(sdepaccount(2), vlimit2);
			END IF;
		ELSE
			IF ifcurrencyisusedintype(1, contracttypeschema.scontractrow.type, scontractno)
			THEN
				IF canexceedlimit(sdepaccount(1).currencyno, vavllimit)
				   OR (vavllimit IS NOT NULL AND vavllimit >= vlimit1)
				THEN
					contracttools.setoverdraft(sdepaccount(1), vlimit1);
				ELSE
					ROLLBACK TO spunclose;
					htools.showmessage('Warning'
									  ,'Maximum limit value should not exceed ' ||
									   ltools.formatamount(vavllimit + sdepaccount(1).overdraft
														  ,sdepaccount(1).currencyno) || '(' ||
									   referencecurrency.getabbreviation(sdepaccount(1).currencyno) || ')');
					RETURN;
				END IF;
			
				IF NOT canexceedacccashlimit(sdepaccount(1).currencyno, vavllimit)
				   AND vavllimit IS NOT NULL
				   AND getalllimitsvalue_fromhistory(scontractno) (1)('-')
				.estabcashlimit > vavllimit
				THEN
					error.raiseerror('According to corporate contract settings, maximum account cash limit value should not exceed ' ||
									 ltools.formatamount(vavllimit, sdepaccount(1).currencyno) || '(' ||
									 referencecurrency.getabbreviation(sdepaccount(1).currencyno) ||
									 ') for this customer contract.');
				END IF;
			
			END IF;
			IF ifcurrencyisusedintype(2, contracttypeschema.scontractrow.type, scontractno)
			THEN
				IF canexceedlimit(sdepaccount(2).currencyno, vavllimit)
				   OR (vavllimit IS NOT NULL AND vavllimit >= vlimit2)
				THEN
					contracttools.setoverdraft(sdepaccount(2), vlimit2);
				ELSE
					ROLLBACK TO spunclose;
					htools.showmessage('Warning'
									  ,'Maximum limit value should not exceed ' ||
									   ltools.formatamount(vavllimit + sdepaccount(2).overdraft
														  ,sdepaccount(2).currencyno) || '(' ||
									   referencecurrency.getabbreviation(sdepaccount(2).currencyno) || ')');
					RETURN;
				END IF;
			
				IF NOT canexceedacccashlimit(sdepaccount(2).currencyno, vavllimit)
				   AND vavllimit IS NOT NULL
				   AND getalllimitsvalue_fromhistory(scontractno) (2)('-')
				.estabcashlimit > vavllimit
				THEN
					error.raiseerror('According to corporate contract settings, maximum account cash limit value should not exceed ' ||
									 ltools.formatamount(vavllimit, sdepaccount(2).currencyno) || '(' ||
									 referencecurrency.getabbreviation(sdepaccount(2).currencyno) ||
									 ') for this customer contract.');
				END IF;
			
			END IF;
		END IF;
	
		IF vdocno IS NOT NULL
		THEN
			IF entry.undo(entry.flnocheck, vdocno) <> 0
			THEN
				error.raiseerror('Error undoing entry!');
			END IF;
			contractparams.deletevalue(contractparams.ccontract, scontractno, 'CloseDocNo');
		END IF;
	
		undoinstallmentclosure_legacy;
	
		s.say(cmethodname || ' -> PackNo=' || vpackno, 1);
		IF vpackno IS NOT NULL
		THEN
			rollbacktrxnlist(vpackno);
		END IF;
	
		a4mlog.logobject(object.gettype(contract.object_name)
						,scontractno
						,'Cancel contract closure'
						,powner => getclientid);
		FOR i IN 1 .. 2
		LOOP
			IF ifcurrencyisusedintype(i, contracttypeschema.scontractrow.type, scontractno)
			THEN
			
				custom_overdueparameterscalculation.fillstminpaymentdataarrays(sdepaccount(i)
																			   .accountno
																			  ,i
																			  ,NULL);
				vcacheindex := sdepaccount(i).accountno || '-' || i || '-';
				s.say(cmethodname || '  Cache Index (vCacheIndex) = ' || vcacheindex);
				IF custom_overdueparameterscalculation.scache.exists(vcacheindex)
				   AND custom_overdueparameterscalculation.scache(vcacheindex)
				  .minpaymentstdataarray.exists(1)
				THEN
					vifduedate       := contracttypeschema.scontractrow.closedate = custom_overdueparameterscalculation.scache(vcacheindex).minpaymentstdataarray(custom_overdueparameterscalculation.scache(vcacheindex).minpaymentstdataarray.count)
									   .duedate;
					vifstatementdate := contracttypeschema.scontractrow.closedate = custom_overdueparameterscalculation.scache(vcacheindex).minpaymentstdataarray(custom_overdueparameterscalculation.scache(vcacheindex).minpaymentstdataarray.count)
									   .statementdate;
				END IF;
			
				custom_overdueparameterscalculation.rollbackaggregatedtrxn(sdepaccount(i).accountno
																		  ,i
																		  ,vpackno
																		  ,vifduedate
																		  ,vifstatementdate);
			END IF;
		END LOOP;
		custom_overdueparameterscalculation.clearcache;
	
		htools.showmessage('Cancel contract closure', 'Contract is reopened successfully');
		scontrattrcalcflag.delete;
		clearcontrtypecache;
	EXCEPTION
		WHEN OTHERS THEN
			ROLLBACK TO spunclose;
			error.save(cmethodname);
			RAISE;
	END undomanualcontractclose_legacy;

	FUNCTION canunclosecontract(oerrmsg OUT NOCOPY VARCHAR2) RETURN BOOLEAN IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CanUncloseContract';
	BEGIN
		t.enter(cmethodname);
	
		oerrmsg := NULL;
	
		IF contracttypeschema.scontractrow.closedate <> seance.getoperdate
		THEN
			oerrmsg := 'Cannot unclose contract as contract closure date is not equal to business date!';
		END IF;
	
		t.leave(cmethodname, htools.b2s(oerrmsg IS NULL));
		RETURN oerrmsg IS NULL;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END canunclosecontract;

	PROCEDURE undoclosecontract
	(
		pcontractno   IN typecontractno
	   ,prollbackdata IN contractrb.trollbackdata
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UndoCloseContract';
		verrmsg VARCHAR2(200);
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		initcontract(pcontractno);
	
		IF canunclosecontract(verrmsg)
		THEN
		
			IF prollbackdata IS NULL
			THEN
				undobatchcontractclose_legacy;
			ELSE
				contractrb.undo(pcontractno, prollbackdata);
			END IF;
		ELSE
		
			error.raiseerror(verrmsg);
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END undoclosecontract;

	FUNCTION getoperationlist
	(
		pcontracttype    IN typecontracttype
	   ,pcontractno      IN typecontractno
	   ,oaoperationslist OUT NOCOPY contract.typeschemaoperationsarray
	) RETURN NUMBER IS
		cmethodname      CONSTANT typemethodname := cpackagename || '.GetOperationList';
		cforaccesssystem CONSTANT BOOLEAN := pcontractno IS NULL;
	
		vacollectionoperations contract.typeschemaoperationsarray;
		vinstallmentsused      BOOLEAN;
		vclosed                BOOLEAN;
	
		FUNCTION isoperallowed(poperation IN VARCHAR2) RETURN BOOLEAN IS
			cmethodname CONSTANT typemethodname := getoperationlist.cmethodname || '.IsOperAllowed';
			vresult BOOLEAN := FALSE;
		BEGIN
			t.enter(cmethodname, poperation);
		
			IF poperation = copertranchesinfo
			THEN
				vresult := TRUE;
			
			ELSIF poperation = coperundoclose
			THEN
				vresult := vclosed;
			
			ELSIF NOT vclosed
			THEN
			
				IF poperation IN (copersetcreditlimit
								 ,copersetcontractparams
								 ,copersetcontractstate
								 ,copermanagecards
								 ,copersetcorporatelink
								 ,copercreditrepayment
								 ,copermoveduedate
								 ,coperclosecontract)
				THEN
					vresult := TRUE;
				
				ELSIF poperation IN (copersetdcparams, copersetdccase)
				THEN
					vresult := debtcollectoravailable;
				
				ELSE
				
					CASE poperation
					
						WHEN coperinstallment THEN
							vresult := vinstallmentsused;
						
						WHEN coperrestructuring THEN
							IF vinstallmentsused
							THEN
								FOR i IN 1 .. 2
								LOOP
									IF ifcurrencyisusedintype(i, scontracttype, scontractno)
									THEN
										vresult := sactparamccy(i) (cctp_debttoinston) = '1';
										EXIT WHEN vresult;
									END IF;
								END LOOP;
							END IF;
						
						WHEN coperundorestructuring THEN
							vresult := contractoplog.getlastrecord(pcontractno, cso_restructuring, c_noexception)
									   .oplogid IS NOT NULL;
						
						WHEN coperchargeinterest THEN
							vresult := saccumintaccmode <> cintaccmode_donotaccumulate;
						
						ELSE
							error.raiseerror('Internal error: operation <' || poperation ||
											 '> is not supported!');
						
					END CASE;
				
				END IF;
			
			END IF;
		
			t.leave(cmethodname, htools.b2s(vresult));
			RETURN vresult;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END;
	
		PROCEDURE addoperation(poperation IN contract.typeschemaoperations) IS
			cmethodname CONSTANT typemethodname := getoperationlist.cmethodname || '.AddOperation';
		BEGIN
			oaoperationslist(oaoperationslist.count + 1) := poperation;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END addoperation;
	
		PROCEDURE registeroperation
		(
			poperation   IN VARCHAR2
		   ,pdescription IN VARCHAR2
		   ,prights      IN VARCHAR2 := NULL
		) IS
			cmethodname CONSTANT typemethodname := getoperationlist.cmethodname ||
												   '.RegisterOperation';
			voperation contract.typeschemaoperations;
			varights   contracttypeschema.typefschparamlist;
		BEGIN
		
			voperation.operationcode   := poperation;
			voperation.operationtype   := contract.cschemaoperation;
			voperation.operationname   := pdescription;
			voperation.ismodifiability := 1;
		
			voperation.enabled := htools.b2i(cforaccesssystem OR isoperallowed(poperation));
		
			varights := contracttools.paramstringtolist(prights, pprohibitdups => TRUE);
		
			FOR i IN 1 .. varights.count
			LOOP
				voperation.paramlist(varights(i).id).paramkey := varights(i).id;
				voperation.paramlist(varights(i).id).paramname := varights(i).stringvalue;
			END LOOP;
		
			addoperation(voperation);
		
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END registeroperation;
	
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		IF NOT cforaccesssystem
		THEN
			initcontract(pcontractno);
			vclosed           := contract.checkstatus(contract.getstatus(pcontractno)
													 ,contract.stat_close);
			vinstallmentsused := (slinkschemasinst.count > 0) AND (sactparam(cctp_useinst) = '1');
		END IF;
	
		registeroperation(copersetcreditlimit
						 ,'Set credit limit'
						 ,'EXEC_LMT=Execute operation;
																			SET_CNFRM=Confirm limit settings for confirmed permission score;
																			SET_PRHBT=Confirm limit setting for prohibitive score');
	
		registeroperation(copersetcontractparams
						 ,'Set contract parameters'
						 ,'VIEW_PARAMS=View contract parameters;
																			COMMON_PG=Modify common parameters;
																			BIL_C_CLDR=Modify billing cycle calendar;
																			DELINQENCY_PG=Modify delinquency parameters;
																			PROFILES_PG=Modify profiles;
																			DAF_GEN_PG=Modify DAF generation parameters;
																			LIMITS_PG=Modify limits;
																			INSTALLMENT_PG=Modify installment parameters;
																			CRD_SHIELD_PG=Modify credit shield parameters;
																			CUSTMRS_ACC_PG=Modify customers accounts');
	
		registeroperation(copersetdcparams, 'Set DC parameters');
		registeroperation(copersetcontractstate, 'Set contract state');
		registeroperation(copermanagecards, 'Set cards state/status');
		registeroperation(copersetcorporatelink, 'Set corporate contract link');
		registeroperation(copercreditrepayment, 'Credit repayment');
		registeroperation(coperchargeinterest, 'Charge accumulated interest');
	
		registeroperation(coperinstallment
						 ,'Installment management'
						 ,cright_instschedule || '=Schedule button;' || cright_instprecheck ||
						  '=Pre-check button;' || cright_insttransfer || '=Transfer button;' ||
						  cright_instaccelerate || '=Accelerate button;' || cright_instdelete ||
						  '=Delete button;' || cright_scheddelete ||
						  '=Delete partial transaction repayment;' || cright_schedrepayment ||
						  '=Set partial transaction repayment');
		registeroperation(copersetdccase, 'Open/close DC case');
		registeroperation(copermoveduedate, 'Change due date');
		registeroperation(coperrestructuring, 'Debt restructuring');
		registeroperation(coperundorestructuring, 'Undo debt restructuring');
		registeroperation(coperclosecontract, 'Close contract');
		registeroperation(coperundoclose, 'Undo contract closure');
		registeroperation(copertranchesinfo, 'Tranches information');
	
		IF collectionavailable
		THEN
			vacollectionoperations := contractcollection.getcontractoperlist;
			FOR i IN 1 .. vacollectionoperations.count
			LOOP
				addoperation(vacollectionoperations(i));
			END LOOP;
		END IF;
	
		t.leave(cmethodname, oaoperationslist.count);
		RETURN oaoperationslist.count;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getoperationlist;

	FUNCTION executeoperation
	(
		pcontractno    IN typecontractno
	   ,poperationcode IN VARCHAR2
	) RETURN contracttypeschema.typeoperationresult IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ExecuteOperation';
		vresult contracttypeschema.typeoperationresult;
	
		PROCEDURE int_managelimits(poresult IN OUT NOCOPY contracttypeschema.typeoperationresult) IS
			cmethodname CONSTANT typemethodname := executeoperation.cmethodname ||
												   '.Int_ManageLimits';
		BEGIN
			t.enter(cmethodname);
		
			IF contract.checkoperright(contract.right_modify_oper
									  ,scontractno
									  ,copersetcreditlimit
									  ,'EXEC_LMT')
			THEN
				dlg_tools.executeoperation(dlg_managelimits_create, poresult, TRUE);
			ELSE
				htools.showmessage('Attention'
								  ,'You have no permission to perform this operation!');
			END IF;
		
			t.leave(cmethodname, poresult.resultvalue);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_managelimits;
	
		PROCEDURE int_setcontractparams(poresult IN OUT NOCOPY contracttypeschema.typeoperationresult) IS
			cmethodname CONSTANT typemethodname := executeoperation.cmethodname ||
												   '.Int_SetContractParams';
		BEGIN
			t.enter(cmethodname);
		
			IF checkright('SET_PARAM', cright_viewparams)
			THEN
				dlg_tools.executeoperation(dlg_contractparams_create, poresult);
			ELSE
				htools.showmessage('Attention'
								  ,'Not enough privileges to view contract parameters!');
			END IF;
		
			t.leave(cmethodname, poresult.resultvalue);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_setcontractparams;
	
		PROCEDURE int_undoclosecontract(poresult IN OUT NOCOPY contracttypeschema.typeoperationresult) IS
			cmethodname CONSTANT typemethodname := executeoperation.cmethodname ||
												   '.Int_UndoCloseContract';
			voplogrec contractoplog.trecoplog;
			verrmsg   VARCHAR2(200);
		BEGIN
			t.enter(cmethodname);
		
			IF canunclosecontract(verrmsg)
			THEN
			
				IF htools.ask(contractdlg.makedialogcaption(scontractno
														   ,contractdlg.c_cap_conunclose)
							 ,'Do you wish to reopen contract "' || scontractno || '"?')
				THEN
				
					voplogrec := contractoplog.getlastrecord(scontractno
															,cso_closecontract
															,c_noexception);
				
					IF voplogrec.oplogid IS NULL
					THEN
						undomanualcontractclose_legacy;
					ELSE
						contractoplog.undo(voplogrec.oplogid);
					END IF;
				
					poresult.resultvalue := contracttypeschema.c_oper_completed;
				END IF;
			
			ELSE
				htools.showmessage('????', verrmsg);
			END IF;
		
			t.leave(cmethodname, poresult.resultvalue);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_undoclosecontract;
	
		PROCEDURE int_moveduedate(poresult IN OUT NOCOPY contracttypeschema.typeoperationresult) IS
			cmethodname CONSTANT typemethodname := executeoperation.cmethodname ||
												   '.Int_MoveDueDate';
		BEGIN
			t.enter(cmethodname);
		
			IF getcurrentcycle().lastduedate IS NULL
			THEN
				dlg_tools.executeoperation(dlg_moveduedate_create, poresult);
			ELSE
				htools.showmessage('Error'
								  ,'Due date ' || htools.d2s(getcurrentcycle().lastduedate) ||
								   ' cannot be changed~as it has already passed!');
			END IF;
		
			t.leave(cmethodname, poresult.resultvalue);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_moveduedate;
	
		PROCEDURE int_undorestructuring(poresult IN OUT NOCOPY contracttypeschema.typeoperationresult) IS
			cmethodname CONSTANT typemethodname := executeoperation.cmethodname ||
												   '.Int_UndoRestructuring';
			voplogrec  contractoplog.trecoplog;
			ventrylist fintools.typeentrylist;
			vlastdocno NUMBER;
		BEGIN
			t.enter(cmethodname);
		
			voplogrec := contractoplog.getlastrecord(pcontractno, cso_restructuring);
		
			ventrylist := fintools.getdocumententries(voplogrec.docno);
		
			FOR i IN 1 .. ventrylist.count
			LOOP
				IF contracttools.equal(ventrylist(i).creditaccount, sdepaccount(1).accountno)
				   OR contracttools.equal(ventrylist(i).creditaccount, sdepaccount(2).accountno)
				THEN
					vlastdocno := greatest(nvl(vlastdocno, voplogrec.docno)
										  ,fintools.getlastdocno(ventrylist(i).creditaccount));
				END IF;
			END LOOP;
		
			IF vlastdocno = voplogrec.docno
			THEN
			
				IF htools.ask('Confirm'
							 ,'Do you want to undo debt restructuring~for contract dated ' ||
							  htools.d2s(voplogrec.operdate) || '?')
				THEN
				
					contractoplog.undo(voplogrec.oplogid);
				
					poresult.resultvalue := contracttypeschema.c_oper_completed;
				
				END IF;
			
			ELSE
				htools.showmessage('Operation impossible'
								  ,'You should first undo all financial documents~up to <' ||
								   voplogrec.docno || '> to cancel debt restructuring!');
			END IF;
		
			t.leave(cmethodname, poresult.resultvalue);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END int_undorestructuring;
	
	BEGIN
		t.enter(cmethodname, poperationcode);
	
		initcontract(pcontractno);
	
		startnewdocument;
	
		vresult.resultvalue := contracttypeschema.c_oper_canceled;
	
		CASE upper(poperationcode)
		
			WHEN copersetcreditlimit THEN
				int_managelimits(vresult);
			
			WHEN copersetcontractparams THEN
				int_setcontractparams(vresult);
			
			WHEN copersetdcparams THEN
				dlg_tools.executeoperation(contractdcsetup.getparamsetupdialog(scontractno)
										  ,vresult);
			
			WHEN copermanagecards THEN
				dlg_tools.executeoperation(dlg_managecards_create, vresult, TRUE);
			
			WHEN copercreditrepayment THEN
				dlg_tools.executeoperation(dlg_creditrepayment_create, vresult);
			
			WHEN coperinstallment THEN
				dlg_tools.executeoperation(getinstallmentmanagementdialog, vresult, TRUE);
			
			WHEN copersetdccase THEN
				dlg_tools.executeoperation(contractdcsetup.openclosecasedialog(scontractno)
										  ,vresult);
			
			WHEN copermoveduedate THEN
				int_moveduedate(vresult);
			
			WHEN coperrestructuring THEN
				dlg_tools.executeoperation(dlg_debtrestructuring_create, vresult);
			
			WHEN coperundorestructuring THEN
				int_undorestructuring(vresult);
			
			WHEN coperclosecontract THEN
				dlg_tools.executeoperation(dlg_closecontract_create, vresult);
			
			WHEN coperundoclose THEN
				int_undoclosecontract(vresult);
			
			WHEN copertranchesinfo THEN
				dlg_tools.executeoperation(dlg_viewtransactions_create, vresult, TRUE);
			
			ELSE
			
				IF collectionavailable
				   AND (substr(upper(poperationcode), 1, 4) = 'COL_')
				THEN
					vresult.resultvalue := execcollectionoperation(poperationcode);
				
				ELSE
					vresult.resultvalue := contracttypeschema.c_oper_undefined;
				END IF;
			
		END CASE;
	
		t.leave(cmethodname, vresult.resultvalue);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END executeoperation;

	FUNCTION execoperation(pcode IN VARCHAR2) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ExecOperation';
		voldcorpno typecontractno;
		vavllimit  NUMBER;
	BEGIN
		t.enter(cmethodname, pcode);
	
		err.seterror(0, cmethodname);
		contracttypeschema.srollbackdata := NULL;
		s.say(cmethodname || ' -> ContractTypeSchema.sContractRow.No=' ||
			  contracttypeschema.scontractrow.no);
	
		scontractno   := contracttypeschema.scontractrow.no;
		scontracttype := contracttypeschema.scontractrow.type;
		scontractstat := contract.getstatus(contracttypeschema.scontractrow.no);
	
		startnewdocument;
	
		IF contract.checkstatus(scontractstat, contract.stat_close)
		   AND upper(pcode) NOT IN (coperundoclose, coperundodefault)
		THEN
			htools.showmessage('Warning', 'Operation can not be executed. Contract is closed');
			RETURN 0;
		END IF;
	
		CASE upper(pcode)
			WHEN copersetdefault THEN
				readsetupscheme;
				getcontractdata(TRUE);
			WHEN coperundodefault THEN
				readsetupscheme(FALSE);
			ELSE
				readsetupscheme(FALSE);
				getcontractdata;
		END CASE;
	
		CASE upper(pcode)
			WHEN copersetdefault THEN
				RETURN setdefaultvalues;
			WHEN coperundodefault THEN
				RETURN 0;
			
			WHEN copersetcorporatelink THEN
			
				voldcorpno := getcorpcontractnumber;
			
				resetcorpcontractnumber;
				SAVEPOINT splink;
				dialog.exec(contractlink.contractnodialog(contractlink.clink
														 ,scontractno
														 ,contractlink.csingle
														 ,FALSE));
			
				IF hascorporatecontract
				   AND contracttools.notequal(voldcorpno, getcorpcontractnumber)
				THEN
					FOR i IN 1 .. 2
					LOOP
						IF ifcurrencyisusedintype(i, scontracttype, scontractno)
						   AND (NOT canexceedlimit(sdepaccount(i).currencyno, vavllimit))
						   AND (vavllimit IS NOT NULL)
						   AND (vavllimit < 0)
						THEN
							ROLLBACK TO splink;
							htools.showmessage('Warning'
											  ,'Maximum limit value should not exceed ' ||
											   ltools.formatamount(vavllimit + sdepaccount(i)
																   .overdraft
																  ,sdepaccount(i).currencyno) || '(' ||
											   referencecurrency.getabbreviation(sdepaccount(i)
																				 .currencyno) ||
											   '). Operation failure.');
							EXIT;
						END IF;
						IF ifcurrencyisusedintype(i, scontracttype, scontractno)
						   AND (NOT canexceedacccashlimit(sdepaccount(i).currencyno, vavllimit))
						   AND (vavllimit IS NOT NULL)
						THEN
							t.var('vAvlLimit', vavllimit);
							t.var('GetAllLimitsValue_EstabCashLimit'
								 , getalllimitsvalue_fromhistory(scontractno) (i)('-')
								  .estabcashlimit);
							IF getalllimitsvalue_fromhistory(scontractno) (i)('-')
							.estabcashlimit > vavllimit
							THEN
								ROLLBACK TO splink;
								htools.showmessage('Warning'
												  ,'According to corporate contract settings, maximum account cash limit value should not exceed ' ||
												   ltools.formatamount(vavllimit
																	  ,sdepaccount(i).currencyno) || '(' ||
												   referencecurrency.getabbreviation(sdepaccount(i)
																					 .currencyno) ||
												   ') for this customer contract. Operation failure.');
								EXIT;
							END IF;
						END IF;
					END LOOP;
				END IF;
			WHEN copersetcontractstate THEN
				dialog.exec(setstate);
			WHEN coperchargeinterest THEN
				dialog.exec(chargeaccumint);
			ELSE
				NULL;
		END CASE;
	
		COMMIT;
	
		t.leave(cmethodname, 0);
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END execoperation;

	PROCEDURE changecontracttype
	(
		pcontractno IN typecontractno
	   ,poldtype    IN typecontracttype
	   ,pnewtype    IN typecontracttype
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ChangeContractType';
	
		vcontractrow tcontract%ROWTYPE;
		voldcurused  types.arrbool;
		vnewcurused  types.arrbool;
	
		PROCEDURE duplicateminpayments(pnewcurrencyno IN NUMBER) IS
			cmethodname CONSTANT typemethodname := changecontracttype.cmethodname ||
												   '.DuplicateMinPayments';
			cbranch     CONSTANT NUMBER := seance.getbranch;
		BEGIN
			t.enter(cmethodname, pnewcurrencyno);
		
			MERGE INTO tcontractstminpaymentdata me
			USING (
				   
				   SELECT mp.screcno
				   FROM   tcontractstcycle c
				   JOIN   tcontractstminpaymentdata mp
				   ON     mp.branch = c.branch
				   AND    mp.screcno = c.recno
				   WHERE  c.branch = cbranch
				   AND    c.contractno = pcontractno
				   AND    mp.currencynumber = decode(pnewcurrencyno, 1, 2, 2, 1)) mn
			ON ((me.branch = cbranch) AND (me.screcno = mn.screcno) AND (me.currencynumber = pnewcurrencyno))
			WHEN NOT MATCHED THEN
				INSERT
					(branch
					,screcno
					,currencynumber
					,minpayment
					,repayment_atcycleend
					,unpaidsdamount_onduedate
					,sdamount
					,mp_payoffdate_atcycleend
					,prevmpovd_onduedate
					,overdueamount_onduedate)
				VALUES
					(cbranch
					,mn.screcno
					,pnewcurrencyno
					,0
					,0
					,0
					,0
					,NULL
					,0
					,0);
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END duplicateminpayments;
	
	BEGIN
		t.enter(cmethodname
			   ,'pContractNo = ' || pcontractno || ', pOldType = ' || poldtype || ', pNewType = ' ||
				pnewtype);
	
		IF (contractparams.loadnumber(contractparams.ccontracttype, poldtype, 'UseInst', FALSE) = 1)
		   AND
		   (contractparams.loadnumber(contractparams.ccontracttype, pnewtype, 'UseInst', FALSE) = 0)
		THEN
			error.raiseerror('Old contract type has "Use Installments" parameter switched on, whereas the new one doesn''t!');
		END IF;
	
		FOR i IN 1 .. 2
		LOOP
		
			voldcurused(i) := ifcurrencyisusedintype(i, poldtype);
			vnewcurused(i) := ifcurrencyisusedintype(i, pnewtype);
			contracttools.loadcontractaccount(contracttypeitems.getitemcode(poldtype
																		   ,'ItemDeposit' ||
																			slabel(i))
											 ,sdepaccount(i)
											 ,pcontractno);
		
			IF voldcurused(i)
			   AND (NOT vnewcurused(i))
			THEN
			
				IF sdepaccount(i).remain <> 0
				THEN
					error.raiseerror('Remain of the account  <' || sdepaccount(i).accountno ||
									 '> should be set to zero before the type changing!');
				END IF;
			
				IF NOT checktrxnlist(i, ccontrtypechanging)
				THEN
					error.raiseerror('Some unhandled transactions were found on account that is going to be closed <' || sdepaccount(i)
									 .accountno ||
									 '>. Try to adjust the contract before the type changing');
				END IF;
			END IF;
		
		END LOOP;
	
		vcontractrow := contract.getcontractrowtype(pcontractno);
	
		sacctocloseontypechange := NULL;
	
		FOR i IN 1 .. 2
		LOOP
		
			IF voldcurused(i)
			THEN
			
				IF NOT vnewcurused(i)
				THEN
				
					sacctocloseontypechange := sdepaccount(i).accountno;
				END IF;
			
			ELSIF vnewcurused(i)
			THEN
			
				IF sdepaccount(i).accountno IS NULL
				THEN
				
					contracttools.createaccountbycode(vcontractrow, sdepaccount(i), TRUE);
				
					duplicateminpayments(i);
				ELSE
				
					contractrbstd.openaccount(sdepaccount(i).accountno);
				END IF;
			END IF;
		END LOOP;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END changecontracttype;

	PROCEDURE changecontracttype_post
	(
		pcontractno IN typecontractno
	   ,poldtype    IN typecontracttype
	   ,pnewtype    IN typecontracttype
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ChangeContractType_Post';
	BEGIN
		t.enter(cmethodname
			   ,'pContractNo = ' || pcontractno || ', pOldType = ' || poldtype || ', pNewType = ' ||
				pnewtype);
	
		t.var('sAccToCloseOnTypeChange', sacctocloseontypechange);
	
		IF sacctocloseontypechange IS NOT NULL
		THEN
			contractrbstd.closeaccount(sacctocloseontypechange);
			sacctocloseontypechange := NULL;
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END changecontracttype_post;

	FUNCTION initaggregate(pcontracttype IN typecontracttype) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.InitAggregate';
	BEGIN
		t.enter(cmethodname, pcontracttype);
	
		scontracttype                        := pcontracttype;
		contracttypeschema.scontractrow.type := scontracttype;
		err.seterror(0, cmethodname);
		readsetupscheme(FALSE);
		saggrdep1(pcontracttype) := contracttypeitems.getitemcode(pcontracttype
																 ,'ItemDeposit' || slabel(1));
		saggrdep2(pcontracttype) := contracttypeitems.getitemcode(pcontracttype
																 ,'ItemDeposit' || slabel(2));
	
		t.leave(cmethodname);
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END initaggregate;

	FUNCTION execaggregate RETURN NUMBER IS
		cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.ExecAggregate';
	
		vcontracttype         NUMBER;
		voverlimit            typelimitarray;
		vacc1                 NUMBER;
		vacc2                 NUMBER;
		vacccount             NUMBER;
		vnotuselimit          NUMBER;
		valloverlimit         NUMBER;
		vinstlimit            NUMBER;
		vinstlimitarr         types.arrnum;
		vaggrallowedoverlimit NUMBER;
	
		PROCEDURE loadaccount
		(
			pitemcode   IN NUMBER
		   ,pcontractno IN typecontractno
		) IS
			cmethodname CONSTANT typemethodname := execaggregate.cmethodname || '.LoadAccount';
			vaccount taccount%ROWTYPE;
		BEGIN
			contracttools.loadcontractaccount(pitemcode, vaccount, pcontractno);
			IF vaccount.accountno IS NOT NULL
			THEN
				contracttypeschema.saaggregate(contracttypeschema.saaggregate.count + 1) := vaccount;
				IF (contracttypeschema.saccountno = vaccount.accountno)
				   AND hascorporatecontract
				THEN
					contracttypeschema.sparentaccountno := getparentaccount(vaccount.currencyno
																		   ,TRUE);
				END IF;
			END IF;
		EXCEPTION
			WHEN contracttools.accountnotexists THEN
				NULL;
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END loadaccount;
	
		PROCEDURE saveaccountuserattribute
		(
			paccountno IN typeaccountno
		   ,pvalue     IN NUMBER
		) IS
			cmethodname CONSTANT typemethodname := execaggregate.cmethodname ||
												   '.SaveAccountUserAttribute';
			vuserproplist apitypes.typeuserproplist;
		BEGIN
			t.enter(cmethodname, pvalue);
		
			vuserproplist(1) := account.getuserattributerecord(paccountno, salwdovlattrname);
		
			IF contracttools.notequal(vuserproplist(1).valuenum, pvalue)
			THEN
				vuserproplist(1).id := salwdovlattrname;
				vuserproplist(1).fieldtype := types.cnumber;
				vuserproplist(1).valuenum := pvalue;
				account.saveuserattributeslist(paccountno, vuserproplist);
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END saveaccountuserattribute;
	
		PROCEDURE addaccounttorefresh
		(
			pcurno    IN NUMBER
		   ,pitemcode IN NUMBER
		) IS
			cmethodname CONSTANT typemethodname := execaggregate.cmethodname ||
												   '.AddAccountToRefresh';
			vallowedol NUMBER;
		BEGIN
			t.enter(cmethodname, pcurno);
		
			loadaccount(pitemcode, contracttypeschema.scontractrow.no);
			sprecision(pcurno) := referencecurrency.getprecision(sdepaccount(pcurno).currencyno);
			snotusedlimit(pcurno) := greatest(sdepaccount(pcurno)
											  .overdraft + sdepaccount(pcurno).remain
											 ,0);
		
			vallowedol := getallowedoverlimit(pcurno);
		
			t.var('Overdraft'
				 ,contracttypeschema.saaggregate(contracttypeschema.saaggregate.count).overdraft);
		
			contracttypeschema.saaggregate(contracttypeschema.saaggregate.count).overdraft := contracttypeschema.saaggregate(contracttypeschema.saaggregate.count)
																							  .overdraft +
																							   vallowedol;
			contracttypeschema.saaggregate(contracttypeschema.saaggregate.count).remain := contracttypeschema.saaggregate(contracttypeschema.saaggregate.count)
																						   .remain -
																							getusedinstlimit(pcurno);
		
			IF sfillalwdovlattr
			THEN
				saveaccountuserattribute(sdepaccount(pcurno).accountno, vallowedol);
			END IF;
		
			t.leave(cmethodname
				   , 'Overdraft = ' || contracttypeschema.saaggregate(contracttypeschema.saaggregate.count)
					.overdraft || ', Remain = ' || contracttypeschema.saaggregate(contracttypeschema.saaggregate.count)
					.remain);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END addaccounttorefresh;
	
	BEGIN
		t.enter(cmethodname, contracttypeschema.scontractrow.no);
	
		vcontracttype := contract.gettype(contracttypeschema.scontractrow.no);
		scontracttype := vcontracttype;
		scontractno   := contracttypeschema.scontractrow.no;
		s.say(cmethodname || '     vContractType = ' || vcontracttype || ', sContractType = ' ||
			  scontracttype || ', sContractNo = ' || scontractno
			 ,1);
	
		getcontractdata;
		s.say(cmethodname || '     ContractTypeSchema.sContractRow.No = ' ||
			  contracttypeschema.scontractrow.no
			 ,1);
		contracttools.loadcontractaccount(saggrdep1(vcontracttype)
										 ,sdepaccount(1)
										 ,contracttypeschema.scontractrow.no);
		contracttools.loadcontractaccount(saggrdep2(vcontracttype)
										 ,sdepaccount(2)
										 ,contracttypeschema.scontractrow.no);
	
		IF getlimittype_int(contracttypeschema.scontractrow.no) = caggregate
		THEN
			FOR i IN 1 .. 2
			LOOP
				s.say(cmethodname || '     sDepAccount(' || i || ').CurrencyNo = ' || sdepaccount(i)
					  .currencyno || ', sDepAccount(' || i || ').Overdraft = ' || sdepaccount(i)
					  .overdraft || ', sDepAccount(' || i || ').Remain = ' || sdepaccount(i).remain
					 ,1);
				sprecision(i) := referencecurrency.getprecision(sdepaccount(i).currencyno);
				snotusedlimit(i) := greatest(sdepaccount(i).overdraft + sdepaccount(i).remain, 0);
				s.say(cmethodname || '     sPrecision(' || i || ') = ' || sprecision(i) ||
					  ', sNotUseLimit(' || i || ') = ' || snotusedlimit(i));
			END LOOP;
			FOR i IN 1 .. 2
			LOOP
				voverlimit(i) := overlimitcalc(i);
			END LOOP;
		
			s.say(cmethodname ||
				  '     Number of cards linked to domestic account (sCardCount1) = ' ||
				  scardcount1);
			IF scardcount1 > 0
			THEN
				loadaccount(saggrdep1(vcontracttype), contracttypeschema.scontractrow.no);
				vacc1 := 1;
				vacc2 := 2;
			ELSE
				loadaccount(saggrdep2(vcontracttype), contracttypeschema.scontractrow.no);
				vacc1 := 2;
				vacc2 := 1;
			END IF;
			vacccount := contracttypeschema.saaggregate.count;
			s.say(cmethodname || '     vAcc1 = ' || vacc1 || ', vAcc2 = ' || vacc2);
			s.say(cmethodname || '     vAccCount = ' || vacccount);
		
			vinstlimitarr(vacc1) := getusedinstlimit(vacc1);
			s.say(cmethodname || '     vInstLimit 1 =' || vinstlimitarr(vacc1));
			vinstlimitarr(vacc2) := getusedinstlimit(vacc2);
			s.say(cmethodname || '     vInstLimit 2 =' || vinstlimitarr(vacc2));
			vinstlimit := vinstlimitarr(vacc1) +
						  contracttools.getsumincurrency(vinstlimitarr(vacc2)
														,sdepaccount(vacc2).currencyno
														,sdepaccount(vacc1).currencyno
														,sactparam(cctp_exchangerate));
		
			s.say(cmethodname || '     "Aggregated" installment amount (vInstLimit) =' ||
				  vinstlimit);
		
			contracttypeschema.saaggregate(vacccount).overdraft := contracttypeschema.saaggregate(vacccount)
																   .overdraft +
																	contracttools.getsumincurrency(sdepaccount(vacc2)
																								   .overdraft
																								  ,sdepaccount(vacc2)
																								   .currencyno
																								  ,sdepaccount(vacc1)
																								   .currencyno
																								  ,sactparam(cctp_exchangerate));
			s.say(cmethodname ||
				  '     "Aggregated" credit limit WITHOUT considering allowed overlimit  =' || contracttypeschema.saaggregate(vacccount)
				  .overdraft);
		
			s.say(cmethodname ||
				  '     Allowed overlimit for domestic currency (vOverLimit(vAcc1).Cur1AllowedOverlimit) = ' || voverlimit(vacc1)
				  .cur1allowedoverlimit);
			s.say(cmethodname ||
				  '     Allowed overlimit for international currency (vOverLimit(vAcc2).Cur1AllowedOverlimit) = ' || voverlimit(vacc2)
				  .cur1allowedoverlimit);
		
			vaggrallowedoverlimit := voverlimit(vacc1)
									 .cur1allowedoverlimit +
									  contracttools.getsumincurrency(voverlimit(vacc2)
																	 .cur1allowedoverlimit
																	,sdepaccount(vacc2).currencyno
																	,sdepaccount(vacc1).currencyno
																	,sactparam(cctp_exchangerate));
			s.say(cmethodname || '     Aggregated allowed overlimit (vAggrAllowedOverLimit) = ' ||
				  vaggrallowedoverlimit);
		
			IF sfillalwdovlattr
			THEN
				saveaccountuserattribute(sdepaccount(vacc1).accountno, vaggrallowedoverlimit);
			END IF;
		
			contracttypeschema.saaggregate(vacccount).overdraft := contracttypeschema.saaggregate(vacccount)
																   .overdraft +
																	vaggrallowedoverlimit;
			s.say(cmethodname || '     Aggregated credit limit considering allowed overlimit  =' || contracttypeschema.saaggregate(vacccount)
				  .overdraft
				 ,1);
		
			vnotuselimit := snotusedlimit(vacc1) +
							contracttools.getsumincurrency(snotusedlimit(vacc2)
														  ,sdepaccount(vacc2).currencyno
														  ,sdepaccount(vacc1).currencyno
														  ,sactparam(cctp_exchangerate));
			s.say(cmethodname || '     Aggregated unused limit (vNotUseLimit) = ' || vnotuselimit);
		
			valloverlimit := voverlimit(vacc1)
							 .cur1aggroverlimit +
							  contracttools.getsumincurrency(voverlimit(vacc2).cur1aggroverlimit
															,sdepaccount(vacc2).currencyno
															,sdepaccount(vacc1).currencyno
															,sactparam(cctp_exchangerate));
			s.say(cmethodname || '     Aggregated overlimit (vAllOverLimit) = ' || valloverlimit);
		
			contracttypeschema.saaggregate(vacccount).remain := - (contracttypeschema.saaggregate(vacccount)
																   .overdraft - vnotuselimit +
																	valloverlimit + vinstlimit -
																	vaggrallowedoverlimit);
		
			s.say(cmethodname || '     Aggregated remain (ContractTypeSchema.saAggregate(' ||
				  vacccount || ').Remain) = ' || contracttypeschema.saaggregate(vacccount).remain
				 ,1);
		
			IF scardcount1 > 0
			THEN
				loadaccount(saggrdep2(vcontracttype), contracttypeschema.scontractrow.no);
			ELSE
				loadaccount(saggrdep1(vcontracttype), contracttypeschema.scontractrow.no);
			END IF;
		
			contracttypeschema.saaggregate(contracttypeschema.saaggregate.count).overdraft := 0;
			contracttypeschema.saaggregate(contracttypeschema.saaggregate.count).remain := 0;
		
		ELSIF contracttypeschema.sitemcode = saggrdep1(vcontracttype)
		THEN
			addaccounttorefresh(1, saggrdep1(vcontracttype));
		ELSIF contracttypeschema.sitemcode = saggrdep2(vcontracttype)
		THEN
			addaccounttorefresh(2, saggrdep2(vcontracttype));
		END IF;
	
		t.leave(cmethodname, contracttypeschema.saaggregate.count);
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END execaggregate;

	PROCEDURE downaggregate(pcontracttype IN typecontracttype) IS
	BEGIN
		saggrdep1.delete(pcontracttype);
		saggrdep2.delete(pcontracttype);
	END downaggregate;

	PROCEDURE updatedepositinfo
	(
		ptranid       IN NUMBER
	   ,pdirectaction IN BOOLEAN
	   ,ppackno       IN NUMBER := NULL
	   ,precno        IN NUMBER := NULL
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UpdateDepositInfo';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	BEGIN
		t.enter(cmethodname, ptranid);
	
		contracttools.checkvalue_exists(ptranid, 'TWO transaction ID');
	
		IF pdirectaction
		THEN
			contracttools.checkvalue_exists(ppackno, 'Extract package number');
			contracttools.checkvalue_exists(precno, 'Extract record number');
		END IF;
	
		UPDATE tcontractdepositinfo
		SET    packno = ppackno
			  ,recno  = precno
		WHERE  branch = cbranch
		AND    tranid = ptranid;
	
		IF pdirectaction
		   AND (SQL%ROWCOUNT > 0)
		THEN
			contractrb.setlabel(crl_depositinfoupdated);
			contractrb.setnvalue('TranID', ptranid);
		END IF;
	
		t.leave(cmethodname, SQL%ROWCOUNT);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END updatedepositinfo;

	PROCEDURE undolabel
	(
		pcontractno IN typecontractno
	   ,plabel      IN contractrb.tlabel
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.UndoLabel';
		vdummylimitsettings typeobjectlimitsettings;
	
		PROCEDURE checkifadjrollbackpossible IS
			cmethodname CONSTANT typemethodname := undolabel.cmethodname ||
												   '.CheckIfAdjRollbackPossible';
			vlastpackno NUMBER;
		BEGIN
			t.enter(cmethodname);
		
			vlastpackno := contractparams.loadnumber(contractparams.ccontract
													,contracttypeschema.scontractrow.no
													,'LastAdPackNo'
													,FALSE);
			IF (vlastpackno IS NOT NULL)
			   AND (vlastpackno <> contractadjustingpack.getcurrentpackno)
			THEN
				error.raiseerror('Adjustment procedure cannot be undone since this batch is not last for current contract! You should start undo from batch number ' ||
								 vlastpackno);
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END checkifadjrollbackpossible;
	
	BEGIN
		t.enter(cmethodname, plabel);
	
		initcontract(pcontractno);
	
		CASE plabel
		
			WHEN crl_corp THEN
				setcorporatecontract(contractrb.getcvalue('OC'), c_norollback);
			
			WHEN crl_limit THEN
				uchangelimit;
			
			WHEN crl_cstate THEN
				uchangestate(pcontractno);
			
			WHEN crl_createcontract THEN
				contract.deletecontract(contractrb.getcvalue('NO'));
			
			WHEN crl_linkcontract THEN
				contractlink.delcontractlink(contractlink.cmain
											,scontractno
											,contractrb.getcvalue('NO')
											,cinstlinkname
											,contractrb.getcvalue('LC'));
			
			WHEN crl_cardstatus THEN
				uchangecardstatus;
			
			WHEN crl_instmark THEN
				rollbackloan(contractrb.getnvalue('LoanNo'));
			
			WHEN crl_limitdeleted THEN
				vdummylimitsettings := getobjectlimitssetup(scontractno
														   ,contractrb.getnvalue('CurNo')
														   ,contractrb.getcvalue('PAN')
														   ,contractrb.getnvalue('MBR'));
			
			WHEN crl_billcycleclndr THEN
				setbillingcalendar(contractrb.getnvalue('BillCycleClndr'), coperationundo);
			
			WHEN crl_daf_profile THEN
				setdafprofile(contractrb.getnvalue('Currency')
							 ,contractrb.getnvalue('Old_Profile')
							 ,c_norollback);
			
			WHEN crl_contractstate THEN
				undoregisterstate(contractrb.getnvalue('PackNo'));
			
			WHEN crl_ovdfeelogsaved THEN
				undooverduefeelog(contractrb.getnvalue('PackNo'));
			
			WHEN crl_packnosaved THEN
				undopackno(contractrb.getnvalue('PackNo')
						  ,htools.i2b(contractrb.getnvalue('IsDD'))
						  ,htools.i2b(contractrb.getnvalue('IsSD')));
			
			WHEN crl_calculatedsd THEN
				deletecycle(contractrb.getnvalue('RecNo'));
			
			WHEN crl_calculateddd THEN
				setcycleduedate(contractrb.getnvalue('RecNo'), NULL);
			
			WHEN crl_contractadjusted THEN
				checkifadjrollbackpossible;
			
			WHEN crl_histpacknosaved THEN
				contractparams.deletehistory(contractrb.getnvalue('PackNo'));
			
			WHEN crl_limitpacknosaved THEN
				rollbackusedlimitschange(contractrb.getnvalue('PackNo'));
			
			WHEN crl_depositinfoupdated THEN
				updatedepositinfo(contractrb.getnvalue('TranID'), FALSE);
			
			WHEN crl_objectlimit THEN
				undoobjectlimitschange(pcontractno);
				updateallobjectslimitsintwcms(coperationundo);
			
			WHEN crl_nextsd THEN
				updatenextsd(contractrb.getdvalue('NextSD')
							,coperationundo
							,contractrb.getnvalue('RecNo'));
			
			WHEN crl_contractmigrated THEN
				checkifadjrollbackpossible;
			
			ELSE
				error.raiseerror('Internal error: unknown rollback label <' || plabel || '>');
			
		END CASE;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END undolabel;

	FUNCTION getlabeldescription
	(
		pcontractno IN typecontractno
	   ,plabel      IN contractrb.tlabel
	) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetLabelDescription [new]';
		vresult VARCHAR2(100);
		vindex  PLS_INTEGER;
	BEGIN
		t.enter(cmethodname, plabel);
	
		vindex := plabel - contractrb.crs_schema;
	
		IF calabeldesc.exists(vindex)
		THEN
			vresult := calabeldesc(vindex);
		ELSE
			vresult := 'Unknown rollback label <' || plabel || '>';
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getlabeldescription;

	FUNCTION getlabeldescription
	(
		pcontractno IN typecontractno
	   ,plabel      IN VARCHAR2
	) RETURN VARCHAR2 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetLabelDescription [old]';
	BEGIN
		CASE plabel
			WHEN '#LPN' THEN
				RETURN 'LimitPackNo';
			WHEN '#ICC' THEN
				RETURN 'Accelerated Installment contracts closure';
			WHEN '#LHS' THEN
				RETURN 'Limit history saving';
			WHEN '#HPN' THEN
				RETURN 'HistPackNo';
			WHEN '#LAP' THEN
				RETURN 'Changed LastAdPackNo';
			WHEN '#DOC' THEN
				RETURN 'Financial document #';
			WHEN '#PLG' THEN
				RETURN 'Interest and MP profiles history saving';
			WHEN '#SSD' THEN
				RETURN 'Calculated next SD';
			WHEN '#SDD' THEN
				RETURN 'Calculated next DD';
			WHEN '#PCN' THEN
				RETURN 'PackNo';
			WHEN '#Von' THEN
				RETURN 'Set status <Violated>';
			WHEN '#Vof' THEN
				RETURN 'Removed status <Violated>';
			WHEN '#LDN' THEN
				RETURN 'Changed LastDocNo';
			WHEN '#DGR' THEN
				RETURN 'Delinquency group was changed';
			WHEN '#OFD' THEN
				RETURN 'Charged overdue fee';
			WHEN '#MST' THEN
				RETURN 'Sticked status';
			WHEN '#ERR' THEN
				RETURN 'Warning! Data integrity error';
			WHEN '#PHP' THEN
				RETURN 'Payment history PackNo';
			WHEN '#OAS' THEN
				RETURN 'Changed LastAccStatus';
			WHEN '#ACS' THEN
				RETURN 'Changed account status';
			ELSE
				RETURN 'Unknown label';
		END CASE;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getlabeldescription;

	PROCEDURE checkifentryallowed_pre IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CheckIfEntryAllowed_Pre';
	BEGIN
		t.enter(cmethodname);
	
		IF cycleisclosed
		THEN
			error.raiseerror('Can''t process this operation, as it is SD and contract ' ||
							 scontractno || ' has been already adjusted!');
		END IF;
	
		IF seance.getoperdate > getcurrentcycle().nextstatementdate
		THEN
			error.raiseerror('Transaction denied. You should close previous cycle first. Please, perform contract adjustment on <' ||
							 htools.d2s(getcurrentcycle().nextstatementdate) || '>!');
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END checkifentryallowed_pre;

	PROCEDURE checkifentryallowed_post
	(
		pcontracttype IN typecontracttype
	   ,pentrycode    IN NUMBER
	   ,paccountno    IN typeaccountno
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.CheckIfEntryAllowed_Post';
		vaccount contracttools.taccountrecord;
	BEGIN
		t.enter(cmethodname
			   ,'ContractType = ' || pcontracttype || ', EntryCode = ' || pentrycode ||
				', AccountNo = ' || paccountno);
	
		IF (sposbalanceblacklist IS NOT NULL)
		   AND (pentrycode MEMBER OF objectentrycode.getelprofileentcodes(sposbalanceblacklist))
		THEN
		
			FOR i IN 1 .. 2
			LOOP
			
				IF ifcurrencyisusedintype(i, pcontracttype)
				THEN
				
					contracttools.loadcontractaccount(contracttypeitems.getitemcode(pcontracttype
																				   ,'ItemDeposit' ||
																					slabel(i))
													 ,vaccount);
				
					IF (vaccount.accountno = paccountno)
					   AND (vaccount.remain > 0)
					THEN
						error.raiseerror('Can''t process this operation, as entry <' ||
										 referenceentry.getident(pentrycode) ||
										 '>~is blacklisted to make account balance positive!');
					END IF;
				
				END IF;
			
			END LOOP;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END checkifentryallowed_post;

	PROCEDURE sop_preexec
	(
		pcontractno IN typecontractno
	   ,pdocno      IN OUT NUMBER
	   ,pno         IN OUT NUMBER
	   ,pparams     IN OUT NOCOPY contracttypeschema.tsop_params
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SOP_PreExec';
	BEGIN
		t.enter(cmethodname);
	
		scontractno := pcontractno;
		resetcurrentcycle;
		checkifentryallowed_pre;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END sop_preexec;

	PROCEDURE sop_postexec
	(
		pcontractno IN typecontractno
	   ,pdocno      IN OUT NUMBER
	   ,pno         IN OUT NUMBER
	   ,pparams     IN contracttypeschema.tsop_params
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.SOP_PostExec';
	BEGIN
		t.enter(cmethodname);
	
		checkifentryallowed_post(contract.gettype(pcontractno)
								,pparams.enrtycode
								,account.getaccountno(pparams.creditaccount));
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END sop_postexec;

	FUNCTION oppreexec RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.OpPreExec';
		vstatecode contractstatereference.typestatecode;
	BEGIN
		t.enter(cmethodname);
	
		err.seterror(0, cmethodname);
	
		scontractno   := contracttypeschema.scontractrow.no;
		scontracttype := contracttypeschema.scontractrow.type;
		scontractstat := contract.getstatus(scontractno);
	
		IF contract.checkstatus(scontractstat, contract.stat_close)
		THEN
			error.raiseerror('Contract is already closed!');
		END IF;
	
		resetcurrentcycle;
	
		checkifentryallowed_pre;
	
		FOR i IN 1 .. 2
		LOOP
			sitem(i).dep := contracttypeitems.getitemcode(scontracttype, 'ItemDeposit' || slabel(i));
			sitem(i).ovd := contracttypeitems.getitemcode(scontracttype
														 ,'ItemOverdraft' || slabel(i));
			contracttools.loadcontractaccount(sitem(i).dep, sdepaccount(i));
			contracttools.loadcontractaccount(sitem(i).ovd, sovdaccount(i));
			sprecision(i) := referencecurrency.getprecision(sdepaccount(i).currencyno);
		END LOOP;
	
		IF ssubstacconextract
		   AND contracttypeschema.sobject_type = object.gettype(extract.object_name)
		THEN
		
			saccountforentry := sdepaccount(getcurnotopostentry(nvl(contracttypeschema.sextractrow.orgcurrency
																   ,contracttypeschema.sextractrow.currency)));
			s.say(cmethodname || ' -> ClientAccount=' || saccountforentry.accountno);
			extract.setcardholderaccount(saccountforentry.accountno);
		
			IF extract.isoriginalcurrencyrule
			   AND saccountforentry.currencyno = contracttypeschema.sextractrow.orgcurrency
			THEN
				s.say(cmethodname || ' -> Extract.SetUseOriginalRule(true)');
				extract.setamountprocesskind(extract.amt_original);
			ELSE
				s.say(cmethodname || ' -> Extract.SetUseOriginalRule(False)');
				extract.setamountprocesskind(NULL);
			END IF;
		
		ELSIF contracttypeschema.sobject_type = object.gettype(event.object_name)
		THEN
		
			vstatecode := contractstatereference.getlastregisteredstate(scontractno).statecode;
			eventscheme.setpreexecret(contractstatereference.getstate(vstatecode).servicefee);
		
			s.say(cmethodname || ' -> Event');
			saccountforentry := sdepaccount(getcurnotopostentry(contracttypeschema.seventrow.currency));
			s.say(cmethodname || ' -> ClientAccount=' || saccountforentry.accountno);
		
			contracttypeschema.seventrow.debitaccount := saccountforentry.accountno;
			eventscheme.seteventrecord(contracttypeschema.seventrow);
			s.say(cmethodname || ' -> Acct: ' || contracttypeschema.seventrow.debitaccount);
		
		END IF;
	
		err.seterror(0, cmethodname);
	
		t.leave(cmethodname);
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END oppreexec;

	FUNCTION oppostexec RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.OpPostExec';
	
		vtrancode textract.trancode%TYPE;
		vtraninfo exchange.ttraninfo;
		vparams   types.arrstr4000;
		voper     VARCHAR(3);
		vtype     VARCHAR(1);
	
		PROCEDURE reportwarning(pwarningmessage IN VARCHAR2) IS
			cmethodname CONSTANT typemethodname := oppostexec.cmethodname || '.ReportWarning';
		BEGIN
			t.note(cmethodname, pwarningmessage);
			t.var('Extract record', contracttypeschema.sobject_key);
			t.var('Card'
				 ,masktodebug(contracttypeschema.sextractrow.pan
							 ,contracttypeschema.sextractrow.mbr));
			t.var('DocNo', contracttypeschema.sextractrow.docno);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END reportwarning;
	
	BEGIN
		t.enter(cmethodname);
	
		err.seterror(0, cmethodname);
	
		IF contracttypeschema.sobject_type = object.gettype(extract.object_name)
		THEN
		
			voper := contracttypeschema.sextractrow.device ||
					 contracttypeschema.sextractrow.entcode;
			t.var('vOper', voper);
		
			IF nvl(extract.iscredit, TRUE)
			THEN
				checkifentryallowed_post(contracttypeschema.scontractrow.type
										,referenceentry.getcode('OPEXT_' || voper)
										,extract.sextractrow.debitaccountno);
			END IF;
		
			vtype := nvl(contracttypeschema.sextractrow.enttype, extract.enttype_single);
			t.var('vType', vtype);
		
			IF vtype IN (extract.enttype_single, extract.enttype_finance)
			THEN
			
				IF vtype = extract.enttype_single
				THEN
					vtrancode := contracttypeschema.sextractrow.trancode;
				
				ELSE
					vtrancode := extract.getextractdelayrecord(contracttypeschema.sextractrow.pan, contracttypeschema.sextractrow.mbr, contracttypeschema.sextractrow.docno)
								 .trancode;
				END IF;
			
				IF vtrancode IS NULL
				THEN
					reportwarning('Transaction code not found!');
				
				ELSIF exchange.gettraninfoexternal(vtrancode, vtraninfo)
					  AND (vtraninfo.directtranid IS NOT NULL)
				THEN
				
					vparams := contracttools.parsestring(contracttypeschema.sobject_key, '|', 2, 2);
				
					BEGIN
					
						contractoplog.init;
					
						updatedepositinfo(vtraninfo.directtranid, TRUE, vparams(1), vparams(2));
					
						contractoplog.done(contracttypeschema.scontractrow.no
										  ,cso_cardoper
										  ,FALSE
										  ,pdocno => contracttypeschema.sextractrow.docno);
					
					EXCEPTION
						WHEN OTHERS THEN
							contractoplog.clearlaststate;
							RAISE;
					END;
				
				ELSE
					reportwarning('TWO transaction ID not found!');
				END IF;
			
			END IF;
		
		END IF;
	
		err.seterror(0, cmethodname);
	
		t.leave(cmethodname);
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END oppostexec;

	PROCEDURE entryundoinit(poentryproperties IN OUT NOCOPY contracttypeschema.typeentryproperties) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.EntryUndoInit';
		vlastdocno typedocno;
	BEGIN
		t.enter(cmethodname
			   ,'DocNo=' || poentryproperties.docno || ', EntryMode=' ||
				poentryproperties.entrymode);
	
		IF poentryproperties.entrymode IN
		   (contracttypeschema.centrymode_del
		   ,contracttypeschema.centrymode_undo
		   ,contracttypeschema.centrymode_undofast
		   ,contracttypeschema.centrymode_edit)
		THEN
			vlastdocno := greatest(nvl(contractparams.loadnumber(contractparams.ccontract
																,poentryproperties.contractno
																,'LastDocNo_1'
																,FALSE)
									  ,0)
								  ,nvl(contractparams.loadnumber(contractparams.ccontract
																,poentryproperties.contractno
																,'LastDocNo_2'
																,FALSE)
									  ,0));
			IF poentryproperties.docno <= vlastdocno
			THEN
				error.raiseerror('Operation impossible as this transaction was processed by adjustment procedure!~(OpDocNo = ' ||
								 poentryproperties.docno || ', LastDocNo = ' || vlastdocno || ')');
			END IF;
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END entryundoinit;

	PROCEDURE entryundopre(poentryproperties IN OUT NOCOPY contracttypeschema.typeentryproperties) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.EntryUndoPre';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		coperdate   CONSTANT DATE := seance.getoperdate;
	
		vfirstrepdate DATE;
		vcurrentsd    DATE;
		vrecno        NUMBER;
	
	BEGIN
		t.enter(cmethodname
			   ,'DocNo=' || poentryproperties.docno || ', EntryMode=' ||
				poentryproperties.entrymode);
	
		IF poentryproperties.entrymode = contracttypeschema.centrymode_reverse
		THEN
		
			scontractno := poentryproperties.contractno;
		
			vcurrentsd := getcurrentcycle().statementdate;
		
			IF vcurrentsd IS NOT NULL
			THEN
			
				IF vcurrentsd > coperdate
				THEN
					error.raiseerror('Can''t process this operation as cycle corresponding to ' ||
									 htools.d2s(coperdate) || ' for the contract ' || scontractno ||
									 ' has been already closed!');
				END IF;
			
				IF susereversalent
				THEN
				
					vrecno := gettrxn(account.getaccountno(poentryproperties.accounthandle), poentryproperties.docno, poentryproperties.entryno)
							  .recno;
				
					SELECT MIN(trandate)
					INTO   vfirstrepdate
					FROM   (SELECT rep.trandate
							FROM   tcontracttrxnrepayment rep
							WHERE  rep.branch = cbranch
							AND    rep.debitrecno = vrecno
							UNION ALL
							SELECT rep.trandate
							FROM   tcontracttrxnrepayment rep
							WHERE  rep.branch = cbranch
							AND    rep.creditrecno = vrecno);
				
					IF (vfirstrepdate IS NOT NULL)
					   AND (vcurrentsd BETWEEN vfirstrepdate AND coperdate)
					   AND (NOT
						htools.ask('Attention'
									   ,'This entry has been taken into account on statement date ' ||
										htools.d2s(vcurrentsd) ||
										'.~Therefore a reversal entry will only change current balance but not affect the interest and fees which were calculated on statement date.~~Do you want to continue?'))
					THEN
						error.raiseerror('Reversal entry creation was canceled!');
					END IF;
				
				END IF;
			
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END entryundopre;

	PROCEDURE entryundodone(poentryproperties IN OUT NOCOPY contracttypeschema.typeentryproperties) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.EntryUndoDone';
		voplogrec contractoplog.trecoplog;
	BEGIN
		t.enter(cmethodname, poentryproperties.docno);
	
		IF poentryproperties.entrymode IN
		   (contracttypeschema.centrymode_undofast
		   ,contracttypeschema.centrymode_undo
		   ,contracttypeschema.centrymode_del)
		THEN
		
			voplogrec := contractoplog.getrecordbydocno(poentryproperties.contractno
													   ,poentryproperties.docno);
		
			IF voplogrec.oplogid IS NOT NULL
			THEN
				contractoplog.undo(voplogrec.oplogid, poentryproperties.docno);
			END IF;
		
		END IF;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END entryundodone;

	PROCEDURE getcontractinformation
	(
		pcontractno      IN typecontractno
	   ,poafschparamlist IN OUT NOCOPY contracttypeschema.typefschparamlist
	) IS
		cmethodname CONSTANT VARCHAR2(100) := cpackagename ||
											  '.GetContractInformation (by parameter array)';
		coperdate   CONSTANT DATE := seance.getoperdate;
	
		PROCEDURE addparam(pparamid IN contracttypeschema.typefschparamid) IS
		BEGIN
			poafschparamlist(poafschparamlist.count + 1).id := pparamid;
		END addparam;
	
	BEGIN
		t.enter(cmethodname
			   ,'pContractNo = ' || pcontractno || ', poaFSchParamList.count = ' ||
				poafschparamlist.count);
	
		IF poafschparamlist.count = 0
		THEN
			addparam(ccontrinform_remaindom);
			addparam(ccontrinform_remainint);
			addparam(ccontrinform_stdate);
			addparam(ccontrinform_dafdate);
			addparam(ccontrinform_prnduedate);
			addparam(ccontrinform_duedate);
			addparam(ccontrinform_creditlimitdom);
			addparam(ccontrinform_creditlimitint);
			addparam(ccontrinform_contrstatecode);
			addparam(ccontrinform_contrstatename);
			addparam(ccontrinform_intr_ovl_ovd_dom);
			addparam(ccontrinform_intr_ovl_ovd_int);
			addparam(ccontrinform_overdueamntdom);
			addparam(ccontrinform_overdueamntint);
			addparam(ccontrinform_totaldebitamntdom);
			addparam(ccontrinform_totaldebitamntint);
			addparam(ccontrinform_overduedays);
			addparam(ccontrinform_ovdbeforefullpaym);
			addparam(ccontrinform_totaloverduecount);
			addparam(ccontrinform_overlimitcountdom);
			addparam(ccontrinform_overlimitcountint);
			addparam(ccontrinform_lastpaidamntdom);
			addparam(ccontrinform_lastpaidamntint);
			addparam(ccontrinform_dueamountdom);
			addparam(ccontrinform_dueamountint);
			addparam(ccontrinform_sdamountdom);
			addparam(ccontrinform_sdamountint);
			addparam(ccontrinform_ovdperiodregged);
			addparam(ccontrinform_ovdperiodcalc);
		
		END IF;
	
		FOR i IN 1 .. poafschparamlist.count
		LOOP
			IF substr(poafschparamlist(i).id, 1, 4) = 'DOM_'
			   AND NOT ifcurrencyisusedintype(1, NULL, pcontractno)
			   OR substr(poafschparamlist(i).id, 1, 4) = 'INT_'
			   AND NOT ifcurrencyisusedintype(2, NULL, pcontractno)
			THEN
				s.say(cmethodname || '        ATTENTION! Parameter <' || poafschparamlist(i).id ||
					  '> does not correspond contract currency used');
				poafschparamlist(i).stringvalue := NULL;
			ELSE
				poafschparamlist(i).stringvalue := getcontractinformation(pcontractno
																		 ,poafschparamlist(i).id
																		 ,nvl(poafschparamlist(i)
																			  .opdate
																			 ,coperdate)
																		 ,nvl(poafschparamlist(i)
																			  .opdate
																			 ,coperdate));
			END IF;
		END LOOP;
	
		s.say(cmethodname || '      Parameters was handled:');
		FOR i IN 1 .. poafschparamlist.count
		LOOP
			s.say(cmethodname || '        poaFSchParamList (' || i || ').ID = ' || poafschparamlist(i).id ||
				  ', poaFSchParamList (' || i || ').OpDate = ' ||
				  htools.d2s(poafschparamlist(i).opdate) || ', poaFSchParamList (' || i ||
				  ').Value = ' || poafschparamlist(i).stringvalue);
		END LOOP;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcontractinformation;

	FUNCTION getcontractinformation
	(
		pcontractno typecontractno
	   ,pparamid    contracttypeschema.typefschparamid
	   ,pstartdate  DATE := NULL
	   ,penddate    DATE := NULL
	) RETURN VARCHAR2 IS
		cmethodname CONSTANT VARCHAR2(100) := cpackagename ||
											  '.GetContractInformation (by certain parameter)';
	
		coperdate CONSTANT DATE := seance.getoperdate;
	
		vvaluetoreturn VARCHAR2(1024);
		vcontracttype  typecontractno;
	
		vcontractstate contractstatereference.typeregisteredstaterow;
	
		ventryarray      contracttypeschema.tentryarray;
		ventryaggregates typeentryaggregatesrecord;
	
		vcacheindex VARCHAR2(100);
	
		vdueamount_dom NUMBER;
		vdueamount_int NUMBER;
	
		valllimits       typealllimitarray;
		vacccredlimitdom NUMBER;
		vacccredlimitint NUMBER;
	
		vtotaloverduecount NUMBER;
		vovdbeforefullpaym NUMBER;
	
		PROCEDURE getoverduecount
		(
			ppaidhistarray      typepaidhistcurrarray
		   ,poverdueparamsarray typeoverdueparametersarray
		   ,ototaloverduecount  OUT NUMBER
		   ,oovdbeforefullpaym  OUT NUMBER
		) IS
			cmethodname CONSTANT VARCHAR2(200) := cpackagename ||
												  '.GetContractInformation (by certain parameter).GetOverdueCount';
		
			vlastovdperiod_begindate DATE;
			vlastovdperiod_enddate   DATE;
		
			vprevpaidhistarray      typepaidhistcurrarray;
			vprevoverdueparamsarray typeoverdueparametersarray;
		
			vcyclescount   NUMBER := 0;
			voverdueexists BOOLEAN := FALSE;
		BEGIN
			s.say(cmethodname || '      --<< BEGIN', 1);
			ototaloverduecount := 0;
			oovdbeforefullpaym := 0;
		
			IF ppaidhistarray.exists(1)
			   AND ppaidhistarray(1) IS NOT NULL
			   AND ppaidhistarray(1).exists(1)
			THEN
				vcyclescount := ppaidhistarray(1).count;
				IF poverdueparamsarray(1).overduedate IS NOT NULL
				THEN
					s.say(cmethodname ||
						  '        - info: The contract has overdue now (detected on domestic currency)'
						 ,1);
					s.say(cmethodname ||
						  '        Overdue Date (pOverdueParamsArray(1).OverdueDate) = ' ||
						  htools.d2s(poverdueparamsarray(1).overduedate));
					voverdueexists := TRUE;
				ELSE
					voverdueexists := FALSE;
					s.say(cmethodname ||
						  '        - info: The contract has NOT overdue now (detected on domestic currency)'
						 ,1);
				END IF;
			END IF;
		
			IF ppaidhistarray.exists(2)
			   AND ppaidhistarray(2) IS NOT NULL
			   AND ppaidhistarray(2).exists(1)
			   AND NOT voverdueexists
			THEN
				vcyclescount := ppaidhistarray(2).count;
				IF poverdueparamsarray(2).overduedate IS NOT NULL
				THEN
					s.say(cmethodname ||
						  '        - info: The contract has overdue now (detected on international currency)'
						 ,1);
					s.say(cmethodname ||
						  '        Overdue Date (pOverdueParamsArray(2).OverdueDate) = ' ||
						  htools.d2s(poverdueparamsarray(2).overduedate));
					voverdueexists := TRUE;
				ELSE
					s.say(cmethodname ||
						  '        - info: The contract has NOT overdue now (confirmed on international currency)'
						 ,1);
				END IF;
			END IF;
		
			s.say(cmethodname ||
				  '        Total number of the cycles for a contract (vCyclesCount) = ' ||
				  vcyclescount
				 ,1);
			s.say(cmethodname || '        ', 1);
		
			FOR cccylceindex IN 1 .. vcyclescount
			LOOP
			
				IF ppaidhistarray.exists(1)
				THEN
					s.say(cmethodname || '        pPaidHistArray(1)(' || cccylceindex ||
						  ').StatementDate = ' ||
						  htools.d2s(ppaidhistarray(1)(cccylceindex).statementdate) ||
						  ', DueDate = ' || htools.d2s(ppaidhistarray(1)(cccylceindex).duedate) ||
						  ', MinPayment = ' || ppaidhistarray(1)(cccylceindex)
						  .minpayment || ', OverdueAmount = ' || ppaidhistarray(1)(cccylceindex)
						  .overdueamount);
				
				ELSIF ppaidhistarray.exists(2)
				THEN
					s.say(cmethodname || '        pPaidHistArray(2)(' || cccylceindex ||
						  ').StatementDate = ' ||
						  htools.d2s(ppaidhistarray(2)(cccylceindex).statementdate) ||
						  ', DueDate = ' || htools.d2s(ppaidhistarray(2)(cccylceindex).duedate) ||
						  ', MinPayment = ' || ppaidhistarray(2)(cccylceindex)
						  .minpayment || ', OverdueAmount = ' || ppaidhistarray(2)(cccylceindex)
						  .overdueamount);
				END IF;
			
				IF ppaidhistarray.exists(1)
				   AND ppaidhistarray(1) IS NOT NULL
				   AND ppaidhistarray(1)(cccylceindex).overdueamount <> 0
				   OR ppaidhistarray.exists(2)
				   AND ppaidhistarray(2) IS NOT NULL
				   AND ppaidhistarray(2)(cccylceindex).overdueamount <> 0
				THEN
				
					ototaloverduecount := ototaloverduecount + 1;
					s.say(cmethodname ||
						  '           TotalOverdueCount: cycle is taken into consideration'
						 ,1);
				
					IF poverdueparamsarray.exists(1)
					   AND poverdueparamsarray(1).overduedate <= ppaidhistarray(1)(cccylceindex)
					.duedate
					   OR poverdueparamsarray.exists(2)
					   AND poverdueparamsarray(2).overduedate <= ppaidhistarray(2)(cccylceindex)
					.duedate
					THEN
					
						IF poverdueparamsarray.exists(1)
						   AND poverdueparamsarray(1).overduedate <= ppaidhistarray(1)(cccylceindex)
						.duedate
						THEN
							s.say(cmethodname ||
								  '             OvdBeforeFullPaym: cycle is taken into consideration (by domestic currency)'
								 ,1);
						ELSIF poverdueparamsarray.exists(2)
							  AND poverdueparamsarray(2).overduedate <= ppaidhistarray(2)(cccylceindex)
						.duedate
						THEN
							s.say(cmethodname ||
								  '             OvdBeforeFullPaym: cycle is taken into consideration (by international currency)'
								 ,1);
						END IF;
					
						oovdbeforefullpaym := oovdbeforefullpaym + 1;
					END IF;
				
				END IF;
			END LOOP;
		
			IF NOT voverdueexists
			THEN
				IF poverdueparamsarray.exists(1)
				   AND poverdueparamsarray.exists(2)
				THEN
					vlastovdperiod_enddate := greatest(poverdueparamsarray(1).mp_payoffdate
													  ,poverdueparamsarray(2).mp_payoffdate) - 1;
				ELSIF poverdueparamsarray.exists(1)
				THEN
					vlastovdperiod_enddate := poverdueparamsarray(1).mp_payoffdate - 1;
				ELSIF poverdueparamsarray.exists(2)
				THEN
					vlastovdperiod_enddate := poverdueparamsarray(2).mp_payoffdate - 1;
				END IF;
				s.say(cmethodname ||
					  '        LAST Overdue period''s end date (vLastOvdPeriod_EndDate) = ' ||
					  htools.d2s(vlastovdperiod_enddate));
				FOR i IN 1 .. 2
				LOOP
					IF ifcurrencyisusedintype(i, vcontracttype, pcontractno)
					THEN
						vprevpaidhistarray(i) := custom_overdueparameterscalculation.getoverdueparameters(paccountno           => sdepaccount(i)
																																  .accountno
																										 ,pcurrencynumber      => i
																										 ,pdate                => vlastovdperiod_enddate
																										 ,pconsideroverduefrom => sactparam(cctp_periodtype)
																										 ,ooverdueparameters   => vprevoverdueparamsarray(i));
					END IF;
				END LOOP;
			
				IF vprevoverdueparamsarray.exists(1)
				   AND vprevoverdueparamsarray.exists(2)
				THEN
					vlastovdperiod_begindate := greatest(vprevoverdueparamsarray(1).overduedate
														,vprevoverdueparamsarray(2).overduedate);
				ELSIF vprevoverdueparamsarray.exists(1)
				THEN
					vlastovdperiod_begindate := vprevoverdueparamsarray(1).overduedate;
				ELSIF vprevoverdueparamsarray.exists(2)
				THEN
					vlastovdperiod_begindate := vprevoverdueparamsarray(2).overduedate;
				END IF;
			
				s.say(cmethodname ||
					  '        LAST overdue period''s begin date (vLastOvdPeriod_BeginDate) = ' ||
					  htools.d2s(vlastovdperiod_begindate));
				s.say(cmethodname ||
					  '        LAST Overdue period''s end date (vLastOvdPeriod_EndDate) = ' ||
					  htools.d2s(vlastovdperiod_enddate));
			
				IF vprevpaidhistarray.exists(1)
				   AND vprevpaidhistarray(1) IS NOT NULL
				   AND vprevpaidhistarray(1).exists(1)
				THEN
					FOR cccylceindex IN 1 .. vprevpaidhistarray(1).count
					LOOP
					
						IF vprevpaidhistarray.exists(1)
						THEN
							s.say(cmethodname || '        vPrevPaidHistArray(1)(' || cccylceindex ||
								  ').StatementDate = ' ||
								  htools.d2s(vprevpaidhistarray(1)(cccylceindex).statementdate) ||
								  ', DueDate = ' ||
								  htools.d2s(vprevpaidhistarray(1)(cccylceindex).duedate) ||
								  ', MinPayment = ' || vprevpaidhistarray(1)(cccylceindex)
								  .minpayment || ', OverdueAmount = ' || vprevpaidhistarray(1)(cccylceindex)
								  .overdueamount);
						
						ELSIF vprevpaidhistarray.exists(2)
							  AND vprevpaidhistarray(2) IS NOT NULL
							  AND vprevpaidhistarray(2).exists(1)
						THEN
							s.say(cmethodname || '        vPrevPaidHistArray(2)(' || cccylceindex ||
								  ').StatementDate = ' ||
								  htools.d2s(vprevpaidhistarray(2)(cccylceindex).statementdate) ||
								  ', DueDate = ' ||
								  htools.d2s(vprevpaidhistarray(2)(cccylceindex).duedate) ||
								  ', MinPayment = ' || vprevpaidhistarray(2)(cccylceindex)
								  .minpayment || ', OverdueAmount = ' || vprevpaidhistarray(2)(cccylceindex)
								  .overdueamount);
						END IF;
					
						IF (vprevpaidhistarray.exists(1) AND vprevpaidhistarray(1)(cccylceindex)
						   .duedate > vlastovdperiod_begindate AND vprevpaidhistarray(1)(cccylceindex)
						   .duedate < vlastovdperiod_enddate)
						   OR (vprevpaidhistarray.exists(2) AND vprevpaidhistarray(2) IS NOT NULL AND
						   vprevpaidhistarray(2)(cccylceindex)
						   .duedate > vlastovdperiod_begindate AND vprevpaidhistarray(2)(cccylceindex)
						   .duedate < vlastovdperiod_enddate)
						THEN
							s.say(cmethodname || '          - info: cycle counted');
						
							oovdbeforefullpaym := oovdbeforefullpaym + 1;
						ELSE
							s.say(cmethodname || '          - info: cycle not counted');
						END IF;
					END LOOP;
				END IF;
			END IF;
		
			s.say(cmethodname || '');
			s.say(cmethodname || '          oTotalOverdueCount = ' || ototaloverduecount ||
				  ', oOvdBeforeFullPaym = ' || oovdbeforefullpaym);
			s.say(cmethodname || '      -->> END');
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END getoverduecount;
	
		FUNCTION getoverlimitcount
		(
			pcurno   NUMBER
		   ,penddate DATE
		) RETURN NUMBER IS
			cmethodname CONSTANT VARCHAR2(200) := cpackagename ||
												  '.GetContractInformation (by certain parameter).GetOvelimitCount';
		
			vovlhistarray      typeamnthistoryarray;
			vovlnumbertoreturn NUMBER := 0;
		BEGIN
			s.say(cmethodname || '      --<< BEGIN', 1);
			s.say(cmethodname || '       - INPUT PARAMETERS: pCurrencyNumber = ' || pcurno ||
				  ', (implicit) sOvdAccount(' || pcurno || ').AccountNo = ' || sovdaccount(pcurno)
				  .accountno || ', pEndDate = ' || htools.d2s(penddate));
		
			vovlhistarray := getamnthistory(pcurno, nvl(penddate, coperdate));
			s.say(cmethodname ||
				  '        Number of transaction on Overlimit Acount (vOvlHistArray.count) = ' ||
				  vovlhistarray.count
				 ,1);
		
			IF vovlhistarray.count <> 0
			THEN
				vovlnumbertoreturn := 1;
				s.say(cmethodname || '        vOvlHistArray(' || vovlhistarray.count ||
					  ').OperDate = ' || htools.d2s(vovlhistarray(vovlhistarray.count).operdate) ||
					  ',  Overlimit Trasaction Amount = ' || vovlhistarray(vovlhistarray.count)
					  .amount || ', Total Overlimit Amount = ' || vovlhistarray(vovlhistarray.count)
					  .balance);
			ELSE
				vovlnumbertoreturn := 0;
				s.say(cmethodname || '        No overlimit exists');
			END IF;
		
			IF vovlhistarray.count > 1
			THEN
				FOR k IN 2 .. vovlhistarray.count
				LOOP
					s.say(cmethodname || '        vOvlHistArray(' || k || ').OperDate = ' ||
						  htools.d2s(vovlhistarray(k).operdate) ||
						  ',  Overlimit Trasaction Amount = ' || vovlhistarray(k).amount ||
						  ', Total Overlimit Amount = ' || vovlhistarray(k).balance);
					IF vovlhistarray(k - 1).balance = 0
						AND vovlhistarray(k).balance <> 0
					THEN
						vovlnumbertoreturn := vovlnumbertoreturn + 1;
					END IF;
				END LOOP;
			END IF;
			s.say(cmethodname || '        vOvlNumberToReturn = ' || vovlnumbertoreturn, 1);
			s.say(cmethodname || '      -->> END');
			RETURN vovlnumbertoreturn;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END;
	
	BEGIN
		t.enter(cmethodname
			   ,'pContractNo = ' || pcontractno || ', pParamID = ' || pparamid ||
				', pStartDate = ' || htools.d2s(pstartdate) || ', pEndDate = ' ||
				htools.d2s(penddate));
	
		vcontracttype := contract.gettype(pcontractno);
		IF nvl(scontracttype, 0) <> vcontracttype
		THEN
			s.say(cmethodname || '      - info: scheme parameters are going to be loaded');
			scontracttype := vcontracttype;
			readsetupscheme(FALSE);
		ELSE
			s.say(cmethodname || '      - info: scheme parameters have been loaded already');
		END IF;
	
		s.say(cmethodname || '      sContractNo = ' || scontractno);
	
		IF (scontractno IS NULL)
		   OR (scontractno <> pcontractno)
		THEN
		
			s.say(cmethodname ||
				  '       - info: sContractNo and pContractNo are different. Contract data are going to be loaded');
		
			scontractno                        := pcontractno;
			contracttypeschema.scontractrow.no := pcontractno;
		
			FOR i IN 1 .. 2
			LOOP
				IF ifcurrencyisusedintype(i, vcontracttype, scontractno)
				THEN
					contracttools.loadcontractaccount(sitem(i).dep, sdepaccount(i), scontractno);
					contracttools.loadcontractaccount(sitem(i).ovd, sovdaccount(i), scontractno);
				END IF;
			END LOOP;
		
			s.say(cmethodname || '       - info: Contract data are loaded, sContractNo = ' ||
				  scontractno);
		ELSE
			s.say(cmethodname || '      - info: contract data have been loaded already');
		END IF;
	
		spaidhistarray.delete;
		soverdueparametersarray.delete;
	
		FOR i IN 1 .. 2
		LOOP
			IF ifcurrencyisusedintype(i, vcontracttype, pcontractno)
			THEN
			
				IF pparamid IN (ccontrinform_overdueamntdom
							   ,ccontrinform_overdueamntint
							   ,ccontrinform_overduedays
							   ,ccontrinform_ovdbeforefullpaym
							   ,ccontrinform_totaloverduecount
							   ,ccontrinform_dueamountdom
							   ,ccontrinform_dueamountint)
				THEN
					spaidhistarray(i) := custom_overdueparameterscalculation.getoverdueparameters(paccountno           => sdepaccount(i)
																														  .accountno
																								 ,pcurrencynumber      => i
																								 ,pdate                => penddate
																								 ,pconsideroverduefrom => sactparam(cctp_periodtype)
																								 ,ooverdueparameters   => soverdueparametersarray(i));
				
					IF pparamid IN (ccontrinform_dueamountdom, ccontrinform_dueamountint)
					THEN
						s.say(cmethodname ||
							  '       Due amount for currency (sOverdueParametersArray(' || i ||
							  ').DueAmount) = ' || soverdueparametersarray(i).dueamount
							 ,1);
						IF i = 1
						THEN
							vdueamount_dom := soverdueparametersarray(i).dueamount;
						ELSE
							vdueamount_int := soverdueparametersarray(i).dueamount;
						END IF;
					END IF;
				
					IF spaidhistarray.exists(i)
					   AND spaidhistarray(i) IS NOT NULL
					   AND spaidhistarray(i).exists(1)
					THEN
					
						IF pparamid = ccontrinform_totaloverduecount
						THEN
							vcacheindex := sdepaccount(i).accountno || '-' || i || '-' ||
											to_char(penddate, 'yyyy.mm.dd');
							s.say(cmethodname ||
								  '       sPaidHistArray are going to be overriden. Cache index (vCacheIndex) = ' ||
								  vcacheindex
								 ,1);
							IF custom_overdueparameterscalculation.scache.exists(vcacheindex)
							THEN
								s.say(cmethodname ||
									  '       custom_overdueparameterscalculation.sCache(' ||
									  vcacheindex || ').MinPaymentStDataArray.count = ' || custom_overdueparameterscalculation.scache(vcacheindex)
									  .minpaymentstdataarray.count
									 ,1);
								FOR k IN 1 .. spaidhistarray(i).count
								LOOP
									s.say(cmethodname || '       i = ' || i || ', k = ' || k, 1);
									spaidhistarray(i)(k).statementdate := custom_overdueparameterscalculation.scache(vcacheindex).minpaymentstdataarray(k)
																		  .statementdate;
									spaidhistarray(i)(k).duedate := custom_overdueparameterscalculation.scache(vcacheindex).minpaymentstdataarray(k)
																	.duedate;
									spaidhistarray(i)(k).minpayment := custom_overdueparameterscalculation.scache(vcacheindex).minpaymentstdataarray(k)
																	   .minpayment;
									spaidhistarray(i)(k).overdueamount := custom_overdueparameterscalculation.scache(vcacheindex).minpaymentstdataarray(k)
																		  .overdueamount_onduedate;
									s.say(cmethodname || '         Due Date = ' ||
										  htools.d2s(spaidhistarray(i)(k).duedate) ||
										  ', Overriden Overdue Amount = ' || spaidhistarray(i)(k)
										  .overdueamount);
								END LOOP;
							ELSE
								s.say(cmethodname ||
									  '       sPaidHistArray has not been overriden since cache for the currency is empty'
									 ,1);
							END IF;
						
						END IF;
					END IF;
				
				END IF;
			END IF;
		END LOOP;
	
		IF pparamid IN
		   (ccontrinform_contrstatecode, ccontrinform_contrstatename, ccontrinform_ovdperiodregged)
		THEN
			vcontractstate := contractstatereference.getlastregisteredstate(pcontractno, penddate);
		END IF;
	
		IF pparamid IN (ccontrinform_creditlimitdom, ccontrinform_creditlimitint)
		THEN
			valllimits := getalllimitsvalue_fromhistory(pcontractno, penddate);
			IF pparamid = ccontrinform_creditlimitdom
			THEN
				IF valllimits.exists(1)
				THEN
					s.say(cmethodname ||
						  '       - info: Credit limit value for DOMestic account is going to be taken from history');
					vacccredlimitdom := valllimits(1)('-').estabcreditlimit;
				ELSE
					s.say(cmethodname ||
						  '       - info: Credit limit value for DOMestic account is going to be taken as established Overdraft');
					vacccredlimitdom := sdepaccount(1).overdraft;
				END IF;
			END IF;
			IF pparamid = ccontrinform_creditlimitint
			THEN
				IF valllimits.exists(2)
				THEN
					s.say(cmethodname ||
						  '       - info: Credit limit value for INTernational account is going to be taken from history');
					vacccredlimitint := valllimits(2)('-').estabcreditlimit;
				ELSE
					s.say(cmethodname ||
						  '       - info: Credit limit value for INTernational account is going to be taken as established Overdraft');
					vacccredlimitint := sdepaccount(2).overdraft;
				END IF;
			END IF;
		END IF;
	
		IF pparamid = ccontrinform_remaindom
		THEN
			IF nvl(pstartdate, coperdate) = coperdate
			THEN
				vvaluetoreturn := sdepaccount(1).remain;
			ELSE
				vvaluetoreturn := contracttools.get_eod_remain(sdepaccount(1).accountno, pstartdate);
			END IF;
		
		ELSIF pparamid = ccontrinform_remainint
		THEN
			IF nvl(pstartdate, coperdate) = coperdate
			THEN
				vvaluetoreturn := sdepaccount(2).remain;
			ELSE
				vvaluetoreturn := contracttools.get_eod_remain(sdepaccount(2).accountno, pstartdate);
			END IF;
		
		ELSIF pparamid = ccontrinform_stdate
		THEN
			vvaluetoreturn := to_char(getcurrentcycle().statementdate
									 ,contracttypeschema.cdateformat);
		
		ELSIF pparamid = ccontrinform_dafdate
		THEN
			vvaluetoreturn := to_char(getcurrentcycle().dafdate, contracttypeschema.cdateformat);
		
		ELSIF pparamid = ccontrinform_prnduedate
		THEN
			vvaluetoreturn := to_char(getcurrentcycle().printedduedate
									 ,contracttypeschema.cdateformat);
		
		ELSIF pparamid = ccontrinform_duedate
		THEN
			vvaluetoreturn := to_char(getcurrentcycle().duedate, contracttypeschema.cdateformat);
		ELSIF pparamid = ccontrinform_creditlimitdom
		THEN
			vvaluetoreturn := vacccredlimitdom;
		ELSIF pparamid = ccontrinform_creditlimitint
		THEN
			vvaluetoreturn := vacccredlimitint;
		ELSIF pparamid = ccontrinform_contrstatecode
		THEN
			vvaluetoreturn := vcontractstate.statecode;
		ELSIF pparamid = ccontrinform_contrstatename
		THEN
			vvaluetoreturn := contractstatereference.getstate(vcontractstate.statecode).statename;
		ELSIF pparamid = ccontrinform_intr_ovl_ovd_dom
		THEN
			vvaluetoreturn := getdebitentryamount(pcontractno
												 ,sdepaccount(1).accountno
												 ,penddate
												 ,sdepaccount(1).createdate
												 ,penddate);
		ELSIF pparamid = ccontrinform_intr_ovl_ovd_int
		THEN
			vvaluetoreturn := getdebitentryamount(pcontractno
												 ,sdepaccount(2).accountno
												 ,penddate
												 ,sdepaccount(2).createdate
												 ,penddate);
		ELSIF pparamid = ccontrinform_overdueamntdom
		THEN
			vvaluetoreturn := soverdueparametersarray(1).overdueamount;
		ELSIF pparamid = ccontrinform_overdueamntint
		THEN
			vvaluetoreturn := soverdueparametersarray(2).overdueamount;
		ELSIF pparamid = ccontrinform_overduedays
		THEN
			IF soverdueparametersarray.exists(1)
			   AND soverdueparametersarray.exists(2)
			THEN
				s.say(cmethodname || '      sOverdueParametersArray(1).OverdueDate= ' ||
					  htools.d2s(soverdueparametersarray(1).overduedate) ||
					  '      sOverdueParametersArray(2).OverdueDate= ' ||
					  htools.d2s(soverdueparametersarray(2).overduedate));
				vvaluetoreturn := coperdate -
								  least(soverdueparametersarray(1).overduedate
									   ,soverdueparametersarray(2).overduedate);
			ELSIF soverdueparametersarray.exists(1)
			THEN
				s.say(cmethodname || '      sOverdueParametersArray(1).OverdueDate= ' ||
					  htools.d2s(soverdueparametersarray(1).overduedate));
				vvaluetoreturn := coperdate - soverdueparametersarray(1).overduedate;
			ELSIF soverdueparametersarray.exists(2)
			THEN
				s.say(cmethodname || '      sOverdueParametersArray(2).OverdueDate= ' ||
					  htools.d2s(soverdueparametersarray(2).overduedate));
				vvaluetoreturn := coperdate - soverdueparametersarray(2).overduedate;
			END IF;
		
		ELSIF pparamid = ccontrinform_totaldebitamntdom
		THEN
			ventryarray := contracttools.getentryarray(sdepaccount(1).accountno
													  ,sdepaccount(1).createdate
													  ,NULL
													  ,NULL
													  ,TRUE);
		
			ventryaggregates := getentryaggregates(ventryarray, sdepaccount(1).createdate, penddate);
			vvaluetoreturn   := ventryaggregates.debitturnover;
		
		ELSIF pparamid = ccontrinform_totaldebitamntint
		THEN
			ventryarray := contracttools.getentryarray(sdepaccount(2).accountno
													  ,sdepaccount(2).createdate
													  ,NULL
													  ,NULL
													  ,TRUE);
		
			ventryaggregates := getentryaggregates(ventryarray, sdepaccount(2).createdate, penddate);
			vvaluetoreturn   := ventryaggregates.debitturnover;
		
		ELSIF pparamid IN (ccontrinform_totaloverduecount, ccontrinform_ovdbeforefullpaym)
		THEN
			getoverduecount(spaidhistarray
						   ,soverdueparametersarray
						   ,vtotaloverduecount
						   ,vovdbeforefullpaym);
			IF pparamid = ccontrinform_totaloverduecount
			THEN
				vvaluetoreturn := vtotaloverduecount;
			ELSIF pparamid = ccontrinform_ovdbeforefullpaym
			THEN
				vvaluetoreturn := vovdbeforefullpaym;
			END IF;
		ELSIF pparamid = ccontrinform_overlimitcountdom
		THEN
			vvaluetoreturn := getoverlimitcount(1, nvl(penddate, coperdate));
		ELSIF pparamid = ccontrinform_overlimitcountint
		THEN
			vvaluetoreturn := getoverlimitcount(2, nvl(penddate, coperdate));
		ELSIF pparamid = ccontrinform_lastpaidamntdom
		THEN
			vvaluetoreturn := nvl(getcontrattr_lastpaidamount(pcontractno
															 ,nvl(penddate, coperdate)
															 ,1)
								 ,0);
		ELSIF pparamid = ccontrinform_lastpaidamntint
		THEN
			vvaluetoreturn := nvl(getcontrattr_lastpaidamount(pcontractno
															 ,nvl(penddate, coperdate)
															 ,2)
								 ,0);
		ELSIF pparamid = ccontrinform_dueamountdom
		THEN
			vvaluetoreturn := vdueamount_dom;
		ELSIF pparamid = ccontrinform_dueamountint
		THEN
			vvaluetoreturn := vdueamount_int;
		ELSIF pparamid = ccontrinform_sdamountdom
		THEN
			vvaluetoreturn := getcontrattr_sdamount(pcontractno, nvl(penddate, coperdate), 1);
		ELSIF pparamid = ccontrinform_sdamountint
		THEN
			vvaluetoreturn := getcontrattr_sdamount(pcontractno, nvl(penddate, coperdate), 2);
		ELSIF pparamid = ccontrinform_ovdperiodregged
		THEN
			vvaluetoreturn := vcontractstate.overdue;
		ELSIF pparamid = ccontrinform_ovdperiodcalc
		THEN
			getcontractdata;
			vvaluetoreturn := sblockparam.period;
		ELSE
			error.raiseerror(contracttypeschema.excincorrect_parameter
							,': Parameter <' || pparamid || '> is not supported!');
		END IF;
	
		t.leave(cmethodname, vvaluetoreturn);
		RETURN vvaluetoreturn;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getcontractinformation;

	FUNCTION getcontractinfo(pcontractno IN typecontractno) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetContractInfo';
	
		cinfotype CONSTANT VARCHAR2(40) := upper(contracttypeschema.scontractrequest.infotype);
		coperdate CONSTANT DATE := seance.getoperdate;
		cbranch   CONSTANT NUMBER := seance.getbranch;
	
		vpreviouscycle typebillingcycle;
		vcurrentcycle  typebillingcycle;
		vcurrency      typecurrency;
		vamp           types.arrnum;
	
		vxml xmltype;
	
		vcurno       NUMBER;
		vstartdate   DATE;
		venddate     DATE;
		vnewbalance  NUMBER := 0;
		vlastbalance NUMBER := 0;
	
		vdatestr   VARCHAR2(20);
		vdate      DATE;
		vamount    NUMBER;
		vvalue     NUMBER;
		vcorpacc   contracttools.taccountrecord;
		vavaildom  NUMBER;
		vavailint  NUMBER;
		vdueamount NUMBER;
	
		FUNCTION getparam
		(
			pxml   IN xmltype
		   ,pxpath IN VARCHAR2
		) RETURN VARCHAR2 IS
			vresult VARCHAR2(100);
		BEGIN
			vresult := xmltools.getvalue(pxml, pxpath);
			t.var(pxpath, vresult);
			RETURN vresult;
		END getparam;
	
		PROCEDURE fillcardsinfo(pusespecifiedcard IN BOOLEAN) IS
			cmethodname CONSTANT typemethodname := getcontractinfo.cmethodname || '.FillCardsInfo';
			vcardlist apitypes.typecardlist;
			vpan      typepan;
			vmbr      typembr;
		
			PROCEDURE addcardinfo
			(
				ppan IN typepan
			   ,pmbr IN typembr
			) IS
				cmethodname CONSTANT typemethodname := fillcardsinfo.cmethodname || '.AddCardInfo';
				vlimitsetup typeobjectlimitsettings;
				vlimitvalue typelimitvaluerecord;
			BEGIN
				t.enter(cmethodname);
			
				vlimitsetup := getobjectlimitssetup(pcontractno, vcurno, ppan, pmbr);
				vlimitvalue := calcobjectlimits(vcurno, ppan, pmbr);
			
				xmltools.opentag('CARD');
				xmltools.additem('PAN', card.getmaskedpan(ppan));
				xmltools.additem('MBR', pmbr);
				xmltools.additem('CREDIT_LIMIT', vlimitvalue.credlimit);
				xmltools.additem('CASH_LIMIT', vlimitvalue.cashlimit);
				xmltools.additem('CREDIT_REMAINING_LIMIT'
								,vlimitvalue.credlimit - vlimitsetup.usedcredlimit.amount);
				xmltools.additem('CASH_REMAINING_LIMIT'
								,vlimitvalue.cashlimit - vlimitsetup.usedcashlimit.amount);
				xmltools.closetag('CARD');
			
				t.leave(cmethodname);
			EXCEPTION
				WHEN OTHERS THEN
					t.exc(cmethodname);
					error.save(cmethodname);
					RAISE;
			END addcardinfo;
		
		BEGIN
			t.enter(cmethodname, htools.b2s(pusespecifiedcard));
		
			xmltools.opentag('CARDLIST');
		
			IF pusespecifiedcard
			   AND (contracttypeschema.scontractrequest.identtype = rpc.ident_type_card)
			   AND (contracttypeschema.scontractrequest.ident IS NOT NULL)
			THEN
			
				contracttools.parsecardstring(contracttypeschema.scontractrequest.ident
											 ,vpan
											 ,vmbr
											 ,'-');
			
				addcardinfo(vpan, vmbr);
			
			ELSE
			
				vcardlist := contract.getcardlist(pcontractno);
			
				FOR i IN 1 .. vcardlist.count
				LOOP
					addcardinfo(vcardlist(i).pan, vcardlist(i).mbr);
				END LOOP;
			
			END IF;
		
			xmltools.closetag('CARDLIST');
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END fillcardsinfo;
	
		PROCEDURE filldepositinfo
		(
			pcurno      IN PLS_INTEGER
		   ,pcurrency   IN NUMBER
		   ,ptranid     IN NUMBER
		   ,ptrancode   IN NUMBER
		   ,ptrantype   IN NUMBER
		   ,ptranamount IN NUMBER
		   ,prevtranid  IN NUMBER
		) IS
			cmethodname CONSTANT typemethodname := getcontractinfo.cmethodname ||
												   '.FillDepositInfo';
			vadjustingerror BOOLEAN := FALSE;
			valllimits      typealllimitarray;
			vdepositinfo    typedepositinfo;
			vindex          VARCHAR2(25);
			vpan            typepan;
			vmbr            typembr;
		
			PROCEDURE validatetransaction
			(
				ptranid     IN NUMBER
			   ,ptrancode   IN NUMBER
			   ,ptrantype   IN NUMBER
			   ,ptranamount IN NUMBER
			   ,prevtranid  IN NUMBER := NULL
			) IS
				cmethodname CONSTANT typemethodname := getcontractinfo.cmethodname ||
													   '.ValidateTransaction';
			BEGIN
				t.enter(cmethodname);
			
				contracttools.checkvalue_exists(ptranid, 'TWO transaction ID');
			
				IF (ptrancode IS NULL)
				   OR (ptrancode NOT IN (20, 140))
				THEN
					error.raiseerror('Unsupported transaction code: <' || ptrancode || '>!');
				END IF;
			
				contracttools.checkvalue_exists(ptrantype, 'Transaction type');
			
				IF ptrantype IN (100, 200)
				THEN
					IF prevtranid IS NOT NULL
					THEN
						error.raiseerror('Reversed transaction ID <' || prevtranid ||
										 '> passed, while transaction type <' || ptrantype ||
										 '> does not belong to "reverse" type!');
					END IF;
				
				ELSIF ptrantype IN (400, 420)
				THEN
					IF prevtranid IS NULL
					THEN
						error.raiseerror('No reversed transaction ID passed for reverse transaction <' ||
										 ptrantype || '>!');
					END IF;
				
				ELSE
					error.raiseerror('Unsupported transaction type: <' || ptrantype || '>!');
				END IF;
			
				contracttools.validatenumber(ptranamount
											,'Transaction sum'
											,contracttools.cnum_nonnegative);
			
				t.leave(cmethodname);
			EXCEPTION
				WHEN OTHERS THEN
					t.exc(cmethodname);
					error.save(cmethodname);
					RAISE;
			END validatetransaction;
		
			FUNCTION gettransaction(ptranid IN NUMBER) RETURN typedepositinfo IS
				cmethodname CONSTANT typemethodname := getcontractinfo.cmethodname ||
													   '.GetTransaction';
				vresult typedepositinfo;
			BEGIN
				t.enter(cmethodname, ptranid);
			
				SELECT *
				INTO   vresult
				FROM   tcontractdepositinfo
				WHERE  branch = cbranch
				AND    tranid = ptranid;
			
				t.leave(cmethodname, vresult.tranid);
				RETURN vresult;
			EXCEPTION
				WHEN no_data_found THEN
					t.exc(cmethodname);
					t.leave(cmethodname, vresult.tranid);
					RETURN vresult;
				WHEN OTHERS THEN
					t.exc(cmethodname);
					error.save(cmethodname);
					RAISE;
			END gettransaction;
		
		BEGIN
			t.enter(cmethodname);
		
			validatetransaction(ptranid, ptrancode, ptrantype, ptranamount, prevtranid);
		
			BEGIN
			
				SAVEPOINT spsavetransaction;
			
				IF prevtranid IS NULL
				THEN
				
					INSERT INTO tcontractdepositinfo
					VALUES
						(cbranch
						,scontractno
						,ptranid
						,ptrancode
						,ptrantype
						,pcurno
						,ptranamount
						,pcurrency
						,NULL
						,NULL);
				
				ELSE
				
					vdepositinfo := gettransaction(prevtranid);
				
					IF vdepositinfo.tranid IS NOT NULL
					THEN
					
						IF ptranamount >= vdepositinfo.transum
						THEN
						
							DELETE FROM tcontractdepositinfo
							WHERE  branch = cbranch
							AND    tranid = vdepositinfo.tranid;
						
						ELSE
						
							UPDATE tcontractdepositinfo
							SET    transum =
								   (vdepositinfo.transum - ptranamount)
							WHERE  branch = cbranch
							AND    tranid = vdepositinfo.tranid;
						
						END IF;
					
					END IF;
				
				END IF;
			
				COMMIT;
			
			EXCEPTION
			
				WHEN OTHERS THEN
					ROLLBACK TO spsavetransaction;
					RAISE;
			END;
		
			BEGIN
			
				SAVEPOINT spexecadjusting;
			
				IF cycleisclosed
				   OR (getcurrentcycle().lastduedate = coperdate)
				THEN
					seance.settempoperdate(coperdate + 1);
				END IF;
			
				BEGIN
				
					checkifentryallowed_pre;
				
					FOR i IN (SELECT *
							  FROM   tcontractdepositinfo
							  WHERE  branch = cbranch
							  AND    contractno = scontractno
							  AND    packno IS NULL
							  AND    recno IS NULL)
					LOOP
					
						validatetransaction(i.tranid, i.trancode, i.trantype, i.transum);
					
						s.say('TranID = ' || i.tranid || ', TranCode = ' || i.trancode ||
							  ', TranType = ' || i.trantype || ', CurrencyNo = ' || i.currencyno ||
							  ', TranCur = ' || i.trancur || ', TranSum = ' || i.transum);
					
						doentry(i.currencyno
							   ,sabaccounts(i.currencyno) (cb_techacc)
							   ,sdepaccount(i.currencyno)
							   ,i.trancur
							   ,i.transum
							   ,CASE i.trancode WHEN 20 THEN 'OPEXT_A20' ELSE 'OPEXT_P40' END
							   ,pdotrxn => FALSE);
					END LOOP;
				
					sdummynum := initadjusting(scontracttype);
					doadjusting(getadjmode_repayment);
				
				EXCEPTION
					WHEN OTHERS THEN
					
						vadjustingerror := TRUE;
					
						error.save(cmethodname);
				END;
			
				IF vadjustingerror
				THEN
				
					xmltools.additem('RESULT', '0');
				
					xmltools.additem('ERR_MSG', error.getusertext);
				
				ELSE
				
					xmltools.additem('RESULT', '1');
				
					xmltools.additem('LIMIT_ID'
									,NULL
									,'ACC_WL'
									,contracttypelimits.getlimitsettings(scontracttype, clk_cashlimit, referencelimit.objtype_account, cco_primary, vcurno)
									 .limitid
									,'CRD_CL'
									,contracttypelimits.getlimitsettings(scontracttype, clk_creditlimit, referencelimit.objtype_acc2card, cco_primary, vcurno)
									 .limitid
									,'CRD_WL'
									,contracttypelimits.getlimitsettings(scontracttype, clk_cashlimit, referencelimit.objtype_acc2card, cco_primary, vcurno)
									 .limitid);
				
					valllimits := getalllimitsvalue;
				
					FOR i IN 1 .. 2
					LOOP
					
						IF ifcurrencyisusedintype(i, scontracttype, scontractno)
						THEN
						
							xmltools.opentag('ACCOUNT'
											,'NO'
											,sdepaccount(i).accountno
											,'STS'
											,sdepaccount(i).acct_stat
											,'CL'
											,valllimits(i)('-').availcreditlimit
											,'WL'
											,valllimits(i)('-').availcashlimit);
						
							vindex := valllimits(i).first;
							WHILE vindex IS NOT NULL
							LOOP
							
								IF vindex <> '-'
								THEN
								
									contracttools.parsecardstring(vindex, vpan, vmbr, '-');
								
									IF card.existaccountcardlink(vpan
																,vmbr
																,sdepaccount(i).accountno)
									THEN
										xmltools.additem('CARD'
														,NULL
														,'NO'
														,vindex
														,'STS'
														,a4mfrontoffice.back2frontcrd_stat(getcardrecord(vindex)
																						   .pcstat)
														,'CL'
														,valllimits(i)(vindex).availcreditlimit
														,'WL'
														,valllimits(i)(vindex).availcashlimit);
									END IF;
								END IF;
								vindex := valllimits(i).next(vindex);
							END LOOP;
							xmltools.closetag('ACCOUNT');
						END IF;
					END LOOP;
				
				END IF;
			
				seance.settempoperdate(coperdate);
				ROLLBACK TO spexecadjusting;
			
			EXCEPTION
				WHEN OTHERS THEN
					seance.settempoperdate(coperdate);
					ROLLBACK TO spexecadjusting;
					error.save(cmethodname);
					RAISE;
			END;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END filldepositinfo;
	
	BEGIN
		t.enter(cmethodname);
	
		initcontract(pcontractno);
	
		vxml := xmltype(upper(contracttypeschema.scontractrequest.addparams));
	
		vcurrency := getparam(vxml, 'ADDPARAMS/CURRENCY');
		contracttools.checkvalue_exists(vcurrency, 'Currency');
	
		IF cinfotype = 'DEPOSIT_TRAN'
		THEN
			vcurno := getcurnotopostentry(vcurrency);
		
		ELSE
			vcurno := getcurnobycurrency(vcurrency);
		END IF;
	
		err.seterror(0, cmethodname);
	
		IF sblockparam.profileiddom = 0
		THEN
			sprofileid(1) := smainprofile(1);
		ELSE
			sprofileid(1) := sblockparam.profileiddom;
		END IF;
		IF sblockparam.profileidint = 0
		THEN
			sprofileid(2) := smainprofile(2);
		ELSE
			sprofileid(2) := sblockparam.profileidint;
		END IF;
	
		IF cinfotype IN ('GETCREDITLASTSTATEMENT', 'GETCREDITSTATEMENTDETAILS')
		THEN
		
			vdatestr := getparam(vxml, 'ADDPARAMS/DATE');
		
			IF vdatestr IS NULL
			THEN
				vdate         := coperdate;
				vcurrentcycle := getcurrentcycle;
			
			ELSE
				vdate         := contracttools.getvaliddate(vdatestr, 'ADDPARAMS/DATE', 'DDMMYYYY');
				vcurrentcycle := getcyclebydate(pcontractno, vdate);
			END IF;
		
			vstartdate := sdepaccount(vcurno).createdate;
			venddate   := vdate;
		
			IF vcurrentcycle.statementdate IS NOT NULL
			THEN
			
				venddate := vcurrentcycle.statementdate;
			
				vnewbalance := contracttools.get_bod_remain(sdepaccount(vcurno).accountno
														   ,venddate + 1);
			
				vpreviouscycle := getcyclebydate(pcontractno
												,vcurrentcycle.statementdate
												,c_noexception);
			
				IF vpreviouscycle.statementdate IS NOT NULL
				THEN
				
					vstartdate := vpreviouscycle.statementdate + 1;
				
					vlastbalance := contracttools.get_bod_remain(sdepaccount(vcurno).accountno
																,vstartdate);
				
				END IF;
			
			END IF;
		
		END IF;
	
		xmltools.init(pskipheader => TRUE, pwriteemptyelement => TRUE);
	
		CASE cinfotype
		
			WHEN 'GETCREDITLASTPAYMENT' THEN
			
				getcreditlastpayment(pcontractno, vcurrency, vdate, vamount);
				xmltools.additem('LAST_PAY_DATE', to_char(vdate, 'DDMMYYYY'));
				xmltools.additem('LAST_PAY_AMOUNT', vamount);
			
			WHEN 'GETCREDITLASTSTATEMENT' THEN
			
				xmltools.additem('ST_DATE', to_char(vcurrentcycle.statementdate, 'DDMMYYYY'));
				xmltools.additem('DUE_DATE', to_char(vcurrentcycle.duedate, 'DDMMYYYY'));
				xmltools.additem('PRN_DUE_DATE', to_char(vcurrentcycle.printedduedate, 'DDMMYYYY'));
			
				getdueamount(sdepaccount(vcurno).accountno, vdate, vdueamount, sdummynum);
				xmltools.additem('DUE_AMOUNT', vdueamount);
			
				IF vdatestr IS NULL
				THEN
					xmltools.additem('ACCT_REMAIN', sdepaccount(vcurno).remain);
				ELSE
					xmltools.additem('ACCT_REMAIN'
									,contracttools.get_eod_remain(sdepaccount(vcurno).accountno
																 ,vdate));
				END IF;
			
				xmltools.additem('NEW_BALANCE', vnewbalance);
				xmltools.additem('LAST_BALANCE', vlastbalance);
			
			WHEN 'GETCREDITSTATEMENTDETAILS' THEN
			
				xmltools.additem('DUE_DATE', to_char(vcurrentcycle.duedate, 'DDMMYYYY'));
				xmltools.additem('ST_DATE', to_char(vcurrentcycle.statementdate, 'DDMMYYYY'));
				xmltools.additem('PRN_DUE_DATE', to_char(vcurrentcycle.printedduedate, 'DDMMYYYY'));
			
				getdueamount(sdepaccount(vcurno).accountno, vdate, vdueamount, sdummynum);
				xmltools.additem('DUE_AMOUNT', vdueamount);
			
				IF vdatestr IS NULL
				THEN
					xmltools.additem('ACCT_REMAIN', sdepaccount(vcurno).remain);
					xmltools.additem('MIN_PAYMENT', getcurrentmp(vcurno));
				ELSE
					xmltools.additem('ACCT_REMAIN'
									,contracttools.get_eod_remain(sdepaccount(vcurno).accountno
																 ,vdate));
					int_getmp(vcurrentcycle.recno, vamp);
					xmltools.additem('MIN_PAYMENT', vamp(vcurno));
				END IF;
			
				vvalue := fintools.getdebitturnover(sdepaccount(vcurno).accountno
												   ,vstartdate
												   ,venddate
												   ,sprconentcode);
				xmltools.additem('INTEREST_AMOUNT', vvalue);
			
				xmltools.additem('NEW_BALANCE', vnewbalance);
				xmltools.additem('LAST_BALANCE', vlastbalance);
			
				vvalue := fintools.getdebitturnover(sdepaccount(vcurno).accountno
												   ,vstartdate
												   ,venddate
												   ,tblnumber(sdelfeeonentcode, sovdfeeonentcode));
				xmltools.additem('PENALTY_AMOUNT', vvalue);
			
			WHEN 'GETDIRECTDEBITDETAILS' THEN
			
				chooseprofiles(vcurno);
				xmltools.additem('DIRECT_PER'
								,smpprofile(smpprofileid(vcurno))
								 (custom_contractprofiles.cp_mpp_prc));
			
				IF hascorporatecontract
				THEN
					contracttools.loadcontractaccountbyaccno(getpaymentaccount(sdepaccount(vcurno)
																			   .currencyno)
															,vcorpacc
															,c_doexception);
				END IF;
				xmltools.additem('DIRECT_ACCNT', vcorpacc.accountno);
			
			WHEN 'GETCREDITCARDSDETAILS' THEN
				fillcardsinfo(htools.i2b(getparam(vxml, 'ADDPARAMS/USESPECIFIEDCARD')));
			
			WHEN 'GETCORPORATEDETAILS' THEN
				IF hascorporatecontract
				THEN
					xmltools.additem('MASTER_ACC', getmasteraccount(vcurno));
				ELSE
					xmltools.additem('MASTER_ACC', '');
				END IF;
			
			WHEN 'GETLIMITDETAILS' THEN
			
				xmltools.additem('CREDIT_LIMIT', sdepaccount(vcurno).overdraft);
				xmltools.additem('CASH_LIMIT', calcobjectlimits(vcurno).cashlimit);
			
				getavailablelimit(pcontractno, vavaildom, vavailint);
				xmltools.additem('AVAIL_LIMIT', getvaluebycurno(vcurno, vavaildom, vavailint));
			
			WHEN 'DEPOSIT_TRAN' THEN
				filldepositinfo(vcurno
							   ,vcurrency
							   ,getparam(vxml, 'ADDPARAMS/TWO_TRAN_ID')
							   ,getparam(vxml, 'ADDPARAMS/TRAN_CODE')
							   ,getparam(vxml, 'ADDPARAMS/TRAN_TYPE')
							   ,getparam(vxml, 'ADDPARAMS/DEPOSIT_AMOUNT')
							   ,getparam(vxml, 'ADDPARAMS/TWO_REVTRAN_ID'));
			
			ELSE
				error.raiseerror('Unsupported InfoType field value: <' || cinfotype || '>!');
		END CASE;
	
		contracttypeschema.sacontractresponse := xmltools.finish_arrtext;
	
		t.leave(cmethodname);
		RETURN rpc.err_success;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			xmltools.abort;
			error.save(cmethodname);
			RAISE;
	END getcontractinfo;

	FUNCTION getdataforreport
	(
		pstartdate  IN DATE
	   ,penddate    IN DATE
	   ,pmaxcount   IN NUMBER
	   ,parchive    IN BOOLEAN := FALSE
	   ,pneedremain IN BOOLEAN := TRUE
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetDataForReport';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vvalue              NUMBER;
		vdepaccount         contracttools.taccountrecord;
		vremain             NUMBER;
		vstartdate          DATE;
		venddate            DATE;
		vamount             types.arrnum;
		vpan                typepan;
		vmbr                typembr;
		vdate               DATE;
		vaccountlimitsvalue typelimitvaluerecord;
		vreverse            NUMBER;
		velementcount       NUMBER := 0;
	
		vcardlist apitypes.typecardlist;
	
		vpreferences statementrt.tpreferencesrec;
		vparams      statementdataprepare.typeparametersrec;
	
		ventryarray      contracttypeschema.tentryarray;
		ventryaggregates typeentryaggregatesrecord;
	
		vbonuscontrarray   contractlink.typecontractarray;
		vbonuscontraccount taccount%ROWTYPE;
	
		vusedinstallmentlimit NUMBER;
		vinstallmentlimits    types.arrnum;
	
		PROCEDURE getamountbygrouptype IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename ||
												 '.GetDataForReport.GetAmountByGroupType';
			CURSOR c IS
				SELECT -a.value VALUE
					  ,nvl(d.cashadvance, 3) gtype
					  ,e.ident ident
				FROM   tentry                  a
					  ,tdocument               b
					  ,treferenceentry         e
					  ,tcontractentrygrouplist c
					  ,tcontractentrygroup     d
				WHERE  a.branch = cbranch
				AND    a.debitaccount = vdepaccount.accountno
				AND    b.branch = a.branch
				AND    b.docno = a.docno
				AND    b.opdate BETWEEN vstartdate AND venddate
				AND    b.newdocno IS NULL
				AND    e.branch = a.branch
				AND    e.code = a.debitentcode
				AND    c.branch(+) = a.branch
				AND    c.entcode(+) = a.debitentcode
				AND    d.branch(+) = c.branch
				AND    d.groupid(+) = c.groupid
				UNION ALL
				SELECT a.value VALUE
					  ,nvl(d.cashadvance, 3) gtype
					  ,e.ident ident
				FROM   tentry                  a
					  ,tdocument               b
					  ,treferenceentry         e
					  ,tcontractentrygrouplist c
					  ,tcontractentrygroup     d
				WHERE  a.branch = cbranch
				AND    a.creditaccount = vdepaccount.accountno
				AND    b.branch = a.branch
				AND    b.docno = a.docno
				AND    b.opdate BETWEEN vstartdate AND venddate
				AND    b.newdocno IS NULL
				AND    e.branch = a.branch
				AND    e.code = a.debitentcode
				AND    c.branch(+) = a.branch
				AND    c.entcode(+) = a.debitentcode
				AND    d.branch(+) = c.branch
				AND    d.groupid(+) = c.groupid;
		BEGIN
			vamount.delete;
			vreverse := 0;
			FOR i IN 0 .. 6
			LOOP
				vamount(i) := 0;
			END LOOP;
			FOR i IN c
			LOOP
				IF i.gtype <> 2
				   AND i.value > 0
				THEN
					vreverse := vreverse + i.value;
				END IF;
				IF substr(i.ident, 1, 22) = 'CHARGE_INTEREST_GROUP_'
				THEN
					vamount(4) := vamount(4) + i.value;
				ELSE
					vamount(i.gtype) := vamount(i.gtype) + i.value;
				END IF;
				IF i.ident = 'OVERDUE_FEE_ON'
				THEN
					vamount(5) := vamount(5) + i.value;
				ELSIF i.ident = 'OVERLIMIT_FEE_ON'
				THEN
					vamount(6) := vamount(6) + i.value;
				END IF;
			END LOOP;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END;
	
		PROCEDURE getpan
		(
			pcontno IN VARCHAR
		   ,popan   OUT NOCOPY typepan
		   ,pombr   OUT typembr
		) IS
			cmethodname CONSTANT VARCHAR2(80) := cpackagename || '.GetDataForReport.GetPAN';
			CURSOR c2 IS
				SELECT ci.no
					  ,c.pan
					  ,c.mbr
					  ,c.createdate
					  ,c.crd_stat
				FROM   tcontractcarditem ci
					  ,tcard             c
					  ,tcontract         ct
				WHERE  ct.branch = cbranch
				AND    ct.no = pcontno
				AND    ci.branch = ct.branch
				AND    ci.no = ct.no
				AND    c.branch = ci.branch
				AND    c.pan = ci.pan
				AND    c.mbr = ci.mbr
				AND    c.idclient = ct.idclient
				ORDER  BY c.createdate;
		BEGIN
			popan := NULL;
			pombr := NULL;
			FOR k IN c2
			LOOP
				IF k.crd_stat <> referencecrd_stat.card_closed
				THEN
					popan := k.pan;
					pombr := k.mbr;
					RETURN;
				END IF;
			END LOOP;
			FOR k IN c2
			LOOP
				popan := k.pan;
				pombr := k.mbr;
				RETURN;
			END LOOP;
		EXCEPTION
			WHEN OTHERS THEN
				error.save(cmethodname);
				RAISE;
		END getpan;
	
		PROCEDURE adddataforreport
		(
			pname        IN VARCHAR2
		   ,pvalue       IN VARCHAR2
		   ,pelementname IN VARCHAR2 := NULL
		   ,pelementkey  IN VARCHAR2 := NULL
		) IS
			cmethodname CONSTANT typemethodname := getdataforreport.cmethodname ||
												   '.AddDataForReport';
			cposition   CONSTANT NUMBER := contracttypeschema.sacontractinfo.count + 1;
		BEGIN
			contracttypeschema.sacontractinfo(cposition).name := pname;
			contracttypeschema.sacontractinfo(cposition).value := pvalue;
			contracttypeschema.sacontractinfo(cposition).elementname := pelementname;
			contracttypeschema.sacontractinfo(cposition).elementkey := pelementkey;
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END adddataforreport;
	
	BEGIN
		t.enter(cmethodname
			   ,'StartDate = ' || htools.d2s(pstartdate) || ', EndDate = ' || htools.d2s(penddate) ||
				', MaxCount = ' || pmaxcount || ', Archive = ' || htools.b2s(parchive) ||
				', NeedRemain = ' || htools.b2s(pneedremain));
	
		scontracttype                        := contract.gettype(contracttypeschema.scontractrow.no);
		scontractno                          := contracttypeschema.scontractrow.no;
		contracttypeschema.scontractrow.type := scontracttype;
	
		IF pneedremain
		THEN
		
			readsetupscheme(FALSE);
			getcontractdata;
		
			spreviouscycle := getcyclebydate(scontractno, penddate);
		
			IF NOT int_getcyclebydate(spreviouscycle.nextstatementdate + 1, scurrentcycle)
			THEN
				error.raiseerror('Cannot get information on date ' || htools.d2s(penddate) ||
								 ' since this is current contract cycle and it has not yet been closed (SD = ' ||
								 htools.d2s(spreviouscycle.nextstatementdate) || ')!');
			END IF;
		
			int_getmp(scurrentcycle.recno, scurrentmp);
		
			vpreferences      := statementrt.loadpreferences;
			vparams.maskpan   := vpreferences.usemask;
			vparams.maskstart := vpreferences.maskstartpos;
			vparams.maskend   := vpreferences.maskendpos;
			vparams.maskchar  := vpreferences.maskchar;
		
		ELSE
			s.say(cmethodname || ' - info: Accounts is being loaded for case NOT pNeedRemain');
			FOR i IN 1 .. 2
			LOOP
				contracttools.loadcontractaccount(contracttypeitems.getitemcode(scontracttype
																			   ,'ItemDeposit' ||
																				slabel(i))
												 ,sdepaccount(i)
												 ,scontractno);
			END LOOP;
		END IF;
	
		IF pneedremain
		THEN
			venddate := scurrentcycle.statementdate;
			IF spreviouscycle.statementdate IS NULL
			THEN
				vstartdate := nvl(sdepaccount(1).createdate, sdepaccount(2).createdate) - 1;
			ELSE
				vstartdate := spreviouscycle.statementdate + 1;
			END IF;
		ELSE
			vstartdate := pstartdate;
			venddate   := penddate;
		END IF;
	
		IF pneedremain
		THEN
		
			s.say(cmethodname || ' StartDate=' || vstartdate || ' EndDate=' || venddate);
		
			adddataforreport('STATEMENT_DATE', to_char(scurrentcycle.statementdate, 'DD/MM/YYYY'));
			adddataforreport('NEXT_STATEMENT_DATE'
							,to_char(scurrentcycle.nextstatementdate, 'DD/MM/YYYY'));
			vdate := contractcalendar.getprintedduedate(getbillingcyclecalendar
													   ,scurrentcycle.statementdate);
			adddataforreport('PAYMENT_DATE', to_char(vdate, 'DD/MM/YYYY'));
			adddataforreport('STATEMENT_PERIOD', to_char(vdate - scurrentcycle.statementdate));
		
			getpan(scontractno, vpan, vmbr);
			adddataforreport('MAIN_CARD'
							,statementdataprepare.maskpan(vpan, vparams) || '-' || vmbr);
			adddataforreport('PROMO_TEXT', sactparam(cctp_promtext));
		
			vcardlist := contract.getcardlist(scontractno
											 ,pclientid4sorting => contract.getidclient(scontractno));
		
			FOR i IN 1 .. vcardlist.count
			LOOP
				velementcount := velementcount + 1;
				adddataforreport('PAN'
								,statementdataprepare.maskpan(vcardlist(i).pan, vparams)
								,'Card'
								,velementcount);
				adddataforreport('MBR', vcardlist(i).mbr, 'Card', velementcount);
				adddataforreport('CLIENTNAME'
								,clientpersone.getpersonerecord(vcardlist(i).idclient).fio
								,'Card'
								,velementcount);
			END LOOP;
		
		END IF;
	
		FOR i IN 1 .. 2
		LOOP
		
			IF ifcurrencyisusedintype(i, scontracttype, scontractno)
			THEN
			
				vdepaccount := sdepaccount(i);
			
				IF pneedremain
				THEN
				
					adddataforreport('ACCOUNTNO'
									,vdepaccount.accountno
									,'Account'
									,vdepaccount.accountno);
					adddataforreport('EXTACCOUNTNO'
									,account.getaccountrecord(vdepaccount.accountno).extaccountno
									,'Account'
									,vdepaccount.accountno);
					adddataforreport('ACURN'
									,referencecurrency.getabbreviation(vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
					adddataforreport('ACURC'
									,vdepaccount.currencyno
									,'Account'
									,vdepaccount.accountno);
				
					vremain := contracttools.get_bod_remain(vdepaccount.accountno, vstartdate);
					adddataforreport('SBALANCE'
									,ltools.formatamount(vremain, vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
				
					vremain := contracttools.get_eod_remain(vdepaccount.accountno, venddate);
					adddataforreport('EBALANCE'
									,ltools.formatamount(vremain, vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
				
					vinstallmentlimits(cinstregpayment) := 0;
					vinstallmentlimits(cinstusedlimit) := 0;
					vusedinstallmentlimit := getusedinstlimit(i, vinstallmentlimits);
				
					adddataforreport('CRD_LIMIT'
									,ltools.formatamount(vdepaccount.overdraft
														,vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
					adddataforreport('AVAIL_CRD_LIMIT'
									,ltools.formatamount(greatest(least(vdepaccount.overdraft +
																		vremain -
																		vusedinstallmentlimit
																	   ,vdepaccount.overdraft)
																 ,0)
														,vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
				
					adddataforreport('INSTALL_MONTH_PAYM'
									,ltools.formatamount(vinstallmentlimits(cinstregpayment)
														,vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
				
					adddataforreport('INSTALL_UNPAID_AMOUNT'
									,ltools.formatamount(vinstallmentlimits(cinstusedlimit)
														,vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
				
					vaccountlimitsvalue := calcobjectlimits(i);
				
					vvalue := greatest(vaccountlimitsvalue.cashlimit - getobjectlimitssetup(scontractno, i)
									   .usedcashlimit.amount
									  ,0);
				
					adddataforreport('CASH_LIMIT'
									,ltools.formatamount(vaccountlimitsvalue.cashlimit
														,vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
					adddataforreport('AVAIL_CASH_LIMIT'
									,ltools.formatamount(vvalue, vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
					adddataforreport('MIN_AMOUNT_DUE'
									,ltools.formatamount(scurrentmp(i), vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
				
					getamountbygrouptype;
				
					adddataforreport('SUM_WITHDRAWAL'
									,ltools.formatamount(-vamount(1), vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
					adddataforreport('SUM_PURCHASE'
									,ltools.formatamount(-vamount(0), vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
					adddataforreport('SUM_INTEREST'
									,ltools.formatamount(-vamount(4), vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
					adddataforreport('SUM_OTHER'
									,ltools.formatamount(-vamount(3), vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
					adddataforreport('SUM_CREDIT'
									,ltools.formatamount(vamount(2), vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
					adddataforreport('SUM_REVERSE'
									,ltools.formatamount(vreverse, vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
					adddataforreport('OVDFEE_AMOUNT'
									,ltools.formatamount(abs(vamount(5)), vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
					adddataforreport('OVLFEE_AMOUNT'
									,ltools.formatamount(abs(vamount(6)), vdepaccount.currencyno)
									,'Account'
									,vdepaccount.accountno);
				
				END IF;
			
				IF (i = 1)
				   OR (contracttypeschema.saentry.count = 0)
				THEN
					contracttypeschema.saentry := contracttools.getentryarray(vdepaccount.accountno
																			 ,vstartdate
																			 ,venddate
																			 ,pmaxcount
																			 ,parchive);
				
				ELSE
					ventryarray := contracttools.getentryarray(vdepaccount.accountno
															  ,vstartdate
															  ,venddate
															  ,pmaxcount
															  ,parchive);
					FOR j IN 1 .. ventryarray.count
					LOOP
						contracttypeschema.saentry(contracttypeschema.saentry.count + 1) := ventryarray(j);
					END LOOP;
				END IF;
			
			END IF;
		
			IF pneedremain
			THEN
			
				velementcount := velementcount + 1;
			
				IF sintaccount.exists(i)
				   AND sintaccount(i).accountno IS NOT NULL
				THEN
				
					ventryarray := contracttools.getentryarray(sintaccount(i).accountno
															  ,sintaccount(i).createdate
															  ,NULL
															  ,100000
															  ,TRUE);
				
					ventryaggregates := getentryaggregates(ventryarray, vstartdate, venddate);
				
					adddataforreport('ACCOUNT_NO'
									,sintaccount(i).accountno
									,'AccumIntAcc'
									,velementcount);
				
					adddataforreport('ACCUM_INT_AMOUNT'
									,ltools.formatamount(ventryaggregates.debitturnover
														,sintaccount(i).currencyno)
									,'AccumIntAcc'
									,velementcount);
				
					adddataforreport('ACCUM_INT_SBALANCE'
									,ltools.formatamount(ventryaggregates.incomebalance
														,sintaccount(i).currencyno)
									,'AccumIntAcc'
									,velementcount);
				
					adddataforreport('ACCUM_INT_EBALANCE'
									,ltools.formatamount(ventryaggregates.outcomebalance
														,sintaccount(i).currencyno)
									,'AccumIntAcc'
									,velementcount);
				
					adddataforreport('ACCUM_INT_RRELEASE'
									,ltools.formatamount(ventryaggregates.creditturnover
														,sintaccount(i).currencyno)
									,'AccumIntAcc'
									,velementcount);
				
				END IF;
			
			END IF;
		
		END LOOP;
	
		IF pneedremain
		THEN
		
			IF contractlink.getlinkno(scontractno, contractlink.clink, vbonuscontrarray, 'BONUS') > 0
			THEN
			
				FOR i IN 1 .. vbonuscontrarray.count
				LOOP
					s.say(cmethodname || '  Bonus Contract Number (vBonusContrArray[' || i ||
						  '].cNo) = ' || vbonuscontrarray(i).cno || ', vBonusContrArr(i).cType = ' || vbonuscontrarray(i)
						  .ctype);
					contracttools.loadcontractaccount(contracttypeitems.getitemcode(vbonuscontrarray(i)
																					.ctype
																				   ,'ITEMBONUS')
													 ,vbonuscontraccount
													 ,vbonuscontrarray(i).cno);
					s.say(cmethodname ||
						  ' Bonus Contract Account (vBonusContrAccount.accountNo) = ' ||
						  vbonuscontraccount.accountno);
				
					ventryarray := contracttools.getentryarray(vbonuscontraccount.accountno
															  ,vbonuscontraccount.createdate
															  ,NULL
															  ,100000
															  ,TRUE);
				
					ventryaggregates := getentryaggregates(ventryarray, vstartdate, venddate);
				
					velementcount := velementcount + 1;
				
					adddataforreport('ACCOUNT_NO'
									,vbonuscontraccount.accountno
									,'BonusContrAcc'
									,velementcount);
					adddataforreport('ACURN'
									,referencecurrency.getabbreviation(vbonuscontraccount.currencyno)
									,'BonusContrAcc'
									,velementcount);
					adddataforreport('ACURC'
									,vbonuscontraccount.currencyno
									,'BonusContrAcc'
									,velementcount);
				
					adddataforreport('SBALANCE'
									,ltools.formatamount(ventryaggregates.incomebalance
														,vbonuscontraccount.currencyno)
									,'BonusContrAcc'
									,velementcount);
				
					adddataforreport('EBALANCE'
									,ltools.formatamount(ventryaggregates.outcomebalance
														,vbonuscontraccount.currencyno)
									,'BonusContrAcc'
									,velementcount);
				
					adddataforreport('SUM_CREDIT'
									,ltools.formatamount(ventryaggregates.creditturnover
														,vbonuscontraccount.currencyno)
									,'BonusContrAcc'
									,velementcount);
				
					adddataforreport('SUM_DEBIT'
									,ltools.formatamount(ventryaggregates.debitturnover
														,vbonuscontraccount.currencyno)
									,'BonusContrAcc'
									,velementcount);
				
				END LOOP;
			
			END IF;
		
		END IF;
	
		IF pneedremain
		THEN
			FOR i IN contracttypeschema.saentry.count .. 1
			LOOP
				contracttypeschema.saentry(contracttypeschema.saentry.count + 1) := NULL;
			END LOOP;
		END IF;
	
		IF pneedremain
		THEN
			resetcurrentcycle;
		END IF;
	
		t.leave(cmethodname, contracttypeschema.sacontractinfo.count);
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getdataforreport;

	PROCEDURE drawinfopanel
	(
		pcontractno   IN typecontractno
	   ,pcontracttype IN typecontracttype
	   ,pdialog       IN NUMBER
	   ,ppanel        IN NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.DrawInfoPanel';
		cinfopanel  CONSTANT VARCHAR2(10) := 'InfoPanel';
	
		vpage NUMBER;
	
		FUNCTION makepage(ptitle IN VARCHAR2) RETURN NUMBER IS
			cmethodname CONSTANT typemethodname := drawinfopanel.cmethodname || '.MakePage';
		BEGIN
			RETURN dialog.page(ppanel, cinfopanel, ptitle, REPLACE(ptitle, ' '));
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makepage;
	
		PROCEDURE makepage
		(
			ptitle      IN VARCHAR2
		   ,plinescount IN NUMBER
		) IS
			cmethodname CONSTANT typemethodname := drawinfopanel.cmethodname || '.MakePage';
			vpage NUMBER;
		BEGIN
			t.enter(cmethodname);
		
			vpage := makepage(ptitle);
		
			FOR i IN 1 .. plinescount
			LOOP
				dialog.textlabel(vpage, REPLACE(ptitle, ' ') || i, 2, i, 70);
			END LOOP;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END makepage;
	
	BEGIN
		t.enter(cmethodname);
	
		dialog.pagelist(ppanel, cinfopanel, 1, 1, 73, 8);
	
		makepage('Common', 6);
	
		makepage('Cycle', 6);
	
		makepage('Overlimit', 2);
	
		makepage('Contract state', 5);
	
		vpage := makepage('State history');
	
		dialog.list(vpage, 'StateHistoryList', 2, 2, 68, 4, 'Contract states history');
		dialog.listaddfield(vpage, 'StateHistoryList', 'Date', 'C', 13, 1);
		dialog.listaddfield(vpage, 'StateHistoryList', 'State', 'C', 20, 1);
		dialog.listaddfield(vpage, 'StateHistoryList', 'Operation', 'C', 32, 1);
		dialog.setcaption(vpage, 'StateHistoryList', 'Date~State~Operation');
	
		makepage('Deferred period', 3);
	
		vpage := makepage('Restructuring');
	
		dialog.list(vpage, 'RestructureList', 2, 2, 68, 4, 'Restructuring operations list');
		dialog.listaddfield(vpage, 'RestructureList', 'Date', 'C', 13, 1);
		dialog.listaddfield(vpage, 'RestructureList', 'Currency', 'C', 13, 1);
		dialog.listaddfield(vpage, 'RestructureList', 'Contract', 'C', 20, 1);
		dialog.listaddfield(vpage, 'RestructureList', 'Amount', 'N', 15, 1);
		dialog.setcaption(vpage, 'RestructureList', 'Date~Currency~Contract~Amount');
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END drawinfopanel;

	PROCEDURE fillinfopanel
	(
		pcontractno   IN typecontractno
	   ,pcontracttype IN typecontracttype
	   ,pdialog       IN NUMBER
	   ,ppanel        IN NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.FillInfoPanel';
		cbranch     CONSTANT NUMBER := seance.getbranch;
		coperdate   CONSTANT DATE := seance.getoperdate;
	
		vcurrentstate    contractstatereference.typeregisteredstaterow;
		varestructurelog contractoplog.tarroplog;
		voverlimitstring VARCHAR2(50);
		vaccountno       typeaccountno;
		voverdueamount   NUMBER;
	
		vovdamount   types.arrnum;
		vcurused     types.arrbool;
		vcurrentpage NUMBER;
	
		FUNCTION getunit(pvalue IN NUMBER) RETURN VARCHAR2 IS
			vresult VARCHAR2(10) := 'no';
		BEGIN
			IF pvalue IS NOT NULL
			THEN
				vresult := service.iif(sdelparam.overdueint IN
									   (contractdelinqsetup.covdday
									  ,contractdelinqsetup.covdfirstday)
									  ,' day'
									  ,' cycle');
				IF pvalue <> 1
				THEN
					vresult := vresult || 's';
				END IF;
			END IF;
			RETURN vresult;
		END getunit;
	
		FUNCTION format
		(
			ptitle IN VARCHAR2
		   ,pvalue IN VARCHAR2
		) RETURN VARCHAR2 IS
		BEGIN
			RETURN ptitle || lpad(pvalue, 33 - length(ptitle)) || rpad(' ', 4);
		END;
	
		PROCEDURE puttext
		(
			pdialog    IN NUMBER
		   ,ppagetitle IN VARCHAR2
		   ,pline      IN NUMBER
		   ,ptext      IN VARCHAR2
		) IS
		BEGIN
			dialog.putchar(pdialog, REPLACE(ppagetitle, ' ') || pline, rtrim(ptext));
		END;
	
		PROCEDURE puttext
		(
			pdialog    IN NUMBER
		   ,ppagetitle IN VARCHAR2
		   ,pline      IN NUMBER
		   ,pparamname IN VARCHAR2
		   ,pvaluedom  IN NUMBER
		   ,pvalueint  IN NUMBER
		) IS
		BEGIN
			IF smulticurrency
			THEN
				puttext(pdialog
					   ,ppagetitle
					   ,pline
					   ,format(rpad(pparamname, 13) || '(' || getcurrencyabbr(1) || '):'
							  ,ltools.formatamount(pvaluedom, sdepaccount(1).currencyno)) ||
						format('(' || getcurrencyabbr(2) || '):'
							  ,ltools.formatamount(pvalueint, sdepaccount(2).currencyno)));
			ELSIF vcurused(1)
			THEN
				puttext(pdialog
					   ,ppagetitle
					   ,pline
					   ,format(rpad(pparamname, 13) || '(' || getcurrencyabbr(1) || '):'
							  ,ltools.formatamount(pvaluedom, sdepaccount(1).currencyno)));
			ELSE
				puttext(pdialog
					   ,ppagetitle
					   ,pline
					   ,format(rpad(pparamname, 13) || '(' || getcurrencyabbr(2) || '):'
							  ,ltools.formatamount(pvalueint, sdepaccount(2).currencyno)));
			END IF;
		END;
	
		PROCEDURE switchpage
		(
			ppagename       IN VARCHAR2
		   ,pcondition      IN BOOLEAN
		   ,pocurrentpageid IN OUT NUMBER
		   ,ppagetomove     IN VARCHAR2
		) IS
			cmethodname CONSTANT typemethodname := fillinfopanel.cmethodname || '.SwitchPage';
			vpageid NUMBER := dialog.idbyname(pdialog, REPLACE(ppagename, ' '));
		BEGIN
			t.enter(cmethodname);
		
			dialog.setvisible(vpageid, pcondition);
		
			IF (NOT pcondition)
			   AND (vpageid = pocurrentpageid)
			THEN
				pocurrentpageid := dialog.idbyname(pdialog, REPLACE(ppagetomove, ' '));
				dialog.setfocus(pocurrentpageid);
			END IF;
		
			t.leave(cmethodname);
		EXCEPTION
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END switchpage;
	
	BEGIN
		t.enter(cmethodname);
	
		custom_overdueparameterscalculation.clearcache;
		scontractno   := contracttypeschema.scontractrow.no;
		scontracttype := contract.gettype(contracttypeschema.scontractrow.no);
		scontractstat := contract.getstatus(contracttypeschema.scontractrow.no);
		readsetupscheme(FALSE);
		getcontractdata;
		vcurrentstate := contractstatereference.getlastregisteredstate(scontractno);
	
		FOR i IN 1 .. 2
		LOOP
			vcurused(i) := ifcurrencyisusedintype(i, scontracttype, scontractno);
		END LOOP;
	
		vcurrentpage := greatest(dialog.getcurpage(dialog.idbyname(pdialog, 'InfoPanel'))
								,dialog.idbyname(pdialog, 'Common'));
	
		puttext(pdialog
			   ,'Common'
			   ,1
			   ,format('Limit type:', getlimittypedescr_int(scontractno)) ||
				format('State:'
					  ,vcurrentstate.statecode || ' (' ||
					   contractstatereference.getdescr_stickmode(vcurrentstate.stickmode) || ')'));
		puttext(pdialog
			   ,'Common'
			   ,2
			   ,format('Corporate No:', nvl(getcorpcontractnumber, 'Not defined')) ||
				format('Class:'
					  ,contractstatereference.getclassbystatecode(sblockparam.state.statecode)
					   .classcode));
		puttext(pdialog
			   ,'Common'
			   ,3
			   ,'Credit limit'
			   ,sdepaccount  (1).overdraft
			   ,sdepaccount  (2).overdraft);
		puttext(pdialog
			   ,'Common'
			   ,4
			   ,'Credit amnt'
			   ,abs(least(sdepaccount(1).remain, 0))
			   ,abs(least(sdepaccount(2).remain, 0)));
		puttext(pdialog
			   ,'Common'
			   ,5
			   ,'Min payment'
			   ,getminpaymentamount(1)
			   ,getminpaymentamount(2));
	
		getdelparameters;
		FOR i IN 1 .. 2
		LOOP
			vovdamount(i) := 0;
			IF vcurused(i)
			THEN
				snowduedate := (getcurrentcycle().lastduedate IS NOT NULL) AND
							   (getcurrentcycle().lastduedate = coperdate);
			
				IF sdepaccount(i).accountno IS NULL
				THEN
					htools.showmessage('Warning'
									  ,'One of accounts is not linked to the contract! Compare allowable contract type currency and contract ones.');
				ELSE
					IF NOT snowduedate
					   AND getcurrentcycle().duedate = coperdate
					THEN
						getdueamount(sdepaccount(i).accountno
									,coperdate - 1
									,sdummynum
									,voverdueamount);
					ELSE
						getdueamount(sdepaccount(i).accountno
									,coperdate
									,sdummynum
									,voverdueamount);
					END IF;
					vovdamount(i) := abs(voverdueamount);
				END IF;
			END IF;
		END LOOP;
	
		puttext(pdialog, 'Common', 6, 'Overdue amnt', vovdamount(1), vovdamount(2));
	
		puttext(pdialog
			   ,'Cycle'
			   ,1
			   ,format('Statement date      :'
					  ,nvl(htools.d2s(getcurrentcycle().statementdate), '-')));
		puttext(pdialog
			   ,'Cycle'
			   ,2
			   ,format('Printed due date    :'
					  ,nvl(htools.d2s(getcurrentcycle().printedduedate), '-')));
		puttext(pdialog
			   ,'Cycle'
			   ,3
			   ,format('Due date            :', nvl(htools.d2s(getcurrentcycle().duedate), '-')));
		puttext(pdialog
			   ,'Cycle'
			   ,4
			   ,format('Adjusted in due date:'
					  ,service.iif(getcurrentcycle().statementdate IS NULL
								  ,'-'
								  ,service.iif(getcurrentcycle().lastduedate IS NULL, 'No', 'Yes'))));
		puttext(pdialog
			   ,'Cycle'
			   ,5
			   ,format('DAF generation date :', nvl(htools.d2s(getcurrentcycle().dafdate), '-')));
		puttext(pdialog
			   ,'Cycle'
			   ,6
			   ,format('Next statement date :'
					  ,nvl(htools.d2s(getcurrentcycle().nextstatementdate), '-')));
	
		IF vcurused(1)
		THEN
		
			voverlimitstring := service.iif(sovdaccount(1).remain = 0
										   ,'   -   '
										   ,referencecurrency.getabbreviation(sovdaccount(1)
																			  .currencyno) || ' ' ||
											ltools.formatamount(abs(sovdaccount(1).remain)
															   ,sovdaccount(1).currencyno));
		
			IF vcurused(2)
			THEN
				puttext(pdialog
					   ,'Overlimit'
					   ,1
					   ,format('Overlimit (DOM):', ' ') || format(voverlimitstring, ' '));
			ELSE
				puttext(pdialog, 'Overlimit', 1, format('Overlimit (DOM):', voverlimitstring));
			END IF;
		
		END IF;
	
		IF vcurused(2)
		THEN
		
			voverlimitstring := service.iif(sovdaccount(2).remain = 0
										   ,'   -   '
										   ,referencecurrency.getabbreviation(sovdaccount(2)
																			  .currencyno) || ' ' ||
											ltools.formatamount(abs(sovdaccount(2).remain)
															   ,sovdaccount(2).currencyno));
		
			IF vcurused(1)
			THEN
				puttext(pdialog
					   ,'Overlimit'
					   ,1 + htools.b2i(vcurused(1))
					   ,format('Overlimit (INT):', voverlimitstring) ||
						format(service.iif(sovdaccount(2).remain = 0
										  ,'   -   '
										  ,referencecurrency.getabbreviation(sovdaccount(1)
																			 .currencyno) || ' ' ||
										   ltools.formatamount(abs(contracttools.getsumincurrency(sovdaccount(2)
																								 ,sdepaccount(1)
																								  .currencyno))
															  ,sdepaccount(1).currencyno))
							  ,' '));
			ELSE
				puttext(pdialog
					   ,'Overlimit'
					   ,1 + htools.b2i(vcurused(1))
					   ,format('Overlimit (INT):', voverlimitstring));
			END IF;
		
		END IF;
	
		puttext(pdialog
			   ,'Contract state'
			   ,1
			   ,'               ' ||
				service.rightpad('Registered ' || htools.d2s(vcurrentstate.operdate), 24) ||
				service.rightpad('Calculated now', 24));
		puttext(pdialog
			   ,'Contract state'
			   ,2
			   ,'State:         ' || service.rightpad(vcurrentstate.statecode || ' (' ||
													  contractstatereference.getdescr_stickmode(vcurrentstate.stickmode) || ')'
													 ,24) ||
				service.rightpad(sblockparam.state.statecode || ' (' ||
								 contractstatereference.getdescr_stickmode(sblockparam.state.stickstate) || ')'
								,24));
		puttext(pdialog
			   ,'Contract state'
			   ,3
			   ,'Overdue:       ' || service.rightpad(service.iif(vcurrentstate.overdue >= 0
																 ,vcurrentstate.overdue ||
																  getunit(vcurrentstate.overdue)
																 ,'-')
													 ,24) ||
				service.rightpad(service.iif(sblockparam.period >= 0
											,sblockparam.period || getunit(sblockparam.period)
											,'-')
								,24));
		puttext(pdialog
			   ,'Contract state'
			   ,4
			   ,'No-overdue:    ' || service.rightpad(service.iif(vcurrentstate.overdue < -0.75
																 ,-vcurrentstate.overdue ||
																  getunit(-vcurrentstate.overdue)
																 ,'-')
													 ,24) ||
				service.rightpad(service.iif(sblockparam.period < -0.75
											,-sblockparam.period || getunit(-sblockparam.period)
											,'-')
								,24));
		puttext(pdialog
			   ,'Contract state'
			   ,5
			   ,'Overlimit:     ' || service.rightpad(service.iif(vcurrentstate.overlimit >= 0
																 ,to_char(vcurrentstate.overlimit)
																 ,'-')
													 ,24) ||
				service.rightpad(service.iif(sblockparam.overlimit >= 0
											,to_char(sblockparam.overlimit)
											,'-')
								,24));
	
		dialog.listclear(pdialog, 'StateHistoryList');
	
		FOR i IN (SELECT operdate
						,statecode
						,CASE operation
							 WHEN 'MIGR' THEN
							  'Adjustment'
							 ELSE
							  operation
						 END AS operation
				  FROM   tcontractstatehistory
				  WHERE  branch = cbranch
				  AND    contractno = pcontractno
				  ORDER  BY recno DESC)
		LOOP
			dialog.listaddrecord(pdialog
								,'StateHistoryList'
								,i.operdate || '~' || i.statecode || '~' || i.operation);
		END LOOP;
	
		puttext(pdialog
			   ,'Deferred period'
			   ,1
			   ,format('Mode:'
					  ,CASE sacparam(cp_ovdperiodcalcmode) WHEN covdcalc_frzwithrep THEN
					   'Freeze (consider payments)' WHEN covdcalc_frzworep THEN
					   'Freeze (ignore payments)' ELSE 'Reset' END) ||
				format('Used:', service.iif(sblockparam.overduecalcspecmodeused, 'Yes', 'No')));
		puttext(pdialog
			   ,'Deferred period'
			   ,2
			   ,format('From date:'
					  ,htools.d2s(to_date(sacparam(cp_ovdperioddatefrom)
										 ,contractparams.cparam_date_format))) ||
				format('Overdue date:', nvl(htools.d2s(sblockparam.deldate), '-')));
		puttext(pdialog
			   ,'Deferred period'
			   ,3
			   ,format('To date:'
					  ,htools.d2s(to_date(sacparam(cp_ovdperioddateto)
										 ,contractparams.cparam_date_format))) ||
				format('Real overdue period:'
					  ,service.iif(sblockparam.fairperiod >= 0
								  ,sblockparam.fairperiod || getunit(sblockparam.fairperiod)
								  ,'-')));
	
		dialog.listclear(pdialog, 'RestructureList');
	
		varestructurelog := contractoplog.getlist(scontractno, cso_restructuring, FALSE);
	
		FOR i IN 1 .. varestructurelog.count
		LOOP
		
			FOR j IN (SELECT loanno
							,contractno
							,loan
					  FROM   tinstloan
					  WHERE  branch = cbranch
					  AND    docno = varestructurelog(i).docno
					  ORDER  BY entryno)
			LOOP
			
				SELECT accountno
				INTO   vaccountno
				FROM   tcontracttrxninstallment
				WHERE  loanno = j.loanno FETCH NEXT 1 rows ONLY;
			
				dialog.listaddrecord(pdialog
									,'RestructureList'
									,varestructurelog(i)
									 .operdate || '~' || slabel(getcurnobyaccountno(vaccountno)) || '~' ||
									  j.contractno || '~' ||
									  ltools.formatamount(j.loan
														 ,sdepaccount(getcurnobyaccountno(vaccountno))
														  .currencyno));
			
			END LOOP;
		
		END LOOP;
	
		switchpage('Restructuring', varestructurelog.count > 0, vcurrentpage, 'Deferred period');
		switchpage('Deferred period'
				  ,sacparam(cp_ovdperiodcalcmode) IN (covdcalc_frzwithrep, covdcalc_frzworep)
				  ,vcurrentpage
				  ,'State history');
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END fillinfopanel;

	FUNCTION fillitemaccountarray RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.FillItemAccountArray';
	
		PROCEDURE registeritemaccount
		(
			pitemname        IN typeitemname
		   ,pdescription     IN VARCHAR2
		   ,pcurrrangemethod IN NUMBER
		   ,piscardaccount   IN BOOLEAN := FALSE
		) IS
			vindex PLS_INTEGER := contracttypeschema.saitemaccountarray.count + 1;
		BEGIN
			contracttypeschema.saitemaccountarray(vindex).itemname := upper(pitemname);
			contracttypeschema.saitemaccountarray(vindex).description := pdescription;
			contracttypeschema.saitemaccountarray(vindex).currrangemethod := pcurrrangemethod;
			contracttypeschema.saitemaccountarray(vindex).iscardaccount := htools.b2i(piscardaccount);
			contracttypeschema.saitemaccountarray(vindex).createmode := contractaccount.createmode_dynamicdefault;
		END registeritemaccount;
	
	BEGIN
		t.enter(cmethodname);
	
		contracttypeschema.saitemaccountarray.delete;
	
		registeritemaccount('ItemDepositDOM'
						   ,'Card Account for Domestic Currency'
						   ,contracttypeschema.ccurrrange_branch
						   ,TRUE);
		registeritemaccount('ItemDepositINT'
						   ,'Card Account for International Currency'
						   ,contracttypeschema.ccurrrange_ubranch
						   ,TRUE);
		registeritemaccount('ItemOverdraftDOM'
						   ,'Over-limit Account for Domestic Currency'
						   ,contracttypeschema.ccurrrange_branch);
		registeritemaccount('ItemOverdraftINT'
						   ,'Over-limit Account for International Currency'
						   ,contracttypeschema.ccurrrange_ubranch);
	
		IF saccumintaccmode <> cintaccmode_donotaccumulate
		THEN
			registeritemaccount('ItemInterestDOM'
							   ,'Interest Account for Domestic Currency'
							   ,contracttypeschema.ccurrrange_branch);
			registeritemaccount('ItemInterestINT'
							   ,'Interest Account for International Currency'
							   ,contracttypeschema.ccurrrange_ubranch);
		END IF;
	
		t.leave(cmethodname, contracttypeschema.saitemaccountarray.count);
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END fillitemaccountarray;

	FUNCTION getmainaccount
	(
		pcontractno IN typecontractno
	   ,pcurrency   IN typecurrency
	) RETURN typeaccountno IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetMainAccount';
		vcontracttype typecontracttype;
		vresult       typeaccountno;
	BEGIN
		t.enter(cmethodname, 'ContractNo = ' || pcontractno || ', Currency = ' || pcurrency);
	
		vcontracttype := contract.gettype(pcontractno, c_doexception);
		contracttools.loadcontractaccount(contracttypeitems.getitemcode(vcontracttype
																	   ,'ItemDeposit' || slabel(1))
										 ,sdepaccount(1)
										 ,pcontractno);
		contracttools.loadcontractaccount(contracttypeitems.getitemcode(vcontracttype
																	   ,'ItemDeposit' || slabel(2))
										 ,sdepaccount(2)
										 ,pcontractno);
		IF NOT ifcurrencyisusedintype(1, vcontracttype, pcontractno)
		THEN
			vresult := sdepaccount(2).accountno;
		ELSIF NOT ifcurrencyisusedintype(2, vcontracttype, pcontractno)
		THEN
			vresult := sdepaccount(1).accountno;
		ELSIF nvl(pcurrency, sdepaccount(1).currencyno) = sdepaccount(1).currencyno
		THEN
			vresult := sdepaccount(1).accountno;
		ELSE
			vresult := sdepaccount(2).accountno;
		END IF;
	
		t.leave(cmethodname, vresult);
		RETURN vresult;
	EXCEPTION
	
		WHEN contracttools.valuenotexists THEN
			RETURN NULL;
		WHEN OTHERS THEN
			err.seterror(SQLCODE, cmethodname);
			RETURN NULL;
	END getmainaccount;

	FUNCTION getmainitemcode RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetMainItemCode';
	BEGIN
		IF contractparams.loadbool(contractparams.ccontracttype
								  ,contracttypeschema.scontractrow.type
								  ,'UseCur' || slabel(1))
		THEN
			RETURN contracttypeitems.getitemcode(contracttypeschema.scontractrow.type
												,'ItemDeposit' || slabel(1));
		ELSE
			RETURN contracttypeitems.getitemcode(contracttypeschema.scontractrow.type
												,'ItemDeposit' || slabel(2));
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END getmainitemcode;

	FUNCTION importcontracttype
	(
		pctypefrom IN typecontracttype
	   ,pctypeto   IN typecontracttype
	) RETURN NUMBER IS
		cmethodname CONSTANT typemethodname := cpackagename || '.ImportContractType';
	BEGIN
		t.enter(cmethodname);
	
		contractdelinqsetup.copyparameters(pctypefrom, pctypeto);
		contractddreference.copyparameters(pctypefrom, pctypeto);
		contracttypelimits.copycontracttype(pctypefrom, pctypeto);
	
		t.leave(cmethodname);
		RETURN 0;
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END importcontracttype;

	PROCEDURE ext_chargeinterest
	(
		pcontractno IN typecontractno
	   ,podocno     IN OUT NUMBER
	   ,poentryno   IN OUT NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Ext_ChargeInterest';
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		initcontract(pcontractno);
	
		contracttools.raiseif(NOT smulticurrency
							 ,'<' || pcontractno || '> is not a dual-currency contract!');
	
		startoperation(FALSE);
	
		assumetodayissd;
	
		chooseprofiles(1);
		chooseprofiles(2);
	
		appendnewtransactions(1);
		appendnewtransactions(2);
	
		FOR i IN 1 .. 2
		LOOP
			IF slastdocno(i) > sacparamccy(i) (cp_lastdocno)
			THEN
				contractrbstd.changecontractparam(scontractno, 'LastDocNo_' || i, slastdocno(i));
			END IF;
		END LOOP;
	
		getunpaidamounts(2, sminpaymentod(2), sminpaymentdd(2), ssdbalancedd(2), ssdbalanceod(2));
	
		setdocument(podocno, poentryno);
	
		interestcharge(2);
	
		custom_overdueparameterscalculation.update_contrstminpaymentdata(1
																		,snowstatementdate
																		,snowduedate
																		,sdepaccount(1)
																		 .accountno || '-1-' ||
																		  to_char(seance.getoperdate
																				 ,'yyyy.mm.dd'));
		custom_overdueparameterscalculation.update_contrstminpaymentdata(2
																		,snowstatementdate
																		,snowduedate
																		,sdepaccount(2)
																		 .accountno || '-2-' ||
																		  to_char(seance.getoperdate
																				 ,'yyyy.mm.dd'));
	
		setoperationrollbackdata(padddocno => FALSE);
	
		getdocument(podocno, poentryno);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END ext_chargeinterest;

	PROCEDURE ext_movedebttodom
	(
		pcontractno   IN typecontractno
	   ,podocno       IN OUT NUMBER
	   ,poentryno     IN OUT NUMBER
	   ,psum          IN NUMBER
	   ,pentryident   IN typeentryident
	   ,pexchangerate IN NUMBER := NULL
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Ext_MoveDebtToDOM';
		ventryno typeentryno;
		vtrxnrec typetrxnrec;
	BEGIN
		t.enter(cmethodname
			   ,'ContractNo = ' || pcontractno || ', , Sum = ' || psum || ', EntryIdent = ' ||
				pentryident);
	
		initcontract(pcontractno);
	
		contracttools.raiseif(NOT smulticurrency
							 ,'<' || pcontractno || '> is not a dual-currency contract!');
	
		contracttools.validatenumber(psum, 'Entry sum', contracttools.cnum_positive);
	
		startoperation(FALSE);
	
		chooseprofiles(1);
		chooseprofiles(2);
	
		snowstatementdate := FALSE;
		snowduedate       := FALSE;
	
		setdocument(podocno, poentryno);
	
		ventryno := sentryno + 1;
	
		sdummynum := contracttools.addentry(contracttypeschema.scontractrow
										   ,sdocno
										   ,sentryno
										   ,sdepaccount(1)
										   ,sdepaccount(2)
										   ,sdepaccount(2).currencyno
										   ,psum
										   ,pentryident
										   ,pexchangeid => pexchangerate);
	
		vtrxnrec := addtrxnfromentry(1
									,sdepaccount          (1).accountno
									,-entry.getentryrecord(sdocno, ventryno).value
									,pentryident
									,pentryno              => ventryno);
	
		dorepayment(1, vtrxnrec);
	
		vtrxnrec := addtrxnfromentry(2
									,sdepaccount(2).accountno
									,psum
									,pentryident
									,pentryno    => ventryno + 1);
	
		dorepayment(2, vtrxnrec);
	
		custom_overdueparameterscalculation.update_contrstminpaymentdata(1
																		,snowstatementdate
																		,snowduedate
																		,sdepaccount(1)
																		 .accountno || '-1-' ||
																		  to_char(seance.getoperdate
																				 ,'yyyy.mm.dd'));
		custom_overdueparameterscalculation.update_contrstminpaymentdata(2
																		,snowstatementdate
																		,snowduedate
																		,sdepaccount(2)
																		 .accountno || '-2-' ||
																		  to_char(seance.getoperdate
																				 ,'yyyy.mm.dd'));
	
		setoperationrollbackdata(padddocno => FALSE);
	
		getdocument(podocno, poentryno);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END ext_movedebttodom;

	PROCEDURE ext_movefundstodom
	(
		pcontractno   IN typecontractno
	   ,podocno       IN OUT NUMBER
	   ,poentryno     IN OUT NUMBER
	   ,psum          IN NUMBER
	   ,pentryident   IN typeentryident
	   ,pexchangerate IN NUMBER := NULL
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Ext_MoveFundsToDOM';
		ventryno typeentryno;
		vtrxnrec typetrxnrec;
	BEGIN
		t.enter(cmethodname
			   ,'ContractNo = ' || pcontractno || ', , Sum = ' || psum || ', EntryIdent = ' ||
				pentryident);
	
		initcontract(pcontractno);
	
		contracttools.raiseif(NOT smulticurrency
							 ,'<' || pcontractno || '> is not a dual-currency contract!');
	
		contracttools.validatenumber(psum, 'Entry sum', contracttools.cnum_positive);
	
		startoperation(FALSE);
	
		chooseprofiles(1);
		chooseprofiles(2);
	
		snowstatementdate := FALSE;
		snowduedate       := FALSE;
	
		setdocument(podocno, poentryno);
	
		ventryno := sentryno + 1;
	
		sdummynum := contracttools.addentry(contracttypeschema.scontractrow
										   ,sdocno
										   ,sentryno
										   ,sdepaccount(2)
										   ,sdepaccount(1)
										   ,sdepaccount(2).currencyno
										   ,psum
										   ,pentryident
										   ,pexchangeid => pexchangerate);
	
		vtrxnrec := addtrxnfromentry(2
									,sdepaccount(2).accountno
									,-psum
									,pentryident
									,pentryno    => ventryno);
	
		dorepayment(2, vtrxnrec);
	
		vtrxnrec := addtrxnfromentry(1
									,sdepaccount         (1).accountno
									,entry.getentryrecord(sdocno, ventryno + 1).value
									,pentryident
									,pentryno             => ventryno + 1);
	
		dorepayment(1, vtrxnrec);
	
		custom_overdueparameterscalculation.update_contrstminpaymentdata(1
																		,snowstatementdate
																		,snowduedate
																		,sdepaccount(1)
																		 .accountno || '-1-' ||
																		  to_char(seance.getoperdate
																				 ,'yyyy.mm.dd'));
		custom_overdueparameterscalculation.update_contrstminpaymentdata(2
																		,snowstatementdate
																		,snowduedate
																		,sdepaccount(2)
																		 .accountno || '-2-' ||
																		  to_char(seance.getoperdate
																				 ,'yyyy.mm.dd'));
	
		setoperationrollbackdata(padddocno => FALSE);
	
		getdocument(podocno, poentryno);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END ext_movefundstodom;

	PROCEDURE ext_moveusedlimitstodom
	(
		pcontractno   IN typecontractno
	   ,ppan          IN typepan
	   ,pmbr          IN typembr
	   ,pexchangerate IN NUMBER := NULL
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Ext_MoveUsedLimitsToDOM';
		cbranch     CONSTANT NUMBER := seance.getbranch;
	
		vlimitsettingsint typeobjectlimitsettings;
		vdummy            typeobjectlimitsettings;
	
		vdeltacred NUMBER;
		vdeltacash NUMBER;
	
	BEGIN
		t.enter(cmethodname
			   ,'ContractNo = ' || pcontractno || ', Card = ' || masktodebug(ppan, pmbr));
	
		initcontract(pcontractno);
	
		contracttools.raiseif(NOT smulticurrency
							 ,'<' || pcontractno || '> is not a dual-currency contract!');
	
		startoperation(FALSE);
	
		vdummy            := getobjectlimitssetup(pcontractno, 1, ppan, pmbr);
		vlimitsettingsint := getobjectlimitssetup(pcontractno, 2, ppan, pmbr);
	
		t.var('vLimitSettingsINT.UsedCredLimit.Amount', vlimitsettingsint.usedcredlimit.amount);
		t.var('vLimitSettingsINT.UsedCashLimit.Amount', vlimitsettingsint.usedcashlimit.amount);
	
		vdeltacred := contracttools.getsumincurrency(vlimitsettingsint.usedcredlimit.amount
													,sdepaccount                           (2)
													 .currencyno
													,sdepaccount                           (1)
													 .currencyno
													,pexchangerate);
		vdeltacash := contracttools.getsumincurrency(vlimitsettingsint.usedcashlimit.amount
													,sdepaccount                           (2)
													 .currencyno
													,sdepaccount                           (1)
													 .currencyno
													,pexchangerate);
	
		updateusedlimits(1, ppan, pmbr, vdeltacred, vdeltacash, c_dorollback);
	
		updateusedlimits(2
						,ppan
						,pmbr
						,-vlimitsettingsint.usedcredlimit.amount
						,-vlimitsettingsint.usedcashlimit.amount
						,c_dorollback);
	
		DELETE FROM tcontractlimitparams
		WHERE  branch = cbranch
		AND    contractno = pcontractno
		AND    pan = ppan
		AND    mbr = pmbr
		AND    currencynumber = 2;
	
		setoperationrollbackdata(padddocno => FALSE);
	
		contractrb.setlabel(crl_limitdeleted, scontractno);
	
		contractrb.setnvalue('CurNo', 2);
		contractrb.setcvalue('PAN', ppan);
		contractrb.setnvalue('MBR', pmbr);
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END ext_moveusedlimitstodom;

	PROCEDURE ext_completemigration
	(
		pcontractno IN typecontractno
	   ,pdocno      IN NUMBER
	   ,pentryno    IN NUMBER
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.Ext_CompleteMigration';
	BEGIN
		t.enter(cmethodname, pcontractno);
	
		initcontract(pcontractno);
	
		contracttools.raiseif(NOT smulticurrency
							 ,'<' || pcontractno || '> is not a dual-currency contract!');
	
		setdocument(pdocno, pentryno);
	
		adddocnotorollback;
	
		FOR i IN 1 .. 2
		LOOP
			IF slastdocno(i) > sacparamccy(i) (cp_lastdocno)
			THEN
				contractrbstd.changecontractparam(scontractno, 'LastDocNo_' || i, slastdocno(i));
			END IF;
		END LOOP;
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END ext_completemigration;

	FUNCTION getbodyversion RETURN VARCHAR2 IS
	BEGIN
		RETURN cbodyversion;
	END getbodyversion;

	FUNCTION getbodydate RETURN DATE IS
	BEGIN
		RETURN cbodydate;
	END getbodydate;

	FUNCTION getbodytwcms RETURN VARCHAR2 IS
	BEGIN
		RETURN cbodytwcms;
	END getbodytwcms;

	FUNCTION getversion RETURN VARCHAR2 IS
	BEGIN
		RETURN cbodyversion || ' (' || cbodydate || ')';
	END getversion;

	PROCEDURE addpackageaboutinfo
	(
		poaaboutinfo IN OUT NOCOPY types.arrstr100
	   ,ppackagename IN typepackagename
	) IS
		cmethodname CONSTANT typemethodname := cpackagename || '.AddPackageAboutInfo';
	
		FUNCTION getvalue(pvalueobject IN VARCHAR2) RETURN VARCHAR2 IS
			cmethodname CONSTANT typemethodname := addpackageaboutinfo.cmethodname || '.GetValue';
			vresult VARCHAR2(100);
		BEGIN
			EXECUTE IMMEDIATE 'begin :Result:= ' || ppackagename || '.' || pvalueobject || '; end;'
				USING OUT vresult;
			RETURN vresult;
		EXCEPTION
			WHEN excmethodnotfound THEN
				t.exc(cmethodname);
				error.raiseerror('Method or variable <' || pvalueobject ||
								 '> not found in package <' || ppackagename || '>!');
			WHEN OTHERS THEN
				t.exc(cmethodname);
				error.save(cmethodname);
				RAISE;
		END getvalue;
	
	BEGIN
		t.enter(cmethodname, ppackagename);
	
		poaaboutinfo(poaaboutinfo.count + 1) := getvalue('cPackageDescr');
		poaaboutinfo(poaaboutinfo.count + 1) := '  Header version ' || getvalue('cHeaderVersion') ||
												' dated ' || htools.d2s(getvalue('cHeaderDate')) || ' (' ||
												getvalue('cHeaderTWCMS') || ')';
		poaaboutinfo(poaaboutinfo.count + 1) := '  Body version ' || getvalue('GetBodyVersion') ||
												' dated ' || htools.d2s(getvalue('GetBodyDate')) || ' (' ||
												getvalue('GetBodyTWCMS') || ')';
	
		t.leave(cmethodname);
	EXCEPTION
		WHEN OTHERS THEN
			t.exc(cmethodname);
			error.save(cmethodname);
			RAISE;
	END addpackageaboutinfo;

	FUNCTION getschemaabout RETURN types.arrstr100 IS
		cmethodname CONSTANT typemethodname := cpackagename || '.GetSchemaAbout';
		vresult types.arrstr100;
	BEGIN
		addpackageaboutinfo(vresult, cpackagename);
	
		vresult(vresult.count + 1) := 'API';
		vresult(vresult.count + 1) := '  ' || sch_rev_api.getbodyversion || ' (' ||
									  sch_rev_api.sheaderversion || ')';
	
		vresult(vresult.count + 1) := 'Dictionary of Billing Cycles Calendars module';
		vresult(vresult.count + 1) := '  ' || contractcalendar.getbodyversion || ' (' ||
									  contractcalendar.sheaderversion || ')';
	
		vresult(vresult.count + 1) := 'Dictionary of Direct Debit Calculation Profile module';
		vresult(vresult.count + 1) := '  ' || contractddreference.getbodyversion || ' (' ||
									  contractddreference.sheaderversion || ')';
	
		vresult(vresult.count + 1) := 'Debt Collector Interface module';
		vresult(vresult.count + 1) := '  ' || contractdcsetup.getbodyversion || ' (' ||
									  contractdcsetup.sheaderversion || ')';
	
		vresult(vresult.count + 1) := 'Delinquency Settings module';
		vresult(vresult.count + 1) := '  ' || contractdelinqsetup.getbodyversion || ' (' ||
									  contractdelinqsetup.sheaderversion || ')';
	
		vresult(vresult.count + 1) := 'MP and Interest Profiles module';
		vresult(vresult.count + 1) := '  ' || custom_contractprofiles.getbodyversion || ' (' ||
									  custom_contractprofiles.sheaderversion || ')';
	
		addpackageaboutinfo(vresult, 'ContractStateReference');
		addpackageaboutinfo(vresult, 'GoodsServicesTax');
		addpackageaboutinfo(vresult, 'ContractTypeLimits');
	
		RETURN vresult;
	EXCEPTION
		WHEN OTHERS THEN
			error.save(cmethodname);
			RAISE;
	END getschemaabout;

BEGIN
	initpackage;
EXCEPTION
	WHEN OTHERS THEN
		t.exc(cpackagename || '.InitBlock');
		error.save(cpackagename || '.InitBlock');
		RAISE;
END custom_sch_customer;
/
